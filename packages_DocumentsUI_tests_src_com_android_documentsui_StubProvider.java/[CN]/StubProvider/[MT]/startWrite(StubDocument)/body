{
  ParcelFileDescriptor[] pipe;
  try {
    pipe=ParcelFileDescriptor.createReliablePipe();
  }
 catch (  IOException exception) {
    throw new FileNotFoundException();
  }
  final ParcelFileDescriptor readPipe=pipe[0];
  final ParcelFileDescriptor writePipe=pipe[1];
  new Thread(){
    @Override public void run(){
      InputStream inputStream=null;
      OutputStream outputStream=null;
      try {
        Log.d(TAG,"Opening write stream on file " + document.documentId);
        inputStream=new ParcelFileDescriptor.AutoCloseInputStream(readPipe);
        outputStream=new FileOutputStream(document.file);
        byte[] buffer=new byte[32 * 1024];
        int bytesToRead;
        int bytesRead=0;
        while (bytesRead != -1) {
synchronized (mWriteLock) {
            bytesToRead=(int)Math.min(document.rootInfo.getRemainingCapacity(),buffer.length);
            if (bytesToRead == 0) {
              closePipeWithErrorSilently(readPipe,"Not enough space.");
              break;
            }
            bytesRead=inputStream.read(buffer,0,bytesToRead);
            if (bytesRead == -1) {
              break;
            }
            outputStream.write(buffer,0,bytesRead);
            document.rootInfo.size+=bytesRead;
          }
        }
      }
 catch (      IOException e) {
        Log.e(TAG,"Error on close",e);
        closePipeWithErrorSilently(readPipe,e.getMessage());
      }
 finally {
        IoUtils.closeQuietly(inputStream);
        IoUtils.closeQuietly(outputStream);
        Log.d(TAG,"Closing write stream on file " + document.documentId);
        notifyParentChanged(document.parentId);
        getContext().getContentResolver().notifyChange(DocumentsContract.buildDocumentUri(mAuthority,document.documentId),null,false);
      }
    }
  }
.start();
  return writePipe;
}
