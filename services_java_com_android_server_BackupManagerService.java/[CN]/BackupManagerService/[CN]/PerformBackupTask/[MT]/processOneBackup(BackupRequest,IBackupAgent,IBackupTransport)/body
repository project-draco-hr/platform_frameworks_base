{
  final String packageName=request.appInfo.packageName;
  if (DEBUG)   Slog.d(TAG,"processOneBackup doBackup() on " + packageName);
  File savedStateName=new File(mStateDir,packageName);
  File backupDataName=new File(mDataDir,packageName + ".data");
  File newStateName=new File(mStateDir,packageName + ".new");
  ParcelFileDescriptor savedState=null;
  ParcelFileDescriptor backupData=null;
  ParcelFileDescriptor newState=null;
  PackageInfo packInfo;
  final int token=generateToken();
  try {
    if (packageName.equals(PACKAGE_MANAGER_SENTINEL)) {
      packInfo=new PackageInfo();
      packInfo.packageName=packageName;
    }
 else {
      packInfo=mPackageManager.getPackageInfo(packageName,PackageManager.GET_SIGNATURES);
    }
    savedState=ParcelFileDescriptor.open(savedStateName,ParcelFileDescriptor.MODE_READ_ONLY | ParcelFileDescriptor.MODE_CREATE);
    backupData=ParcelFileDescriptor.open(backupDataName,ParcelFileDescriptor.MODE_READ_WRITE | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE);
    newState=ParcelFileDescriptor.open(newStateName,ParcelFileDescriptor.MODE_READ_WRITE | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE);
    prepareOperationTimeout(token,TIMEOUT_BACKUP_INTERVAL);
    agent.doBackup(savedState,backupData,newState,false,token,mBackupManagerBinder);
    boolean success=waitUntilOperationComplete(token);
    if (!success) {
      throw new RuntimeException("Backup timeout");
    }
    logBackupComplete(packageName);
    if (DEBUG)     Slog.v(TAG,"doBackup() success");
  }
 catch (  Exception e) {
    Slog.e(TAG,"Error backing up " + packageName,e);
    EventLog.writeEvent(EventLogTags.BACKUP_AGENT_FAILURE,packageName,e.toString());
    backupDataName.delete();
    newStateName.delete();
    return BackupConstants.TRANSPORT_ERROR;
  }
 finally {
    try {
      if (savedState != null)       savedState.close();
    }
 catch (    IOException e) {
    }
    try {
      if (backupData != null)       backupData.close();
    }
 catch (    IOException e) {
    }
    try {
      if (newState != null)       newState.close();
    }
 catch (    IOException e) {
    }
    savedState=backupData=newState=null;
synchronized (mCurrentOpLock) {
      mCurrentOperations.clear();
    }
  }
  int result=BackupConstants.TRANSPORT_OK;
  try {
    int size=(int)backupDataName.length();
    if (size > 0) {
      if (result == BackupConstants.TRANSPORT_OK) {
        backupData=ParcelFileDescriptor.open(backupDataName,ParcelFileDescriptor.MODE_READ_ONLY);
        result=transport.performBackup(packInfo,backupData);
      }
      if (result == BackupConstants.TRANSPORT_OK) {
        result=transport.finishBackup();
      }
    }
 else {
      if (DEBUG)       Slog.i(TAG,"no backup data written; not calling transport");
    }
    if (result == BackupConstants.TRANSPORT_OK) {
      backupDataName.delete();
      newStateName.renameTo(savedStateName);
      EventLog.writeEvent(EventLogTags.BACKUP_PACKAGE,packageName,size);
    }
 else {
      EventLog.writeEvent(EventLogTags.BACKUP_TRANSPORT_FAILURE,packageName);
    }
  }
 catch (  Exception e) {
    Slog.e(TAG,"Transport error backing up " + packageName,e);
    EventLog.writeEvent(EventLogTags.BACKUP_TRANSPORT_FAILURE,packageName);
    result=BackupConstants.TRANSPORT_ERROR;
  }
 finally {
    try {
      if (backupData != null)       backupData.close();
    }
 catch (    IOException e) {
    }
  }
  return result;
}
