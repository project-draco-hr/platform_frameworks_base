{
  if (DEBUG)   Log.v(TAG,"Beginning restore process");
  int err=-1;
  try {
    err=mTransport.startSession();
  }
 catch (  Exception e) {
    Log.e(TAG,"Error starting transport for restore");
    e.printStackTrace();
  }
  if (err == 0) {
    try {
      RestoreSet[] images=mTransport.getAvailableRestoreSets();
      if (images.length > 0) {
        mImage=images[0];
        PackageManagerBackupAgent pmAgent=new PackageManagerBackupAgent(mPackageManager,allAgentApps());
        PackageInfo pmApp=new PackageInfo();
        pmApp.packageName=PACKAGE_MANAGER_SENTINEL;
        processOneRestore(pmApp,IBackupAgent.Stub.asInterface(pmAgent.onBind()));
        PackageInfo[] packages=mTransport.getAppSet(mImage.token);
        HashSet<PackageInfo> appsToRestore=new HashSet<PackageInfo>();
        for (        PackageInfo pkg : packages) {
          PackageInfo app=isRestorable(pkg);
          if (app != null) {
            Metadata info=pmAgent.getRestoredMetadata(app.packageName);
            if (app.versionCode >= info.versionCode) {
              if (DEBUG)               Log.v(TAG,"Restore version " + info.versionCode + " compatible with app version "+ app.versionCode);
              if (signaturesMatch(info.signatures,app.signatures)) {
                appsToRestore.add(app);
              }
 else {
                Log.w(TAG,"Sig mismatch restoring " + app.packageName);
              }
            }
 else {
              Log.i(TAG,"Restore set for " + app.packageName + " is too new ["+ info.versionCode+ "] for installed app version "+ app.versionCode);
            }
          }
        }
        doQueuedRestores(appsToRestore);
      }
    }
 catch (    RemoteException e) {
    }
    try {
      mTransport.endSession();
    }
 catch (    Exception e) {
      Log.e(TAG,"Error ending transport for restore");
      e.printStackTrace();
    }
  }
}
