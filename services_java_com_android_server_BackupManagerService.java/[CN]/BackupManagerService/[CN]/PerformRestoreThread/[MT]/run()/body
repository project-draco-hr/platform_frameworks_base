{
  long startRealtime=SystemClock.elapsedRealtime();
  if (DEBUG)   Log.v(TAG,"Beginning restore process mTransport=" + mTransport + " mObserver="+ mObserver+ " mToken="+ Long.toHexString(mToken));
  int error=-1;
  try {
    EventLog.writeEvent(RESTORE_START_EVENT,mTransport.transportDirName(),mToken);
    ArrayList<PackageInfo> restorePackages=new ArrayList<PackageInfo>();
    PackageInfo omPackage=new PackageInfo();
    omPackage.packageName=PACKAGE_MANAGER_SENTINEL;
    restorePackages.add(omPackage);
    List<PackageInfo> agentPackages=allAgentPackages();
    restorePackages.addAll(agentPackages);
    if (mObserver != null) {
      try {
        mObserver.restoreStarting(restorePackages.size());
      }
 catch (      RemoteException e) {
        Log.d(TAG,"Restore observer died at restoreStarting");
        mObserver=null;
      }
    }
    if (mTransport.startRestore(mToken,restorePackages.toArray(new PackageInfo[0])) != BackupConstants.TRANSPORT_OK) {
      Log.e(TAG,"Error starting restore operation");
      EventLog.writeEvent(RESTORE_TRANSPORT_FAILURE_EVENT);
      return;
    }
    String packageName=mTransport.nextRestorePackage();
    if (packageName == null) {
      Log.e(TAG,"Error getting first restore package");
      EventLog.writeEvent(RESTORE_TRANSPORT_FAILURE_EVENT);
      return;
    }
 else     if (packageName.equals("")) {
      Log.i(TAG,"No restore data available");
      int millis=(int)(SystemClock.elapsedRealtime() - startRealtime);
      EventLog.writeEvent(RESTORE_SUCCESS_EVENT,0,millis);
      return;
    }
 else     if (!packageName.equals(PACKAGE_MANAGER_SENTINEL)) {
      Log.e(TAG,"Expected restore data for \"" + PACKAGE_MANAGER_SENTINEL + "\", found only \""+ packageName+ "\"");
      EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,PACKAGE_MANAGER_SENTINEL,"Package manager data missing");
      return;
    }
    PackageManagerBackupAgent pmAgent=new PackageManagerBackupAgent(mPackageManager,agentPackages);
    processOneRestore(omPackage,0,IBackupAgent.Stub.asInterface(pmAgent.onBind()));
    if (!pmAgent.hasMetadata()) {
      Log.e(TAG,"No restore metadata available, so not restoring settings");
      EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,PACKAGE_MANAGER_SENTINEL,"Package manager restore metadata missing");
      return;
    }
    int count=0;
    for (; ; ) {
      packageName=mTransport.nextRestorePackage();
      if (packageName == null) {
        Log.e(TAG,"Error getting next restore package");
        EventLog.writeEvent(RESTORE_TRANSPORT_FAILURE_EVENT);
        return;
      }
 else       if (packageName.equals("")) {
        break;
      }
      if (mObserver != null) {
        try {
          mObserver.onUpdate(count);
        }
 catch (        RemoteException e) {
          Log.d(TAG,"Restore observer died in onUpdate");
          mObserver=null;
        }
      }
      Metadata metaInfo=pmAgent.getRestoredMetadata(packageName);
      if (metaInfo == null) {
        Log.e(TAG,"Missing metadata for " + packageName);
        EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,packageName,"Package metadata missing");
        continue;
      }
      PackageInfo packageInfo;
      try {
        int flags=PackageManager.GET_SIGNATURES;
        packageInfo=mPackageManager.getPackageInfo(packageName,flags);
      }
 catch (      NameNotFoundException e) {
        Log.e(TAG,"Invalid package restoring data",e);
        EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,packageName,"Package missing on device");
        continue;
      }
      if (metaInfo.versionCode > packageInfo.versionCode) {
        String message="Version " + metaInfo.versionCode + " > installed version "+ packageInfo.versionCode;
        Log.w(TAG,"Package " + packageName + ": "+ message);
        EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,packageName,message);
        continue;
      }
      if (!signaturesMatch(metaInfo.signatures,packageInfo.signatures)) {
        Log.w(TAG,"Signature mismatch restoring " + packageName);
        EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,packageName,"Signature mismatch");
        continue;
      }
      if (DEBUG)       Log.v(TAG,"Package " + packageName + " restore version ["+ metaInfo.versionCode+ "] is compatible with installed version ["+ packageInfo.versionCode+ "]");
      clearApplicationDataSynchronous(packageName);
      boolean useRealApp=(packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION) != 0;
      if (DEBUG && useRealApp) {
        Log.v(TAG,"agent requires real Application subclass for restore");
      }
      IBackupAgent agent=bindToAgentSynchronous(packageInfo.applicationInfo,(useRealApp ? IApplicationThread.BACKUP_MODE_INCREMENTAL : IApplicationThread.BACKUP_MODE_RESTORE));
      if (agent == null) {
        Log.w(TAG,"Can't find backup agent for " + packageName);
        EventLog.writeEvent(RESTORE_AGENT_FAILURE_EVENT,packageName,"Restore agent missing");
        continue;
      }
      try {
        processOneRestore(packageInfo,metaInfo.versionCode,agent);
        ++count;
      }
  finally {
        mActivityManager.unbindBackupAgent(packageInfo.applicationInfo);
        if ((packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_KILL_AFTER_RESTORE) != 0) {
          if (DEBUG)           Log.d(TAG,"Restore complete, killing host process of " + packageInfo.applicationInfo.processName);
          mActivityManager.killApplicationProcess(packageInfo.applicationInfo.processName,packageInfo.applicationInfo.uid);
        }
      }
    }
    error=0;
    int millis=(int)(SystemClock.elapsedRealtime() - startRealtime);
    EventLog.writeEvent(RESTORE_SUCCESS_EVENT,count,millis);
  }
 catch (  Exception e) {
    Log.e(TAG,"Error in restore thread",e);
  }
 finally {
    if (DEBUG)     Log.d(TAG,"finishing restore mObserver=" + mObserver);
    try {
      mTransport.finishRestore();
    }
 catch (    RemoteException e) {
      Log.e(TAG,"Error finishing restore",e);
    }
    if (mObserver != null) {
      try {
        mObserver.restoreFinished(error);
      }
 catch (      RemoteException e) {
        Log.d(TAG,"Restore observer died at restoreFinished");
      }
    }
    mWakelock.release();
  }
}
