{
  int err=-1;
  try {
    err=mTransport.startSession();
  }
 catch (  Exception e) {
    Log.e(TAG,"Error starting transport for restore");
    e.printStackTrace();
  }
  if (err == 0) {
    try {
      RestoreSet[] images=mTransport.getAvailableRestoreSets();
      if (images.length > 0) {
        mImage=images[0];
        PackageManagerBackupAgent pmAgent=new PackageManagerBackupAgent(mPackageManager,allAgentApps());
        PackageInfo pmApp=new PackageInfo();
        pmApp.packageName=PACKAGE_MANAGER_SENTINEL;
        processOneRestore(pmApp,IBackupAgent.Stub.asInterface(pmAgent.onBind()));
        PackageInfo[] packages=mTransport.getAppSet(mImage.token);
        HashSet<PackageInfo> appsToRestore=new HashSet<PackageInfo>();
        for (        PackageInfo pkg : packages) {
          PackageInfo app=isRestorable(pkg);
          if (app != null) {
            Signature[] storedSigs=pmAgent.getRestoredSignatures(app.packageName);
            if (signaturesMatch(storedSigs,app.signatures)) {
              appsToRestore.add(app);
            }
 else {
              Log.w(TAG,"Sig mismatch on restore of " + app.packageName);
            }
          }
        }
        doQueuedRestores(appsToRestore);
      }
    }
 catch (    RemoteException e) {
    }
    try {
      mTransport.endSession();
    }
 catch (    Exception e) {
      Log.e(TAG,"Error ending transport for restore");
      e.printStackTrace();
    }
  }
}
