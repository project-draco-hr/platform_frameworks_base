{
switch (msg.what) {
case MSG_RUN_BACKUP:
{
      mLastBackupPass=System.currentTimeMillis();
      mNextBackupPass=mLastBackupPass + BACKUP_INTERVAL;
      IBackupTransport transport=getTransport(mCurrentTransport);
      if (transport == null) {
        Log.v(TAG,"Backup requested but no transport available");
        mWakelock.release();
        break;
      }
      ArrayList<BackupRequest> queue=new ArrayList<BackupRequest>();
synchronized (mQueueLock) {
        if (mPendingBackups.size() > 0) {
          for (          BackupRequest b : mPendingBackups.values()) {
            queue.add(b);
          }
          if (DEBUG)           Log.v(TAG,"clearing pending backups");
          mPendingBackups.clear();
          File oldJournal=mJournal;
          mJournal=null;
          (new PerformBackupTask(transport,queue,oldJournal)).run();
        }
 else {
          Log.v(TAG,"Backup requested but nothing pending");
          mWakelock.release();
        }
      }
      break;
    }
case MSG_RUN_FULL_BACKUP:
  break;
case MSG_RUN_RESTORE:
{
  RestoreParams params=(RestoreParams)msg.obj;
  Log.d(TAG,"MSG_RUN_RESTORE observer=" + params.observer);
  (new PerformRestoreTask(params.transport,params.observer,params.token)).run();
  break;
}
case MSG_RUN_CLEAR:
{
ClearParams params=(ClearParams)msg.obj;
(new PerformClearTask(params.transport,params.packageInfo)).run();
break;
}
case MSG_RUN_INITIALIZE:
{
HashSet<String> queue;
synchronized (mQueueLock) {
queue=new HashSet<String>(mPendingInits);
mPendingInits.clear();
}
(new PerformInitializeTask(queue)).run();
break;
}
case MSG_TIMEOUT:
{
synchronized (mCurrentOpLock) {
final int token=msg.arg1;
int state=mCurrentOperations.get(token,OP_TIMEOUT);
if (state == OP_PENDING) {
if (DEBUG) Log.v(TAG,"TIMEOUT: token=" + token);
mCurrentOperations.put(token,OP_TIMEOUT);
}
mCurrentOpLock.notifyAll();
}
break;
}
}
}
