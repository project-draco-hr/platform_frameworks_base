{
  int status=BackupConstants.TRANSPORT_OK;
  long startRealtime=SystemClock.elapsedRealtime();
  if (DEBUG)   Log.v(TAG,"Beginning backup of " + mQueue.size() + " targets");
  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  try {
    EventLog.writeEvent(BACKUP_START_EVENT,mTransport.transportDirName());
    if (status == BackupConstants.TRANSPORT_OK && mEverStoredApps.size() == 0) {
      status=mTransport.initializeDevice();
    }
    if (status == BackupConstants.TRANSPORT_OK) {
      PackageManagerBackupAgent pmAgent=new PackageManagerBackupAgent(mPackageManager,allAgentPackages());
      BackupRequest pmRequest=new BackupRequest(new ApplicationInfo(),false);
      pmRequest.appInfo.packageName=PACKAGE_MANAGER_SENTINEL;
      status=processOneBackup(pmRequest,IBackupAgent.Stub.asInterface(pmAgent.onBind()),mTransport);
    }
    if (status == BackupConstants.TRANSPORT_OK) {
      status=doQueuedBackups(mTransport);
    }
    if (status == BackupConstants.TRANSPORT_OK) {
      status=mTransport.finishBackup();
      if (status == BackupConstants.TRANSPORT_OK) {
        int millis=(int)(SystemClock.elapsedRealtime() - startRealtime);
        EventLog.writeEvent(BACKUP_SUCCESS_EVENT,mQueue.size(),millis);
      }
 else {
        EventLog.writeEvent(BACKUP_TRANSPORT_FAILURE_EVENT,"");
        Log.e(TAG,"Transport error in finishBackup()");
      }
    }
    if (status == BackupConstants.TRANSPORT_NOT_INITIALIZED) {
      EventLog.writeEvent(BACKUP_RESET_EVENT,mTransport.transportDirName());
      resetBackupState(mStateDir);
      backupNow();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,"Error in backup thread",e);
    status=BackupConstants.TRANSPORT_ERROR;
  }
 finally {
    if (status != BackupConstants.TRANSPORT_OK) {
      Log.w(TAG,"Backup pass unsuccessful, restaging");
      for (      BackupRequest req : mQueue) {
        try {
          dataChanged(req.appInfo.packageName);
        }
 catch (        RemoteException e) {
        }
      }
      try {
        startBackupAlarmsLocked(mTransport.requestBackupTime());
      }
 catch (      RemoteException e) {
      }
    }
    if (!mJournal.delete()) {
      Log.e(TAG,"Unable to remove backup journal file " + mJournal);
    }
synchronized (mQueueLock) {
      mBackupOrRestoreInProgress=false;
    }
    mWakelock.release();
  }
}
