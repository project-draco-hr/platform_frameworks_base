{
  FileMetadata info;
  try {
    info=readTarHeaders(instream);
    if (info != null) {
      if (MORE_DEBUG) {
        dumpFileMetadata(info);
      }
      final String pkg=info.packageName;
      if (!pkg.equals(mAgentPackage)) {
        if (!mPackagePolicies.containsKey(pkg)) {
          mPackagePolicies.put(pkg,RestorePolicy.IGNORE);
        }
        if (mAgent != null) {
          if (DEBUG)           Slog.d(TAG,"Saw new package; tearing down old one");
          tearDownPipes();
          tearDownAgent(mTargetApp);
          mTargetApp=null;
          mAgentPackage=null;
        }
      }
      if (info.path.equals(BACKUP_MANIFEST_FILENAME)) {
        mPackagePolicies.put(pkg,readAppManifest(info,instream));
        mPackageInstallers.put(pkg,info.installerPackageName);
        skipTarPadding(info.size,instream);
        sendOnRestorePackage(pkg);
      }
 else {
        boolean okay=true;
        RestorePolicy policy=mPackagePolicies.get(pkg);
switch (policy) {
case IGNORE:
          okay=false;
        break;
case ACCEPT_IF_APK:
      if (info.domain.equals(FullBackup.APK_TREE_TOKEN)) {
        if (DEBUG)         Slog.d(TAG,"APK file; installing");
        String installerName=mPackageInstallers.get(pkg);
        okay=installApk(info,installerName,instream);
        mPackagePolicies.put(pkg,(okay) ? RestorePolicy.ACCEPT : RestorePolicy.IGNORE);
        skipTarPadding(info.size,instream);
        return true;
      }
 else {
        mPackagePolicies.put(pkg,RestorePolicy.IGNORE);
        okay=false;
      }
    break;
case ACCEPT:
  if (info.domain.equals(FullBackup.APK_TREE_TOKEN)) {
    if (DEBUG)     Slog.d(TAG,"apk present but ACCEPT");
    okay=false;
  }
break;
default :
Slog.e(TAG,"Invalid policy from manifest");
okay=false;
mPackagePolicies.put(pkg,RestorePolicy.IGNORE);
break;
}
if (info.path.contains("..") || info.path.contains("//")) {
if (MORE_DEBUG) {
Slog.w(TAG,"Dropping invalid path " + info.path);
}
okay=false;
}
if (DEBUG && okay && mAgent != null) {
Slog.i(TAG,"Reusing existing agent instance");
}
if (okay && mAgent == null) {
if (DEBUG) Slog.d(TAG,"Need to launch agent for " + pkg);
try {
mTargetApp=mPackageManager.getApplicationInfo(pkg,0);
if (!mClearedPackages.contains(pkg)) {
if (mTargetApp.backupAgentName == null) {
if (DEBUG) Slog.d(TAG,"Clearing app data preparatory to full restore");
clearApplicationDataSynchronous(pkg);
}
 else {
if (DEBUG) Slog.d(TAG,"backup agent (" + mTargetApp.backupAgentName + ") => no clear");
}
mClearedPackages.add(pkg);
}
 else {
if (DEBUG) Slog.d(TAG,"We've initialized this app already; no clear required");
}
setUpPipes();
mAgent=bindToAgentSynchronous(mTargetApp,IApplicationThread.BACKUP_MODE_RESTORE_FULL);
mAgentPackage=pkg;
}
 catch (IOException e) {
}
catch (NameNotFoundException e) {
}
if (mAgent == null) {
if (DEBUG) Slog.d(TAG,"Unable to create agent for " + pkg);
okay=false;
tearDownPipes();
mPackagePolicies.put(pkg,RestorePolicy.IGNORE);
}
}
if (okay && !pkg.equals(mAgentPackage)) {
Slog.e(TAG,"Restoring data for " + pkg + " but agent is for "+ mAgentPackage);
okay=false;
}
if (okay) {
boolean agentSuccess=true;
long toCopy=info.size;
final int token=generateToken();
try {
prepareOperationTimeout(token,TIMEOUT_FULL_BACKUP_INTERVAL,null);
if (info.domain.equals(FullBackup.OBB_TREE_TOKEN)) {
if (DEBUG) Slog.d(TAG,"Restoring OBB file for " + pkg + " : "+ info.path);
mObbConnection.restoreObbFile(pkg,mPipes[0],info.size,info.type,info.path,info.mode,info.mtime,token,mBackupManagerBinder);
}
 else {
if (DEBUG) Slog.d(TAG,"Invoking agent to restore file " + info.path);
if (mTargetApp.processName.equals("system")) {
Slog.d(TAG,"system process agent - spinning a thread");
RestoreFileRunnable runner=new RestoreFileRunnable(mAgent,info,mPipes[0],token);
new Thread(runner).start();
}
 else {
mAgent.doRestoreFile(mPipes[0],info.size,info.type,info.domain,info.path,info.mode,info.mtime,token,mBackupManagerBinder);
}
}
}
 catch (IOException e) {
Slog.d(TAG,"Couldn't establish restore");
agentSuccess=false;
okay=false;
}
catch (RemoteException e) {
Slog.e(TAG,"Agent crashed during full restore");
agentSuccess=false;
okay=false;
}
if (okay) {
boolean pipeOkay=true;
FileOutputStream pipe=new FileOutputStream(mPipes[1].getFileDescriptor());
while (toCopy > 0) {
int toRead=(toCopy > buffer.length) ? buffer.length : (int)toCopy;
int nRead=instream.read(buffer,0,toRead);
if (nRead >= 0) mBytes+=nRead;
if (nRead <= 0) break;
toCopy-=nRead;
if (pipeOkay) {
try {
pipe.write(buffer,0,nRead);
}
 catch (IOException e) {
Slog.e(TAG,"Failed to write to restore pipe",e);
pipeOkay=false;
}
}
}
skipTarPadding(info.size,instream);
agentSuccess=waitUntilOperationComplete(token);
}
if (!agentSuccess) {
mBackupHandler.removeMessages(MSG_TIMEOUT);
tearDownPipes();
tearDownAgent(mTargetApp);
mAgent=null;
mPackagePolicies.put(pkg,RestorePolicy.IGNORE);
}
}
if (!okay) {
if (DEBUG) Slog.d(TAG,"[discarding file content]");
long bytesToConsume=(info.size + 511) & ~511;
while (bytesToConsume > 0) {
int toRead=(bytesToConsume > buffer.length) ? buffer.length : (int)bytesToConsume;
long nRead=instream.read(buffer,0,toRead);
if (nRead >= 0) mBytes+=nRead;
if (nRead <= 0) break;
bytesToConsume-=nRead;
}
}
}
}
}
 catch (IOException e) {
if (DEBUG) Slog.w(TAG,"io exception on restore socket read",e);
info=null;
}
return (info != null);
}
