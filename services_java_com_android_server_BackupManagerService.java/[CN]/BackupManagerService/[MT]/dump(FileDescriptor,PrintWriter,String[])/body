{
synchronized (mQueueLock) {
    pw.println("Backup Manager is " + (mEnabled ? "enabled" : "disabled") + " / "+ (!mProvisioned ? "not " : "")+ "provisioned / "+ (!mBackupOrRestoreInProgress ? "not " : "")+ "in progress / "+ (this.mPendingInits.size() == 0 ? "not " : "")+ "pending init / "+ (!mInitInProgress ? "not " : "")+ "initializing");
    pw.println("Last backup pass: " + mLastBackupPass + " (now = "+ System.currentTimeMillis()+ ')');
    pw.println("  next scheduled: " + mNextBackupPass);
    pw.println("Available transports:");
    for (    String t : listAllTransports()) {
      pw.println((t.equals(mCurrentTransport) ? "  * " : "    ") + t);
      try {
        File dir=new File(mBaseStateDir,getTransport(t).transportDirName());
        for (        File f : dir.listFiles()) {
          pw.println("       " + f.getName() + " - "+ f.length()+ " state bytes");
        }
      }
 catch (      RemoteException e) {
        Log.e(TAG,"Error in transportDirName()",e);
        pw.println("        Error: " + e);
      }
    }
    pw.println("Pending init: " + mPendingInits.size());
    for (    String s : mPendingInits) {
      pw.println("    " + s);
    }
    int N=mBackupParticipants.size();
    pw.println("Participants:");
    for (int i=0; i < N; i++) {
      int uid=mBackupParticipants.keyAt(i);
      pw.print("  uid: ");
      pw.println(uid);
      HashSet<ApplicationInfo> participants=mBackupParticipants.valueAt(i);
      for (      ApplicationInfo app : participants) {
        pw.println("    " + app.packageName);
      }
    }
    pw.println("Ever backed up: " + mEverStoredApps.size());
    for (    String pkg : mEverStoredApps) {
      pw.println("    " + pkg);
    }
    pw.println("Pending backup: " + mPendingBackups.size());
    for (    BackupRequest req : mPendingBackups.values()) {
      pw.println("    " + req);
    }
  }
}
