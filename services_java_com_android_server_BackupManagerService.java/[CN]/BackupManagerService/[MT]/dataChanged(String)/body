{
  Log.d(TAG,"dataChanged packageName=" + packageName);
  HashSet<ApplicationInfo> targets;
  if ((mContext.checkPermission("android.permission.BACKUP",Binder.getCallingPid(),Binder.getCallingUid())) == PackageManager.PERMISSION_DENIED) {
    targets=mBackupParticipants.get(Binder.getCallingUid());
  }
 else {
    if (DEBUG)     Log.v(TAG,"Privileged caller, allowing backup of other apps");
    targets=new HashSet<ApplicationInfo>();
    int N=mBackupParticipants.size();
    for (int i=0; i < N; i++) {
      HashSet<ApplicationInfo> s=mBackupParticipants.valueAt(i);
      if (s != null) {
        targets.addAll(s);
      }
    }
  }
  if (targets != null) {
synchronized (mQueueLock) {
      for (      ApplicationInfo app : targets) {
        if (app.packageName.equals(packageName)) {
          BackupRequest req=new BackupRequest(app,false);
          mPendingBackups.put(app,req);
          writeToJournalLocked(packageName);
        }
      }
      if (DEBUG) {
        int numKeys=mPendingBackups.size();
        Log.d(TAG,"Scheduling backup for " + numKeys + " participants:");
        for (        BackupRequest b : mPendingBackups.values()) {
          Log.d(TAG,"    + " + b + " agent="+ b.appInfo.backupAgentName);
        }
      }
      mBackupHandler.removeMessages(MSG_RUN_BACKUP);
      mBackupHandler.sendEmptyMessageDelayed(MSG_RUN_BACKUP,COLLECTION_INTERVAL);
    }
  }
 else {
    Log.w(TAG,"dataChanged but no participant pkg " + packageName);
  }
}
