{
  mContext=context;
  mPackageManager=context.getPackageManager();
  mPackageManagerBinder=AppGlobals.getPackageManager();
  mActivityManager=ActivityManagerNative.getDefault();
  mAlarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  mPowerManager=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mMountService=IMountService.Stub.asInterface(ServiceManager.getService("mount"));
  mBackupManagerBinder=asInterface(asBinder());
  mHandlerThread=new HandlerThread("backup",Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mBackupHandler=new BackupHandler(mHandlerThread.getLooper());
  final ContentResolver resolver=context.getContentResolver();
  boolean areEnabled=Settings.Secure.getInt(resolver,Settings.Secure.BACKUP_ENABLED,0) != 0;
  mProvisioned=Settings.Global.getInt(resolver,Settings.Global.DEVICE_PROVISIONED,0) != 0;
  mAutoRestore=Settings.Secure.getInt(resolver,Settings.Secure.BACKUP_AUTO_RESTORE,1) != 0;
  mProvisionedObserver=new ProvisionedObserver(mBackupHandler);
  resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONED),false,mProvisionedObserver);
  mBaseStateDir=new File(Environment.getSecureDataDirectory(),"backup");
  mBaseStateDir.mkdirs();
  if (!SELinux.restorecon(mBaseStateDir)) {
    Slog.e(TAG,"SELinux restorecon failed on " + mBaseStateDir);
  }
  mDataDir=Environment.getDownloadCacheDirectory();
  mPasswordVersion=1;
  mPasswordVersionFile=new File(mBaseStateDir,"pwversion");
  if (mPasswordVersionFile.exists()) {
    FileInputStream fin=null;
    DataInputStream in=null;
    try {
      fin=new FileInputStream(mPasswordVersionFile);
      in=new DataInputStream(fin);
      mPasswordVersion=in.readInt();
    }
 catch (    IOException e) {
      Slog.e(TAG,"Unable to read backup pw version");
    }
 finally {
      try {
        if (in != null)         in.close();
        if (fin != null)         fin.close();
      }
 catch (      IOException e) {
        Slog.w(TAG,"Error closing pw version files");
      }
    }
  }
  mPasswordHashFile=new File(mBaseStateDir,"pwhash");
  if (mPasswordHashFile.exists()) {
    FileInputStream fin=null;
    DataInputStream in=null;
    try {
      fin=new FileInputStream(mPasswordHashFile);
      in=new DataInputStream(new BufferedInputStream(fin));
      int saltLen=in.readInt();
      byte[] salt=new byte[saltLen];
      in.readFully(salt);
      mPasswordHash=in.readUTF();
      mPasswordSalt=salt;
    }
 catch (    IOException e) {
      Slog.e(TAG,"Unable to read saved backup pw hash");
    }
 finally {
      try {
        if (in != null)         in.close();
        if (fin != null)         fin.close();
      }
 catch (      IOException e) {
        Slog.w(TAG,"Unable to close streams");
      }
    }
  }
  mRunBackupReceiver=new RunBackupReceiver();
  IntentFilter filter=new IntentFilter();
  filter.addAction(RUN_BACKUP_ACTION);
  context.registerReceiver(mRunBackupReceiver,filter,android.Manifest.permission.BACKUP,null);
  mRunInitReceiver=new RunInitializeReceiver();
  filter=new IntentFilter();
  filter.addAction(RUN_INITIALIZE_ACTION);
  context.registerReceiver(mRunInitReceiver,filter,android.Manifest.permission.BACKUP,null);
  Intent backupIntent=new Intent(RUN_BACKUP_ACTION);
  backupIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  mRunBackupIntent=PendingIntent.getBroadcast(context,MSG_RUN_BACKUP,backupIntent,0);
  Intent initIntent=new Intent(RUN_INITIALIZE_ACTION);
  backupIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  mRunInitIntent=PendingIntent.getBroadcast(context,MSG_RUN_INITIALIZE,initIntent,0);
  mJournalDir=new File(mBaseStateDir,"pending");
  mJournalDir.mkdirs();
  mJournal=null;
  initPackageTracking();
synchronized (mBackupParticipants) {
    addPackageParticipantsLocked(null);
  }
  mCurrentTransport=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.BACKUP_TRANSPORT);
  if ("".equals(mCurrentTransport)) {
    mCurrentTransport=null;
  }
  if (DEBUG)   Slog.v(TAG,"Starting with transport " + mCurrentTransport);
  Intent transportServiceIntent=new Intent(SERVICE_ACTION_TRANSPORT_HOST);
  List<ResolveInfo> hosts=mPackageManager.queryIntentServicesAsUser(transportServiceIntent,0,UserHandle.USER_OWNER);
  if (DEBUG) {
    Slog.v(TAG,"Found transports: " + ((hosts == null) ? "null" : hosts.size()));
  }
  if (hosts != null) {
    if (MORE_DEBUG) {
      for (int i=0; i < hosts.size(); i++) {
        ServiceInfo info=hosts.get(i).serviceInfo;
        Slog.v(TAG,"   " + info.packageName + "/"+ info.name);
      }
    }
    for (int i=0; i < hosts.size(); i++) {
      try {
        ServiceInfo info=hosts.get(i).serviceInfo;
        PackageInfo packInfo=mPackageManager.getPackageInfo(info.packageName,0);
        if ((packInfo.applicationInfo.flags & ApplicationInfo.FLAG_PRIVILEGED) != 0) {
          ComponentName svcName=new ComponentName(info.packageName,info.name);
          if (DEBUG) {
            Slog.i(TAG,"Binding to transport host " + svcName);
          }
          Intent intent=new Intent(transportServiceIntent);
          intent.setComponent(svcName);
          TransportConnection connection=new TransportConnection();
          mTransportConnections.add(connection);
          context.bindServiceAsUser(intent,connection,Context.BIND_AUTO_CREATE,UserHandle.OWNER);
        }
 else {
          Slog.w(TAG,"Transport package not privileged: " + info.packageName);
        }
      }
 catch (      Exception e) {
        Slog.e(TAG,"Problem resolving transport service: " + e.getMessage());
      }
    }
  }
  parseLeftoverJournals();
  mWakelock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,"*backup*");
  setBackupEnabled(areEnabled);
}
