{
  if (response == null) {
    Log.e(TAG,"getNetworkLocation(): response is null");
    return false;
  }
  int status1=response.getInt(GLocReply.STATUS);
  if (status1 != ResponseCodes.STATUS_STATUS_SUCCESS) {
    Log.e(TAG,"getNetworkLocation(): RPC failed with status " + status1);
    return false;
  }
  if (response.has(GLocReply.PLATFORM_KEY)) {
    String platformKey=response.getString(GLocReply.PLATFORM_KEY);
    if (!TextUtils.isEmpty(platformKey)) {
      setPlatformKey(platformKey);
    }
  }
  if (!response.has(GLocReply.REPLY_ELEMENTS)) {
    Log.e(TAG,"getNetworkLocation(): no ReplyElement");
    return false;
  }
  ProtoBuf replyElement=response.getProtoBuf(GLocReply.REPLY_ELEMENTS);
  int status2=replyElement.getInt(GLocReplyElement.STATUS);
  if (status2 != ResponseCodes.STATUS_STATUS_SUCCESS && status2 != ResponseCodes.STATUS_STATUS_FAILED) {
    Log.e(TAG,"getNetworkLocation(): GLS failed with status " + status2);
    return false;
  }
  Log.d(TAG,"getNetworkLocation(): Number of prefetched entries " + replyElement.getCount(GLocReplyElement.DEVICE_LOCATION));
  long now=System.currentTimeMillis();
  for (int i=0; i < replyElement.getCount(GLocReplyElement.DEVICE_LOCATION); i++) {
    ProtoBuf device=replyElement.getProtoBuf(GLocReplyElement.DEVICE_LOCATION,i);
    double lat=0;
    double lng=0;
    int accuracy=-1;
    int confidence=-1;
    int locType=-1;
    if (device.has(GDeviceLocation.LOCATION)) {
      ProtoBuf deviceLocation=device.getProtoBuf(GDeviceLocation.LOCATION);
      if (deviceLocation.has(GLocation.ACCURACY) && deviceLocation.has(GLocation.LAT_LNG) && deviceLocation.has(GLocation.CONFIDENCE)) {
        lat=deviceLocation.getProtoBuf(GLocation.LAT_LNG).getInt(GLatLng.LAT_E7) / E7;
        lng=deviceLocation.getProtoBuf(GLocation.LAT_LNG).getInt(GLatLng.LNG_E7) / E7;
        accuracy=deviceLocation.getInt(GLocation.ACCURACY);
        confidence=deviceLocation.getInt(GLocation.CONFIDENCE);
      }
      if (deviceLocation.has(GLocation.LOC_TYPE)) {
        locType=deviceLocation.getInt(GLocation.LOC_TYPE);
      }
    }
    if (device.has(GDeviceLocation.CELL) && locType != GLocation.LOCTYPE_TOWER_LOCATION) {
      ProtoBuf deviceCell=device.getProtoBuf(GDeviceLocation.CELL);
      int cid=deviceCell.getInt(GCell.CELLID);
      int lac=deviceCell.getInt(GCell.LAC);
      int mcc=-1;
      int mnc=-1;
      if (deviceCell.has(GCell.MNC) && deviceCell.has(GCell.MCC)) {
        mcc=deviceCell.getInt(GCell.MCC);
        mnc=deviceCell.getInt(GCell.MNC);
      }
      mLocationCache.insert(mcc,mnc,lac,cid,lat,lng,accuracy,confidence,now);
    }
    if (device.has(GDeviceLocation.WIFI_DEVICE)) {
      ProtoBuf deviceWifi=device.getProtoBuf(GDeviceLocation.WIFI_DEVICE);
      String bssid=deviceWifi.getString(GWifiDevice.MAC);
      mLocationCache.insert(bssid,lat,lng,accuracy,confidence,now);
    }
  }
  mLocationCache.save();
  boolean foundInCache=mLocationCache.lookup(mCellState,mCellHistory,mWifiScanResults,mLocation);
  if (foundInCache) {
    Bundle extras=mLocation.getExtras() == null ? new Bundle() : mLocation.getExtras();
    extras.putString(EXTRA_KEY_LOCATION_SOURCE,EXTRA_VALUE_LOCATION_SOURCE_SERVER);
    mLocation.setExtras(extras);
    Log.d(TAG,"getNetworkLocation(): Returning network location with accuracy " + mLocation.getAccuracy());
    return true;
  }
  if (status2 == ResponseCodes.STATUS_STATUS_FAILED) {
    Log.e(TAG,"getNetworkLocation(): GLS does not have location");
    return true;
  }
  if (!replyElement.has(GLocReplyElement.LOCATION)) {
    Log.e(TAG,"getNetworkLocation(): no location in ReplyElement");
    return false;
  }
  ProtoBuf location=replyElement.getProtoBuf(GLocReplyElement.LOCATION);
  if (!location.has(GLocation.LAT_LNG)) {
    Log.e(TAG,"getNetworkLocation(): no Lat,Lng in location");
    return false;
  }
  ProtoBuf point=location.getProtoBuf(GLocation.LAT_LNG);
  double lat=point.getInt(GLatLng.LAT_E7) / E7;
  double lng=point.getInt(GLatLng.LNG_E7) / E7;
  int accuracy=0;
  if (location.has(GLocation.ACCURACY)) {
    accuracy=location.getInt(GLocation.ACCURACY);
  }
  mLocation.setLatitude(lat);
  mLocation.setLongitude(lng);
  mLocation.setTime(System.currentTimeMillis());
  mLocation.setAccuracy(accuracy);
  Bundle extras=mLocation.getExtras() == null ? new Bundle() : mLocation.getExtras();
  extras.putString(EXTRA_KEY_LOCATION_SOURCE,EXTRA_VALUE_LOCATION_SOURCE_SERVER);
  mLocation.setExtras(extras);
  Log.e(TAG,"getNetworkLocation(): Returning *server* computed location with accuracy " + accuracy);
  return true;
}
