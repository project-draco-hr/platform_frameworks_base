{
  if (mKeyStore == null || mSpec == null) {
    throw new IllegalStateException("Must call initialize with an android.security.KeyPairGeneratorSpec first");
  }
  if (((mSpec.getFlags() & KeyStore.FLAG_ENCRYPTED) != 0) && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
    throw new IllegalStateException("Android keystore must be in initialized and unlocked state " + "if encryption is required");
  }
  final String alias=mSpec.getKeystoreAlias();
  Credentials.deleteAllTypesForAlias(mKeyStore,alias);
  final int keyType=KeyStore.getKeyTypeForAlgorithm(mSpec.getKeyType());
  byte[][] args=getArgsForKeyType(keyType,mSpec.getAlgorithmParameterSpec());
  final String privateKeyAlias=Credentials.USER_PRIVATE_KEY + alias;
  if (!mKeyStore.generate(privateKeyAlias,KeyStore.UID_SELF,keyType,mSpec.getKeySize(),mSpec.getFlags(),args)) {
    throw new IllegalStateException("could not generate key in keystore");
  }
  final PrivateKey privKey;
  final OpenSSLEngine engine=OpenSSLEngine.getInstance("keystore");
  try {
    privKey=engine.getPrivateKeyById(privateKeyAlias);
  }
 catch (  InvalidKeyException e) {
    throw new RuntimeException("Can't get key",e);
  }
  final byte[] pubKeyBytes=mKeyStore.getPubkey(privateKeyAlias);
  final PublicKey pubKey;
  try {
    final KeyFactory keyFact=KeyFactory.getInstance(mSpec.getKeyType());
    pubKey=keyFact.generatePublic(new X509EncodedKeySpec(pubKeyBytes));
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalStateException("Can't instantiate key generator",e);
  }
catch (  InvalidKeySpecException e) {
    throw new IllegalStateException("keystore returned invalid key encoding",e);
  }
  final X509V3CertificateGenerator certGen=new X509V3CertificateGenerator();
  certGen.setPublicKey(pubKey);
  certGen.setSerialNumber(mSpec.getSerialNumber());
  certGen.setSubjectDN(mSpec.getSubjectDN());
  certGen.setIssuerDN(mSpec.getSubjectDN());
  certGen.setNotBefore(mSpec.getStartDate());
  certGen.setNotAfter(mSpec.getEndDate());
  certGen.setSignatureAlgorithm(getDefaultSignatureAlgorithmForKeyType(mSpec.getKeyType()));
  final X509Certificate cert;
  try {
    cert=certGen.generate(privKey);
  }
 catch (  Exception e) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    throw new IllegalStateException("Can't generate certificate",e);
  }
  byte[] certBytes;
  try {
    certBytes=cert.getEncoded();
  }
 catch (  CertificateEncodingException e) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    throw new IllegalStateException("Can't get encoding of certificate",e);
  }
  if (!mKeyStore.put(Credentials.USER_CERTIFICATE + alias,certBytes,KeyStore.UID_SELF,mSpec.getFlags())) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    throw new IllegalStateException("Can't store certificate in AndroidKeyStore");
  }
  return new KeyPair(pubKey,privKey);
}
