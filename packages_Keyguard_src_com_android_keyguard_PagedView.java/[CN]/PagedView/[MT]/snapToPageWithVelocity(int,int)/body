{
  whichPage=Math.max(0,Math.min(whichPage,getChildCount() - 1));
  int halfScreenSize=getViewportWidth() / 2;
  if (isWarping()) {
    cancelWarpAnimation("snapToPageWithVelocity",mCurrentPage != whichPage);
  }
  if (DEBUG)   Log.d(TAG,"snapToPage.getChildOffset(): " + getChildOffset(whichPage));
  if (DEBUG)   Log.d(TAG,"snapToPageWithVelocity.getRelativeChildOffset(): " + getViewportWidth() + ", "+ getChildWidth(whichPage));
  final int newX=getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
  int delta=newX - mUnboundedScrollX;
  int duration=0;
  if (Math.abs(velocity) < mMinFlingVelocity) {
    snapToPage(whichPage,getPageSnapDuration());
    return;
  }
  float distanceRatio=Math.min(1f,1.0f * Math.abs(delta) / (2 * halfScreenSize));
  float distance=halfScreenSize + halfScreenSize * distanceInfluenceForSnapDuration(distanceRatio);
  velocity=Math.abs(velocity);
  velocity=Math.max(mMinSnapVelocity,velocity);
  duration=4 * Math.round(1000 * Math.abs(distance / velocity));
  snapToPage(whichPage,delta,duration);
}
