{
  final long startTime=AnimationUtils.currentAnimationTimeMillis();
  final TimeInterpolator tInterpolator=new TimeInterpolator(){
    private int mCount=-1;
    private long mStartTime;
    private float mOffset;
{
      mStartTime=startTime;
    }
    @Override public float getInterpolation(    float t){
      if (mCount < 0) {
        mCount++;
      }
 else       if (mCount == 0) {
        mOffset=Math.min(0.5f,(float)(AnimationUtils.currentAnimationTimeMillis() - mStartTime) / FLING_TO_DELETE_FADE_OUT_DURATION);
        mCount++;
      }
      return Math.min(1f,mOffset + t);
    }
  }
;
  final Rect from=new Rect();
  final View dragView=mDragView;
  from.left=(int)dragView.getTranslationX();
  from.top=(int)dragView.getTranslationY();
  AnimatorUpdateListener updateCb=new FlingAlongVectorAnimatorUpdateListener(dragView,vel,from,startTime,FLING_TO_DELETE_FRICTION);
  mDeleteString=getContext().getResources().getString(R.string.keyguard_accessibility_widget_deleted,mDragView.getContentDescription());
  final Runnable onAnimationEndRunnable=createPostDeleteAnimationRunnable(dragView);
  ValueAnimator mDropAnim=new ValueAnimator();
  mDropAnim.setInterpolator(tInterpolator);
  mDropAnim.setDuration(FLING_TO_DELETE_FADE_OUT_DURATION);
  mDropAnim.setFloatValues(0f,1f);
  mDropAnim.addUpdateListener(updateCb);
  mDropAnim.addListener(new AnimatorListenerAdapter(){
    public void onAnimationEnd(    Animator animation){
      onAnimationEndRunnable.run();
    }
  }
);
  mDropAnim.start();
  mDeferringForDelete=true;
}
