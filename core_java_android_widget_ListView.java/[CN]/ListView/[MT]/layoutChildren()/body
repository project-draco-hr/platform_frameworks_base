{
  final boolean blockLayoutRequests=mBlockLayoutRequests;
  if (blockLayoutRequests) {
    return;
  }
  mBlockLayoutRequests=true;
  try {
    super.layoutChildren();
    invalidate();
    if (mAdapter == null) {
      resetList();
      invokeOnItemScrollListener();
      return;
    }
    final int childrenTop=mListPadding.top;
    final int childrenBottom=mBottom - mTop - mListPadding.bottom;
    final int childCount=getChildCount();
    int index=0;
    int delta=0;
    View sel;
    View oldSel=null;
    View oldFirst=null;
    View newSel=null;
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
      index=mNextSelectedPosition - mFirstPosition;
    if (index >= 0 && index < childCount) {
      newSel=getChildAt(index);
    }
  break;
case LAYOUT_FORCE_TOP:
case LAYOUT_FORCE_BOTTOM:
case LAYOUT_SPECIFIC:
case LAYOUT_SYNC:
break;
case LAYOUT_MOVE_SELECTION:
default :
index=mSelectedPosition - mFirstPosition;
if (index >= 0 && index < childCount) {
oldSel=getChildAt(index);
}
oldFirst=getChildAt(0);
if (mNextSelectedPosition >= 0) {
delta=mNextSelectedPosition - mSelectedPosition;
}
newSel=getChildAt(index + delta);
}
boolean dataChanged=mDataChanged;
if (dataChanged) {
handleDataChanged();
}
if (mItemCount == 0) {
resetList();
invokeOnItemScrollListener();
return;
}
 else if (mItemCount != mAdapter.getCount()) {
throw new IllegalStateException("The content of the adapter has changed but " + "ListView did not receive a notification. Make sure the content of " + "your adapter is not modified from a background thread, but only from "+ "the UI thread. Make sure your adapter calls notifyDataSetChanged() "+ "when its content changes. [in ListView(" + getId() + ", "+ getClass()+ ") with Adapter("+ mAdapter.getClass()+ ")]");
}
setSelectedPositionInt(mNextSelectedPosition);
final int accessibilityFocusPosition;
final View accessFocusedChild=getAccessibilityFocusedChild();
if (accessFocusedChild != null) {
accessibilityFocusPosition=getPositionForView(accessFocusedChild);
accessFocusedChild.setHasTransientState(true);
}
 else {
accessibilityFocusPosition=INVALID_POSITION;
}
final View focusedChild=getFocusedChild();
if (focusedChild != null) {
focusedChild.setHasTransientState(true);
}
final int firstPosition=mFirstPosition;
final RecycleBin recycleBin=mRecycler;
if (dataChanged) {
for (int i=0; i < childCount; i++) {
recycleBin.addScrapView(getChildAt(i),firstPosition + i);
}
}
 else {
recycleBin.fillActiveViews(childCount,firstPosition);
}
detachAllViewsFromParent();
recycleBin.removeSkippedScrap();
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
if (newSel != null) {
sel=fillFromSelection(newSel.getTop(),childrenTop,childrenBottom);
}
 else {
sel=fillFromMiddle(childrenTop,childrenBottom);
}
break;
case LAYOUT_SYNC:
sel=fillSpecific(mSyncPosition,mSpecificTop);
break;
case LAYOUT_FORCE_BOTTOM:
sel=fillUp(mItemCount - 1,childrenBottom);
adjustViewsUpOrDown();
break;
case LAYOUT_FORCE_TOP:
mFirstPosition=0;
sel=fillFromTop(childrenTop);
adjustViewsUpOrDown();
break;
case LAYOUT_SPECIFIC:
sel=fillSpecific(reconcileSelectedPosition(),mSpecificTop);
break;
case LAYOUT_MOVE_SELECTION:
sel=moveSelection(oldSel,newSel,delta,childrenTop,childrenBottom);
break;
default :
if (childCount == 0) {
if (!mStackFromBottom) {
final int position=lookForSelectablePosition(0,true);
setSelectedPositionInt(position);
sel=fillFromTop(childrenTop);
}
 else {
final int position=lookForSelectablePosition(mItemCount - 1,false);
setSelectedPositionInt(position);
sel=fillUp(mItemCount - 1,childrenBottom);
}
}
 else {
if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
sel=fillSpecific(mSelectedPosition,oldSel == null ? childrenTop : oldSel.getTop());
}
 else if (mFirstPosition < mItemCount) {
sel=fillSpecific(mFirstPosition,oldFirst == null ? childrenTop : oldFirst.getTop());
}
 else {
sel=fillSpecific(0,childrenTop);
}
}
break;
}
recycleBin.scrapActiveViews();
if (sel != null) {
final boolean shouldPlaceFocus=mItemsCanFocus && hasFocus();
final boolean maintainedFocus=focusedChild != null && focusedChild.hasFocus();
if (shouldPlaceFocus && !maintainedFocus && !sel.hasFocus()) {
if (sel.requestFocus()) {
sel.setSelected(false);
mSelectorRect.setEmpty();
}
 else {
final View focused=getFocusedChild();
if (focused != null) {
focused.clearFocus();
}
positionSelector(INVALID_POSITION,sel);
}
}
 else {
positionSelector(INVALID_POSITION,sel);
}
mSelectedTop=sel.getTop();
}
 else {
if (mTouchMode == TOUCH_MODE_TAP || mTouchMode == TOUCH_MODE_DONE_WAITING) {
final View child=getChildAt(mMotionPosition - mFirstPosition);
if (child != null) {
positionSelector(mMotionPosition,child);
}
}
 else {
mSelectedTop=0;
mSelectorRect.setEmpty();
}
}
if (accessFocusedChild != null) {
accessFocusedChild.setHasTransientState(false);
if (!accessFocusedChild.isAccessibilityFocused() && accessibilityFocusPosition != INVALID_POSITION) {
final int position=MathUtils.constrain(accessibilityFocusPosition - mFirstPosition,0,getChildCount() - 1);
final View restoreView=getChildAt(position);
if (restoreView != null) {
restoreView.requestAccessibilityFocus();
}
}
}
if (focusedChild != null) {
focusedChild.setHasTransientState(false);
}
mLayoutMode=LAYOUT_NORMAL;
mDataChanged=false;
if (mPositionScrollAfterLayout != null) {
post(mPositionScrollAfterLayout);
mPositionScrollAfterLayout=null;
}
mNeedSync=false;
setNextSelectedPositionInt(mSelectedPosition);
updateScrollIndicators();
if (mItemCount > 0) {
checkSelectionChanged();
}
invokeOnItemScrollListener();
}
  finally {
if (!blockLayoutRequests) {
mBlockLayoutRequests=false;
}
}
}
