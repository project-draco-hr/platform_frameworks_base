{
  final boolean blockLayoutRequests=mBlockLayoutRequests;
  if (!blockLayoutRequests) {
    mBlockLayoutRequests=true;
  }
 else {
    return;
  }
  try {
    super.layoutChildren();
    invalidate();
    if (mAdapter == null) {
      resetList();
      invokeOnItemScrollListener();
      return;
    }
    int childrenTop=mListPadding.top;
    int childrenBottom=mBottom - mTop - mListPadding.bottom;
    int childCount=getChildCount();
    int index=0;
    int delta=0;
    View sel;
    View oldSel=null;
    View oldFirst=null;
    View newSel=null;
    View focusLayoutRestoreView=null;
    AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode=null;
    View accessibilityFocusLayoutRestoreView=null;
    int accessibilityFocusPosition=INVALID_POSITION;
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
      index=mNextSelectedPosition - mFirstPosition;
    if (index >= 0 && index < childCount) {
      newSel=getChildAt(index);
    }
  break;
case LAYOUT_FORCE_TOP:
case LAYOUT_FORCE_BOTTOM:
case LAYOUT_SPECIFIC:
case LAYOUT_SYNC:
break;
case LAYOUT_MOVE_SELECTION:
default :
index=mSelectedPosition - mFirstPosition;
if (index >= 0 && index < childCount) {
oldSel=getChildAt(index);
}
oldFirst=getChildAt(0);
if (mNextSelectedPosition >= 0) {
delta=mNextSelectedPosition - mSelectedPosition;
}
newSel=getChildAt(index + delta);
}
boolean dataChanged=mDataChanged;
if (dataChanged) {
handleDataChanged();
}
if (mItemCount == 0) {
resetList();
invokeOnItemScrollListener();
return;
}
 else if (mItemCount != mAdapter.getCount()) {
throw new IllegalStateException("The content of the adapter has changed but " + "ListView did not receive a notification. Make sure the content of " + "your adapter is not modified from a background thread, but only "+ "from the UI thread. [in ListView(" + getId() + ", "+ getClass()+ ") with Adapter("+ mAdapter.getClass()+ ")]");
}
setSelectedPositionInt(mNextSelectedPosition);
final int firstPosition=mFirstPosition;
final RecycleBin recycleBin=mRecycler;
View focusLayoutRestoreDirectChild=null;
if (dataChanged) {
for (int i=0; i < childCount; i++) {
recycleBin.addScrapView(getChildAt(i),firstPosition + i);
}
}
 else {
recycleBin.fillActiveViews(childCount,firstPosition);
}
final View focusedChild=getFocusedChild();
if (focusedChild != null) {
if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
focusLayoutRestoreDirectChild=focusedChild;
focusLayoutRestoreView=findFocus();
if (focusLayoutRestoreView != null) {
focusLayoutRestoreView.onStartTemporaryDetach();
}
}
requestFocus();
}
final View accessFocusedView=getViewRootImpl().getAccessibilityFocusedHost();
if (accessFocusedView != null) {
final View accessFocusedChild=findAccessibilityFocusedChild(accessFocusedView);
if (accessFocusedChild != null) {
if (!dataChanged || isDirectChildHeaderOrFooter(accessFocusedChild)) {
accessibilityFocusLayoutRestoreView=accessFocusedView;
accessibilityFocusLayoutRestoreNode=getViewRootImpl().getAccessibilityFocusedVirtualView();
}
 else {
accessibilityFocusPosition=getPositionForView(accessFocusedChild);
}
}
}
detachAllViewsFromParent();
recycleBin.removeSkippedScrap();
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
if (newSel != null) {
sel=fillFromSelection(newSel.getTop(),childrenTop,childrenBottom);
}
 else {
sel=fillFromMiddle(childrenTop,childrenBottom);
}
break;
case LAYOUT_SYNC:
sel=fillSpecific(mSyncPosition,mSpecificTop);
break;
case LAYOUT_FORCE_BOTTOM:
sel=fillUp(mItemCount - 1,childrenBottom);
adjustViewsUpOrDown();
break;
case LAYOUT_FORCE_TOP:
mFirstPosition=0;
sel=fillFromTop(childrenTop);
adjustViewsUpOrDown();
break;
case LAYOUT_SPECIFIC:
sel=fillSpecific(reconcileSelectedPosition(),mSpecificTop);
break;
case LAYOUT_MOVE_SELECTION:
sel=moveSelection(oldSel,newSel,delta,childrenTop,childrenBottom);
break;
default :
if (childCount == 0) {
if (!mStackFromBottom) {
final int position=lookForSelectablePosition(0,true);
setSelectedPositionInt(position);
sel=fillFromTop(childrenTop);
}
 else {
final int position=lookForSelectablePosition(mItemCount - 1,false);
setSelectedPositionInt(position);
sel=fillUp(mItemCount - 1,childrenBottom);
}
}
 else {
if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
sel=fillSpecific(mSelectedPosition,oldSel == null ? childrenTop : oldSel.getTop());
}
 else if (mFirstPosition < mItemCount) {
sel=fillSpecific(mFirstPosition,oldFirst == null ? childrenTop : oldFirst.getTop());
}
 else {
sel=fillSpecific(0,childrenTop);
}
}
break;
}
recycleBin.scrapActiveViews();
if (sel != null) {
if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
final boolean focusWasTaken=(sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView != null && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
if (!focusWasTaken) {
final View focused=getFocusedChild();
if (focused != null) {
focused.clearFocus();
}
positionSelector(INVALID_POSITION,sel);
}
 else {
sel.setSelected(false);
mSelectorRect.setEmpty();
}
}
 else {
positionSelector(INVALID_POSITION,sel);
}
mSelectedTop=sel.getTop();
}
 else {
if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
View child=getChildAt(mMotionPosition - mFirstPosition);
if (child != null) positionSelector(mMotionPosition,child);
}
 else {
mSelectedTop=0;
mSelectorRect.setEmpty();
}
if (hasFocus() && focusLayoutRestoreView != null) {
focusLayoutRestoreView.requestFocus();
}
}
if (accessibilityFocusLayoutRestoreNode != null) {
accessibilityFocusLayoutRestoreNode.performAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
}
 else if (accessibilityFocusLayoutRestoreView != null) {
accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();
}
 else if (accessibilityFocusPosition != INVALID_POSITION) {
final int position=MathUtils.constrain((accessibilityFocusPosition - mFirstPosition),0,(getChildCount() - 1));
final View restoreView=getChildAt(position);
if (restoreView != null) {
restoreView.requestAccessibilityFocus();
}
}
if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
focusLayoutRestoreView.onFinishTemporaryDetach();
}
mLayoutMode=LAYOUT_NORMAL;
mDataChanged=false;
if (mPositionScrollAfterLayout != null) {
post(mPositionScrollAfterLayout);
mPositionScrollAfterLayout=null;
}
mNeedSync=false;
setNextSelectedPositionInt(mSelectedPosition);
updateScrollIndicators();
if (mItemCount > 0) {
checkSelectionChanged();
}
invokeOnItemScrollListener();
}
  finally {
if (!blockLayoutRequests) {
mBlockLayoutRequests=false;
}
}
}
