{
  if (key == null) {
    throw new InvalidKeyException("Unsupported key: null");
  }
  if (!KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(key.getAlgorithm())) {
    throw new InvalidKeyException("Unsupported key algorithm: " + key.getAlgorithm() + ". Only "+ KeyProperties.KEY_ALGORITHM_RSA+ " supported");
  }
  AndroidKeyStoreKey keystoreKey;
  if (key instanceof AndroidKeyStorePrivateKey) {
    keystoreKey=(AndroidKeyStoreKey)key;
  }
 else   if (key instanceof AndroidKeyStorePublicKey) {
    keystoreKey=(AndroidKeyStoreKey)key;
  }
 else {
    throw new InvalidKeyException("Unsupported key type: " + key);
  }
  if (keystoreKey instanceof PrivateKey) {
switch (opmode) {
case Cipher.DECRYPT_MODE:
case Cipher.UNWRAP_MODE:
      break;
case Cipher.ENCRYPT_MODE:
case Cipher.WRAP_MODE:
    if (!adjustConfigForEncryptingWithPrivateKey()) {
      throw new InvalidKeyException("RSA private keys cannot be used with " + opmodeToString(opmode) + " and padding "+ KeyProperties.EncryptionPadding.fromKeymaster(mKeymasterPadding)+ ". Only RSA public keys supported for this mode");
    }
  break;
default :
throw new InvalidKeyException("RSA private keys cannot be used with opmode: " + opmode);
}
}
 else {
switch (opmode) {
case Cipher.ENCRYPT_MODE:
case Cipher.WRAP_MODE:
break;
case Cipher.DECRYPT_MODE:
case Cipher.UNWRAP_MODE:
throw new InvalidKeyException("RSA public keys cannot be used with " + opmodeToString(opmode) + " and padding "+ KeyProperties.EncryptionPadding.fromKeymaster(mKeymasterPadding)+ ". Only RSA private keys supported for this opmode.");
default :
throw new InvalidKeyException("RSA public keys cannot be used with " + opmodeToString(opmode));
}
}
KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
int errorCode=getKeyStore().getKeyCharacteristics(keystoreKey.getAlias(),null,null,keystoreKey.getUid(),keyCharacteristics);
if (errorCode != KeyStore.NO_ERROR) {
throw getKeyStore().getInvalidKeyException(keystoreKey.getAlias(),keystoreKey.getUid(),errorCode);
}
long keySizeBits=keyCharacteristics.getUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE,-1);
if (keySizeBits == -1) {
throw new InvalidKeyException("Size of key not known");
}
 else if (keySizeBits > Integer.MAX_VALUE) {
throw new InvalidKeyException("Key too large: " + keySizeBits + " bits");
}
mModulusSizeBytes=(int)((keySizeBits + 7) / 8);
setKey(keystoreKey);
}
