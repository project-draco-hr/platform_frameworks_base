{
  if (key == null) {
    throw new InvalidKeyException("Unsupported key: null");
  }
  if (!KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(key.getAlgorithm())) {
    throw new InvalidKeyException("Unsupported key algorithm: " + key.getAlgorithm() + ". Only "+ KeyProperties.KEY_ALGORITHM_RSA+ " supported");
  }
  AndroidKeyStoreKey keystoreKey;
  if (key instanceof AndroidKeyStorePrivateKey) {
    keystoreKey=(AndroidKeyStoreKey)key;
  }
 else   if (key instanceof AndroidKeyStorePublicKey) {
    keystoreKey=(AndroidKeyStoreKey)key;
  }
 else {
    throw new InvalidKeyException("Unsupported key type: " + key);
  }
  if (keystoreKey instanceof PrivateKey) {
    if ((opmode != Cipher.DECRYPT_MODE) && (opmode != Cipher.UNWRAP_MODE)) {
      throw new InvalidKeyException("Private key cannot be used with opmode: " + opmode + ". Only DECRYPT_MODE and UNWRAP_MODE supported");
    }
  }
 else {
    if ((opmode != Cipher.ENCRYPT_MODE) && (opmode != Cipher.WRAP_MODE)) {
      throw new InvalidKeyException("Public key cannot be used with opmode: " + opmode + ". Only ENCRYPT_MODE and WRAP_MODE supported");
    }
  }
  KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
  int errorCode=getKeyStore().getKeyCharacteristics(keystoreKey.getAlias(),null,null,keyCharacteristics);
  if (errorCode != KeyStore.NO_ERROR) {
    throw getKeyStore().getInvalidKeyException(keystoreKey.getAlias(),errorCode);
  }
  int keySizeBits=keyCharacteristics.getInt(KeymasterDefs.KM_TAG_KEY_SIZE,-1);
  if (keySizeBits == -1) {
    throw new InvalidKeyException("Size of key not known");
  }
  mModulusSizeBytes=(keySizeBits + 7) / 8;
  setKey(keystoreKey);
}
