{
  LocalSocket socket=null;
  try {
    socket=new LocalSocket();
    LocalSocketAddress address=determineSocketAddress();
    socket.connect(address);
    InputStream inputStream=socket.getInputStream();
synchronized (mDaemonLock) {
      mOutputStream=socket.getOutputStream();
    }
    mCallbacks.onDaemonConnected();
    FileDescriptor[] fdList=null;
    byte[] buffer=new byte[BUFFER_SIZE];
    int start=0;
    while (true) {
      int count=inputStream.read(buffer,start,BUFFER_SIZE - start);
      if (count < 0) {
        loge("got " + count + " reading with start = "+ start);
        break;
      }
      fdList=socket.getAncillaryFileDescriptors();
      count+=start;
      start=0;
      for (int i=0; i < count; i++) {
        if (buffer[i] == 0) {
          final String rawEvent=new String(buffer,start,i - start,StandardCharsets.UTF_8);
          boolean releaseWl=false;
          try {
            final NativeDaemonEvent event=NativeDaemonEvent.parseRawEvent(rawEvent,fdList);
            log("RCV <- {" + event + "}");
            if (event.isClassUnsolicited()) {
              if (mCallbacks.onCheckHoldWakeLock(event.getCode()) && mWakeLock != null) {
                mWakeLock.acquire();
                releaseWl=true;
              }
              if (mCallbackHandler.sendMessage(mCallbackHandler.obtainMessage(event.getCode(),event.getRawEvent()))) {
                releaseWl=false;
              }
            }
 else {
              mResponseQueue.add(event.getCmdNumber(),event);
            }
          }
 catch (          IllegalArgumentException e) {
            log("Problem parsing message " + e);
          }
 finally {
            if (releaseWl) {
              mWakeLock.acquire();
            }
          }
          start=i + 1;
        }
      }
      if (start == 0) {
        log("RCV incomplete");
      }
      if (start != count) {
        final int remaining=BUFFER_SIZE - start;
        System.arraycopy(buffer,start,buffer,0,remaining);
        start=remaining;
      }
 else {
        start=0;
      }
    }
  }
 catch (  IOException ex) {
    loge("Communications error: " + ex);
    throw ex;
  }
 finally {
synchronized (mDaemonLock) {
      if (mOutputStream != null) {
        try {
          loge("closing stream for " + mSocket);
          mOutputStream.close();
        }
 catch (        IOException e) {
          loge("Failed closing output stream: " + e);
        }
        mOutputStream=null;
      }
    }
    try {
      if (socket != null) {
        socket.close();
      }
    }
 catch (    IOException ex) {
      loge("Failed closing socket: " + ex);
    }
  }
}
