{
  PackageManager pm=mContext.getPackageManager();
  ArrayList<ServiceInfo<V>> serviceInfos=new ArrayList<ServiceInfo<V>>();
  List<ResolveInfo> resolveInfos=pm.queryIntentServices(new Intent(mInterfaceName),PackageManager.GET_META_DATA);
  for (  ResolveInfo resolveInfo : resolveInfos) {
    try {
      ServiceInfo<V> info=parseServiceInfo(resolveInfo);
      if (info == null) {
        Log.w(TAG,"Unable to load service info " + resolveInfo.toString());
        continue;
      }
      serviceInfos.add(info);
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,"Unable to load service info " + resolveInfo.toString(),e);
    }
catch (    IOException e) {
      Log.w(TAG,"Unable to load service info " + resolveInfo.toString(),e);
    }
  }
synchronized (mServicesLock) {
    if (mPersistentServices == null) {
      readPersistentServicesLocked();
    }
    mServices=Maps.newHashMap();
    StringBuilder changes=new StringBuilder();
    for (    ServiceInfo<V> info : serviceInfos) {
      Integer previousUid=mPersistentServices.get(info.type);
      if (previousUid == null) {
        changes.append("  New service added: ").append(info).append("\n");
        mServices.put(info.type,info);
        mPersistentServices.put(info.type,info.uid);
        if (!mPersistentServicesFileDidNotExist) {
          notifyListener(info.type,false);
        }
      }
 else       if (previousUid == info.uid) {
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          changes.append("  Existing service (nop): ").append(info).append("\n");
        }
        mServices.put(info.type,info);
      }
 else       if (inSystemImage(info.uid) || !containsTypeAndUid(serviceInfos,info.type,previousUid)) {
        if (inSystemImage(info.uid)) {
          changes.append("  System service replacing existing: ").append(info).append("\n");
        }
 else {
          changes.append("  Existing service replacing a removed service: ").append(info).append("\n");
        }
        mServices.put(info.type,info);
        mPersistentServices.put(info.type,info.uid);
        notifyListener(info.type,false);
      }
 else {
        changes.append("  Existing service with new uid ignored: ").append(info).append("\n");
      }
    }
    ArrayList<V> toBeRemoved=Lists.newArrayList();
    for (    V v1 : mPersistentServices.keySet()) {
      if (!containsType(serviceInfos,v1)) {
        toBeRemoved.add(v1);
      }
    }
    for (    V v1 : toBeRemoved) {
      mPersistentServices.remove(v1);
      changes.append("  Service removed: ").append(v1).append("\n");
      notifyListener(v1,true);
    }
    if (changes.length() > 0) {
      Log.d(TAG,"generateServicesMap(" + mInterfaceName + "): "+ serviceInfos.size()+ " services:\n"+ changes);
      writePersistentServicesLocked();
    }
 else {
      Log.d(TAG,"generateServicesMap(" + mInterfaceName + "): "+ serviceInfos.size()+ " services unchanged");
    }
    mPersistentServicesFileDidNotExist=false;
  }
}
