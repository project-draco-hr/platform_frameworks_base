{
  Slog.d(TAG,"generateServicesMap() for " + userId);
  final PackageManager pm=mContext.getPackageManager();
  final ArrayList<ServiceInfo<V>> serviceInfos=new ArrayList<ServiceInfo<V>>();
  final List<ResolveInfo> resolveInfos=pm.queryIntentServicesAsUser(new Intent(mInterfaceName),PackageManager.GET_META_DATA,userId);
  for (  ResolveInfo resolveInfo : resolveInfos) {
    try {
      ServiceInfo<V> info=parseServiceInfo(resolveInfo);
      if (info == null) {
        Log.w(TAG,"Unable to load service info " + resolveInfo.toString());
        continue;
      }
      serviceInfos.add(info);
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,"Unable to load service info " + resolveInfo.toString(),e);
    }
catch (    IOException e) {
      Log.w(TAG,"Unable to load service info " + resolveInfo.toString(),e);
    }
  }
synchronized (mServicesLock) {
    final UserServices<V> user=findOrCreateUserLocked(userId);
    final boolean firstScan=user.services == null;
    if (firstScan) {
      user.services=Maps.newHashMap();
    }
 else {
      user.services.clear();
    }
    StringBuilder changes=new StringBuilder();
    for (    ServiceInfo<V> info : serviceInfos) {
      Integer previousUid=user.persistentServices.get(info.type);
      if (previousUid == null) {
        changes.append("  New service added: ").append(info).append("\n");
        user.services.put(info.type,info);
        user.persistentServices.put(info.type,info.uid);
        if (!(mPersistentServicesFileDidNotExist && firstScan)) {
          notifyListener(info.type,userId,false);
        }
      }
 else       if (previousUid == info.uid) {
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          changes.append("  Existing service (nop): ").append(info).append("\n");
        }
        user.services.put(info.type,info);
      }
 else       if (inSystemImage(info.uid) || !containsTypeAndUid(serviceInfos,info.type,previousUid)) {
        if (inSystemImage(info.uid)) {
          changes.append("  System service replacing existing: ").append(info).append("\n");
        }
 else {
          changes.append("  Existing service replacing a removed service: ").append(info).append("\n");
        }
        user.services.put(info.type,info);
        user.persistentServices.put(info.type,info.uid);
        notifyListener(info.type,userId,false);
      }
 else {
        changes.append("  Existing service with new uid ignored: ").append(info).append("\n");
      }
    }
    ArrayList<V> toBeRemoved=Lists.newArrayList();
    for (    V v1 : user.persistentServices.keySet()) {
      if (!containsType(serviceInfos,v1)) {
        toBeRemoved.add(v1);
      }
    }
    for (    V v1 : toBeRemoved) {
      user.persistentServices.remove(v1);
      changes.append("  Service removed: ").append(v1).append("\n");
      notifyListener(v1,userId,true);
    }
    if (changes.length() > 0) {
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.d(TAG,"generateServicesMap(" + mInterfaceName + "): "+ serviceInfos.size()+ " services:\n"+ changes);
      }
      writePersistentServicesLocked();
    }
 else {
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.d(TAG,"generateServicesMap(" + mInterfaceName + "): "+ serviceInfos.size()+ " services unchanged");
      }
    }
  }
}
