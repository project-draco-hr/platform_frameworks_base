{
  if (!initGL(sh))   return false;
  final float right=left + mBackground.getWidth() * mScale;
  final float bottom=top + mBackground.getHeight() * mScale;
  final Rect frame=sh.getSurfaceFrame();
  final Matrix4f ortho=new Matrix4f();
  ortho.loadOrtho(0.0f,frame.width(),frame.height(),0.0f,-1.0f,1.0f);
  final FloatBuffer triangleVertices=createMesh(left,top,right,bottom);
  final int texture=loadTexture(mBackground);
  final int program=buildProgram(sSimpleVS,sSimpleFS);
  final int attribPosition=glGetAttribLocation(program,"position");
  final int attribTexCoords=glGetAttribLocation(program,"texCoords");
  final int uniformTexture=glGetUniformLocation(program,"texture");
  final int uniformProjection=glGetUniformLocation(program,"projection");
  checkGlError();
  glViewport(0,0,frame.width(),frame.height());
  glBindTexture(GL_TEXTURE_2D,texture);
  glUseProgram(program);
  glEnableVertexAttribArray(attribPosition);
  glEnableVertexAttribArray(attribTexCoords);
  glUniform1i(uniformTexture,0);
  glUniformMatrix4fv(uniformProjection,1,false,ortho.getArray(),0);
  checkGlError();
  if (w < 0 || h < 0) {
    glClearColor(0.0f,0.0f,0.0f,0.0f);
    glClear(GL_COLOR_BUFFER_BIT);
  }
  triangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);
  glVertexAttribPointer(attribPosition,3,GL_FLOAT,false,TRIANGLE_VERTICES_DATA_STRIDE_BYTES,triangleVertices);
  triangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);
  glVertexAttribPointer(attribTexCoords,3,GL_FLOAT,false,TRIANGLE_VERTICES_DATA_STRIDE_BYTES,triangleVertices);
  glDrawArrays(GL_TRIANGLE_STRIP,0,4);
  boolean status=mEgl.eglSwapBuffers(mEglDisplay,mEglSurface);
  checkEglError();
  finishGL();
  return status;
}
