{
  if (!mSurfaceValid) {
    return;
  }
  try {
    DisplayInfo displayInfo=getDefaultDisplayInfo();
    int newRotation=displayInfo.rotation;
    if (newRotation != mLastRotation) {
      if (!updateSurfaceSize(getSurfaceHolder(),displayInfo,true)) {
        return;
      }
      mRotationAtLastSurfaceSizeUpdate=newRotation;
      mDisplayWidthAtLastSurfaceSizeUpdate=displayInfo.logicalWidth;
      mDisplayHeightAtLastSurfaceSizeUpdate=displayInfo.logicalHeight;
    }
    SurfaceHolder sh=getSurfaceHolder();
    final Rect frame=sh.getSurfaceFrame();
    final int dw=frame.width();
    final int dh=frame.height();
    boolean surfaceDimensionsChanged=dw != mLastSurfaceWidth || dh != mLastSurfaceHeight;
    boolean redrawNeeded=surfaceDimensionsChanged || newRotation != mLastRotation;
    if (!redrawNeeded && !mOffsetsChanged) {
      if (DEBUG) {
        Log.d(TAG,"Suppressed drawFrame since redraw is not needed " + "and offsets have not changed.");
      }
      return;
    }
    mLastRotation=newRotation;
    if (mBackground == null) {
      if (DEBUG) {
        Log.d(TAG,"Reloading bitmap: mBackground, bgw, bgh, dw, dh = " + mBackground + ", "+ ((mBackground == null) ? 0 : mBackground.getWidth())+ ", "+ ((mBackground == null) ? 0 : mBackground.getHeight())+ ", "+ dw+ ", "+ dh);
      }
      mWallpaperManager.forgetLoadedWallpaper();
      loadWallpaper(true);
      if (DEBUG) {
        Log.d(TAG,"Reloading, resuming draw later");
      }
      return;
    }
    mScale=Math.max(1f,Math.max(dw / (float)mBackground.getWidth(),dh / (float)mBackground.getHeight()));
    final int availw=dw - (int)(mBackground.getWidth() * mScale);
    final int availh=dh - (int)(mBackground.getHeight() * mScale);
    int xPixels=availw / 2;
    int yPixels=availh / 2;
    final int availwUnscaled=dw - mBackground.getWidth();
    final int availhUnscaled=dh - mBackground.getHeight();
    if (availwUnscaled < 0)     xPixels+=(int)(availwUnscaled * (mXOffset - .5f) + .5f);
    if (availhUnscaled < 0)     yPixels+=(int)(availhUnscaled * (mYOffset - .5f) + .5f);
    mOffsetsChanged=false;
    if (surfaceDimensionsChanged) {
      mLastSurfaceWidth=dw;
      mLastSurfaceHeight=dh;
    }
    if (!redrawNeeded && xPixels == mLastXTranslation && yPixels == mLastYTranslation) {
      if (DEBUG) {
        Log.d(TAG,"Suppressed drawFrame since the image has not " + "actually moved an integral number of pixels.");
      }
      return;
    }
    mLastXTranslation=xPixels;
    mLastYTranslation=yPixels;
    if (DEBUG) {
      Log.d(TAG,"Redrawing wallpaper");
    }
    if (mIsHwAccelerated) {
      if (!drawWallpaperWithOpenGL(sh,availw,availh,xPixels,yPixels)) {
        drawWallpaperWithCanvas(sh,availw,availh,xPixels,yPixels);
      }
    }
 else {
      drawWallpaperWithCanvas(sh,availw,availh,xPixels,yPixels);
    }
  }
  finally {
    if (FIXED_SIZED_SURFACE && !mIsHwAccelerated) {
      mBackground=null;
      mWallpaperManager.forgetLoadedWallpaper();
    }
  }
}
