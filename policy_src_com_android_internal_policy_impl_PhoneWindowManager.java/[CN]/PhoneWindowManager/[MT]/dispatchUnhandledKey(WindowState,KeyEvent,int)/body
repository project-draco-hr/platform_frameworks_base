{
  if (DEBUG_FALLBACK) {
    Slog.d(TAG,"Unhandled key: win=" + win + ", action="+ event.getAction()+ ", flags="+ event.getFlags()+ ", keyCode="+ event.getKeyCode()+ ", scanCode="+ event.getScanCode()+ ", metaState="+ event.getMetaState()+ ", repeatCount="+ event.getRepeatCount()+ ", policyFlags="+ policyFlags);
  }
  if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    boolean fallback=kcm.getFallbackAction(event.getKeyCode(),event.getMetaState(),mFallbackAction);
    if (fallback) {
      if (DEBUG_FALLBACK) {
        Slog.d(TAG,"Fallback: keyCode=" + mFallbackAction.keyCode + " metaState="+ Integer.toHexString(mFallbackAction.metaState));
      }
      int flags=event.getFlags() | KeyEvent.FLAG_FALLBACK;
      KeyEvent fallbackEvent=KeyEvent.obtain(event.getDownTime(),event.getEventTime(),event.getAction(),mFallbackAction.keyCode,event.getRepeatCount(),mFallbackAction.metaState,event.getDeviceId(),event.getScanCode(),flags,event.getSource(),null);
      int actions=interceptKeyBeforeQueueing(fallbackEvent,policyFlags,true);
      if ((actions & ACTION_PASS_TO_USER) != 0) {
        if (!interceptKeyBeforeDispatching(win,fallbackEvent,policyFlags)) {
          if (DEBUG_FALLBACK) {
            Slog.d(TAG,"Performing fallback.");
          }
          return fallbackEvent;
        }
      }
      fallbackEvent.recycle();
    }
  }
  if (DEBUG_FALLBACK) {
    Slog.d(TAG,"No fallback.");
  }
  return null;
}
