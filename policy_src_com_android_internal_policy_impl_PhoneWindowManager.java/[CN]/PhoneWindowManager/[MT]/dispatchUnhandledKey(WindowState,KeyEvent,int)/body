{
  if (DEBUG_FALLBACK) {
    Slog.d(TAG,"Unhandled key: win=" + win + ", action="+ event.getAction()+ ", flags="+ event.getFlags()+ ", keyCode="+ event.getKeyCode()+ ", scanCode="+ event.getScanCode()+ ", metaState="+ event.getMetaState()+ ", repeatCount="+ event.getRepeatCount()+ ", policyFlags="+ policyFlags);
  }
  if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    final int keyCode=event.getKeyCode();
    final int metaState=event.getMetaState();
    if ((metaState & KeyEvent.META_META_ON) != 0) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(shortcutIntent);
        return null;
      }
    }
    if (kcm.getFallbackAction(keyCode,metaState,mFallbackAction)) {
      if (DEBUG_FALLBACK) {
        Slog.d(TAG,"Fallback: keyCode=" + mFallbackAction.keyCode + " metaState="+ Integer.toHexString(mFallbackAction.metaState));
      }
      int flags=event.getFlags() | KeyEvent.FLAG_FALLBACK;
      KeyEvent fallbackEvent=KeyEvent.obtain(event.getDownTime(),event.getEventTime(),event.getAction(),mFallbackAction.keyCode,event.getRepeatCount(),mFallbackAction.metaState,event.getDeviceId(),event.getScanCode(),flags,event.getSource(),null);
      int actions=interceptKeyBeforeQueueing(fallbackEvent,policyFlags,true);
      if ((actions & ACTION_PASS_TO_USER) != 0) {
        if (!interceptKeyBeforeDispatching(win,fallbackEvent,policyFlags)) {
          if (DEBUG_FALLBACK) {
            Slog.d(TAG,"Performing fallback.");
          }
          return fallbackEvent;
        }
      }
      fallbackEvent.recycle();
    }
  }
  if (DEBUG_FALLBACK) {
    Slog.d(TAG,"No fallback.");
  }
  return null;
}
