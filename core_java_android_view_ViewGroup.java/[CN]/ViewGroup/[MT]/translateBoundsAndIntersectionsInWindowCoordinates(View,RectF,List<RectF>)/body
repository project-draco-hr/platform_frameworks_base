{
  if (mAttachInfo == null) {
    return false;
  }
  if (getAlpha() <= 0 || getTransitionAlpha() <= 0 || getVisibility() != VISIBLE) {
    return false;
  }
  if (!child.hasIdentityMatrix()) {
    Matrix matrix=child.getMatrix();
    matrix.mapRect(bounds);
    final int intersectionCount=intersections.size();
    for (int i=0; i < intersectionCount; i++) {
      RectF intersection=intersections.get(i);
      matrix.mapRect(intersection);
    }
  }
  final int dx=child.mLeft - mScrollX;
  final int dy=child.mTop - mScrollY;
  bounds.offset(dx,dy);
  offsetRects(intersections,dx,dy);
  if (!bounds.intersects(0,0,getWidth(),getHeight())) {
    return false;
  }
  bounds.left=Math.max(bounds.left,0);
  bounds.top=Math.max(bounds.top,0);
  bounds.right=Math.min(bounds.right,mRight);
  bounds.bottom=Math.min(bounds.bottom,mBottom);
  Iterator<View> iterator=obtainOrderedChildIterator();
  while (iterator.hasNext()) {
    View sibling=iterator.next();
    if (sibling == child) {
      break;
    }
    if (!isVisible(sibling)) {
      continue;
    }
    RectF siblingBounds=mAttachInfo.mTmpTransformRect1;
    siblingBounds.set(0,0,sibling.getWidth(),sibling.getHeight());
    offsetChildRectToMyCoords(siblingBounds,sibling);
    if (siblingBounds.intersect(bounds)) {
      List<RectF> clickableRects=new ArrayList<>();
      sibling.addClickableRectsForAccessibility(clickableRects);
      final int clickableRectCount=clickableRects.size();
      for (int j=0; j < clickableRectCount; j++) {
        RectF clickableRect=clickableRects.get(j);
        offsetChildRectToMyCoords(clickableRect,sibling);
        if (clickableRect.intersect(bounds)) {
          if (clickableRect.equals(bounds)) {
            releaseOrderedChildIterator();
            return false;
          }
          intersections.add(clickableRect);
        }
      }
    }
  }
  releaseOrderedChildIterator();
  if (mParent instanceof ViewGroup) {
    ViewGroup parentGroup=(ViewGroup)mParent;
    return parentGroup.translateBoundsAndIntersectionsInWindowCoordinates(this,bounds,intersections);
  }
  return true;
}
