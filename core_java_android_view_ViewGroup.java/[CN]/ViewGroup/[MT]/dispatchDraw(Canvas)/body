{
  final int count=mChildrenCount;
  final View[] children=mChildren;
  int flags=mGroupFlags;
  if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
    final boolean cache=(mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
    final boolean buildCache=!isHardwareAccelerated();
    for (int i=0; i < count; i++) {
      final View child=children[i];
      if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
        final LayoutParams params=child.getLayoutParams();
        attachLayoutAnimationParameters(child,params,i,count);
        bindLayoutAnimation(child);
        if (cache) {
          child.setDrawingCacheEnabled(true);
          if (buildCache) {
            child.buildDrawingCache(true);
          }
        }
      }
    }
    final LayoutAnimationController controller=mLayoutAnimationController;
    if (controller.willOverlap()) {
      mGroupFlags|=FLAG_OPTIMIZE_INVALIDATE;
    }
    controller.start();
    mGroupFlags&=~FLAG_RUN_ANIMATION;
    mGroupFlags&=~FLAG_ANIMATION_DONE;
    if (cache) {
      mGroupFlags|=FLAG_CHILDREN_DRAWN_WITH_CACHE;
    }
    if (mAnimationListener != null) {
      mAnimationListener.onAnimationStart(controller.getAnimation());
    }
  }
  int saveCount=0;
  final boolean clipToPadding=(flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    saveCount=canvas.save();
    canvas.clipRect(mScrollX + mPaddingLeft,mScrollY + mPaddingTop,mScrollX + mRight - mLeft - mPaddingRight,mScrollY + mBottom - mTop - mPaddingBottom);
  }
  mPrivateFlags&=~DRAW_ANIMATION;
  mGroupFlags&=~FLAG_INVALIDATE_REQUIRED;
  boolean more=false;
  final long drawingTime=getDrawingTime();
  if ((flags & FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
    for (int i=0; i < count; i++) {
      final View child=children[i];
      if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
        more|=drawChild(canvas,child,drawingTime);
      }
    }
  }
 else {
    for (int i=0; i < count; i++) {
      final View child=children[getChildDrawingOrder(count,i)];
      if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
        more|=drawChild(canvas,child,drawingTime);
      }
    }
  }
  if (mDisappearingChildren != null) {
    final ArrayList<View> disappearingChildren=mDisappearingChildren;
    final int disappearingCount=disappearingChildren.size() - 1;
    for (int i=disappearingCount; i >= 0; i--) {
      final View child=disappearingChildren.get(i);
      more|=drawChild(canvas,child,drawingTime);
    }
  }
  if (clipToPadding) {
    canvas.restoreToCount(saveCount);
  }
  flags=mGroupFlags;
  if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
    invalidate();
  }
  if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
    mGroupFlags|=FLAG_NOTIFY_ANIMATION_LISTENER;
    final Runnable end=new Runnable(){
      public void run(){
        notifyAnimationListener();
      }
    }
;
    post(end);
  }
}
