{
  boolean usingRenderNodeProperties=canvas.isRecordingFor(mRenderNode);
  final int childrenCount=mChildrenCount;
  final View[] children=mChildren;
  int flags=mGroupFlags;
  if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
    final boolean buildCache=!isHardwareAccelerated();
    for (int i=0; i < childrenCount; i++) {
      final View child=children[i];
      if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
        final LayoutParams params=child.getLayoutParams();
        attachLayoutAnimationParameters(child,params,i,childrenCount);
        bindLayoutAnimation(child);
      }
    }
    final LayoutAnimationController controller=mLayoutAnimationController;
    if (controller.willOverlap()) {
      mGroupFlags|=FLAG_OPTIMIZE_INVALIDATE;
    }
    controller.start();
    mGroupFlags&=~FLAG_RUN_ANIMATION;
    mGroupFlags&=~FLAG_ANIMATION_DONE;
    if (mAnimationListener != null) {
      mAnimationListener.onAnimationStart(controller.getAnimation());
    }
  }
  int clipSaveCount=0;
  final boolean clipToPadding=(flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    clipSaveCount=canvas.save();
    canvas.clipRect(mScrollX + mPaddingLeft,mScrollY + mPaddingTop,mScrollX + mRight - mLeft - mPaddingRight,mScrollY + mBottom - mTop - mPaddingBottom);
  }
  mPrivateFlags&=~PFLAG_DRAW_ANIMATION;
  mGroupFlags&=~FLAG_INVALIDATE_REQUIRED;
  boolean more=false;
  final long drawingTime=getDrawingTime();
  if (usingRenderNodeProperties)   canvas.insertReorderBarrier();
  final int transientCount=mTransientIndices == null ? 0 : mTransientIndices.size();
  int transientIndex=transientCount != 0 ? 0 : -1;
  final ArrayList<View> preorderedList=usingRenderNodeProperties ? null : buildOrderedChildList();
  final boolean customOrder=preorderedList == null && isChildrenDrawingOrderEnabled();
  for (int i=0; i < childrenCount; i++) {
    while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
      final View transientChild=mTransientViews.get(transientIndex);
      if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) {
        more|=drawChild(canvas,transientChild,drawingTime);
      }
      transientIndex++;
      if (transientIndex >= transientCount) {
        transientIndex=-1;
      }
    }
    final int childIndex=getAndVerifyPreorderedIndex(childrenCount,i,customOrder);
    final View child=getAndVerifyPreorderedView(preorderedList,children,childIndex);
    if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
      more|=drawChild(canvas,child,drawingTime);
    }
  }
  while (transientIndex >= 0) {
    final View transientChild=mTransientViews.get(transientIndex);
    if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) {
      more|=drawChild(canvas,transientChild,drawingTime);
    }
    transientIndex++;
    if (transientIndex >= transientCount) {
      break;
    }
  }
  if (preorderedList != null)   preorderedList.clear();
  if (mDisappearingChildren != null) {
    final ArrayList<View> disappearingChildren=mDisappearingChildren;
    final int disappearingCount=disappearingChildren.size() - 1;
    for (int i=disappearingCount; i >= 0; i--) {
      final View child=disappearingChildren.get(i);
      more|=drawChild(canvas,child,drawingTime);
    }
  }
  if (usingRenderNodeProperties)   canvas.insertInorderBarrier();
  if (debugDraw()) {
    onDebugDraw(canvas);
  }
  if (clipToPadding) {
    canvas.restoreToCount(clipSaveCount);
  }
  flags=mGroupFlags;
  if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
    invalidate(true);
  }
  if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
    mGroupFlags|=FLAG_NOTIFY_ANIMATION_LISTENER;
    final Runnable end=new Runnable(){
      @Override public void run(){
        notifyAnimationListener();
      }
    }
;
    post(end);
  }
}
