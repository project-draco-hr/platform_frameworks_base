{
  boolean usingRenderNodeProperties=canvas.isRecordingFor(mRenderNode);
  final int childrenCount=mChildrenCount;
  final View[] children=mChildren;
  int flags=mGroupFlags;
  if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
    final boolean cache=(mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
    final boolean buildCache=!isHardwareAccelerated();
    for (int i=0; i < childrenCount; i++) {
      final View child=children[i];
      if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
        final LayoutParams params=child.getLayoutParams();
        attachLayoutAnimationParameters(child,params,i,childrenCount);
        bindLayoutAnimation(child);
        if (cache) {
          child.setDrawingCacheEnabled(true);
          if (buildCache) {
            child.buildDrawingCache(true);
          }
        }
      }
    }
    final LayoutAnimationController controller=mLayoutAnimationController;
    if (controller.willOverlap()) {
      mGroupFlags|=FLAG_OPTIMIZE_INVALIDATE;
    }
    controller.start();
    mGroupFlags&=~FLAG_RUN_ANIMATION;
    mGroupFlags&=~FLAG_ANIMATION_DONE;
    if (cache) {
      mGroupFlags|=FLAG_CHILDREN_DRAWN_WITH_CACHE;
    }
    if (mAnimationListener != null) {
      mAnimationListener.onAnimationStart(controller.getAnimation());
    }
  }
  int clipSaveCount=0;
  final boolean clipToPadding=(flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
  if (clipToPadding) {
    clipSaveCount=canvas.save();
    canvas.clipRect(mScrollX + mPaddingLeft,mScrollY + mPaddingTop,mScrollX + mRight - mLeft - mPaddingRight,mScrollY + mBottom - mTop - mPaddingBottom);
  }
  mPrivateFlags&=~PFLAG_DRAW_ANIMATION;
  mGroupFlags&=~FLAG_INVALIDATE_REQUIRED;
  boolean more=false;
  final long drawingTime=getDrawingTime();
  final ArrayList<View> preorderedList=usingRenderNodeProperties ? null : buildOrderedChildList();
  final boolean customOrder=preorderedList == null && isChildrenDrawingOrderEnabled();
  for (int i=0; i < childrenCount; i++) {
    int childIndex=customOrder ? getChildDrawingOrder(childrenCount,i) : i;
    final View child=(preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
    if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
      more|=drawChild(canvas,child,drawingTime);
    }
  }
  if (preorderedList != null)   preorderedList.clear();
  if (mDisappearingChildren != null) {
    final ArrayList<View> disappearingChildren=mDisappearingChildren;
    final int disappearingCount=disappearingChildren.size() - 1;
    for (int i=disappearingCount; i >= 0; i--) {
      final View child=disappearingChildren.get(i);
      more|=drawChild(canvas,child,drawingTime);
    }
  }
  if (debugDraw()) {
    onDebugDraw(canvas);
  }
  if (clipToPadding) {
    canvas.restoreToCount(clipSaveCount);
  }
  flags=mGroupFlags;
  if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
    invalidate(true);
  }
  if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
    mGroupFlags|=FLAG_NOTIFY_ANIMATION_LISTENER;
    final Runnable end=new Runnable(){
      public void run(){
        notifyAnimationListener();
      }
    }
;
    post(end);
  }
}
