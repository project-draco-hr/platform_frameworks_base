{
  if (x < 0) {
    w-=x;
    off+=x;
    x=0;
  }
  if (y < 0) {
    h-=y;
    off+=y * scansize;
    y=0;
  }
  if (x + w > width) {
    w=width - x;
  }
  if (y + h > height) {
    h=height - y;
  }
  if (w <= 0 || h <= 0) {
    return;
  }
  if (this.cm == null) {
    setColorModel(model);
  }
 else   if (model == null) {
    model=this.cm;
  }
 else   if (!model.equals(this.cm)) {
    forceRGB();
  }
  boolean canArraycopy;
switch (transferType) {
case DataBuffer.TYPE_UNDEFINED:
{
      if (isByteData) {
        transferType=DataBuffer.TYPE_BYTE;
        createRaster(transferType);
        canArraycopy=!forcedRGB;
        break;
      }
      transferType=DataBuffer.TYPE_INT;
      createRaster(transferType);
      canArraycopy=!forcedRGB || model.equals(ColorModel.getRGBdefault());
      break;
    }
case DataBuffer.TYPE_INT:
{
    if (isByteData) {
      forceRGB();
      canArraycopy=false;
      break;
    }
 else     if (!forcedRGB || model.equals(ColorModel.getRGBdefault())) {
      canArraycopy=true;
      break;
    }
  }
case DataBuffer.TYPE_BYTE:
{
  if (isByteData && !forcedRGB) {
    canArraycopy=true;
    break;
  }
  canArraycopy=false;
  break;
}
default :
{
throw new IllegalStateException(Messages.getString("awt.06"));
}
}
off+=x;
int maxOffset=off + h * scansize;
int dstOffset=x + y * width;
if (canArraycopy) {
Object dstArray=isByteData ? (Object)bData : (Object)iData;
for (; off < maxOffset; off+=scansize, dstOffset+=width) {
System.arraycopy(pixels,off,dstArray,dstOffset,w);
}
}
 else {
for (; off < maxOffset; off+=scansize, dstOffset+=width) {
int srcPos=off;
int dstPos=dstOffset;
int maxDstPos=dstOffset + w;
for (; dstPos < maxDstPos; dstPos++, srcPos++) {
iData[dstPos]=model.getRGB(isByteData ? ((byte[])pixels)[srcPos] : ((int[])pixels)[srcPos]);
}
}
}
}
