{
  if (mMainDataStreamer != null) {
    return;
  }
  if (mKey == null) {
    throw new IllegalStateException("Not initialized");
  }
  if ((mEncrypting) && (mIvRequired) && (mIvHasBeenUsed)) {
    throw new IllegalStateException("IV has already been used. Reusing IV in encryption mode violates security best" + " practices.");
  }
  KeymasterArguments keymasterInputArgs=new KeymasterArguments();
  keymasterInputArgs.addInt(KeymasterDefs.KM_TAG_ALGORITHM,mAlgorithm);
  keymasterInputArgs.addInt(KeymasterDefs.KM_TAG_BLOCK_MODE,mBlockMode);
  keymasterInputArgs.addInt(KeymasterDefs.KM_TAG_PADDING,mPadding);
  addAlgorithmSpecificParametersToBegin(keymasterInputArgs);
  KeymasterArguments keymasterOutputArgs=new KeymasterArguments();
  OperationResult opResult=mKeyStore.begin(mKey.getAlias(),mEncrypting ? KeymasterDefs.KM_PURPOSE_ENCRYPT : KeymasterDefs.KM_PURPOSE_DECRYPT,true,keymasterInputArgs,mAdditionalEntropyForBegin,keymasterOutputArgs);
  mAdditionalEntropyForBegin=null;
  if (opResult == null) {
    throw new KeyStoreConnectException();
  }
 else   if (opResult.resultCode != KeyStore.NO_ERROR) {
    throw KeyStore.getCryptoOperationException(opResult.resultCode);
  }
  if (opResult.token == null) {
    throw new CryptoOperationException("Keystore returned null operation token");
  }
  mOperationToken=opResult.token;
  mOperationHandle=opResult.operationHandle;
  loadAlgorithmSpecificParametersFromBeginResult(keymasterOutputArgs);
  mFirstOperationInitiated=true;
  mIvHasBeenUsed=true;
  mMainDataStreamer=new KeyStoreCryptoOperationChunkedStreamer(new KeyStoreCryptoOperationChunkedStreamer.MainDataStream(mKeyStore,opResult.token));
}
