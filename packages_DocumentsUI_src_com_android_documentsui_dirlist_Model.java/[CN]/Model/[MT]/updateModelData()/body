{
  int[] positions=new int[mCursorCount];
  mIds.clear();
  String[] stringValues=new String[mCursorCount];
  long[] longValues=null;
  if (mSortOrder == SORT_ORDER_LAST_MODIFIED || mSortOrder == SORT_ORDER_SIZE) {
    longValues=new long[mCursorCount];
  }
  mCursor.moveToPosition(-1);
  for (int pos=0; pos < mCursorCount; ++pos) {
    mCursor.moveToNext();
    positions[pos]=pos;
    mIds.add(createModelId(mCursor));
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
      final String mimeType=getCursorString(mCursor,Document.COLUMN_MIME_TYPE);
    final String displayName=getCursorString(mCursor,Document.COLUMN_DISPLAY_NAME);
  if (Document.MIME_TYPE_DIR.equals(mimeType)) {
    stringValues[pos]=DocumentInfo.DIR_PREFIX + displayName;
  }
 else {
    stringValues[pos]=displayName;
  }
break;
case SORT_ORDER_LAST_MODIFIED:
longValues[pos]=getCursorLong(mCursor,Document.COLUMN_LAST_MODIFIED);
stringValues[pos]=getCursorString(mCursor,Document.COLUMN_MIME_TYPE);
break;
case SORT_ORDER_SIZE:
longValues[pos]=getCursorLong(mCursor,Document.COLUMN_SIZE);
stringValues[pos]=getCursorString(mCursor,Document.COLUMN_MIME_TYPE);
break;
}
}
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
binarySort(stringValues,positions,mIds);
break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
binarySort(longValues,stringValues,positions,mIds);
break;
}
mPositions.clear();
for (int i=0; i < mCursorCount; ++i) {
mPositions.put(mIds.get(i),positions[i]);
}
}
