{
  int[] positions=new int[mCursorCount];
  mIds.clear();
  String[] strings=null;
  long[] longs=null;
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
    strings=new String[mCursorCount];
  break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
longs=new long[mCursorCount];
break;
}
mCursor.moveToPosition(-1);
for (int pos=0; pos < mCursorCount; ++pos) {
mCursor.moveToNext();
positions[pos]=pos;
mIds.add(createModelId(mCursor));
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
final String mimeType=getCursorString(mCursor,Document.COLUMN_MIME_TYPE);
final String displayName=getCursorString(mCursor,Document.COLUMN_DISPLAY_NAME);
if (Document.MIME_TYPE_DIR.equals(mimeType)) {
strings[pos]=DocumentInfo.DIR_PREFIX + displayName;
}
 else {
strings[pos]=displayName;
}
break;
case SORT_ORDER_LAST_MODIFIED:
longs[pos]=getCursorLong(mCursor,Document.COLUMN_LAST_MODIFIED);
break;
case SORT_ORDER_SIZE:
longs[pos]=getCursorLong(mCursor,Document.COLUMN_SIZE);
break;
}
}
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
binarySort(positions,strings,mIds);
break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
binarySort(positions,longs,mIds);
break;
}
mPositions.clear();
for (int i=0; i < mCursorCount; ++i) {
mPositions.put(mIds.get(i),positions[i]);
}
}
