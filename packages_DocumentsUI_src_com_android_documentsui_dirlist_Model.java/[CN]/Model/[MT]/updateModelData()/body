{
  int[] positions=new int[mCursorCount];
  mIds=new String[mCursorCount];
  boolean[] isDirs=new boolean[mCursorCount];
  String[] displayNames=null;
  long[] longValues=null;
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
    displayNames=new String[mCursorCount];
  break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
longValues=new long[mCursorCount];
break;
}
String mimeType;
mCursor.moveToPosition(-1);
for (int pos=0; pos < mCursorCount; ++pos) {
if (!mCursor.moveToNext()) {
Log.e(TAG,"Fail to move cursor to next pos: " + pos);
return;
}
positions[pos]=pos;
if (mCursor instanceof MergeCursor) {
mIds[pos]=getCursorString(mCursor,RootCursorWrapper.COLUMN_AUTHORITY) + "|" + getCursorString(mCursor,Document.COLUMN_DOCUMENT_ID);
}
 else {
mIds[pos]=getCursorString(mCursor,Document.COLUMN_DOCUMENT_ID);
}
mimeType=getCursorString(mCursor,Document.COLUMN_MIME_TYPE);
isDirs[pos]=Document.MIME_TYPE_DIR.equals(mimeType);
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
final String displayName=getCursorString(mCursor,Document.COLUMN_DISPLAY_NAME);
displayNames[pos]=displayName;
break;
case SORT_ORDER_LAST_MODIFIED:
longValues[pos]=getLastModified(mCursor);
break;
case SORT_ORDER_SIZE:
longValues[pos]=getCursorLong(mCursor,Document.COLUMN_SIZE);
break;
}
}
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
binarySort(displayNames,isDirs,positions,mIds);
break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
binarySort(longValues,isDirs,positions,mIds);
break;
}
mPositions.clear();
for (int i=0; i < mCursorCount; ++i) {
mPositions.put(mIds[i],positions[i]);
}
}
