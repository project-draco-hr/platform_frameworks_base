{
  int[] positions=new int[mCursorCount];
  mIds=new String[mCursorCount];
  boolean[] isDirs=new boolean[mCursorCount];
  String[] displayNames=null;
  long[] longValues=null;
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
    displayNames=new String[mCursorCount];
  break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
longValues=new long[mCursorCount];
break;
}
String mimeType;
mCursor.moveToPosition(-1);
for (int pos=0; pos < mCursorCount; ++pos) {
if (!mCursor.moveToNext()) {
Log.e(TAG,"Fail to move cursor to next pos: " + pos);
return;
}
positions[pos]=pos;
if (mCursor instanceof MergeCursor) {
mIds[pos]=getStringOrEmpty(mAuthorityIndex) + "|" + getStringOrEmpty(mDocIdIndex);
}
 else {
mIds[pos]=getStringOrEmpty(mDocIdIndex);
}
mimeType=getStringOrEmpty(mMimeTypeIndex);
isDirs[pos]=Document.MIME_TYPE_DIR.equals(mimeType);
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
displayNames[pos]=getStringOrEmpty(mDisplayNameIndex);
break;
case SORT_ORDER_LAST_MODIFIED:
longValues[pos]=getLastModified();
break;
case SORT_ORDER_SIZE:
longValues[pos]=getDocSize();
break;
}
}
switch (mSortOrder) {
case SORT_ORDER_DISPLAY_NAME:
binarySort(displayNames,isDirs,positions,mIds);
break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
binarySort(longValues,isDirs,positions,mIds);
break;
}
mPositions.clear();
for (int i=0; i < mCursorCount; ++i) {
mPositions.put(mIds[i],positions[i]);
}
}
