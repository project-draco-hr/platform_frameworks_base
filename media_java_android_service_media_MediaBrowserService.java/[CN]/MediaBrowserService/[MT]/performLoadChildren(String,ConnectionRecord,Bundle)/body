{
  final Result<List<MediaBrowser.MediaItem>> result=new Result<List<MediaBrowser.MediaItem>>(parentId){
    @Override void onResultSent(    List<MediaBrowser.MediaItem> list,    @ResultFlags int flag){
      if (mConnections.get(connection.callbacks.asBinder()) != connection) {
        if (DBG) {
          Log.d(TAG,"Not sending onLoadChildren result for connection that has" + " been disconnected. pkg=" + connection.pkg + " id="+ parentId);
        }
        return;
      }
      List<MediaBrowser.MediaItem> filteredList=(flag & RESULT_FLAG_OPTION_NOT_HANDLED) != 0 ? applyOptions(list,options) : list;
      final ParceledListSlice<MediaBrowser.MediaItem> pls=filteredList == null ? null : new ParceledListSlice<>(filteredList);
      try {
        connection.callbacks.onLoadChildrenWithOptions(parentId,pls,options);
      }
 catch (      RemoteException ex) {
        Log.w(TAG,"Calling onLoadChildren() failed for id=" + parentId + " package="+ connection.pkg);
      }
    }
  }
;
  mCurConnection=connection;
  if (options == null) {
    onLoadChildren(parentId,result);
  }
 else {
    onLoadChildren(parentId,result,options);
  }
  mCurConnection=null;
  if (!result.isDone()) {
    throw new IllegalStateException("onLoadChildren must call detach() or sendResult()" + " before returning for package=" + connection.pkg + " id="+ parentId);
  }
}
