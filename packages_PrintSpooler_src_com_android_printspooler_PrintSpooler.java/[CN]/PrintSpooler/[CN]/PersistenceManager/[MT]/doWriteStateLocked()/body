{
  FileOutputStream out=null;
  try {
    out=mStatePersistFile.startWrite();
    XmlSerializer serializer=new FastXmlSerializer();
    serializer.setOutput(out,"utf-8");
    serializer.startDocument(null,true);
    serializer.startTag(null,TAG_SPOOLER);
    List<PrintJobInfo> printJobs=mPrintJobs;
    final int printJobCount=printJobs.size();
    for (int j=0; j < printJobCount; j++) {
      PrintJobInfo printJob=printJobs.get(j);
      final int state=printJob.getState();
      if (state < PrintJobInfo.STATE_QUEUED || state > PrintJobInfo.STATE_FAILED) {
        continue;
      }
      serializer.startTag(null,TAG_JOB);
      serializer.startTag(null,TAG_ID);
      serializer.text(String.valueOf(printJob.getId()));
      serializer.endTag(null,TAG_ID);
      serializer.startTag(null,TAG_TAG);
      serializer.text(printJob.getTag());
      serializer.endTag(null,TAG_TAG);
      serializer.startTag(null,TAG_APP_ID);
      serializer.text(String.valueOf(printJob.getAppId()));
      serializer.endTag(null,TAG_APP_ID);
      serializer.startTag(null,TAG_LABEL);
      serializer.text(printJob.getLabel().toString());
      serializer.endTag(null,TAG_LABEL);
      serializer.startTag(null,TAG_STATE);
      serializer.text(String.valueOf(printJob.getState()));
      serializer.endTag(null,TAG_STATE);
      serializer.startTag(null,TAG_PRINTER);
      serializer.text(printJob.getPrinterId().flattenToString());
      serializer.endTag(null,TAG_PRINTER);
      PrintAttributes attributes=printJob.getAttributes();
      if (attributes != null) {
        serializer.startTag(null,TAG_ATTRIBUTES);
        final int duplexMode=attributes.getDuplexMode();
        if (duplexMode > 0) {
          serializer.attribute(null,ATTRIBUTE_DUPLEX_MODE,String.valueOf(duplexMode));
        }
        final int colorMode=attributes.getColorMode();
        if (colorMode > 0) {
          serializer.attribute(null,ATTRIBUTE_COLOR_MODE,String.valueOf(colorMode));
        }
        final int fittingMode=attributes.getFittingMode();
        if (fittingMode > 0) {
          serializer.attribute(null,ATTRIBUTE_FITTING_MODE,String.valueOf(fittingMode));
        }
        final int orientation=attributes.getOrientation();
        if (orientation > 0) {
          serializer.attribute(null,ATTRIBUTE_ORIENTATION,String.valueOf(orientation));
        }
        serializer.endTag(null,TAG_ATTRIBUTES);
      }
      serializer.endTag(null,TAG_JOB);
      if (DEBUG_PERSISTENCE) {
        Log.i(LOG_TAG,"[PERSISTED] " + printJob);
      }
    }
    serializer.endTag(null,TAG_SPOOLER);
    serializer.endDocument();
    mStatePersistFile.finishWrite(out);
  }
 catch (  IOException e) {
    Slog.w(LOG_TAG,"Failed to write state, restoring backup.",e);
    mStatePersistFile.failWrite(out);
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
}
