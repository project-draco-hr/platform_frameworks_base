{
  try {
    checkpoint(false);
    for (    String daemon : mDaemons) {
      SystemProperties.set("ctl.stop",daemon);
    }
    for (    String daemon : mDaemons) {
      String key="init.svc." + daemon;
      while (!"stopped".equals(SystemProperties.get(key))) {
        checkpoint(true);
      }
    }
    SystemProperties.set("vpn.dns",NONE);
    SystemProperties.set("vpn.via",NONE);
    while (!NONE.equals(SystemProperties.get("vpn.dns")) || !NONE.equals(SystemProperties.get("vpn.via"))) {
      checkpoint(true);
    }
    boolean restart=false;
    for (    String[] arguments : mArguments) {
      restart=restart || (arguments != null);
    }
    if (!restart) {
      return;
    }
    for (int i=0; i < mDaemons.length; ++i) {
      String[] arguments=mArguments[i];
      if (arguments == null) {
        continue;
      }
      String daemon=mDaemons[i];
      SystemProperties.set("ctl.start",daemon);
      String key="init.svc." + daemon;
      while (!"running".equals(SystemProperties.get(key))) {
        checkpoint(true);
      }
      LocalSocket socket=new LocalSocket();
      LocalSocketAddress address=new LocalSocketAddress(daemon,LocalSocketAddress.Namespace.RESERVED);
      while (true) {
        try {
          socket.connect(address);
          break;
        }
 catch (        Exception e) {
        }
        checkpoint(true);
      }
      socket.setSoTimeout(500);
      OutputStream out=socket.getOutputStream();
      for (      String argument : arguments) {
        byte[] bytes=argument.getBytes(Charsets.UTF_8);
        if (bytes.length >= 0xFFFF) {
          throw new IllegalArgumentException("argument too large");
        }
        out.write(bytes.length >> 8);
        out.write(bytes.length);
        out.write(bytes);
        checkpoint(false);
      }
      out.write(0xFF);
      out.write(0xFF);
      out.flush();
      socket.close();
    }
    while (NONE.equals(SystemProperties.get("vpn.dns")) || NONE.equals(SystemProperties.get("vpn.via"))) {
      for (int i=0; i < mDaemons.length; ++i) {
        String daemon=mDaemons[i];
        if (mArguments[i] != null && !"running".equals(SystemProperties.get("init.svc." + daemon))) {
          throw new IllegalArgumentException(daemon + " is dead");
        }
      }
      checkpoint(true);
    }
    mConfig.interfaceName=SystemProperties.get("vpn.via");
    if (mConfig.dnsServers == null || mConfig.dnsServers.size() == 0) {
      String dnsServers=SystemProperties.get("vpn.dns").trim();
      if (!dnsServers.isEmpty()) {
        mConfig.dnsServers=Arrays.asList(dnsServers.split(" "));
      }
    }
    if (mConfig.routes != null) {
      jniSetRoutes(mConfig.interfaceName,mConfig.routes);
    }
synchronized (Vpn.this) {
      checkpoint(false);
      if (jniCheckInterface(mConfig.interfaceName) == 0) {
        throw new IllegalStateException(mConfig.interfaceName + " is gone");
      }
      mInterfaceName=mConfig.interfaceName;
      mCallback.override(mConfig.dnsServers,mConfig.searchDomains);
      showNotification(mConfig,null,null);
    }
    Log.i(TAG,"Connected!");
  }
 catch (  Exception e) {
    Log.i(TAG,"Abort due to " + e.getMessage());
    exit();
  }
}
