{
  try {
    checkpoint(false);
    mInfo.state=LegacyVpnInfo.STATE_INITIALIZING;
    for (    String daemon : mDaemons) {
      String key="init.svc." + daemon;
      while (!"stopped".equals(SystemProperties.get(key,"stopped"))) {
        checkpoint(true);
      }
    }
    File state=new File("/data/misc/vpn/state");
    state.delete();
    if (state.exists()) {
      throw new IllegalStateException("Cannot delete the state");
    }
    boolean restart=false;
    for (    String[] arguments : mArguments) {
      restart=restart || (arguments != null);
    }
    if (!restart) {
      mInfo.state=LegacyVpnInfo.STATE_DISCONNECTED;
      return;
    }
    mInfo.state=LegacyVpnInfo.STATE_CONNECTING;
    for (int i=0; i < mDaemons.length; ++i) {
      String[] arguments=mArguments[i];
      if (arguments == null) {
        continue;
      }
      String daemon=mDaemons[i];
      SystemProperties.set("ctl.start",daemon);
      String key="init.svc." + daemon;
      while (!"running".equals(SystemProperties.get(key))) {
        checkpoint(true);
      }
      mSockets[i]=new LocalSocket();
      LocalSocketAddress address=new LocalSocketAddress(daemon,LocalSocketAddress.Namespace.RESERVED);
      while (true) {
        try {
          mSockets[i].connect(address);
          break;
        }
 catch (        Exception e) {
        }
        checkpoint(true);
      }
      mSockets[i].setSoTimeout(500);
      OutputStream out=mSockets[i].getOutputStream();
      for (      String argument : arguments) {
        byte[] bytes=argument.getBytes(Charsets.UTF_8);
        if (bytes.length >= 0xFFFF) {
          throw new IllegalArgumentException("Argument is too large");
        }
        out.write(bytes.length >> 8);
        out.write(bytes.length);
        out.write(bytes);
        checkpoint(false);
      }
      out.write(0xFF);
      out.write(0xFF);
      out.flush();
      InputStream in=mSockets[i].getInputStream();
      while (true) {
        try {
          if (in.read() == -1) {
            break;
          }
        }
 catch (        Exception e) {
        }
        checkpoint(true);
      }
    }
    while (!state.exists()) {
      for (int i=0; i < mDaemons.length; ++i) {
        String daemon=mDaemons[i];
        if (mArguments[i] != null && !"running".equals(SystemProperties.get("init.svc." + daemon))) {
          throw new IllegalStateException(daemon + " is dead");
        }
      }
      checkpoint(true);
    }
    byte[] buffer=new byte[(int)state.length()];
    if (new FileInputStream(state).read(buffer) != buffer.length) {
      throw new IllegalStateException("Cannot read the state");
    }
    String[] parameters=new String(buffer,Charsets.UTF_8).split("\n",-1);
    if (parameters.length != 6) {
      throw new IllegalStateException("Cannot parse the state");
    }
    mConfig.interfaze=parameters[0].trim();
    mConfig.addresses=parameters[1].trim();
    if (mConfig.routes == null || mConfig.routes.isEmpty()) {
      mConfig.routes=parameters[2].trim();
    }
    if (mConfig.dnsServers == null || mConfig.dnsServers.size() == 0) {
      String dnsServers=parameters[3].trim();
      if (!dnsServers.isEmpty()) {
        mConfig.dnsServers=Arrays.asList(dnsServers.split(" "));
      }
    }
    if (mConfig.searchDomains == null || mConfig.searchDomains.size() == 0) {
      String searchDomains=parameters[4].trim();
      if (!searchDomains.isEmpty()) {
        mConfig.searchDomains=Arrays.asList(searchDomains.split(" "));
      }
    }
    jniSetRoutes(mConfig.interfaze,mConfig.routes);
synchronized (Vpn.this) {
      checkpoint(false);
      if (jniCheck(mConfig.interfaze) == 0) {
        throw new IllegalStateException(mConfig.interfaze + " is gone");
      }
      mInterface=mConfig.interfaze;
      mCallback.override(mConfig.dnsServers,mConfig.searchDomains);
      showNotification(mConfig,null,null);
      Log.i(TAG,"Connected!");
      mInfo.state=LegacyVpnInfo.STATE_CONNECTED;
      mInfo.intent=VpnConfig.getIntentForStatusPanel(mContext,null);
    }
  }
 catch (  Exception e) {
    Log.i(TAG,"Aborting",e);
    exit();
  }
 finally {
    if (mInfo.state == LegacyVpnInfo.STATE_INITIALIZING) {
      for (      String daemon : mDaemons) {
        SystemProperties.set("ctl.stop",daemon);
      }
    }
    if (mInfo.state == LegacyVpnInfo.STATE_INITIALIZING || mInfo.state == LegacyVpnInfo.STATE_CONNECTING) {
      mInfo.state=LegacyVpnInfo.STATE_FAILED;
    }
  }
}
