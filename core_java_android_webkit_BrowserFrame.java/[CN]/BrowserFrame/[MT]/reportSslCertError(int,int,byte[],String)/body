{
  final SslError sslError;
  try {
    X509Certificate cert=new X509CertImpl(certDER);
    SslCertificate sslCert=new SslCertificate(cert);
    if (JniUtil.useChromiumHttpStack()) {
      sslError=SslError.SslErrorFromChromiumErrorCode(certError,sslCert,new URL(url).getHost());
    }
 else {
      sslError=new SslError(certError,cert,url);
    }
  }
 catch (  IOException e) {
    Log.e(LOGTAG,"Can't get the certificate from WebKit, canceling");
    nativeSslCertErrorCancel(handle,certError);
    return;
  }
  if (SslCertLookupTable.getInstance().isAllowed(sslError)) {
    nativeSslCertErrorProceed(handle);
    return;
  }
  SslErrorHandler handler=new SslErrorHandler(){
    @Override public void proceed(){
      SslCertLookupTable.getInstance().setIsAllowed(sslError,true);
      nativeSslCertErrorProceed(handle);
    }
    @Override public void cancel(){
      SslCertLookupTable.getInstance().setIsAllowed(sslError,false);
      nativeSslCertErrorCancel(handle,certError);
    }
  }
;
  mCallbackProxy.onReceivedSslError(handler,sslError);
}
