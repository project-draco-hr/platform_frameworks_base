{
  final int callingUid=Binder.getCallingUid();
  mPm.enforceCrossUserPermission(callingUid,userId,true,"createSession");
  if (mPm.isUserRestricted(UserHandle.getUserId(callingUid),UserManager.DISALLOW_INSTALL_APPS)) {
    throw new SecurityException("User restriction prevents installing");
  }
  if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {
    installerPackageName="com.android.shell";
    params.installFlags|=INSTALL_FROM_ADB;
  }
 else {
    mAppOps.checkPackage(callingUid,installerPackageName);
    params.installFlags&=~INSTALL_FROM_ADB;
    params.installFlags&=~INSTALL_ALL_USERS;
    params.installFlags|=INSTALL_REPLACE_EXISTING;
  }
  if (params.appIcon != null) {
    final ActivityManager am=(ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    final int iconSize=am.getLauncherLargeIconSize();
    if ((params.appIcon.getWidth() > iconSize * 2) || (params.appIcon.getHeight() > iconSize * 2)) {
      params.appIcon=Bitmap.createScaledBitmap(params.appIcon,iconSize,iconSize,true);
    }
  }
  final boolean stageInternal;
  if (params.mode == SessionParams.MODE_FULL_INSTALL) {
    final int resolved=PackageHelper.resolveInstallLocation(mContext,params.installLocation,params.sizeBytes,params.installFlags);
    if (resolved == PackageHelper.RECOMMEND_INSTALL_INTERNAL) {
      stageInternal=true;
    }
 else     if (resolved == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {
      stageInternal=false;
    }
 else {
      throw new IOException("No storage with enough free space; res=" + resolved);
    }
  }
 else   if (params.mode == SessionParams.MODE_INHERIT_EXISTING) {
    stageInternal=true;
    checkInternalStorage(params.sizeBytes);
    final ApplicationInfo info=mPm.getApplicationInfo(params.appPackageName,0,userId);
    if (info != null && (info.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
      checkExternalStorage(params.sizeBytes);
      throw new UnsupportedOperationException("TODO: finish fleshing out ASEC support");
    }
  }
 else {
    throw new IllegalArgumentException("Invalid install mode: " + params.mode);
  }
  final int sessionId;
  final PackageInstallerSession session;
synchronized (mSessions) {
    final int activeCount=getSessionCount(mSessions,callingUid);
    if (activeCount >= MAX_ACTIVE_SESSIONS) {
      throw new IllegalStateException("Too many active sessions for UID " + callingUid);
    }
    final int historicalCount=getSessionCount(mHistoricalSessions,callingUid);
    if (historicalCount >= MAX_HISTORICAL_SESSIONS) {
      throw new IllegalStateException("Too many historical sessions for UID " + callingUid);
    }
    final long createdMillis=System.currentTimeMillis();
    sessionId=allocateSessionIdLocked();
    File stageDir=null;
    String stageCid=null;
    if (stageInternal) {
      stageDir=prepareInternalStageDir(sessionId);
    }
 else {
      stageCid=prepareExternalStageCid(sessionId,params.sizeBytes);
    }
    session=new PackageInstallerSession(mInternalCallback,mContext,mPm,mInstallThread.getLooper(),sessionId,userId,installerPackageName,params,createdMillis,stageDir,stageCid,false);
    mSessions.put(sessionId,session);
  }
  mCallbacks.notifySessionCreated(session.sessionId,session.userId);
  writeSessionsAsync();
  return sessionId;
}
