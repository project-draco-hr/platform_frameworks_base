{
  final int callingUid=Binder.getCallingUid();
  mPm.enforceCrossUserPermission(callingUid,userId,true,true,"createSession");
  if (mPm.isUserRestricted(userId,UserManager.DISALLOW_INSTALL_APPS)) {
    throw new SecurityException("User restriction prevents installing");
  }
  if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {
    params.installFlags|=PackageManager.INSTALL_FROM_ADB;
  }
 else {
    mAppOps.checkPackage(callingUid,installerPackageName);
    params.installFlags&=~PackageManager.INSTALL_FROM_ADB;
    params.installFlags&=~PackageManager.INSTALL_ALL_USERS;
    params.installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
  }
  if ((params.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0 && mContext.checkCallingOrSelfPermission(Manifest.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) {
    throw new SecurityException("You need the " + "android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission " + "to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag");
  }
  if (params.appIcon != null) {
    final ActivityManager am=(ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    final int iconSize=am.getLauncherLargeIconSize();
    if ((params.appIcon.getWidth() > iconSize * 2) || (params.appIcon.getHeight() > iconSize * 2)) {
      params.appIcon=Bitmap.createScaledBitmap(params.appIcon,iconSize,iconSize,true);
    }
  }
switch (params.mode) {
case SessionParams.MODE_FULL_INSTALL:
case SessionParams.MODE_INHERIT_EXISTING:
    break;
default :
  throw new IllegalArgumentException("Invalid install mode: " + params.mode);
}
if ((params.installFlags & PackageManager.INSTALL_INTERNAL) != 0) {
if (!PackageHelper.fitsOnInternal(mContext,params.sizeBytes)) {
  throw new IOException("No suitable internal storage available");
}
}
 else if ((params.installFlags & PackageManager.INSTALL_EXTERNAL) != 0) {
if (!PackageHelper.fitsOnExternal(mContext,params.sizeBytes)) {
  throw new IOException("No suitable external storage available");
}
}
 else if ((params.installFlags & PackageManager.INSTALL_FORCE_VOLUME_UUID) != 0) {
params.setInstallFlagsInternal();
}
 else {
params.setInstallFlagsInternal();
final long ident=Binder.clearCallingIdentity();
try {
  params.volumeUuid=PackageHelper.resolveInstallVolume(mContext,params.appPackageName,params.installLocation,params.sizeBytes);
}
  finally {
  Binder.restoreCallingIdentity(ident);
}
}
final int sessionId;
final PackageInstallerSession session;
synchronized (mSessions) {
final int activeCount=getSessionCount(mSessions,callingUid);
if (activeCount >= MAX_ACTIVE_SESSIONS) {
  throw new IllegalStateException("Too many active sessions for UID " + callingUid);
}
final int historicalCount=getSessionCount(mHistoricalSessions,callingUid);
if (historicalCount >= MAX_HISTORICAL_SESSIONS) {
  throw new IllegalStateException("Too many historical sessions for UID " + callingUid);
}
final long createdMillis=System.currentTimeMillis();
sessionId=allocateSessionIdLocked();
File stageDir=null;
String stageCid=null;
if ((params.installFlags & PackageManager.INSTALL_INTERNAL) != 0) {
  final boolean isEphemeral=(params.installFlags & PackageManager.INSTALL_EPHEMERAL) != 0;
  stageDir=buildStageDir(params.volumeUuid,sessionId,isEphemeral);
}
 else {
  stageCid=buildExternalStageCid(sessionId);
}
session=new PackageInstallerSession(mInternalCallback,mContext,mPm,mInstallThread.getLooper(),sessionId,userId,installerPackageName,callingUid,params,createdMillis,stageDir,stageCid,false,false);
mSessions.put(sessionId,session);
}
mCallbacks.notifySessionCreated(session.sessionId,session.userId);
writeSessionsAsync();
return sessionId;
}
