{
  final int callingUid=Binder.getCallingUid();
  mPm.enforceCrossUserPermission(callingUid,userId,true,"createSession");
  if (mPm.isUserRestricted(UserHandle.getUserId(callingUid),UserManager.DISALLOW_INSTALL_APPS)) {
    throw new SecurityException("User restriction prevents installing");
  }
  if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {
    installerPackageName="com.android.shell";
    params.installFlags|=INSTALL_FROM_ADB;
  }
 else {
    mAppOps.checkPackage(callingUid,installerPackageName);
    params.installFlags&=~INSTALL_FROM_ADB;
    params.installFlags&=~INSTALL_ALL_USERS;
    params.installFlags|=INSTALL_REPLACE_EXISTING;
  }
  if (params.appIcon != null) {
    final ActivityManager am=(ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    final int iconSize=am.getLauncherLargeIconSize();
    if ((params.appIcon.getWidth() > iconSize * 2) || (params.appIcon.getHeight() > iconSize * 2)) {
      params.appIcon=Bitmap.createScaledBitmap(params.appIcon,iconSize,iconSize,true);
    }
  }
  final boolean stageInternal;
  if (params.mode == SessionParams.MODE_FULL_INSTALL) {
    final long ident=Binder.clearCallingIdentity();
    try {
      final int resolved=PackageHelper.resolveInstallLocation(mContext,params.appPackageName,params.installLocation,params.sizeBytes,params.installFlags);
      if (resolved == PackageHelper.RECOMMEND_INSTALL_INTERNAL) {
        stageInternal=true;
      }
 else       if (resolved == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {
        stageInternal=false;
      }
 else {
        throw new IOException("No storage with enough free space; res=" + resolved);
      }
    }
  finally {
      Binder.restoreCallingIdentity(ident);
    }
  }
 else   if (params.mode == SessionParams.MODE_INHERIT_EXISTING) {
    final ApplicationInfo existingApp=mPm.getApplicationInfo(params.appPackageName,0,userId);
    if (existingApp == null) {
      throw new IllegalStateException("Missing existing app " + params.appPackageName);
    }
    final long existingSize;
    try {
      final PackageLite existingPkg=PackageParser.parsePackageLite(new File(existingApp.getCodePath()),0);
      existingSize=PackageHelper.calculateInstalledSize(existingPkg,false,params.abiOverride);
    }
 catch (    PackageParserException e) {
      throw new IllegalStateException("Failed to calculate size of " + params.appPackageName);
    }
    if ((existingApp.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) == 0) {
      checkInternalStorage(params.sizeBytes);
      stageInternal=true;
    }
 else {
      checkExternalStorage(params.sizeBytes + existingSize);
      stageInternal=false;
    }
  }
 else {
    throw new IllegalArgumentException("Invalid install mode: " + params.mode);
  }
  final int sessionId;
  final PackageInstallerSession session;
synchronized (mSessions) {
    final int activeCount=getSessionCount(mSessions,callingUid);
    if (activeCount >= MAX_ACTIVE_SESSIONS) {
      throw new IllegalStateException("Too many active sessions for UID " + callingUid);
    }
    final int historicalCount=getSessionCount(mHistoricalSessions,callingUid);
    if (historicalCount >= MAX_HISTORICAL_SESSIONS) {
      throw new IllegalStateException("Too many historical sessions for UID " + callingUid);
    }
    final long createdMillis=System.currentTimeMillis();
    sessionId=allocateSessionIdLocked();
    File stageDir=null;
    String stageCid=null;
    if (stageInternal) {
      stageDir=prepareInternalStageDir(sessionId);
    }
 else {
      stageCid=prepareExternalStageCid(sessionId,params.sizeBytes);
    }
    session=new PackageInstallerSession(mInternalCallback,mContext,mPm,mInstallThread.getLooper(),sessionId,userId,installerPackageName,params,createdMillis,stageDir,stageCid,false);
    mSessions.put(sessionId,session);
  }
  mCallbacks.notifySessionCreated(session.sessionId,session.userId);
  writeSessionsAsync();
  return sessionId;
}
