{
  GLES20.glClearColor(0.4f,0.4f,0.4f,1.0f);
  GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
  GLES20.glUseProgram(mProgram);
  checkGlError("glUseProgram");
  float x, y, dx, dy;
  long t, dt;
synchronized (TestLatencyView.this) {
    x=mX;
    y=mY;
    dx=mDX;
    dy=mDY;
    dt=mDT;
  }
  if (dt > 0) {
    dx=dx * MS_PER_FRAME / dt;
    dy=dy * MS_PER_FRAME / dt;
  }
  GLES20.glEnableVertexAttribArray(mvPositionHandle);
  checkGlError("glEnableVertexAttribArray");
  GLES20.glEnableVertexAttribArray(mvColorHandle);
  checkGlError("glEnableVertexAttribArray");
  for (int step=0; step < 8; step++) {
    float sx=(x + dx * step) * mScaleX + mOffsetX;
    float sy=(y + dy * step) * mScaleY + mOffsetY;
    int cbase=step * 4;
    for (int i=0; i < mTriangleVerticesData.length; i+=6) {
      mTriangleVerticesData2[i]=sx + mTriangleVerticesData[i];
      mTriangleVerticesData2[i + 1]=-sy + mTriangleVerticesData[i + 1];
      mTriangleVerticesData2[i + 2]=mColors[cbase];
      mTriangleVerticesData2[i + 3]=mColors[cbase + 1];
      mTriangleVerticesData2[i + 4]=mColors[cbase + 2];
      mTriangleVerticesData2[i + 5]=mColors[cbase + 3];
    }
    mTriangleVertices.position(0);
    mTriangleVertices.put(mTriangleVerticesData2).position(0);
    GLES20.glVertexAttribPointer(mvPositionHandle,2,GLES20.GL_FLOAT,false,6 * 4,mTriangleVertices);
    checkGlError("glVertexAttribPointer mvPosition");
    mTriangleVertices.put(mTriangleVerticesData2).position(2);
    GLES20.glVertexAttribPointer(mvColorHandle,4,GLES20.GL_FLOAT,false,6 * 4,mTriangleVertices);
    checkGlError("glVertexAttribPointer mvColor");
    GLES20.glDrawArrays(GLES20.GL_TRIANGLES,0,3);
    checkGlError("glDrawArrays");
  }
}
