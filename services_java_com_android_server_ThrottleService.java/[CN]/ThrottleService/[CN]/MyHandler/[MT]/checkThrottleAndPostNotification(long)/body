{
  if (mPolicyThreshold == 0) {
    return;
  }
  if ((mNtpServer != null) && !mNtpActive) {
    return;
  }
  if (currentTotal > mPolicyThreshold) {
    if (mThrottleIndex != 1) {
synchronized (ThrottleService.this) {
        mThrottleIndex=1;
      }
      if (DBG)       Slog.d(TAG,"Threshold " + mPolicyThreshold + " exceeded!");
      try {
        mNMService.setInterfaceThrottle(mIface,mPolicyThrottleValue,mPolicyThrottleValue);
      }
 catch (      Exception e) {
        Slog.e(TAG,"error setting Throttle: " + e);
      }
      mNotificationManager.cancel(R.drawable.stat_sys_throttled);
      postNotification(R.string.throttled_notification_title,R.string.throttled_notification_message,R.drawable.stat_sys_throttled,Notification.FLAG_ONGOING_EVENT);
      Intent broadcast=new Intent(ThrottleManager.THROTTLE_ACTION);
      broadcast.putExtra(ThrottleManager.EXTRA_THROTTLE_LEVEL,mPolicyThrottleValue);
      mContext.sendStickyBroadcast(broadcast);
    }
  }
 else {
    clearThrottleAndNotification();
    if ((mPolicyNotificationsAllowedMask & NOTIFICATION_WARNING) != 0) {
      long start=mRecorder.getPeriodStart();
      long end=mRecorder.getPeriodEnd();
      long periodLength=end - start;
      long now=System.currentTimeMillis();
      long timeUsed=now - start;
      long warningThreshold=2 * mPolicyThreshold * timeUsed / (timeUsed + periodLength);
      if ((currentTotal > warningThreshold) && (currentTotal > mPolicyThreshold / 4)) {
        if (mWarningNotificationSent == false) {
          mWarningNotificationSent=true;
          mNotificationManager.cancel(R.drawable.stat_sys_throttled);
          postNotification(R.string.throttle_warning_notification_title,R.string.throttle_warning_notification_message,R.drawable.stat_sys_throttled,0);
        }
      }
 else {
        if (mWarningNotificationSent == true) {
          mNotificationManager.cancel(R.drawable.stat_sys_throttled);
          mWarningNotificationSent=false;
        }
      }
    }
  }
}
