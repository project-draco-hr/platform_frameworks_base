{
  zeroData(0);
  File f=getDataFile();
  byte[] buffer;
  FileInputStream s=null;
  try {
    buffer=new byte[(int)f.length()];
    s=new FileInputStream(f);
    s.read(buffer);
  }
 catch (  IOException e) {
    Slog.e(TAG,"Error reading data file");
    return;
  }
 finally {
    if (s != null) {
      try {
        s.close();
      }
 catch (      Exception e) {
      }
    }
  }
  String data=new String(buffer);
  if (data == null || data.length() == 0) {
    if (DBG)     Slog.d(TAG,"data file empty");
    return;
  }
  String[] parsed=data.split(":");
  int parsedUsed=0;
  if (parsed.length < 6) {
    Slog.e(TAG,"reading data file with insufficient length - ignoring");
    return;
  }
  if (Integer.parseInt(parsed[parsedUsed++]) != DATA_FILE_VERSION) {
    Slog.e(TAG,"reading data file with bad version - ignoring");
    return;
  }
  int periodCount=Integer.parseInt(parsed[parsedUsed++]);
  if (parsed.length != 5 + (2 * periodCount)) {
    Slog.e(TAG,"reading data file with bad length (" + parsed.length + " != "+ (5 + (2 * periodCount))+ ") - ignoring");
    return;
  }
  long[] periodRxData=new long[periodCount];
  for (int i=0; i < periodCount; i++) {
    periodRxData[i]=Long.parseLong(parsed[parsedUsed++]);
  }
  long[] periodTxData=new long[periodCount];
  for (int i=0; i < periodCount; i++) {
    periodTxData[i]=Long.parseLong(parsed[parsedUsed++]);
  }
  Calendar periodStart=new GregorianCalendar();
  periodStart.setTimeInMillis(Long.parseLong(parsed[parsedUsed++]));
  Calendar periodEnd=new GregorianCalendar();
  periodEnd.setTimeInMillis(Long.parseLong(parsed[parsedUsed++]));
synchronized (mParent) {
    mPeriodCount=periodCount;
    mPeriodRxData=periodRxData;
    mPeriodTxData=periodTxData;
    mCurrentPeriod=Integer.parseInt(parsed[parsedUsed++]);
    mPeriodStart=periodStart;
    mPeriodEnd=periodEnd;
  }
}
