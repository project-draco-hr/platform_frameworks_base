{
  RILRequest rr=(RILRequest)(msg.obj);
  RILRequest req=null;
switch (msg.what) {
case EVENT_SEND:
    boolean alreadySubtracted=false;
  try {
    LocalSocket s;
    s=mSocket;
    if (s == null) {
      rr.onError(RADIO_NOT_AVAILABLE,null);
      rr.release();
      mRequestMessagesPending--;
      alreadySubtracted=true;
      return;
    }
synchronized (mRequestsList) {
      mRequestsList.add(rr);
    }
    mRequestMessagesPending--;
    alreadySubtracted=true;
    byte[] data;
    data=rr.mp.marshall();
    rr.mp.recycle();
    rr.mp=null;
    if (data.length > RIL_MAX_COMMAND_BYTES) {
      throw new RuntimeException("Parcel larger than max bytes allowed! " + data.length);
    }
    dataLength[0]=dataLength[1]=0;
    dataLength[2]=(byte)((data.length >> 8) & 0xff);
    dataLength[3]=(byte)((data.length) & 0xff);
    s.getOutputStream().write(dataLength);
    s.getOutputStream().write(data);
  }
 catch (  IOException ex) {
    Log.e(LOG_TAG,"IOException",ex);
    req=findAndRemoveRequestFromList(rr.mSerial);
    if (req != null || !alreadySubtracted) {
      rr.onError(RADIO_NOT_AVAILABLE,null);
      rr.release();
    }
  }
catch (  RuntimeException exc) {
    Log.e(LOG_TAG,"Uncaught exception ",exc);
    req=findAndRemoveRequestFromList(rr.mSerial);
    if (req != null || !alreadySubtracted) {
      rr.onError(GENERIC_FAILURE,null);
      rr.release();
    }
  }
 finally {
    releaseWakeLockIfDone();
  }
if (!alreadySubtracted) {
  mRequestMessagesPending--;
}
break;
case EVENT_WAKE_LOCK_TIMEOUT:
synchronized (mWakeLock) {
if (mWakeLock.isHeld()) {
if (RILJ_LOGD) {
synchronized (mRequestsList) {
    int count=mRequestsList.size();
    Log.d(LOG_TAG,"WAKE_LOCK_TIMEOUT " + " mReqPending=" + mRequestMessagesPending + " mRequestList="+ count);
    for (int i=0; i < count; i++) {
      rr=mRequestsList.get(i);
      Log.d(LOG_TAG,i + ": [" + rr.mSerial+ "] "+ requestToString(rr.mRequest));
    }
  }
}
mWakeLock.release();
}
}
break;
}
}
