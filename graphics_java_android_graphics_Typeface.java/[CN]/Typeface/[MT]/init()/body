{
  File systemFontConfigLocation=getSystemFontConfigLocation();
  File systemConfigFilename=new File(systemFontConfigLocation,SYSTEM_FONTS_CONFIG);
  File configFilename=new File(systemFontConfigLocation,FALLBACK_FONTS_CONFIG);
  try {
    new FontFamily();
    FileInputStream systemIn=new FileInputStream(systemConfigFilename);
    List<FontListParser.Family> systemFontConfig=FontListParser.parse(systemIn);
    FileInputStream fallbackIn=new FileInputStream(configFilename);
    List<FontFamily> familyList=new ArrayList<FontFamily>();
    familyList.add(makeFamilyFromParsed(systemFontConfig.get(0)));
    for (    Family f : FontListParser.parse(fallbackIn)) {
      familyList.add(makeFamilyFromParsed(f));
    }
    sFallbackFonts=familyList.toArray(new FontFamily[familyList.size()]);
    setDefault(Typeface.createFromFamilies(sFallbackFonts));
    Map<String,Typeface> systemFonts=new HashMap<String,Typeface>();
    for (int i=0; i < systemFontConfig.size(); i++) {
      Typeface typeface;
      Family f=systemFontConfig.get(i);
      if (i == 0) {
        typeface=sDefaultTypeface;
      }
 else {
        FontFamily fontFamily=makeFamilyFromParsed(f);
        FontFamily[] families={fontFamily};
        typeface=Typeface.createFromFamiliesWithDefault(families);
      }
      for (      String name : f.names) {
        systemFonts.put(name,typeface);
      }
    }
    sSystemFontMap=systemFonts;
  }
 catch (  RuntimeException e) {
    Log.w(TAG,"Didn't create default family (most likely, non-Minikin build)");
  }
catch (  FileNotFoundException e) {
    Log.e(TAG,"Error opening " + configFilename);
  }
catch (  IOException e) {
    Log.e(TAG,"Error reading " + configFilename);
  }
catch (  XmlPullParserException e) {
    Log.e(TAG,"XML parse exception for " + configFilename);
  }
}
