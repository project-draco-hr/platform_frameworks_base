{
  final File path=new File(injectUserDataPath(userId),FILENAME_USER_PACKAGES);
  if (DEBUG) {
    Slog.i(TAG,"Loading from " + path);
  }
  path.mkdirs();
  final AtomicFile file=new AtomicFile(path);
  final FileInputStream in;
  try {
    in=file.openRead();
  }
 catch (  FileNotFoundException e) {
    if (DEBUG) {
      Slog.i(TAG,"Not found " + path);
    }
    return null;
  }
  final ArrayMap<String,PackageShortcuts> ret=new ArrayMap<String,PackageShortcuts>();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(in,StandardCharsets.UTF_8.name());
    String packageName=null;
    PackageShortcuts shortcuts=null;
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT) {
      if (type != XmlPullParser.START_TAG) {
        continue;
      }
      final int depth=parser.getDepth();
      final String tag=parser.getName();
      if (DEBUG_LOAD) {
        Slog.d(TAG,String.format("depth=%d type=%d name=%s",depth,type,tag));
      }
switch (depth) {
case 1:
{
          if (TAG_ROOT.equals(tag)) {
            continue;
          }
          break;
        }
case 2:
{
switch (tag) {
case TAG_PACKAGE:
          packageName=parseStringAttribute(parser,ATTR_NAME);
        shortcuts=new PackageShortcuts(userId,packageName);
      ret.put(packageName,shortcuts);
    shortcuts.mDynamicShortcutCount=(int)parseLongAttribute(parser,ATTR_DYNAMIC_COUNT);
  shortcuts.mApiCallCount=(int)parseLongAttribute(parser,ATTR_CALL_COUNT);
shortcuts.mLastResetTime=parseLongAttribute(parser,ATTR_LAST_RESET);
continue;
}
break;
}
case 3:
{
switch (tag) {
case TAG_SHORTCUT:
final ShortcutInfo si=parseShortcut(parser,packageName);
shortcuts.mShortcuts.put(si.getId(),si);
continue;
}
break;
}
}
throwForInvalidTag(depth,tag);
}
return ret;
}
 catch (IOException|XmlPullParserException e) {
Slog.e(TAG,"Failed to read file " + file.getBaseFile(),e);
return null;
}
 finally {
IoUtils.closeQuietly(in);
}
}
