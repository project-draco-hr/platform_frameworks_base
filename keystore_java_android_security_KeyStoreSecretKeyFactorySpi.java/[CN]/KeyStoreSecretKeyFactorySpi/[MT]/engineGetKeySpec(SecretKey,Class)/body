{
  if (keySpecClass == null) {
    throw new InvalidKeySpecException("keySpecClass == null");
  }
  if (!(key instanceof KeyStoreSecretKey)) {
    throw new InvalidKeySpecException("Only Android KeyStore secret keys supported: " + ((key != null) ? key.getClass().getName() : "null"));
  }
  if (SecretKeySpec.class.isAssignableFrom(keySpecClass)) {
    throw new InvalidKeySpecException("Key material export of Android KeyStore keys is not supported");
  }
  if (!KeyStoreKeySpec.class.equals(keySpecClass)) {
    throw new InvalidKeySpecException("Unsupported key spec: " + keySpecClass.getName());
  }
  String keyAliasInKeystore=((KeyStoreSecretKey)key).getAlias();
  String entryAlias;
  if (keyAliasInKeystore.startsWith(Credentials.USER_SECRET_KEY)) {
    entryAlias=keyAliasInKeystore.substring(Credentials.USER_SECRET_KEY.length());
  }
 else {
    throw new InvalidKeySpecException("Invalid key alias: " + keyAliasInKeystore);
  }
  KeyCharacteristics keyCharacteristics=new KeyCharacteristics();
  int errorCode=mKeyStore.getKeyCharacteristics(keyAliasInKeystore,null,null,keyCharacteristics);
  if (errorCode != KeyStore.NO_ERROR) {
    throw new InvalidKeySpecException("Failed to obtain information about key." + " Keystore error: " + errorCode);
  }
  boolean teeBacked;
  @KeyStoreKeyCharacteristics.OriginEnum int origin;
  int keySize;
  @KeyStoreKeyConstraints.PurposeEnum int purposes;
  @KeyStoreKeyConstraints.AlgorithmEnum int algorithm;
  @KeyStoreKeyConstraints.PaddingEnum int paddings;
  @KeyStoreKeyConstraints.DigestEnum int digests;
  @KeyStoreKeyConstraints.BlockModeEnum int blockModes;
  @KeyStoreKeyConstraints.UserAuthenticatorEnum int userAuthenticators;
  @KeyStoreKeyConstraints.UserAuthenticatorEnum int teeEnforcedUserAuthenticators;
  try {
    if (keyCharacteristics.hwEnforced.containsTag(KeymasterDefs.KM_TAG_ORIGIN)) {
      teeBacked=true;
      origin=KeyStoreKeyCharacteristics.Origin.fromKeymaster(keyCharacteristics.hwEnforced.getInt(KeymasterDefs.KM_TAG_ORIGIN,-1));
    }
 else     if (keyCharacteristics.swEnforced.containsTag(KeymasterDefs.KM_TAG_ORIGIN)) {
      teeBacked=false;
      origin=KeyStoreKeyCharacteristics.Origin.fromKeymaster(keyCharacteristics.swEnforced.getInt(KeymasterDefs.KM_TAG_ORIGIN,-1));
    }
 else {
      throw new InvalidKeySpecException("Key origin not available");
    }
    Integer keySizeInteger=KeymasterUtils.getInt(keyCharacteristics,KeymasterDefs.KM_TAG_KEY_SIZE);
    if (keySizeInteger == null) {
      throw new InvalidKeySpecException("Key size not available");
    }
    keySize=keySizeInteger;
    purposes=KeyStoreKeyConstraints.Purpose.allFromKeymaster(KeymasterUtils.getInts(keyCharacteristics,KeymasterDefs.KM_TAG_PURPOSE));
    Integer alg=KeymasterUtils.getInt(keyCharacteristics,KeymasterDefs.KM_TAG_ALGORITHM);
    if (alg == null) {
      throw new InvalidKeySpecException("Key algorithm not available");
    }
    algorithm=KeyStoreKeyConstraints.Algorithm.fromKeymaster(alg);
    paddings=KeyStoreKeyConstraints.Padding.allFromKeymaster(KeymasterUtils.getInts(keyCharacteristics,KeymasterDefs.KM_TAG_PADDING));
    digests=KeyStoreKeyConstraints.Digest.allFromKeymaster(KeymasterUtils.getInts(keyCharacteristics,KeymasterDefs.KM_TAG_DIGEST));
    blockModes=KeyStoreKeyConstraints.BlockMode.allFromKeymaster(KeymasterUtils.getInts(keyCharacteristics,KeymasterDefs.KM_TAG_BLOCK_MODE));
    @KeyStoreKeyConstraints.UserAuthenticatorEnum int swEnforcedKeymasterUserAuthenticators=keyCharacteristics.swEnforced.getInt(KeymasterDefs.KM_TAG_USER_AUTH_TYPE,0);
    @KeyStoreKeyConstraints.UserAuthenticatorEnum int hwEnforcedKeymasterUserAuthenticators=keyCharacteristics.hwEnforced.getInt(KeymasterDefs.KM_TAG_USER_AUTH_TYPE,0);
    @KeyStoreKeyConstraints.UserAuthenticatorEnum int keymasterUserAuthenticators=swEnforcedKeymasterUserAuthenticators | hwEnforcedKeymasterUserAuthenticators;
    userAuthenticators=KeyStoreKeyConstraints.UserAuthenticator.allFromKeymaster(keymasterUserAuthenticators);
    teeEnforcedUserAuthenticators=KeyStoreKeyConstraints.UserAuthenticator.allFromKeymaster(hwEnforcedKeymasterUserAuthenticators);
  }
 catch (  IllegalArgumentException e) {
    throw new InvalidKeySpecException("Unsupported key characteristic",e);
  }
  Date keyValidityStart=KeymasterUtils.getDate(keyCharacteristics,KeymasterDefs.KM_TAG_ACTIVE_DATETIME);
  if ((keyValidityStart != null) && (keyValidityStart.getTime() <= 0)) {
    keyValidityStart=null;
  }
  Date keyValidityForOriginationEnd=KeymasterUtils.getDate(keyCharacteristics,KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME);
  if ((keyValidityForOriginationEnd != null) && (keyValidityForOriginationEnd.getTime() == Long.MAX_VALUE)) {
    keyValidityForOriginationEnd=null;
  }
  Date keyValidityForConsumptionEnd=KeymasterUtils.getDate(keyCharacteristics,KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME);
  if ((keyValidityForConsumptionEnd != null) && (keyValidityForConsumptionEnd.getTime() == Long.MAX_VALUE)) {
    keyValidityForConsumptionEnd=null;
  }
  Integer userAuthenticationValidityDurationSeconds=KeymasterUtils.getInt(keyCharacteristics,KeymasterDefs.KM_TAG_AUTH_TIMEOUT);
  boolean invalidatedOnNewFingerprintEnrolled=false;
  return new KeyStoreKeySpec(entryAlias,teeBacked,origin,keySize,keyValidityStart,keyValidityForOriginationEnd,keyValidityForConsumptionEnd,purposes,algorithm,paddings,digests,blockModes,userAuthenticators,teeEnforcedUserAuthenticators,((userAuthenticationValidityDurationSeconds != null) ? userAuthenticationValidityDurationSeconds : -1),invalidatedOnNewFingerprintEnrolled);
}
