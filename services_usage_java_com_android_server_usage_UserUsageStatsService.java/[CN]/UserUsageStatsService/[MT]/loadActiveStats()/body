{
  final long timeNow=System.currentTimeMillis();
  final UnixCalendar tempCal=mDailyExpiryDate;
  for (int intervalType=0; intervalType < mCurrentStats.length; intervalType++) {
    tempCal.setTimeInMillis(timeNow);
    UnixCalendar.truncateTo(tempCal,intervalType);
    if (mCurrentStats[intervalType] != null && mCurrentStats[intervalType].beginTime == tempCal.getTimeInMillis()) {
      continue;
    }
    final long lastBeginTime=mDatabase.getLatestUsageStatsBeginTime(intervalType);
    if (lastBeginTime > timeNow) {
      Slog.e(TAG,mLogPrefix + "Latest usage stats for interval " + intervalType+ " begins in the future");
      mCurrentStats[intervalType]=null;
    }
 else     if (lastBeginTime >= tempCal.getTimeInMillis()) {
      if (DEBUG) {
        Slog.d(TAG,mLogPrefix + "Loading existing stats @ " + sDateFormat.format(lastBeginTime)+ "("+ lastBeginTime+ ") for interval "+ intervalType);
      }
      mCurrentStats[intervalType]=mDatabase.getLatestUsageStats(intervalType);
    }
 else {
      mCurrentStats[intervalType]=null;
    }
    if (mCurrentStats[intervalType] == null) {
      if (DEBUG) {
        Slog.d(TAG,"Creating new stats @ " + sDateFormat.format(tempCal.getTimeInMillis()) + "("+ tempCal.getTimeInMillis()+ ") for interval "+ intervalType);
      }
      mCurrentStats[intervalType]=new IntervalStats();
      mCurrentStats[intervalType].beginTime=tempCal.getTimeInMillis();
      mCurrentStats[intervalType].endTime=timeNow;
    }
  }
  mStatsChanged=false;
  mDailyExpiryDate.setTimeInMillis(timeNow);
  mDailyExpiryDate.addDays(1);
  mDailyExpiryDate.truncateToDay();
  Slog.i(TAG,mLogPrefix + "Rollover scheduled @ " + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ "("+ tempCal.getTimeInMillis()+ ")");
}
