{
  if (!mHasFeature) {
    return false;
  }
  final int callingUid=mInjector.binderGetCallingUid();
  final int userHandle=mInjector.userHandleGetCallingUserId();
  String password=passwordOrNull != null ? passwordOrNull : "";
  if (TextUtils.isEmpty(password)) {
    enforceNotManagedProfile(userHandle,"clear the active password");
  }
  int quality;
synchronized (this) {
    ActiveAdmin admin=getActiveAdminWithPolicyForUidLocked(null,DeviceAdminInfo.USES_POLICY_PROFILE_OWNER,callingUid);
    if (admin == null) {
      admin=getActiveAdminForCallerLocked(null,DeviceAdminInfo.USES_POLICY_RESET_PASSWORD);
      final boolean preN=getTargetSdk(admin.info.getPackageName(),userHandle) <= android.os.Build.VERSION_CODES.M;
      if (TextUtils.isEmpty(password)) {
        if (!preN) {
          throw new SecurityException("Cannot call with null password");
        }
 else {
          Slog.e(LOG_TAG,"Cannot call with null password");
          return false;
        }
      }
      if (isLockScreenSecureUnchecked(userHandle)) {
        if (!preN) {
          throw new SecurityException("Admin cannot change current password");
        }
 else {
          Slog.e(LOG_TAG,"Admin cannot change current password");
          return false;
        }
      }
    }
    quality=getPasswordQuality(null,userHandle,false);
    if (quality == DevicePolicyManager.PASSWORD_QUALITY_MANAGED) {
      quality=DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
    }
    if (quality != DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) {
      int realQuality=LockPatternUtils.computePasswordQuality(password);
      if (realQuality < quality && quality != DevicePolicyManager.PASSWORD_QUALITY_COMPLEX) {
        Slog.w(LOG_TAG,"resetPassword: password quality 0x" + Integer.toHexString(realQuality) + " does not meet required quality 0x"+ Integer.toHexString(quality));
        return false;
      }
      quality=Math.max(realQuality,quality);
    }
    int length=getPasswordMinimumLength(null,userHandle,false);
    if (password.length() < length) {
      Slog.w(LOG_TAG,"resetPassword: password length " + password.length() + " does not meet required length "+ length);
      return false;
    }
    if (quality == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX) {
      int letters=0;
      int uppercase=0;
      int lowercase=0;
      int numbers=0;
      int symbols=0;
      int nonletter=0;
      for (int i=0; i < password.length(); i++) {
        char c=password.charAt(i);
        if (c >= 'A' && c <= 'Z') {
          letters++;
          uppercase++;
        }
 else         if (c >= 'a' && c <= 'z') {
          letters++;
          lowercase++;
        }
 else         if (c >= '0' && c <= '9') {
          numbers++;
          nonletter++;
        }
 else {
          symbols++;
          nonletter++;
        }
      }
      int neededLetters=getPasswordMinimumLetters(null,userHandle,false);
      if (letters < neededLetters) {
        Slog.w(LOG_TAG,"resetPassword: number of letters " + letters + " does not meet required number of letters "+ neededLetters);
        return false;
      }
      int neededNumbers=getPasswordMinimumNumeric(null,userHandle,false);
      if (numbers < neededNumbers) {
        Slog.w(LOG_TAG,"resetPassword: number of numerical digits " + numbers + " does not meet required number of numerical digits "+ neededNumbers);
        return false;
      }
      int neededLowerCase=getPasswordMinimumLowerCase(null,userHandle,false);
      if (lowercase < neededLowerCase) {
        Slog.w(LOG_TAG,"resetPassword: number of lowercase letters " + lowercase + " does not meet required number of lowercase letters "+ neededLowerCase);
        return false;
      }
      int neededUpperCase=getPasswordMinimumUpperCase(null,userHandle,false);
      if (uppercase < neededUpperCase) {
        Slog.w(LOG_TAG,"resetPassword: number of uppercase letters " + uppercase + " does not meet required number of uppercase letters "+ neededUpperCase);
        return false;
      }
      int neededSymbols=getPasswordMinimumSymbols(null,userHandle,false);
      if (symbols < neededSymbols) {
        Slog.w(LOG_TAG,"resetPassword: number of special symbols " + symbols + " does not meet required number of special symbols "+ neededSymbols);
        return false;
      }
      int neededNonLetter=getPasswordMinimumNonLetter(null,userHandle,false);
      if (nonletter < neededNonLetter) {
        Slog.w(LOG_TAG,"resetPassword: number of non-letter characters " + nonletter + " does not meet required number of non-letter characters "+ neededNonLetter);
        return false;
      }
    }
  }
  DevicePolicyData policy=getUserData(userHandle);
  if (policy.mPasswordOwner >= 0 && policy.mPasswordOwner != callingUid) {
    Slog.w(LOG_TAG,"resetPassword: already set by another uid and not entered by user");
    return false;
  }
  boolean callerIsDeviceOwnerAdmin=isCallerDeviceOwner(callingUid);
  boolean doNotAskCredentialsOnBoot=(flags & DevicePolicyManager.RESET_PASSWORD_DO_NOT_ASK_CREDENTIALS_ON_BOOT) != 0;
  if (callerIsDeviceOwnerAdmin && doNotAskCredentialsOnBoot) {
    setDoNotAskCredentialsOnBoot();
  }
  final long ident=mInjector.binderClearCallingIdentity();
  try {
    if (isManagedProfile(userHandle)) {
      mLockPatternUtils.setSeparateProfileChallengeEnabled(userHandle,true);
    }
    if (!TextUtils.isEmpty(password)) {
      mLockPatternUtils.saveLockPassword(password,null,quality,userHandle);
    }
 else {
      mLockPatternUtils.clearLock(userHandle);
    }
    boolean requireEntry=(flags & DevicePolicyManager.RESET_PASSWORD_REQUIRE_ENTRY) != 0;
    if (requireEntry) {
      mLockPatternUtils.requireStrongAuth(STRONG_AUTH_REQUIRED_AFTER_DPM_LOCK_NOW,UserHandle.USER_ALL);
    }
synchronized (this) {
      int newOwner=requireEntry ? callingUid : -1;
      if (policy.mPasswordOwner != newOwner) {
        policy.mPasswordOwner=newOwner;
        saveSettingsLocked(userHandle);
      }
    }
  }
  finally {
    mInjector.binderRestoreCallingIdentity(ident);
  }
  return true;
}
