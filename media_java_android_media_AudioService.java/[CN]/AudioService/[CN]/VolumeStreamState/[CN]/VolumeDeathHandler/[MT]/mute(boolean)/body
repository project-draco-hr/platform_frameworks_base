{
  boolean updateVolume=false;
  if (state) {
    if (mMuteCount == 0) {
      try {
        if (mICallback != null) {
          mICallback.linkToDeath(this,0);
        }
        VolumeStreamState.this.mDeathHandlers.add(this);
        if (!VolumeStreamState.this.isMuted()) {
          updateVolume=true;
        }
      }
 catch (      RemoteException e) {
        binderDied();
        return;
      }
    }
 else {
      Log.w(TAG,"stream: " + mStreamType + " was already muted by this client");
    }
    mMuteCount++;
  }
 else {
    if (mMuteCount == 0) {
      Log.e(TAG,"unexpected unmute for stream: " + mStreamType);
    }
 else {
      mMuteCount--;
      if (mMuteCount == 0) {
        VolumeStreamState.this.mDeathHandlers.remove(this);
        if (mICallback != null) {
          mICallback.unlinkToDeath(this,0);
        }
        if (!VolumeStreamState.this.isMuted()) {
          updateVolume=true;
        }
      }
    }
  }
  if (updateVolume) {
    sendMsg(mAudioHandler,MSG_SET_ALL_VOLUMES,SENDMSG_QUEUE,0,0,VolumeStreamState.this,0);
  }
}
