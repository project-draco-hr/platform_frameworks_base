{
  if (DEBUG_RC)   Log.d(TAG,"onNewPlaybackInfoForRcc(id=" + rccId + ", what="+ key+ ",val="+ value+ ")");
synchronized (mRCStack) {
    Iterator<RemoteControlStackEntry> stackIterator=mRCStack.iterator();
    while (stackIterator.hasNext()) {
      RemoteControlStackEntry rcse=stackIterator.next();
      if (rcse.mRccId == rccId) {
switch (key) {
case RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE:
          rcse.mPlaybackType=value;
        postReevaluateRemote();
      break;
case RemoteControlClient.PLAYBACKINFO_VOLUME:
    rcse.mPlaybackVolume=value;
synchronized (mMainRemote) {
    if (rccId == mMainRemote.mRccId) {
      mMainRemote.mVolume=value;
      mVolumePanel.postHasNewRemotePlaybackInfo();
    }
  }
break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_MAX:
rcse.mPlaybackVolumeMax=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemote.mVolumeMax=value;
mVolumePanel.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING:
rcse.mPlaybackVolumeHandling=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemote.mVolumeHandling=value;
mVolumePanel.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_USES_STREAM:
rcse.mPlaybackStream=value;
break;
case RemoteControlClient.PLAYBACKINFO_PLAYSTATE:
rcse.mPlaybackState=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemoteIsActive=isPlaystateActive(value);
postReevaluateRemote();
}
}
break;
default :
Log.e(TAG,"unhandled key " + key + " for RCC "+ rccId);
break;
}
return;
}
}
}
}
