{
  if (DEBUG_RC)   Log.d(TAG,"onNewPlaybackInfoForRcc(id=" + rccId + ", what="+ key+ ",val="+ value+ ")");
synchronized (mRCStack) {
    try {
      for (int index=mRCStack.size() - 1; index >= 0; index--) {
        final RemoteControlStackEntry rcse=mRCStack.elementAt(index);
        if (rcse.mRccId == rccId) {
switch (key) {
case RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE:
            rcse.mPlaybackType=value;
          postReevaluateRemote();
        break;
case RemoteControlClient.PLAYBACKINFO_VOLUME:
      rcse.mPlaybackVolume=value;
synchronized (mMainRemote) {
      if (rccId == mMainRemote.mRccId) {
        mMainRemote.mVolume=value;
        mVolumePanel.postHasNewRemotePlaybackInfo();
      }
    }
  break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_MAX:
rcse.mPlaybackVolumeMax=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
  mMainRemote.mVolumeMax=value;
  mVolumePanel.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING:
rcse.mPlaybackVolumeHandling=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemote.mVolumeHandling=value;
mVolumePanel.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_USES_STREAM:
rcse.mPlaybackStream=value;
break;
case RemoteControlClient.PLAYBACKINFO_PLAYSTATE:
rcse.mPlaybackState=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemoteIsActive=isPlaystateActive(value);
postReevaluateRemote();
}
}
break;
default :
Log.e(TAG,"unhandled key " + key + " for RCC "+ rccId);
break;
}
return;
}
}
}
 catch (ArrayIndexOutOfBoundsException e) {
Log.e(TAG,"Wrong index accessing RC stack, lock error? ",e);
}
}
}
