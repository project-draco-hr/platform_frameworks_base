{
  KeyGeneratorSpec spec=mSpec;
  if (spec == null) {
    throw new IllegalStateException("Not initialized");
  }
  if ((spec.isEncryptionRequired()) && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
    throw new IllegalStateException("Android KeyStore must be in initialized and unlocked state if encryption is" + " required");
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addInt(KeymasterDefs.KM_TAG_ALGORITHM,KeyStoreKeyConstraints.Algorithm.toKeymaster(mAlgorithm));
  if (mDigest != null) {
    args.addInt(KeymasterDefs.KM_TAG_DIGEST,KeyStoreKeyConstraints.Digest.toKeymaster(mDigest));
    Integer digestOutputSizeBytes=KeyStoreKeyConstraints.Digest.getOutputSizeBytes(mDigest);
    if (digestOutputSizeBytes != null) {
      args.addInt(KeymasterDefs.KM_TAG_MAC_LENGTH,digestOutputSizeBytes);
    }
  }
  if (mAlgorithm == KeyStoreKeyConstraints.Algorithm.HMAC) {
    if (mDigest == null) {
      throw new IllegalStateException("Digest algorithm must be specified for key" + " algorithm " + KeyStoreKeyConstraints.Algorithm.toString(mAlgorithm));
    }
  }
  int keySizeBits=(spec.getKeySize() != null) ? spec.getKeySize() : mDefaultKeySizeBits;
  args.addInt(KeymasterDefs.KM_TAG_KEY_SIZE,keySizeBits);
  @KeyStoreKeyConstraints.PurposeEnum int purposes=(spec.getPurposes() != null) ? spec.getPurposes() : (KeyStoreKeyConstraints.Purpose.ENCRYPT | KeyStoreKeyConstraints.Purpose.DECRYPT | KeyStoreKeyConstraints.Purpose.SIGN| KeyStoreKeyConstraints.Purpose.VERIFY);
  for (  int keymasterPurpose : KeyStoreKeyConstraints.Purpose.allToKeymaster(purposes)) {
    args.addInt(KeymasterDefs.KM_TAG_PURPOSE,keymasterPurpose);
  }
  if (spec.getBlockMode() != null) {
    args.addInt(KeymasterDefs.KM_TAG_BLOCK_MODE,KeyStoreKeyConstraints.BlockMode.toKeymaster(spec.getBlockMode()));
  }
  if (spec.getPadding() != null) {
    args.addInt(KeymasterDefs.KM_TAG_PADDING,KeyStoreKeyConstraints.Padding.toKeymaster(spec.getPadding()));
  }
  if (spec.getMaxUsesPerBoot() != null) {
    args.addInt(KeymasterDefs.KM_TAG_MAX_USES_PER_BOOT,spec.getMaxUsesPerBoot());
  }
  if (spec.getMinSecondsBetweenOperations() != null) {
    args.addInt(KeymasterDefs.KM_TAG_MIN_SECONDS_BETWEEN_OPS,spec.getMinSecondsBetweenOperations());
  }
  if (spec.getUserAuthenticators().isEmpty()) {
    args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
  }
 else {
    args.addInt(KeymasterDefs.KM_TAG_USER_AUTH_TYPE,KeyStoreKeyConstraints.UserAuthenticator.allToKeymaster(spec.getUserAuthenticators()));
  }
  if (spec.getUserAuthenticationValidityDurationSeconds() != null) {
    args.addInt(KeymasterDefs.KM_TAG_AUTH_TIMEOUT,spec.getUserAuthenticationValidityDurationSeconds());
  }
  args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,(spec.getKeyValidityStart() != null) ? spec.getKeyValidityStart() : new Date(0));
  args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,(spec.getKeyValidityForOriginationEnd() != null) ? spec.getKeyValidityForOriginationEnd() : new Date(Long.MAX_VALUE));
  args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,(spec.getKeyValidityForConsumptionEnd() != null) ? spec.getKeyValidityForConsumptionEnd() : new Date(Long.MAX_VALUE));
  if (((purposes & KeyStoreKeyConstraints.Purpose.ENCRYPT) != 0) || ((purposes & KeyStoreKeyConstraints.Purpose.DECRYPT) != 0)) {
    args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
  }
  byte[] additionalEntropy=null;
  SecureRandom rng=mRng;
  if (rng != null) {
    additionalEntropy=new byte[(keySizeBits + 7) / 8];
    rng.nextBytes(additionalEntropy);
  }
  int flags=spec.getFlags();
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + spec.getKeystoreAlias();
  int errorCode=mKeyStore.generateKey(keyAliasInKeystore,args,additionalEntropy,flags,new KeyCharacteristics());
  if (errorCode != KeyStore.NO_ERROR) {
    throw KeyStore.getCryptoOperationException(errorCode);
  }
  String keyAlgorithmJCA=KeyStoreKeyConstraints.Algorithm.toJCASecretKeyAlgorithm(mAlgorithm,mDigest);
  return new KeyStoreSecretKey(keyAliasInKeystore,keyAlgorithmJCA);
}
