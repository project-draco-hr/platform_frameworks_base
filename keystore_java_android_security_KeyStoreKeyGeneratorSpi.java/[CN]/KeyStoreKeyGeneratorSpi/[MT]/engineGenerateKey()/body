{
  KeyGeneratorSpec spec=mSpec;
  if (spec == null) {
    throw new IllegalStateException("Not initialized");
  }
  if ((spec.isEncryptionRequired()) && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
    throw new IllegalStateException("Android KeyStore must be in initialized and unlocked state if encryption is" + " required");
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addInt(KeymasterDefs.KM_TAG_ALGORITHM,mKeymasterAlgorithm);
  if (mKeymasterDigest != -1) {
    args.addInt(KeymasterDefs.KM_TAG_DIGEST,mKeymasterDigest);
    int digestOutputSizeBytes=KeymasterUtils.getDigestOutputSizeBytes(mKeymasterDigest);
    if (digestOutputSizeBytes != -1) {
      args.addInt(KeymasterDefs.KM_TAG_MAC_LENGTH,digestOutputSizeBytes);
    }
  }
  if (mKeymasterAlgorithm == KeymasterDefs.KM_ALGORITHM_HMAC) {
    if (mKeymasterDigest == -1) {
      throw new IllegalStateException("Digest algorithm must be specified for HMAC key");
    }
  }
  int keySizeBits=(spec.getKeySize() != null) ? spec.getKeySize() : mDefaultKeySizeBits;
  args.addInt(KeymasterDefs.KM_TAG_KEY_SIZE,keySizeBits);
  @KeyStoreKeyProperties.PurposeEnum int purposes=spec.getPurposes();
  int[] keymasterBlockModes=KeymasterUtils.getKeymasterBlockModesFromJcaBlockModes(spec.getBlockModes());
  if (((purposes & KeyStoreKeyProperties.Purpose.ENCRYPT) != 0) && (spec.isRandomizedEncryptionRequired())) {
    for (    int keymasterBlockMode : keymasterBlockModes) {
      if (!KeymasterUtils.isKeymasterBlockModeIndCpaCompatible(keymasterBlockMode)) {
        throw new IllegalStateException("Randomized encryption (IND-CPA) required but may be violated by block" + " mode: " + KeymasterUtils.getJcaBlockModeFromKeymasterBlockMode(keymasterBlockMode) + ". See KeyGeneratorSpec documentation.");
      }
    }
  }
  for (  int keymasterPurpose : KeyStoreKeyProperties.Purpose.allToKeymaster(purposes)) {
    args.addInt(KeymasterDefs.KM_TAG_PURPOSE,keymasterPurpose);
  }
  args.addInts(KeymasterDefs.KM_TAG_BLOCK_MODE,keymasterBlockModes);
  args.addInts(KeymasterDefs.KM_TAG_PADDING,KeymasterUtils.getKeymasterPaddingsFromJcaEncryptionPaddings(spec.getEncryptionPaddings()));
  if (spec.getUserAuthenticators() == 0) {
    args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
  }
 else {
    args.addInt(KeymasterDefs.KM_TAG_USER_AUTH_TYPE,KeyStoreKeyProperties.UserAuthenticator.allToKeymaster(spec.getUserAuthenticators()));
  }
  if (spec.getUserAuthenticationValidityDurationSeconds() != -1) {
    args.addInt(KeymasterDefs.KM_TAG_AUTH_TIMEOUT,spec.getUserAuthenticationValidityDurationSeconds());
  }
  args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,(spec.getKeyValidityStart() != null) ? spec.getKeyValidityStart() : new Date(0));
  args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,(spec.getKeyValidityForOriginationEnd() != null) ? spec.getKeyValidityForOriginationEnd() : new Date(Long.MAX_VALUE));
  args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,(spec.getKeyValidityForConsumptionEnd() != null) ? spec.getKeyValidityForConsumptionEnd() : new Date(Long.MAX_VALUE));
  if (((purposes & KeyStoreKeyProperties.Purpose.ENCRYPT) != 0) && (!spec.isRandomizedEncryptionRequired())) {
    args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
  }
  byte[] additionalEntropy=null;
  SecureRandom rng=mRng;
  if (rng != null) {
    additionalEntropy=new byte[(keySizeBits + 7) / 8];
    rng.nextBytes(additionalEntropy);
  }
  int flags=spec.getFlags();
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + spec.getKeystoreAlias();
  int errorCode=mKeyStore.generateKey(keyAliasInKeystore,args,additionalEntropy,flags,new KeyCharacteristics());
  if (errorCode != KeyStore.NO_ERROR) {
    throw KeyStore.getCryptoOperationException(errorCode);
  }
  String keyAlgorithmJCA=KeymasterUtils.getJcaSecretKeyAlgorithm(mKeymasterAlgorithm,mKeymasterDigest);
  return new KeyStoreSecretKey(keyAliasInKeystore,keyAlgorithmJCA);
}
