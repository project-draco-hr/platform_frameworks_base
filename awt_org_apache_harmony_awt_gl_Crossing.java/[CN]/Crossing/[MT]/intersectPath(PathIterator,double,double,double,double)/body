{
  int cross=0;
  int count;
  double mx, my, cx, cy;
  mx=my=cx=cy=0.0;
  double coords[]=new double[6];
  double rx1=x;
  double ry1=y;
  double rx2=x + w;
  double ry2=y + h;
  while (!p.isDone()) {
    count=0;
switch (p.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
      if (cx != mx || cy != my) {
        count=intersectLine(cx,cy,mx,my,rx1,ry1,rx2,ry2);
      }
    mx=cx=coords[0];
  my=cy=coords[1];
break;
case PathIterator.SEG_LINETO:
count=intersectLine(cx,cy,cx=coords[0],cy=coords[1],rx1,ry1,rx2,ry2);
break;
case PathIterator.SEG_QUADTO:
count=intersectQuad(cx,cy,coords[0],coords[1],cx=coords[2],cy=coords[3],rx1,ry1,rx2,ry2);
break;
case PathIterator.SEG_CUBICTO:
count=intersectCubic(cx,cy,coords[0],coords[1],coords[2],coords[3],cx=coords[4],cy=coords[5],rx1,ry1,rx2,ry2);
break;
case PathIterator.SEG_CLOSE:
if (cy != my || cx != mx) {
count=intersectLine(cx,cy,mx,my,rx1,ry1,rx2,ry2);
}
cx=mx;
cy=my;
break;
}
if (count == CROSSING) {
return CROSSING;
}
cross+=count;
p.next();
}
if (cy != my) {
count=intersectLine(cx,cy,mx,my,rx1,ry1,rx2,ry2);
if (count == CROSSING) {
return CROSSING;
}
cross+=count;
}
return cross;
}
