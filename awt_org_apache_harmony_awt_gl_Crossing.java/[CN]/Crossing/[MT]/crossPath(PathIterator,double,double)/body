{
  int cross=0;
  double mx, my, cx, cy;
  mx=my=cx=cy=0.0;
  double coords[]=new double[6];
  while (!p.isDone()) {
switch (p.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
      if (cx != mx || cy != my) {
        cross+=crossLine(cx,cy,mx,my,x,y);
      }
    mx=cx=coords[0];
  my=cy=coords[1];
break;
case PathIterator.SEG_LINETO:
cross+=crossLine(cx,cy,cx=coords[0],cy=coords[1],x,y);
break;
case PathIterator.SEG_QUADTO:
cross+=crossQuad(cx,cy,coords[0],coords[1],cx=coords[2],cy=coords[3],x,y);
break;
case PathIterator.SEG_CUBICTO:
cross+=crossCubic(cx,cy,coords[0],coords[1],coords[2],coords[3],cx=coords[4],cy=coords[5],x,y);
break;
case PathIterator.SEG_CLOSE:
if (cy != my || cx != mx) {
cross+=crossLine(cx,cy,cx=mx,cy=my,x,y);
}
break;
}
p.next();
}
if (cy != my) {
cross+=crossLine(cx,cy,mx,my,x,y);
}
return cross;
}
