{
  mContext.enforceCallingOrSelfPermission(android.Manifest.permission.BACKUP,"setBackupPassword");
  final boolean pbkdf2Fallback=(mPasswordVersion < BACKUP_PW_FILE_VERSION);
  if (!passwordMatchesSaved(PBKDF_CURRENT,currentPw,PBKDF2_HASH_ROUNDS) && !(pbkdf2Fallback && passwordMatchesSaved(PBKDF_FALLBACK,currentPw,PBKDF2_HASH_ROUNDS))) {
    return false;
  }
  mPasswordVersion=BACKUP_PW_FILE_VERSION;
  FileOutputStream pwFout=null;
  DataOutputStream pwOut=null;
  try {
    pwFout=new FileOutputStream(mPasswordVersionFile);
    pwOut=new DataOutputStream(pwFout);
    pwOut.writeInt(mPasswordVersion);
  }
 catch (  IOException e) {
    Slog.e(TAG,"Unable to write backup pw version; password not changed");
    return false;
  }
 finally {
    try {
      if (pwOut != null)       pwOut.close();
      if (pwFout != null)       pwFout.close();
    }
 catch (    IOException e) {
      Slog.w(TAG,"Unable to close pw version record");
    }
  }
  if (newPw == null || newPw.isEmpty()) {
    if (mPasswordHashFile.exists()) {
      if (!mPasswordHashFile.delete()) {
        Slog.e(TAG,"Unable to clear backup password");
        return false;
      }
    }
    mPasswordHash=null;
    mPasswordSalt=null;
    return true;
  }
  try {
    byte[] salt=randomBytes(PBKDF2_SALT_SIZE);
    String newPwHash=buildPasswordHash(PBKDF_CURRENT,newPw,salt,PBKDF2_HASH_ROUNDS);
    OutputStream pwf=null, buffer=null;
    DataOutputStream out=null;
    try {
      pwf=new FileOutputStream(mPasswordHashFile);
      buffer=new BufferedOutputStream(pwf);
      out=new DataOutputStream(buffer);
      out.writeInt(salt.length);
      out.write(salt);
      out.writeUTF(newPwHash);
      out.flush();
      mPasswordHash=newPwHash;
      mPasswordSalt=salt;
      return true;
    }
  finally {
      if (out != null)       out.close();
      if (buffer != null)       buffer.close();
      if (pwf != null)       pwf.close();
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,"Unable to set backup password");
  }
  return false;
}
