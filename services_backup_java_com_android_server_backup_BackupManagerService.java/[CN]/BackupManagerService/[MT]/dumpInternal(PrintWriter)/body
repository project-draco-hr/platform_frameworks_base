{
synchronized (mQueueLock) {
    pw.println("Backup Manager is " + (mEnabled ? "enabled" : "disabled") + " / "+ (!mProvisioned ? "not " : "")+ "provisioned / "+ (this.mPendingInits.size() == 0 ? "not " : "")+ "pending init");
    pw.println("Auto-restore is " + (mAutoRestore ? "enabled" : "disabled"));
    if (mBackupRunning)     pw.println("Backup currently running");
    pw.println("Last backup pass started: " + mLastBackupPass + " (now = "+ System.currentTimeMillis()+ ')');
    pw.println("  next scheduled: " + KeyValueBackupJob.nextScheduled());
    pw.println("Transport whitelist:");
    for (    ComponentName transport : mTransportWhitelist) {
      pw.print("    ");
      pw.println(transport.flattenToShortString());
    }
    pw.println("Available transports:");
    final String[] transports=listAllTransports();
    if (transports != null) {
      for (      String t : listAllTransports()) {
        pw.println((t.equals(mCurrentTransport) ? "  * " : "    ") + t);
        try {
          IBackupTransport transport=getTransport(t);
          File dir=new File(mBaseStateDir,transport.transportDirName());
          pw.println("       destination: " + transport.currentDestinationString());
          pw.println("       intent: " + transport.configurationIntent());
          for (          File f : dir.listFiles()) {
            pw.println("       " + f.getName() + " - "+ f.length()+ " state bytes");
          }
        }
 catch (        Exception e) {
          Slog.e(TAG,"Error in transport",e);
          pw.println("        Error: " + e);
        }
      }
    }
    pw.println("Pending init: " + mPendingInits.size());
    for (    String s : mPendingInits) {
      pw.println("    " + s);
    }
    if (DEBUG_BACKUP_TRACE) {
synchronized (mBackupTrace) {
        if (!mBackupTrace.isEmpty()) {
          pw.println("Most recent backup trace:");
          for (          String s : mBackupTrace) {
            pw.println("   " + s);
          }
        }
      }
    }
    pw.print("Ancestral: ");
    pw.println(Long.toHexString(mAncestralToken));
    pw.print("Current:   ");
    pw.println(Long.toHexString(mCurrentToken));
    int N=mBackupParticipants.size();
    pw.println("Participants:");
    for (int i=0; i < N; i++) {
      int uid=mBackupParticipants.keyAt(i);
      pw.print("  uid: ");
      pw.println(uid);
      HashSet<String> participants=mBackupParticipants.valueAt(i);
      for (      String app : participants) {
        pw.println("    " + app);
      }
    }
    pw.println("Ancestral packages: " + (mAncestralPackages == null ? "none" : mAncestralPackages.size()));
    if (mAncestralPackages != null) {
      for (      String pkg : mAncestralPackages) {
        pw.println("    " + pkg);
      }
    }
    pw.println("Ever backed up: " + mEverStoredApps.size());
    for (    String pkg : mEverStoredApps) {
      pw.println("    " + pkg);
    }
    pw.println("Pending key/value backup: " + mPendingBackups.size());
    for (    BackupRequest req : mPendingBackups.values()) {
      pw.println("    " + req);
    }
    pw.println("Full backup queue:" + mFullBackupQueue.size());
    for (    FullBackupEntry entry : mFullBackupQueue) {
      pw.print("    ");
      pw.print(entry.lastBackup);
      pw.print(" : ");
      pw.println(entry.packageName);
    }
  }
}
