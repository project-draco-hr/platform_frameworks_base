{
  long now=System.currentTimeMillis();
  FullBackupEntry entry=null;
  long latency=MIN_FULL_BACKUP_INTERVAL;
  if (!mEnabled || !mProvisioned) {
    if (MORE_DEBUG) {
      Slog.i(TAG,"beginFullBackup but e=" + mEnabled + " p="+ mProvisioned+ "; ignoring");
    }
    return false;
  }
  if (DEBUG_SCHEDULING) {
    Slog.i(TAG,"Beginning scheduled full backup operation");
  }
synchronized (mQueueLock) {
    if (mRunningFullBackupTask != null) {
      Slog.e(TAG,"Backup triggered but one already/still running!");
      return false;
    }
    if (mFullBackupQueue.size() == 0) {
      if (DEBUG) {
        Slog.i(TAG,"Backup queue empty; doing nothing");
      }
      return false;
    }
    boolean runBackup=true;
    if (!fullBackupAllowable(getTransport(mCurrentTransport))) {
      if (MORE_DEBUG) {
        Slog.i(TAG,"Preconditions not met; not running full backup");
      }
      runBackup=false;
      latency=KeyValueBackupJob.BATCH_INTERVAL;
    }
    if (runBackup) {
      entry=mFullBackupQueue.get(0);
      long timeSinceRun=now - entry.lastBackup;
      runBackup=(timeSinceRun >= MIN_FULL_BACKUP_INTERVAL);
      if (!runBackup) {
        if (MORE_DEBUG) {
          Slog.i(TAG,"Device ready but too early to back up next app");
        }
        latency=MIN_FULL_BACKUP_INTERVAL - timeSinceRun;
      }
    }
    if (!runBackup) {
      if (DEBUG_SCHEDULING) {
        Slog.i(TAG,"Nothing pending full backup; rescheduling +" + latency);
      }
      final long deferTime=latency;
      mBackupHandler.post(new Runnable(){
        @Override public void run(){
          FullBackupJob.schedule(mContext,deferTime);
        }
      }
);
      return false;
    }
    mFullBackupQueue.remove(0);
    CountDownLatch latch=new CountDownLatch(1);
    String[] pkg=new String[]{entry.packageName};
    mRunningFullBackupTask=new PerformFullTransportBackupTask(null,pkg,true,scheduledJob,latch);
    (new Thread(mRunningFullBackupTask)).start();
  }
  return true;
}
