{
  boolean changed=false;
  ArrayList<FullBackupEntry> schedule=null;
  List<PackageInfo> apps=PackageManagerBackupAgent.getStorableApplications(mPackageManager);
  if (mFullBackupScheduleFile.exists()) {
    FileInputStream fstream=null;
    BufferedInputStream bufStream=null;
    DataInputStream in=null;
    try {
      fstream=new FileInputStream(mFullBackupScheduleFile);
      bufStream=new BufferedInputStream(fstream);
      in=new DataInputStream(bufStream);
      int version=in.readInt();
      if (version != SCHEDULE_FILE_VERSION) {
        Slog.e(TAG,"Unknown backup schedule version " + version);
        return null;
      }
      final int N=in.readInt();
      schedule=new ArrayList<FullBackupEntry>(N);
      HashSet<String> foundApps=new HashSet<String>(N);
      for (int i=0; i < N; i++) {
        String pkgName=in.readUTF();
        long lastBackup=in.readLong();
        foundApps.add(pkgName);
        try {
          PackageInfo pkg=mPackageManager.getPackageInfo(pkgName,0);
          if (appGetsFullBackup(pkg) && appIsEligibleForBackup(pkg.applicationInfo)) {
            schedule.add(new FullBackupEntry(pkgName,lastBackup));
          }
 else {
            if (DEBUG) {
              Slog.i(TAG,"Package " + pkgName + " no longer eligible for full backup");
            }
          }
        }
 catch (        NameNotFoundException e) {
          if (DEBUG) {
            Slog.i(TAG,"Package " + pkgName + " not installed; dropping from full backup");
          }
        }
      }
      for (      PackageInfo app : apps) {
        if (appGetsFullBackup(app) && appIsEligibleForBackup(app.applicationInfo)) {
          if (!foundApps.contains(app.packageName)) {
            if (MORE_DEBUG) {
              Slog.i(TAG,"New full backup app " + app.packageName + " found");
            }
            schedule.add(new FullBackupEntry(app.packageName,0));
            changed=true;
          }
        }
      }
      Collections.sort(schedule);
    }
 catch (    Exception e) {
      Slog.e(TAG,"Unable to read backup schedule",e);
      mFullBackupScheduleFile.delete();
      schedule=null;
    }
 finally {
      IoUtils.closeQuietly(in);
      IoUtils.closeQuietly(bufStream);
      IoUtils.closeQuietly(fstream);
    }
  }
  if (schedule == null) {
    changed=true;
    schedule=new ArrayList<FullBackupEntry>(apps.size());
    for (    PackageInfo info : apps) {
      if (appGetsFullBackup(info) && appIsEligibleForBackup(info.applicationInfo)) {
        schedule.add(new FullBackupEntry(info.packageName,0));
      }
    }
  }
  if (changed) {
    writeFullBackupScheduleAsync();
  }
  return schedule;
}
