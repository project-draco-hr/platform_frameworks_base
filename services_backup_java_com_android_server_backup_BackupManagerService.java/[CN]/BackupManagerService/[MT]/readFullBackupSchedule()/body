{
  ArrayList<FullBackupEntry> schedule=null;
synchronized (mQueueLock) {
    if (mFullBackupScheduleFile.exists()) {
      FileInputStream fstream=null;
      BufferedInputStream bufStream=null;
      DataInputStream in=null;
      try {
        fstream=new FileInputStream(mFullBackupScheduleFile);
        bufStream=new BufferedInputStream(fstream);
        in=new DataInputStream(bufStream);
        int version=in.readInt();
        if (version != SCHEDULE_FILE_VERSION) {
          Slog.e(TAG,"Unknown backup schedule version " + version);
          return null;
        }
        int N=in.readInt();
        schedule=new ArrayList<FullBackupEntry>(N);
        for (int i=0; i < N; i++) {
          String pkgName=in.readUTF();
          long lastBackup=in.readLong();
          schedule.add(new FullBackupEntry(pkgName,lastBackup));
        }
        Collections.sort(schedule);
      }
 catch (      Exception e) {
        Slog.e(TAG,"Unable to read backup schedule",e);
        mFullBackupScheduleFile.delete();
        schedule=null;
      }
 finally {
        IoUtils.closeQuietly(in);
        IoUtils.closeQuietly(bufStream);
        IoUtils.closeQuietly(fstream);
      }
    }
    if (schedule == null) {
      List<PackageInfo> apps=PackageManagerBackupAgent.getStorableApplications(mPackageManager);
      final int N=apps.size();
      schedule=new ArrayList<FullBackupEntry>(N);
      for (int i=0; i < N; i++) {
        PackageInfo info=apps.get(i);
        if (appGetsFullBackup(info)) {
          schedule.add(new FullBackupEntry(info.packageName,0));
        }
      }
      writeFullBackupScheduleAsync();
    }
  }
  return schedule;
}
