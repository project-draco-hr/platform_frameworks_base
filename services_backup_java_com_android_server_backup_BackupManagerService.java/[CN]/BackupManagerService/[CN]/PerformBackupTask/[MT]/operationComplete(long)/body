{
  if (mBackupData == null) {
    final String pkg=(mCurrentPackage != null) ? mCurrentPackage.packageName : "[none]";
    if (MORE_DEBUG) {
      Slog.i(TAG,"Callback after agent teardown: " + pkg);
    }
    addBackupTrace("late opComplete; curPkg = " + pkg);
    return;
  }
  final String pkgName=mCurrentPackage.packageName;
  final long filepos=mBackupDataName.length();
  FileDescriptor fd=mBackupData.getFileDescriptor();
  try {
    if (mCurrentPackage.applicationInfo != null && (mCurrentPackage.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
      ParcelFileDescriptor readFd=ParcelFileDescriptor.open(mBackupDataName,ParcelFileDescriptor.MODE_READ_ONLY);
      BackupDataInput in=new BackupDataInput(readFd.getFileDescriptor());
      try {
        while (in.readNextHeader()) {
          final String key=in.getKey();
          if (key != null && key.charAt(0) >= 0xff00) {
            failAgent(mAgentBinder,"Illegal backup key: " + key);
            addBackupTrace("illegal key " + key + " from "+ pkgName);
            EventLog.writeEvent(EventLogTags.BACKUP_AGENT_FAILURE,pkgName,"bad key");
            mBackupHandler.removeMessages(MSG_TIMEOUT);
            sendBackupOnPackageResult(mObserver,pkgName,BackupManager.ERROR_AGENT_FAILURE);
            agentErrorCleanup();
            return;
          }
          in.skipEntityData();
        }
      }
  finally {
        if (readFd != null) {
          readFd.close();
        }
      }
    }
    writeWidgetPayloadIfAppropriate(fd,pkgName);
  }
 catch (  IOException e) {
    Slog.w(TAG,"Unable to save widget state for " + pkgName);
    try {
      Os.ftruncate(fd,filepos);
    }
 catch (    ErrnoException ee) {
      Slog.w(TAG,"Unable to roll back!");
    }
  }
  if (MORE_DEBUG)   Slog.v(TAG,"operationComplete(): sending data to transport for " + pkgName);
  mBackupHandler.removeMessages(MSG_TIMEOUT);
  clearAgentState();
  addBackupTrace("operation complete");
  ParcelFileDescriptor backupData=null;
  mStatus=BackupTransport.TRANSPORT_OK;
  long size=0;
  try {
    size=mBackupDataName.length();
    if (size > 0) {
      if (mStatus == BackupTransport.TRANSPORT_OK) {
        backupData=ParcelFileDescriptor.open(mBackupDataName,ParcelFileDescriptor.MODE_READ_ONLY);
        addBackupTrace("sending data to transport");
        int flags=mUserInitiated ? BackupTransport.FLAG_USER_INITIATED : 0;
        mStatus=mTransport.performBackup(mCurrentPackage,backupData,flags);
      }
      addBackupTrace("data delivered: " + mStatus);
      if (mStatus == BackupTransport.TRANSPORT_OK) {
        addBackupTrace("finishing op on transport");
        mStatus=mTransport.finishBackup();
        addBackupTrace("finished: " + mStatus);
      }
 else       if (mStatus == BackupTransport.TRANSPORT_PACKAGE_REJECTED) {
        addBackupTrace("transport rejected package");
      }
    }
 else {
      if (MORE_DEBUG)       Slog.i(TAG,"no backup data written; not calling transport");
      addBackupTrace("no data to send");
    }
    if (mStatus == BackupTransport.TRANSPORT_OK) {
      mBackupDataName.delete();
      mNewStateName.renameTo(mSavedStateName);
      sendBackupOnPackageResult(mObserver,pkgName,BackupManager.SUCCESS);
      EventLog.writeEvent(EventLogTags.BACKUP_PACKAGE,pkgName,size);
      logBackupComplete(pkgName);
    }
 else     if (mStatus == BackupTransport.TRANSPORT_PACKAGE_REJECTED) {
      mBackupDataName.delete();
      mNewStateName.delete();
      sendBackupOnPackageResult(mObserver,pkgName,BackupManager.ERROR_TRANSPORT_PACKAGE_REJECTED);
      EventLogTags.writeBackupAgentFailure(pkgName,"Transport rejected");
    }
 else     if (mStatus == BackupTransport.TRANSPORT_QUOTA_EXCEEDED) {
      sendBackupOnPackageResult(mObserver,pkgName,BackupManager.ERROR_TRANSPORT_QUOTA_EXCEEDED);
      EventLog.writeEvent(EventLogTags.BACKUP_QUOTA_EXCEEDED,pkgName);
    }
 else {
      sendBackupOnPackageResult(mObserver,pkgName,BackupManager.ERROR_TRANSPORT_ABORTED);
      EventLog.writeEvent(EventLogTags.BACKUP_TRANSPORT_FAILURE,pkgName);
    }
  }
 catch (  Exception e) {
    sendBackupOnPackageResult(mObserver,pkgName,BackupManager.ERROR_TRANSPORT_ABORTED);
    Slog.e(TAG,"Transport error backing up " + pkgName,e);
    EventLog.writeEvent(EventLogTags.BACKUP_TRANSPORT_FAILURE,pkgName);
    mStatus=BackupTransport.TRANSPORT_ERROR;
  }
 finally {
    try {
      if (backupData != null)       backupData.close();
    }
 catch (    IOException e) {
    }
  }
  final BackupState nextState;
  if (mStatus == BackupTransport.TRANSPORT_OK || mStatus == BackupTransport.TRANSPORT_PACKAGE_REJECTED) {
    nextState=(mQueue.isEmpty()) ? BackupState.FINAL : BackupState.RUNNING_QUEUE;
  }
 else   if (mStatus == BackupTransport.TRANSPORT_QUOTA_EXCEEDED) {
    if (MORE_DEBUG) {
      Slog.d(TAG,"Package " + mCurrentPackage.packageName + " hit quota limit on k/v backup");
    }
    if (mAgentBinder != null) {
      try {
        long quota=mTransport.getBackupQuota(mCurrentPackage.packageName,false);
        mAgentBinder.doQuotaExceeded(size,quota);
      }
 catch (      RemoteException e) {
        Slog.e(TAG,"Unable to contact backup agent for quota exceeded");
      }
    }
    nextState=(mQueue.isEmpty()) ? BackupState.FINAL : BackupState.RUNNING_QUEUE;
  }
 else {
    revertAndEndBackup();
    nextState=BackupState.FINAL;
  }
  executeNextState(nextState);
}
