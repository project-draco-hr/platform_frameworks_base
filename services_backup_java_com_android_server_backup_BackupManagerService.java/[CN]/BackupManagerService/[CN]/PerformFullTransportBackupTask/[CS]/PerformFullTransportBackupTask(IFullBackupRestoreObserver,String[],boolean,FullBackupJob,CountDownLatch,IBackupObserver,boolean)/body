{
  super(observer);
  mUpdateSchedule=updateSchedule;
  mLatch=latch;
  mKeepRunning=new AtomicBoolean(true);
  mJob=runningJob;
  mPackages=new ArrayList<PackageInfo>(whichPackages.length);
  mBackupObserver=backupObserver;
  mUserInitiated=userInitiated;
  for (  String pkg : whichPackages) {
    try {
      PackageInfo info=mPackageManager.getPackageInfo(pkg,PackageManager.GET_SIGNATURES);
      if ((info.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_BACKUP) == 0 || pkg.equals(SHARED_BACKUP_AGENT_PACKAGE)) {
        if (MORE_DEBUG) {
          Slog.d(TAG,"Ignoring opted-out package " + pkg);
        }
        sendBackupOnResult(mBackupObserver,pkg,BackupManager.ERROR_BACKUP_NOT_ALLOWED);
        continue;
      }
 else       if ((info.applicationInfo.uid < Process.FIRST_APPLICATION_UID) && (info.applicationInfo.backupAgentName == null)) {
        if (MORE_DEBUG) {
          Slog.d(TAG,"Ignoring non-agent system package " + pkg);
        }
        sendBackupOnResult(mBackupObserver,pkg,BackupManager.ERROR_BACKUP_NOT_ALLOWED);
        continue;
      }
 else       if ((info.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) != 0) {
        if (MORE_DEBUG) {
          Slog.d(TAG,"Ignoring stopped package " + pkg);
        }
        sendBackupOnResult(mBackupObserver,pkg,BackupManager.ERROR_BACKUP_NOT_ALLOWED);
        continue;
      }
      mPackages.add(info);
    }
 catch (    NameNotFoundException e) {
      Slog.i(TAG,"Requested package " + pkg + " not found; ignoring");
    }
  }
}
