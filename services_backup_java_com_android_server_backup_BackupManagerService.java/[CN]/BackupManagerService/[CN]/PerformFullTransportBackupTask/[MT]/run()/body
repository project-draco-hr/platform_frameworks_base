{
  ParcelFileDescriptor[] enginePipes=null;
  ParcelFileDescriptor[] transportPipes=null;
  PackageInfo currentPackage;
  long backoff=0;
  try {
    if (!mEnabled || !mProvisioned) {
      if (DEBUG) {
        Slog.i(TAG,"full backup requested but e=" + mEnabled + " p="+ mProvisioned+ "; ignoring");
      }
      mUpdateSchedule=false;
      sendBackupFinished(mBackupObserver,BackupManager.ERROR_BACKUP_NOT_ALLOWED);
      return;
    }
    IBackupTransport transport=getTransport(mCurrentTransport);
    if (transport == null) {
      Slog.w(TAG,"Transport not present; full data backup not performed");
      sendBackupFinished(mBackupObserver,BackupManager.ERROR_TRANSPORT_ABORTED);
      return;
    }
    final int N=mPackages.size();
    final byte[] buffer=new byte[8192];
    for (int i=0; i < N; i++) {
      currentPackage=mPackages.get(i);
      if (DEBUG) {
        Slog.i(TAG,"Initiating full-data transport backup of " + currentPackage.packageName);
      }
      EventLog.writeEvent(EventLogTags.FULL_BACKUP_PACKAGE,currentPackage.packageName);
      transportPipes=ParcelFileDescriptor.createPipe();
      int flags=mUserInitiated ? BackupTransport.FLAG_USER_INITIATED : 0;
      int result=transport.performFullBackup(currentPackage,transportPipes[0],flags);
      if (result == BackupTransport.TRANSPORT_OK) {
        transportPipes[0].close();
        transportPipes[0]=null;
        enginePipes=ParcelFileDescriptor.createPipe();
        CountDownLatch runnerLatch=new CountDownLatch(1);
        SinglePackageBackupRunner backupRunner=new SinglePackageBackupRunner(enginePipes[1],currentPackage,transport,runnerLatch);
        enginePipes[1].close();
        enginePipes[1]=null;
        (new Thread(backupRunner,"package-backup-bridge")).start();
        FileInputStream in=new FileInputStream(enginePipes[0].getFileDescriptor());
        FileOutputStream out=new FileOutputStream(transportPipes[1].getFileDescriptor());
        long totalRead=0;
        final long expectedSize=backupRunner.expectedSize();
        if (expectedSize < 0) {
          result=BackupTransport.AGENT_ERROR;
          sendBackupOnResult(mBackupObserver,currentPackage.packageName,BackupManager.ERROR_AGENT_FAILURE);
        }
        int nRead=0;
        do {
          if (!mKeepRunning.get()) {
            if (DEBUG_SCHEDULING) {
              Slog.i(TAG,"Full backup task told to stop");
            }
            break;
          }
          nRead=in.read(buffer);
          if (MORE_DEBUG) {
            Slog.v(TAG,"in.read(buffer) from app: " + nRead);
          }
          if (nRead > 0) {
            out.write(buffer,0,nRead);
            result=transport.sendBackupData(nRead);
            totalRead+=nRead;
            if (mBackupObserver != null && expectedSize > 0) {
              sendBackupOnUpdate(mBackupObserver,currentPackage.packageName,new BackupProgress(expectedSize,totalRead));
            }
          }
        }
 while (nRead > 0 && result == BackupTransport.TRANSPORT_OK);
        if (result == BackupTransport.TRANSPORT_QUOTA_EXCEEDED) {
          long quota=transport.getBackupQuota(currentPackage.packageName,true);
          if (MORE_DEBUG) {
            Slog.d(TAG,"Package hit quota limit " + currentPackage.packageName + ": "+ totalRead+ " of "+ quota);
          }
          backupRunner.sendQuotaExceeded(totalRead,quota);
        }
        if (!mKeepRunning.get()) {
          result=BackupTransport.TRANSPORT_ERROR;
          transport.cancelFullBackup();
        }
 else {
          final int finishResult=transport.finishBackup();
          if (result == BackupTransport.TRANSPORT_OK) {
            result=finishResult;
          }
        }
        if (MORE_DEBUG) {
          Slog.i(TAG,"Done trying to send backup data: result=" + result);
        }
        if (result != BackupTransport.TRANSPORT_OK) {
          Slog.e(TAG,"Error " + result + " backing up "+ currentPackage.packageName);
        }
        backoff=transport.requestFullBackupTime();
        if (DEBUG_SCHEDULING) {
          Slog.i(TAG,"Transport suggested backoff=" + backoff);
        }
      }
      if (mUpdateSchedule) {
        enqueueFullBackup(currentPackage.packageName,System.currentTimeMillis());
      }
      if (result == BackupTransport.TRANSPORT_PACKAGE_REJECTED) {
        sendBackupOnResult(mBackupObserver,currentPackage.packageName,BackupManager.ERROR_TRANSPORT_PACKAGE_REJECTED);
        if (DEBUG) {
          Slog.i(TAG,"Transport rejected backup of " + currentPackage.packageName + ", skipping");
        }
        EventLog.writeEvent(EventLogTags.FULL_BACKUP_AGENT_FAILURE,currentPackage.packageName,"transport rejected");
      }
 else       if (result == BackupTransport.TRANSPORT_QUOTA_EXCEEDED) {
        sendBackupOnResult(mBackupObserver,currentPackage.packageName,BackupManager.ERROR_TRANSPORT_QUOTA_EXCEEDED);
        Slog.w(TAG,"Transport quota exceeded; aborting backup: " + result);
        EventLog.writeEvent(EventLogTags.FULL_BACKUP_QUOTA_EXCEEDED,currentPackage.packageName);
        return;
      }
 else       if (result != BackupTransport.TRANSPORT_OK) {
        sendBackupOnResult(mBackupObserver,currentPackage.packageName,BackupManager.ERROR_TRANSPORT_ABORTED);
        Slog.w(TAG,"Transport failed; aborting backup: " + result);
        EventLog.writeEvent(EventLogTags.FULL_BACKUP_TRANSPORT_FAILURE);
        return;
      }
 else {
        sendBackupOnResult(mBackupObserver,currentPackage.packageName,BackupManager.SUCCESS);
        EventLog.writeEvent(EventLogTags.FULL_BACKUP_SUCCESS,currentPackage.packageName);
        logBackupComplete(currentPackage.packageName);
      }
      cleanUpPipes(transportPipes);
      cleanUpPipes(enginePipes);
      currentPackage=null;
    }
    sendBackupFinished(mBackupObserver,BackupManager.SUCCESS);
    if (DEBUG) {
      Slog.i(TAG,"Full backup completed.");
    }
  }
 catch (  Exception e) {
    sendBackupFinished(mBackupObserver,BackupManager.ERROR_TRANSPORT_ABORTED);
    Slog.w(TAG,"Exception trying full transport backup",e);
  }
 finally {
    cleanUpPipes(transportPipes);
    cleanUpPipes(enginePipes);
    if (mJob != null) {
      mJob.finishBackupPass();
    }
synchronized (mQueueLock) {
      mRunningFullBackupTask=null;
    }
    mLatch.countDown();
    if (mUpdateSchedule) {
      scheduleNextFullBackupJob(backoff);
    }
    Slog.i(BackupManagerService.TAG,"Full data backup pass finished.");
    mWakelock.release();
  }
}
