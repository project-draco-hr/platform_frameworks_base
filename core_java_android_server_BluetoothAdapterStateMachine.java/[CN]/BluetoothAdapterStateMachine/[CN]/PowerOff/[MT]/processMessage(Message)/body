{
  log("PowerOff process message: " + message.what);
  boolean retValue=HANDLED;
switch (message.what) {
case USER_TURN_ON:
    transitionTo(mWarmUp);
  broadcastState(BluetoothAdapter.STATE_TURNING_ON);
if (prepareBluetooth()) {
  if ((Boolean)message.obj) {
    persistSwitchSetting(true);
  }
  deferMessage(obtainMessage(TURN_ON_CONTINUE));
}
 else {
  Log.e(TAG,"failed to prepare bluetooth, abort turning on");
  transitionTo(mPowerOff);
  broadcastState(BluetoothAdapter.STATE_OFF);
}
break;
case TURN_HOT:
if (prepareBluetooth()) {
transitionTo(mWarmUp);
}
break;
case AIRPLANE_MODE_OFF:
if (getBluetoothPersistedSetting()) {
transitionTo(mWarmUp);
broadcastState(BluetoothAdapter.STATE_TURNING_ON);
if (prepareBluetooth()) {
deferMessage(obtainMessage(TURN_ON_CONTINUE));
transitionTo(mWarmUp);
}
 else {
Log.e(TAG,"failed to prepare bluetooth, abort turning on");
transitionTo(mPowerOff);
broadcastState(BluetoothAdapter.STATE_OFF);
}
}
 else if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
sendMessage(TURN_HOT);
}
break;
case PER_PROCESS_TURN_ON:
if (prepareBluetooth()) {
transitionTo(mWarmUp);
}
deferMessage(obtainMessage(PER_PROCESS_TURN_ON));
break;
case PER_PROCESS_TURN_OFF:
perProcessCallback(false,(IBluetoothStateChangeCallback)message.obj);
break;
case USER_TURN_OFF:
Log.w(TAG,"PowerOff received: " + message.what);
case AIRPLANE_MODE_ON:
break;
default :
return NOT_HANDLED;
}
return retValue;
}
