{
  log("HotOff process message: " + message.what);
  boolean retValue=HANDLED;
switch (message.what) {
case USER_TURN_ON:
    broadcastState(BluetoothAdapter.STATE_TURNING_ON);
  if ((Boolean)message.obj) {
    persistSwitchSetting(true);
  }
case TURN_ON_CONTINUE:
mBluetoothService.switchConnectable(true);
transitionTo(mSwitching);
break;
case AIRPLANE_MODE_ON:
case TURN_COLD:
shutoffBluetooth();
sendMessageDelayed(POWER_DOWN_TIMEOUT,POWER_DOWN_TIMEOUT_TIME);
break;
case POWER_DOWN_TIMEOUT:
transitionTo(mPowerOff);
if (!mDelayBroadcastStateOff) {
broadcastState(BluetoothAdapter.STATE_OFF);
}
break;
case AIRPLANE_MODE_OFF:
if (getBluetoothPersistedSetting()) {
broadcastState(BluetoothAdapter.STATE_TURNING_ON);
transitionTo(mSwitching);
mBluetoothService.switchConnectable(true);
}
break;
case PER_PROCESS_TURN_ON:
transitionTo(mPerProcessState);
deferMessage(message);
mBluetoothService.switchConnectable(true);
break;
case PER_PROCESS_TURN_OFF:
perProcessCallback(false,(IBluetoothStateChangeCallback)message.obj);
break;
case USER_TURN_OFF:
break;
case POWER_STATE_CHANGED:
if ((Boolean)message.obj) {
recoverStateMachine(TURN_HOT,null);
}
break;
case TURN_HOT:
deferMessage(message);
break;
default :
return NOT_HANDLED;
}
return retValue;
}
