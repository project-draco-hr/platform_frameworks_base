{
  log("Switching process message: " + message.what);
  boolean retValue=HANDLED;
switch (message.what) {
case SCAN_MODE_CHANGED:
    if (mPublicState == BluetoothAdapter.STATE_TURNING_ON) {
      mBluetoothService.setPairable();
      mBluetoothService.initBluetoothAfterTurningOn();
      transitionTo(mBluetoothOn);
      broadcastState(BluetoothAdapter.STATE_ON);
      mBluetoothService.runBluetooth();
    }
  break;
case POWER_STATE_CHANGED:
if (!((Boolean)message.obj)) {
  transitionTo(mHotOff);
  finishSwitchingOff();
}
break;
case ALL_DEVICES_DISCONNECTED:
removeMessages(DEVICES_DISCONNECT_TIMEOUT);
mBluetoothService.switchConnectable(false);
break;
case DEVICES_DISCONNECT_TIMEOUT:
sendMessage(ALL_DEVICES_DISCONNECTED);
Log.e(TAG,"Devices failed to disconnect, reseting...");
deferMessage(obtainMessage(TURN_COLD));
if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
deferMessage(obtainMessage(TURN_HOT));
}
break;
case USER_TURN_ON:
case AIRPLANE_MODE_OFF:
case AIRPLANE_MODE_ON:
case PER_PROCESS_TURN_ON:
case PER_PROCESS_TURN_OFF:
case USER_TURN_OFF:
deferMessage(message);
break;
default :
return NOT_HANDLED;
}
return retValue;
}
