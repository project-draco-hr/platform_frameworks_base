{
  if (DBG)   log("PerProcessState process message: " + message.what);
  boolean retValue=HANDLED;
switch (message.what) {
case PER_PROCESS_TURN_ON:
    mCallback=(IBluetoothStateChangeCallback)getCurrentMessage().obj;
  if (mBluetoothService.getNumberOfApplicationStateChangeTrackers() > 1) {
    perProcessCallback(true,mCallback);
  }
break;
case BECAME_PAIRABLE:
perProcessCallback(true,mCallback);
break;
case USER_TURN_ON:
broadcastState(BluetoothAdapter.STATE_TURNING_ON);
persistSwitchSetting(true);
mBluetoothService.initBluetoothAfterTurningOn();
transitionTo(mBluetoothOn);
broadcastState(BluetoothAdapter.STATE_ON);
mBluetoothService.runBluetooth();
break;
case USER_TURN_OFF:
broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
mBluetoothService.disconnectDevices();
break;
}
case ALL_DEVICES_DISCONNECTED:
mBluetoothService.finishDisable();
broadcastState(BluetoothAdapter.STATE_OFF);
break;
case PER_PROCESS_TURN_OFF:
perProcessCallback(false,(IBluetoothStateChangeCallback)message.obj);
if (mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
mBluetoothService.switchConnectable(false);
}
break;
case BECAME_NON_PAIRABLE:
transitionTo(mHotOff);
if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
deferMessage(obtainMessage(TURN_COLD));
}
break;
case AIRPLANE_MODE_ON:
mBluetoothService.switchConnectable(false);
allProcessesCallback(false);
deferMessage(obtainMessage(AIRPLANE_MODE_ON));
break;
default :
return NOT_HANDLED;
}
return retValue;
}
