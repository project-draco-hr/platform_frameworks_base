{
  log("PerProcessState process message: " + message.what);
  boolean retValue=HANDLED;
switch (message.what) {
case PER_PROCESS_TURN_ON:
    mCallback=(IBluetoothStateChangeCallback)getCurrentMessage().obj;
  if (mBluetoothService.getNumberOfApplicationStateChangeTrackers() > 1) {
    perProcessCallback(true,mCallback);
  }
break;
case SCAN_MODE_CHANGED:
if (isTurningOn) {
perProcessCallback(true,mCallback);
isTurningOn=false;
}
break;
case POWER_STATE_CHANGED:
removeMessages(POWER_DOWN_TIMEOUT);
if (!((Boolean)message.obj)) {
transitionTo(mHotOff);
deferMessage(obtainMessage(TURN_COLD));
if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
deferMessage(obtainMessage(TURN_HOT));
}
}
 else {
if (!isTurningOn) {
recoverStateMachine(TURN_COLD,null);
for (IBluetoothStateChangeCallback c : mBluetoothService.getApplicationStateChangeCallbacks()) {
perProcessCallback(false,c);
deferMessage(obtainMessage(PER_PROCESS_TURN_ON,c));
}
}
}
break;
case POWER_DOWN_TIMEOUT:
transitionTo(mHotOff);
Log.e(TAG,"Power-down timed out, resetting...");
deferMessage(obtainMessage(TURN_COLD));
if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_adapter_quick_switch)) {
deferMessage(obtainMessage(TURN_HOT));
}
break;
case USER_TURN_ON:
broadcastState(BluetoothAdapter.STATE_TURNING_ON);
persistSwitchSetting(true);
mBluetoothService.initBluetoothAfterTurningOn();
transitionTo(mBluetoothOn);
broadcastState(BluetoothAdapter.STATE_ON);
mBluetoothService.runBluetooth();
break;
case TURN_HOT:
broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
mBluetoothService.disconnectDevices();
sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT,DEVICES_DISCONNECT_TIMEOUT_TIME);
break;
}
case ALL_DEVICES_DISCONNECTED:
removeMessages(DEVICES_DISCONNECT_TIMEOUT);
finishSwitchingOff();
break;
case DEVICES_DISCONNECT_TIMEOUT:
finishSwitchingOff();
Log.e(TAG,"Devices fail to disconnect, reseting...");
transitionTo(mHotOff);
deferMessage(obtainMessage(TURN_COLD));
for (IBluetoothStateChangeCallback c : mBluetoothService.getApplicationStateChangeCallbacks()) {
perProcessCallback(false,c);
deferMessage(obtainMessage(PER_PROCESS_TURN_ON,c));
}
break;
case PER_PROCESS_TURN_OFF:
perProcessCallback(false,(IBluetoothStateChangeCallback)message.obj);
if (mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
mBluetoothService.switchConnectable(false);
sendMessageDelayed(POWER_DOWN_TIMEOUT,POWER_DOWN_TIMEOUT_TIME);
}
break;
case AIRPLANE_MODE_ON:
mBluetoothService.switchConnectable(false);
sendMessageDelayed(POWER_DOWN_TIMEOUT,POWER_DOWN_TIMEOUT_TIME);
allProcessesCallback(false);
deferMessage(obtainMessage(AIRPLANE_MODE_ON));
break;
case USER_TURN_OFF:
Log.w(TAG,"PerProcessState received: " + message.what);
break;
default :
return NOT_HANDLED;
}
return retValue;
}
