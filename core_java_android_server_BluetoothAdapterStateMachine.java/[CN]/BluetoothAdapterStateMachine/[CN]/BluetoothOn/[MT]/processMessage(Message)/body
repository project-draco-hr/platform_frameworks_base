{
  log("BluetoothOn process message: " + message.what);
  boolean retValue=HANDLED;
switch (message.what) {
case USER_TURN_OFF:
    if ((Boolean)message.obj) {
      persistSwitchSetting(false);
    }
  if (mBluetoothService.isDiscovering()) {
    mBluetoothService.cancelDiscovery();
  }
if (!mBluetoothService.isApplicationStateChangeTrackerEmpty()) {
  transitionTo(mPerProcessState);
  deferMessage(obtainMessage(TURN_HOT));
  break;
}
case AIRPLANE_MODE_ON:
broadcastState(BluetoothAdapter.STATE_TURNING_OFF);
transitionTo(mSwitching);
if (mBluetoothService.getAdapterConnectionState() != BluetoothAdapter.STATE_DISCONNECTED) {
mBluetoothService.disconnectDevices();
sendMessageDelayed(DEVICES_DISCONNECT_TIMEOUT,DEVICES_DISCONNECT_TIMEOUT_TIME);
}
 else {
mBluetoothService.switchConnectable(false);
sendMessageDelayed(TURN_OFF_TIMEOUT,TURN_OFF_TIMEOUT_TIME);
}
if (message.what == AIRPLANE_MODE_ON || mBluetoothService.isAirplaneModeOn()) {
allProcessesCallback(false);
deferMessage(obtainMessage(AIRPLANE_MODE_ON));
}
break;
case AIRPLANE_MODE_OFF:
case USER_TURN_ON:
Log.w(TAG,"BluetoothOn received: " + message.what);
break;
case PER_PROCESS_TURN_ON:
perProcessCallback(true,(IBluetoothStateChangeCallback)message.obj);
break;
case PER_PROCESS_TURN_OFF:
perProcessCallback(false,(IBluetoothStateChangeCallback)message.obj);
break;
case POWER_STATE_CHANGED:
if ((Boolean)message.obj) {
recoverStateMachine(USER_TURN_ON,false);
}
break;
default :
return NOT_HANDLED;
}
return retValue;
}
