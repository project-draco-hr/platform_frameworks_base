{
  if (!mHasEarlyConstraint && !mHasLateConstraint && !mRequiresCharging&& !mRequiresDeviceIdle&& mNetworkType == NETWORK_TYPE_NONE && mTriggerContentUris == null) {
    throw new IllegalArgumentException("You're trying to build a job with no " + "constraints, this is not allowed.");
  }
  mExtras=new PersistableBundle(mExtras);
  if (mIsPeriodic && (mMaxExecutionDelayMillis != 0L)) {
    throw new IllegalArgumentException("Can't call setOverrideDeadline() on a " + "periodic job.");
  }
  if (mIsPeriodic && (mMinLatencyMillis != 0L)) {
    throw new IllegalArgumentException("Can't call setMinimumLatency() on a " + "periodic job");
  }
  if (mIsPeriodic && (mTriggerContentUris != null)) {
    throw new IllegalArgumentException("Can't call addTriggerContentUri() on a " + "periodic job");
  }
  if (mIsPersisted && (mTriggerContentUris != null)) {
    throw new IllegalArgumentException("Can't call addTriggerContentUri() on a " + "persisted job");
  }
  if (mBackoffPolicySet && mRequiresDeviceIdle) {
    throw new IllegalArgumentException("An idle mode job will not respect any" + " back-off policy, so calling setBackoffCriteria with" + " setRequiresDeviceIdle is an error.");
  }
  JobInfo job=new JobInfo(this);
  if (job.isPeriodic()) {
    if (job.intervalMillis != job.getIntervalMillis()) {
      StringBuilder builder=new StringBuilder();
      builder.append("Specified interval for ").append(String.valueOf(mJobId)).append(" is ");
      formatDuration(mIntervalMillis,builder);
      builder.append(". Clamped to ");
      formatDuration(job.getIntervalMillis(),builder);
      Log.w(TAG,builder.toString());
    }
    if (job.flexMillis != job.getFlexMillis()) {
      StringBuilder builder=new StringBuilder();
      builder.append("Specified flex for ").append(String.valueOf(mJobId)).append(" is ");
      formatDuration(mFlexMillis,builder);
      builder.append(". Clamped to ");
      formatDuration(job.getFlexMillis(),builder);
      Log.w(TAG,builder.toString());
    }
  }
  return job;
}
