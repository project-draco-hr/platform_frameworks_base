{
  ContentValues paramMap=mCurrentPropNode.paramMap;
  String charsetString=paramMap.getAsString("CHARSET");
  boolean setupParamValues=false;
  if (paramMap.containsKey("ENCODING")) {
    String encoding=paramMap.getAsString("ENCODING");
    if (encoding.equalsIgnoreCase("BASE64") || encoding.equalsIgnoreCase("B")) {
      if (values.size() > 1) {
        Log.e(LOG_TAG,("BASE64 encoding is used while " + "there are multiple values (" + values.size()));
      }
      mCurrentPropNode.propValue_bytes=Base64.decodeBase64(values.get(0).replaceAll(" ","").replaceAll("\t","").replaceAll("\r\n","").getBytes());
    }
    if (encoding.equalsIgnoreCase("QUOTED-PRINTABLE")) {
      List<String> tmpValues=new ArrayList<String>();
      Vector<byte[]> byteVector=new Vector<byte[]>();
      int size=0;
      try {
        for (        String value : values) {
          String quotedPrintable=value.replaceAll("= "," ").replaceAll("=\t","\t");
          String[] lines;
          if (mStrictLineBreakParsing) {
            lines=quotedPrintable.split("\r\n");
          }
 else {
            lines=quotedPrintable.replace("\r\n","\n").replace("\r","\n").split("\n");
          }
          StringBuilder builder=new StringBuilder();
          for (          String line : lines) {
            if (line.endsWith("=")) {
              line=line.substring(0,line.length() - 1);
            }
            builder.append(line);
          }
          byte[] bytes=QuotedPrintableCodec.decodeQuotedPrintable(builder.toString().getBytes());
          if (charsetString != null) {
            try {
              tmpValues.add(new String(bytes,charsetString));
            }
 catch (            UnsupportedEncodingException e) {
              Log.e(LOG_TAG,"Failed to encode: charset=" + charsetString);
              tmpValues.add(new String(bytes));
            }
          }
 else {
            tmpValues.add(new String(bytes));
          }
          byteVector.add(bytes);
          size+=bytes.length;
        }
        mCurrentPropNode.propValue_vector=tmpValues;
        mCurrentPropNode.propValue=listToString(tmpValues);
        mCurrentPropNode.propValue_bytes=new byte[size];
{
          byte[] tmpBytes=mCurrentPropNode.propValue_bytes;
          int index=0;
          for (          byte[] bytes : byteVector) {
            int length=bytes.length;
            for (int i=0; i < length; i++, index++) {
              tmpBytes[index]=bytes[i];
            }
          }
        }
        setupParamValues=true;
      }
 catch (      Exception e) {
        Log.e(LOG_TAG,"Failed to decode quoted-printable: " + e);
      }
    }
  }
  if (!setupParamValues) {
    if (charsetString != null) {
      List<String> tmpValues=new ArrayList<String>();
      for (      String value : values) {
        String result=encodeString(value,charsetString);
        if (result != null) {
          tmpValues.add(result);
        }
 else {
          Log.e(LOG_TAG,"Failed to encode: charset=" + charsetString);
          tmpValues.add(value);
        }
      }
      values=tmpValues;
    }
    mCurrentPropNode.propValue_vector=values;
    mCurrentPropNode.propValue=listToString(values);
  }
  mCurrentVNode.propList.add(mCurrentPropNode);
}
