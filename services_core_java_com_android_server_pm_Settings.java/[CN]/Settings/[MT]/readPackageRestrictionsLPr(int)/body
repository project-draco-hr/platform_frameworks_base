{
  if (DEBUG_MU) {
    Log.i(TAG,"Reading package restrictions for user=" + userId);
  }
  FileInputStream str=null;
  File userPackagesStateFile=getUserPackagesStateFile(userId);
  File backupFile=getUserPackagesStateBackupFile(userId);
  if (backupFile.exists()) {
    try {
      str=new FileInputStream(backupFile);
      mReadMessages.append("Reading from backup stopped packages file\n");
      PackageManagerService.reportSettingsProblem(Log.INFO,"Need to read from backup stopped packages file");
      if (userPackagesStateFile.exists()) {
        Slog.w(PackageManagerService.TAG,"Cleaning up stopped packages file " + userPackagesStateFile);
        userPackagesStateFile.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  try {
    if (str == null) {
      if (!userPackagesStateFile.exists()) {
        mReadMessages.append("No stopped packages file found\n");
        PackageManagerService.reportSettingsProblem(Log.INFO,"No stopped packages file; " + "assuming all started");
        for (        PackageSetting pkg : mPackages.values()) {
          pkg.setUserState(userId,COMPONENT_ENABLED_STATE_DEFAULT,true,false,false,false,null,null,null,false);
        }
        return;
      }
      str=new FileInputStream(userPackagesStateFile);
    }
    final XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append("No start tag found in package restrictions file\n");
      PackageManagerService.reportSettingsProblem(Log.WARN,"No start tag found in package manager stopped packages");
      return;
    }
    int outerDepth=parser.getDepth();
    PackageSetting ps=null;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals(TAG_PACKAGE)) {
        String name=parser.getAttributeValue(null,ATTR_NAME);
        ps=mPackages.get(name);
        if (ps == null) {
          Slog.w(PackageManagerService.TAG,"No package known for stopped package: " + name);
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        final String enabledStr=parser.getAttributeValue(null,ATTR_ENABLED);
        final int enabled=enabledStr == null ? COMPONENT_ENABLED_STATE_DEFAULT : Integer.parseInt(enabledStr);
        final String enabledCaller=parser.getAttributeValue(null,ATTR_ENABLED_CALLER);
        final String installedStr=parser.getAttributeValue(null,ATTR_INSTALLED);
        final boolean installed=installedStr == null ? true : Boolean.parseBoolean(installedStr);
        final String stoppedStr=parser.getAttributeValue(null,ATTR_STOPPED);
        final boolean stopped=stoppedStr == null ? false : Boolean.parseBoolean(stoppedStr);
        final String blockedStr=parser.getAttributeValue(null,ATTR_BLOCKED);
        boolean hidden=blockedStr == null ? false : Boolean.parseBoolean(blockedStr);
        final String hiddenStr=parser.getAttributeValue(null,ATTR_HIDDEN);
        hidden=hiddenStr == null ? hidden : Boolean.parseBoolean(hiddenStr);
        final String notLaunchedStr=parser.getAttributeValue(null,ATTR_NOT_LAUNCHED);
        final boolean notLaunched=stoppedStr == null ? false : Boolean.parseBoolean(notLaunchedStr);
        final String blockUninstallStr=parser.getAttributeValue(null,ATTR_BLOCK_UNINSTALL);
        final boolean blockUninstall=blockUninstallStr == null ? false : Boolean.parseBoolean(blockUninstallStr);
        HashSet<String> enabledComponents=null;
        HashSet<String> disabledComponents=null;
        int packageDepth=parser.getDepth();
        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > packageDepth)) {
          if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
          }
          tagName=parser.getName();
          if (tagName.equals(TAG_ENABLED_COMPONENTS)) {
            enabledComponents=readComponentsLPr(parser);
          }
 else           if (tagName.equals(TAG_DISABLED_COMPONENTS)) {
            disabledComponents=readComponentsLPr(parser);
          }
        }
        ps.setUserState(userId,enabled,installed,stopped,notLaunched,hidden,enabledCaller,enabledComponents,disabledComponents,blockUninstall);
      }
 else       if (tagName.equals("preferred-activities")) {
        readPreferredActivitiesLPw(parser,userId);
      }
 else       if (tagName.equals(TAG_PERSISTENT_PREFERRED_ACTIVITIES)) {
        readPersistentPreferredActivitiesLPw(parser,userId);
      }
 else       if (tagName.equals(TAG_CROSS_PROFILE_INTENT_FILTERS)) {
        readCrossProfileIntentFiltersLPw(parser,userId);
      }
 else {
        Slog.w(PackageManagerService.TAG,"Unknown element under <stopped-packages>: " + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append("Error reading: " + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,"Error reading stopped packages: " + e);
    Log.wtf(PackageManagerService.TAG,"Error reading package manager stopped packages",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append("Error reading: " + e.toString());
    PackageManagerService.reportSettingsProblem(Log.ERROR,"Error reading settings: " + e);
    Log.wtf(PackageManagerService.TAG,"Error reading package manager stopped packages",e);
  }
}
