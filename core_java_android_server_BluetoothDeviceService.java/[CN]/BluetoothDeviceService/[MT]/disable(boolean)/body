{
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,"Need BLUETOOTH_ADMIN permission");
  if (mEnableThread != null && mEnableThread.isAlive()) {
    return false;
  }
  if (!mIsEnabled) {
    return true;
  }
  mEventLoop.stop();
  disableNative();
  for (  String address : mBondState.listInState(BluetoothDevice.BOND_BONDING)) {
    mBondState.setBondState(address,BluetoothDevice.BOND_NOT_BONDED,BluetoothDevice.UNBOND_REASON_AUTH_CANCELED);
  }
  HashMap<String,IBluetoothDeviceCallback> callbacksMap=mEventLoop.getRemoteServiceChannelCallbacks();
  IBluetoothDeviceCallback callback;
  for (  String address : callbacksMap.keySet()) {
    callback=callbacksMap.get(address);
    try {
      callback.onGetRemoteServiceChannelResult(address,BluetoothError.ERROR_DISABLED);
    }
 catch (    RemoteException e) {
    }
    callbacksMap.remove(address);
  }
  Intent intent=new Intent(BluetoothIntent.SCAN_MODE_CHANGED_ACTION);
  intent.putExtra(BluetoothIntent.SCAN_MODE,BluetoothDevice.SCAN_MODE_NONE);
  mContext.sendBroadcast(intent,BLUETOOTH_PERM);
  mIsEnabled=false;
  if (saveSetting) {
    persistBluetoothOnSetting(false);
  }
  mIsDiscovering=false;
  intent=new Intent(BluetoothIntent.DISABLED_ACTION);
  mContext.sendBroadcast(intent,BLUETOOTH_PERM);
  return true;
}
