{
  initGL();
  FloatBuffer triangleVertices=ByteBuffer.allocateDirect(mTriangleVerticesData.length * FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();
  triangleVertices.put(mTriangleVerticesData).position(0);
  int texture=loadTexture(R.drawable.large_photo);
  int program=buildProgram(sSimpleVS,sSimpleFS);
  int attribPosition=glGetAttribLocation(program,"position");
  checkGlError();
  int attribTexCoords=glGetAttribLocation(program,"texCoords");
  checkGlError();
  int uniformTexture=glGetUniformLocation(program,"texture");
  checkGlError();
  glBindTexture(GL_TEXTURE_2D,texture);
  checkGlError();
  glUseProgram(program);
  checkGlError();
  glEnableVertexAttribArray(attribPosition);
  checkGlError();
  glEnableVertexAttribArray(attribTexCoords);
  checkGlError();
  glUniform1i(texture,0);
  checkGlError();
  while (!mFinished) {
    checkCurrent();
    Log.d(LOG_TAG,"Rendering frame");
    glClearColor(0.0f,0.0f,0.0f,0.0f);
    checkGlError();
    glClear(GL_COLOR_BUFFER_BIT);
    checkGlError();
    triangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);
    glVertexAttribPointer(attribPosition,3,GL_FLOAT,false,TRIANGLE_VERTICES_DATA_STRIDE_BYTES,triangleVertices);
    triangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);
    glVertexAttribPointer(attribTexCoords,3,GL_FLOAT,false,TRIANGLE_VERTICES_DATA_STRIDE_BYTES,triangleVertices);
    glDrawArrays(GL_TRIANGLE_STRIP,0,4);
    if (!mEgl.eglSwapBuffers(mEglDisplay,mEglSurface)) {
      throw new RuntimeException("Cannot swap buffers");
    }
    checkEglError();
    try {
      Thread.sleep(20);
    }
 catch (    InterruptedException e) {
    }
  }
  finishGL();
}
