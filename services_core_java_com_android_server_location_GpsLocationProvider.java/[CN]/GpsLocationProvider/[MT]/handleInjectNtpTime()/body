{
  if (mInjectNtpTimePending == STATE_DOWNLOADING) {
    return;
  }
  if (!mNetworkAvailable) {
    mInjectNtpTimePending=STATE_PENDING_NETWORK;
    return;
  }
  mInjectNtpTimePending=STATE_DOWNLOADING;
  mWakeLock.acquire();
  AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable(){
    @Override public void run(){
      long delay;
      if (mNtpTime.getCacheAge() >= NTP_INTERVAL) {
        mNtpTime.forceRefresh();
      }
      if (mNtpTime.getCacheAge() < NTP_INTERVAL) {
        long time=mNtpTime.getCachedNtpTime();
        long timeReference=mNtpTime.getCachedNtpTimeReference();
        long certainty=mNtpTime.getCacheCertainty();
        long now=System.currentTimeMillis();
        Log.d(TAG,"NTP server returned: " + time + " ("+ new Date(time)+ ") reference: "+ timeReference+ " certainty: "+ certainty+ " system time offset: "+ (time - now));
        native_inject_time(time,timeReference,(int)certainty);
        delay=NTP_INTERVAL;
      }
 else {
        if (DEBUG)         Log.d(TAG,"requestTime failed");
        delay=RETRY_INTERVAL;
      }
      sendMessage(INJECT_NTP_TIME_FINISHED,0,null);
      if (mPeriodicTimeInjection) {
        mHandler.sendEmptyMessageDelayed(INJECT_NTP_TIME,delay);
      }
      mWakeLock.release();
    }
  }
);
}
