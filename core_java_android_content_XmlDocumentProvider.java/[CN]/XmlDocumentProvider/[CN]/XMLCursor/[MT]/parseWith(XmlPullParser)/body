{
  StringBuilder path=new StringBuilder();
  Stack<Integer> pathLengthStack=new Stack<Integer>();
  int currentNodeDepth=-1;
  int currentNodePathStartIndex=0;
  int eventType=parser.getEventType();
  while (eventType != XmlPullParser.END_DOCUMENT) {
    if (eventType == XmlPullParser.START_TAG) {
      pathLengthStack.push(path.length());
      path.append('/');
      String prefix=null;
      try {
        prefix=parser.getPrefix();
      }
 catch (      RuntimeException e) {
        prefix=null;
      }
      if (prefix != null) {
        path.append(prefix);
        path.append(':');
      }
      path.append(parser.getName());
      if (currentNodeDepth >= 0) {
        currentNodeDepth++;
      }
 else {
        if (mSelectionPattern.matcher(path.toString()).matches()) {
          currentNodeDepth=0;
          currentNodePathStartIndex=path.length();
          mCurrentValues[0]=Integer.toString(getCount());
          for (int i=0; i < mNumberOfProjections; i++) {
            mCurrentValues[i + 1]="";
            mActiveTextDepthMask[i].clear();
          }
        }
      }
      if (currentNodeDepth >= 0) {
        final String localNodePath=path.substring(currentNodePathStartIndex);
        for (int i=0; i < mNumberOfProjections; i++) {
          if (mProjectionPatterns[i].matcher(localNodePath).matches()) {
            String attribute=mAttributeNames[i];
            if (attribute != null) {
              mCurrentValues[i + 1]=parser.getAttributeValue(null,attribute);
            }
 else {
              mActiveTextDepthMask[i].set(currentNodeDepth,true);
            }
          }
        }
      }
    }
 else     if (eventType == XmlPullParser.END_TAG) {
      final int length=pathLengthStack.pop();
      path.setLength(length);
      if (currentNodeDepth >= 0) {
        if (currentNodeDepth == 0) {
          addRow(mCurrentValues);
        }
 else {
          for (int i=0; i < mNumberOfProjections; i++) {
            mActiveTextDepthMask[i].set(currentNodeDepth,false);
          }
        }
        currentNodeDepth--;
      }
    }
 else     if ((eventType == XmlPullParser.TEXT) && (!parser.isWhitespace())) {
      for (int i=0; i < mNumberOfProjections; i++) {
        if ((currentNodeDepth >= 0) && (mActiveTextDepthMask[i].get(currentNodeDepth))) {
          mCurrentValues[i + 1]+=parser.getText();
        }
      }
    }
    eventType=parser.next();
  }
}
