{
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
{
      final float x=event.getX();
      final float y=event.getY();
      mPreviousX=x;
      mPreviousY=y;
      mStrokeBuffer.add(new GesturePoint(x,y,event.getEventTime()));
    }
  break;
case MotionEvent.ACTION_MOVE:
{
  final float x=event.getX();
  final float y=event.getY();
  final float dX=Math.abs(x - mPreviousX);
  final float dY=Math.abs(y - mPreviousY);
  if (dX >= TOUCH_TOLERANCE || dY >= TOUCH_TOLERANCE) {
    mPreviousX=x;
    mPreviousY=y;
    mStrokeBuffer.add(new GesturePoint(x,y,event.getEventTime()));
  }
}
break;
case MotionEvent.ACTION_UP:
{
sendAccessibilityEvent(AccessibilityEvent.TYPE_GESTURE_DETECTION_END);
sendAccessibilityEvent(AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);
float x=event.getX();
float y=event.getY();
mStrokeBuffer.add(new GesturePoint(x,y,event.getEventTime()));
Gesture gesture=new Gesture();
gesture.addStroke(new GestureStroke(mStrokeBuffer));
ArrayList<Prediction> predictions=mGestureLibrary.recognize(gesture);
if (!predictions.isEmpty()) {
Prediction bestPrediction=predictions.get(0);
if (bestPrediction.score >= MIN_PREDICTION_SCORE) {
  if (DEBUG) {
    Slog.i(LOG_TAG,"gesture: " + bestPrediction.name + " score: "+ bestPrediction.score);
  }
  try {
    final int gestureId=Integer.parseInt(bestPrediction.name);
    mAms.onGesture(gestureId);
  }
 catch (  NumberFormatException nfe) {
    Slog.w(LOG_TAG,"Non numeric gesture id:" + bestPrediction.name);
  }
}
}
mStrokeBuffer.clear();
mExitGestureDetectionModeDelayed.remove();
mCurrentState=STATE_TOUCH_EXPLORING;
}
break;
case MotionEvent.ACTION_CANCEL:
{
clear(event,policyFlags);
}
break;
}
}
