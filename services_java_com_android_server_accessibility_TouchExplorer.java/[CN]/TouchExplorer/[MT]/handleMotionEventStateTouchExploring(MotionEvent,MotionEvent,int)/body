{
  ReceivedPointerTracker receivedTracker=mReceivedPointerTracker;
  final int activePointerCount=receivedTracker.getActivePointerCount();
  mVelocityTracker.addMovement(rawEvent);
  mDoubleTapDetector.onMotionEvent(event,policyFlags);
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mAms.onTouchInteractionStart();
  handleMotionEventGestureDetecting(rawEvent,policyFlags);
case MotionEvent.ACTION_POINTER_DOWN:
{
switch (activePointerCount) {
case 0:
{
      throw new IllegalStateException("The must always be one active pointer in" + "touch exploring state!");
    }
case 1:
{
    if (mSendHoverEnterDelayed.isPending()) {
      mSendHoverEnterDelayed.remove();
      mSendHoverExitDelayed.remove();
    }
    if (mSendTouchExplorationEndDelayed.isPending()) {
      mSendTouchExplorationEndDelayed.forceSendAndRemove();
    }
    if (mSendTouchInteractionEndDelayed.isPending()) {
      mSendTouchInteractionEndDelayed.forceSendAndRemove();
    }
    if (event.getPointerCount() == 1) {
      sendAccessibilityEvent(AccessibilityEvent.TYPE_TOUCH_INTERACTION_START);
    }
    mPerformLongPressDelayed.remove();
    if (mDoubleTapDetector.firstTapDetected()) {
      mPerformLongPressDelayed.post(event,policyFlags);
      break;
    }
    if (!mTouchExplorationInProgress) {
      final int pointerId=receivedTracker.getPrimaryActivePointerId();
      final int pointerIdBits=(1 << pointerId);
      mSendHoverEnterDelayed.post(event,true,pointerIdBits,policyFlags);
    }
  }
break;
default :
{
}
break;
}
}
break;
case MotionEvent.ACTION_MOVE:
{
final int pointerId=receivedTracker.getPrimaryActivePointerId();
final int pointerIndex=event.findPointerIndex(pointerId);
final int pointerIdBits=(1 << pointerId);
switch (activePointerCount) {
case 0:
{
}
break;
case 1:
{
if (mSendHoverEnterDelayed.isPending()) {
handleMotionEventGestureDetecting(rawEvent,policyFlags);
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - rawEvent.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - rawEvent.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mDoubleTapSlop) {
mVelocityTracker.computeCurrentVelocity(1000);
final float maxAbsVelocity=Math.max(Math.abs(mVelocityTracker.getXVelocity(pointerId)),Math.abs(mVelocityTracker.getYVelocity(pointerId)));
if (maxAbsVelocity > mScaledGestureDetectionVelocity) {
mCurrentState=STATE_GESTURE_DETECTING;
mVelocityTracker.clear();
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
mExitGestureDetectionModeDelayed.post();
sendAccessibilityEvent(AccessibilityEvent.TYPE_GESTURE_DETECTION_START);
}
 else {
mSendHoverEnterDelayed.forceSendAndRemove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
sendMotionEvent(event,MotionEvent.ACTION_HOVER_MOVE,pointerIdBits,policyFlags);
}
break;
}
}
 else {
if (mPerformLongPressDelayed.isPending()) {
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - rawEvent.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - rawEvent.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mTouchSlop) {
mPerformLongPressDelayed.remove();
}
}
if (mDoubleTapDetector.firstTapDetected()) {
break;
}
sendTouchExplorationGestureStartAndHoverEnterIfNeeded(policyFlags);
sendMotionEvent(event,MotionEvent.ACTION_HOVER_MOVE,pointerIdBits,policyFlags);
}
}
break;
case 2:
{
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mPerformLongPressDelayed.remove();
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - rawEvent.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - rawEvent.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta < mDoubleTapSlop) {
break;
}
sendHoverExitAndTouchExplorationGestureEndIfNeeded(policyFlags);
}
mStrokeBuffer.clear();
if (isDraggingGesture(event)) {
mCurrentState=STATE_DRAGGING;
mDraggingPointerId=pointerId;
sendMotionEvent(event,MotionEvent.ACTION_DOWN,pointerIdBits,policyFlags);
}
 else {
mCurrentState=STATE_DELEGATING;
sendDownForAllActiveNotInjectedPointers(event,policyFlags);
}
mVelocityTracker.clear();
}
break;
default :
{
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mPerformLongPressDelayed.remove();
sendHoverExitAndTouchExplorationGestureEndIfNeeded(policyFlags);
}
mCurrentState=STATE_DELEGATING;
sendDownForAllActiveNotInjectedPointers(event,policyFlags);
mVelocityTracker.clear();
}
}
}
break;
case MotionEvent.ACTION_UP:
mAms.onTouchInteractionEnd();
mStrokeBuffer.clear();
case MotionEvent.ACTION_POINTER_UP:
{
final int pointerId=receivedTracker.getLastReceivedUpPointerId();
final int pointerIdBits=(1 << pointerId);
switch (activePointerCount) {
case 0:
{
if (!receivedTracker.wasLastReceivedUpPointerActive()) {
break;
}
mPerformLongPressDelayed.remove();
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverExitDelayed.post(event,false,pointerIdBits,policyFlags);
}
 else {
sendHoverExitAndTouchExplorationGestureEndIfNeeded(policyFlags);
}
if (!mSendTouchInteractionEndDelayed.isPending()) {
mSendTouchInteractionEndDelayed.post();
}
}
break;
}
mVelocityTracker.clear();
}
break;
case MotionEvent.ACTION_CANCEL:
{
clear(event,policyFlags);
}
break;
}
}
