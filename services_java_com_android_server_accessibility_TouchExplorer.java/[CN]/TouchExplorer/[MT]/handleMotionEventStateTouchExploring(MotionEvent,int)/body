{
  ReceivedPointerTracker receivedTracker=mReceivedPointerTracker;
  final int activePointerCount=receivedTracker.getActivePointerCount();
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(event);
  mDoubleTapDetector.onMotionEvent(event,policyFlags);
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    handleMotionEventGestureDetecting(event,policyFlags);
case MotionEvent.ACTION_POINTER_DOWN:
{
switch (activePointerCount) {
case 0:
{
        throw new IllegalStateException("The must always be one active pointer in" + "touch exploring state!");
      }
case 1:
{
      if (mSendHoverEnterDelayed.isPending()) {
        mSendHoverEnterDelayed.remove();
        mSendHoverExitDelayed.remove();
      }
      mPerformLongPressDelayed.remove();
      if (mDoubleTapDetector.firstTapDetected()) {
        mPerformLongPressDelayed.post(event,policyFlags);
        break;
      }
      final int pointerId=receivedTracker.getPrimaryActivePointerId();
      final int pointerIdBits=(1 << pointerId);
      mSendHoverEnterDelayed.post(event,pointerIdBits,policyFlags);
    }
  break;
default :
{
}
break;
}
}
break;
case MotionEvent.ACTION_MOVE:
{
final int pointerId=receivedTracker.getPrimaryActivePointerId();
final int pointerIndex=event.findPointerIndex(pointerId);
final int pointerIdBits=(1 << pointerId);
switch (activePointerCount) {
case 0:
{
}
break;
case 1:
{
if (mSendHoverEnterDelayed.isPending()) {
handleMotionEventGestureDetecting(event,policyFlags);
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - event.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - event.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mDoubleTapSlop) {
mVelocityTracker.computeCurrentVelocity(1000);
final float maxAbsVelocity=Math.max(Math.abs(mVelocityTracker.getXVelocity(pointerId)),Math.abs(mVelocityTracker.getYVelocity(pointerId)));
if (maxAbsVelocity > mScaledGestureDetectionVelocity) {
mCurrentState=STATE_GESTURE_DETECTING;
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mSendHoverEnterDelayed.forceSendAndRemove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
sendMotionEvent(event,MotionEvent.ACTION_HOVER_MOVE,pointerIdBits,policyFlags);
}
break;
}
}
 else {
if (mDoubleTapDetector.firstTapDetected()) {
break;
}
sendEnterEventsIfNeeded(policyFlags);
sendMotionEvent(event,MotionEvent.ACTION_HOVER_MOVE,pointerIdBits,policyFlags);
}
}
break;
case 2:
{
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mPerformLongPressDelayed.remove();
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - event.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - event.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta < mDoubleTapSlop) {
break;
}
sendExitEventsIfNeeded(policyFlags);
}
mStrokeBuffer.clear();
if (isDraggingGesture(event)) {
mCurrentState=STATE_DRAGGING;
mDraggingPointerId=pointerId;
sendMotionEvent(event,MotionEvent.ACTION_DOWN,pointerIdBits,policyFlags);
}
 else {
mCurrentState=STATE_DELEGATING;
sendDownForAllActiveNotInjectedPointers(event,policyFlags);
}
}
break;
default :
{
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mPerformLongPressDelayed.remove();
sendExitEventsIfNeeded(policyFlags);
}
mCurrentState=STATE_DELEGATING;
sendDownForAllActiveNotInjectedPointers(event,policyFlags);
}
}
}
break;
case MotionEvent.ACTION_UP:
mStrokeBuffer.clear();
case MotionEvent.ACTION_POINTER_UP:
{
final int pointerId=receivedTracker.getLastReceivedUpPointerId();
final int pointerIdBits=(1 << pointerId);
switch (activePointerCount) {
case 0:
{
if (!receivedTracker.wasLastReceivedUpPointerActive()) {
break;
}
mPerformLongPressDelayed.remove();
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverExitDelayed.post(event,pointerIdBits,policyFlags);
}
 else {
sendExitEventsIfNeeded(policyFlags);
}
}
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.clear();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
{
clear(event,policyFlags);
}
break;
}
}
