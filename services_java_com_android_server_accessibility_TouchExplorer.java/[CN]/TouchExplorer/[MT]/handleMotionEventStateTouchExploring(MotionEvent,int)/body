{
  ReceivedPointerTracker receivedTracker=mReceivedPointerTracker;
  final int activePointerCount=receivedTracker.getActivePointerCount();
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(event);
  mDoubleTapDetector.onMotionEvent(event,policyFlags);
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    if (mSendHoverEnterDelayed.isPending()) {
      sendAccessibilityEvent(AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);
    }
  sendAccessibilityEvent(AccessibilityEvent.TYPE_TOUCH_INTERACTION_START);
handleMotionEventGestureDetecting(event,policyFlags);
case MotionEvent.ACTION_POINTER_DOWN:
{
switch (activePointerCount) {
case 0:
{
    throw new IllegalStateException("The must always be one active pointer in" + "touch exploring state!");
  }
case 1:
{
  if (mSendHoverEnterDelayed.isPending()) {
    mSendHoverEnterDelayed.remove();
    mSendHoverExitDelayed.remove();
  }
  if (mSendInteractionEndEventsDelayed.isPending()) {
    mSendInteractionEndEventsDelayed.forceSendAndRemove();
  }
  mPerformLongPressDelayed.remove();
  if (mDoubleTapDetector.firstTapDetected()) {
    mPerformLongPressDelayed.post(event,policyFlags);
    break;
  }
  final int pointerId=receivedTracker.getPrimaryActivePointerId();
  final int pointerIdBits=(1 << pointerId);
  mSendHoverEnterDelayed.post(event,true,pointerIdBits,policyFlags);
}
break;
default :
{
}
break;
}
}
break;
case MotionEvent.ACTION_MOVE:
{
final int pointerId=receivedTracker.getPrimaryActivePointerId();
final int pointerIndex=event.findPointerIndex(pointerId);
final int pointerIdBits=(1 << pointerId);
switch (activePointerCount) {
case 0:
{
}
break;
case 1:
{
if (mSendHoverEnterDelayed.isPending()) {
handleMotionEventGestureDetecting(event,policyFlags);
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - event.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - event.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mDoubleTapSlop) {
mVelocityTracker.computeCurrentVelocity(1000);
final float maxAbsVelocity=Math.max(Math.abs(mVelocityTracker.getXVelocity(pointerId)),Math.abs(mVelocityTracker.getYVelocity(pointerId)));
if (maxAbsVelocity > mScaledGestureDetectionVelocity) {
mCurrentState=STATE_GESTURE_DETECTING;
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
mExitGestureDetectionModeDelayed.post();
sendAccessibilityEvent(AccessibilityEvent.TYPE_GESTURE_DETECTION_START);
}
 else {
mSendHoverEnterDelayed.forceSendAndRemove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
sendMotionEvent(event,MotionEvent.ACTION_HOVER_MOVE,pointerIdBits,policyFlags);
}
break;
}
}
 else {
if (mDoubleTapDetector.firstTapDetected()) {
break;
}
sendEnterEventsIfNeeded(policyFlags);
sendMotionEvent(event,MotionEvent.ACTION_HOVER_MOVE,pointerIdBits,policyFlags);
}
}
break;
case 2:
{
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mPerformLongPressDelayed.remove();
final float deltaX=receivedTracker.getReceivedPointerDownX(pointerId) - event.getX(pointerIndex);
final float deltaY=receivedTracker.getReceivedPointerDownY(pointerId) - event.getY(pointerIndex);
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta < mDoubleTapSlop) {
break;
}
sendExitEventsIfNeeded(policyFlags);
}
mStrokeBuffer.clear();
if (isDraggingGesture(event)) {
mCurrentState=STATE_DRAGGING;
mDraggingPointerId=pointerId;
sendMotionEvent(event,MotionEvent.ACTION_DOWN,pointerIdBits,policyFlags);
}
 else {
mCurrentState=STATE_DELEGATING;
sendDownForAllActiveNotInjectedPointers(event,policyFlags);
}
}
break;
default :
{
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.remove();
mSendHoverExitDelayed.remove();
mPerformLongPressDelayed.remove();
}
 else {
mPerformLongPressDelayed.remove();
sendExitEventsIfNeeded(policyFlags);
}
mCurrentState=STATE_DELEGATING;
sendDownForAllActiveNotInjectedPointers(event,policyFlags);
}
}
}
break;
case MotionEvent.ACTION_UP:
mStrokeBuffer.clear();
case MotionEvent.ACTION_POINTER_UP:
{
final int pointerId=receivedTracker.getLastReceivedUpPointerId();
final int pointerIdBits=(1 << pointerId);
switch (activePointerCount) {
case 0:
{
if (!receivedTracker.wasLastReceivedUpPointerActive()) {
break;
}
mPerformLongPressDelayed.remove();
if (mSendHoverEnterDelayed.isPending()) {
mSendHoverEnterDelayed.mTouchExplorationInProgress=false;
mSendHoverExitDelayed.post(event,false,pointerIdBits,policyFlags);
}
 else {
sendExitEventsIfNeeded(policyFlags);
}
}
break;
}
if (mVelocityTracker != null) {
mVelocityTracker.clear();
mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_CANCEL:
{
clear(event,policyFlags);
}
break;
}
}
