{
  final float[] values=new float[3];
  final int[] status=new int[1];
  final long timestamp[]=new long[1];
  Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);
  if (mSensorDataFd == null) {
    Log.e(TAG,"mSensorDataFd == NULL, exiting");
    return;
  }
  sensors_data_open(mSensorDataFd.getFileDescriptor());
  try {
    mSensorDataFd.close();
  }
 catch (  IOException e) {
    Log.e(TAG,"IOException: ",e);
  }
  mSensorDataFd=null;
  while (true) {
    final int sensor=sensors_data_poll(values,status,timestamp);
    if (sensor == -1) {
      Log.d(TAG,"_sensors_data_poll() failed, we bail out.");
      break;
    }
    int accuracy=status[0];
synchronized (sListeners) {
      if (sListeners.isEmpty()) {
        sensors_data_close();
        mThread=null;
        break;
      }
      final Sensor sensorObject=sHandleToSensor.get(sensor);
      if (sensorObject != null) {
        final int size=sListeners.size();
        for (int i=0; i < size; i++) {
          ListenerDelegate listener=sListeners.get(i);
          if (listener.hasSensor(sensorObject)) {
            listener.onSensorChangedLocked(sensorObject,values,timestamp,accuracy);
          }
        }
      }
    }
  }
}
