{
  final float[] values=new float[3];
  final int[] status=new int[1];
  final long timestamp[]=new long[1];
  Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
  if (!open()) {
    return;
  }
synchronized (this) {
    mSensorsReady=true;
    this.notify();
  }
  while (true) {
    final int sensor=sensors_data_poll(sQueue,values,status,timestamp);
    int accuracy=status[0];
synchronized (sListeners) {
      if (sensor == -1 || sListeners.isEmpty()) {
        if (sensor == -1 && !sListeners.isEmpty()) {
          Log.e(TAG,"_sensors_data_poll() failed, we bail out: sensors=" + sensor);
        }
        sensors_destroy_queue(sQueue);
        sQueue=0;
        mThread=null;
        break;
      }
      final Sensor sensorObject=sHandleToSensor.get(sensor);
      if (sensorObject != null) {
        final int size=sListeners.size();
        for (int i=0; i < size; i++) {
          ListenerDelegate listener=sListeners.get(i);
          if (listener.hasSensor(sensorObject)) {
            listener.onSensorChangedLocked(sensorObject,values,timestamp,accuracy);
          }
        }
      }
    }
  }
}
