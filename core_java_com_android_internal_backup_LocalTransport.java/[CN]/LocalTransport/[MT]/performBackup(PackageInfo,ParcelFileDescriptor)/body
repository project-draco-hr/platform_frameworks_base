{
  if (DEBUG) {
    try {
      StructStat ss=Os.fstat(data.getFileDescriptor());
      Log.v(TAG,"performBackup() pkg=" + packageInfo.packageName + " size="+ ss.st_size);
    }
 catch (    ErrnoException e) {
      Log.w(TAG,"Unable to stat input file in performBackup() on " + packageInfo.packageName);
    }
  }
  File packageDir=new File(mCurrentSetIncrementalDir,packageInfo.packageName);
  packageDir.mkdirs();
  BackupDataInput changeSet=new BackupDataInput(data.getFileDescriptor());
  try {
    int bufSize=512;
    byte[] buf=new byte[bufSize];
    while (changeSet.readNextHeader()) {
      String key=changeSet.getKey();
      String base64Key=new String(Base64.encode(key.getBytes()));
      File entityFile=new File(packageDir,base64Key);
      int dataSize=changeSet.getDataSize();
      if (DEBUG)       Log.v(TAG,"Got change set key=" + key + " size="+ dataSize+ " key64="+ base64Key);
      if (dataSize >= 0) {
        if (entityFile.exists()) {
          entityFile.delete();
        }
        FileOutputStream entity=new FileOutputStream(entityFile);
        if (dataSize > bufSize) {
          bufSize=dataSize;
          buf=new byte[bufSize];
        }
        changeSet.readEntityData(buf,0,dataSize);
        if (DEBUG) {
          try {
            long cur=Os.lseek(data.getFileDescriptor(),0,SEEK_CUR);
            Log.v(TAG,"  read entity data; new pos=" + cur);
          }
 catch (          ErrnoException e) {
            Log.w(TAG,"Unable to stat input file in performBackup() on " + packageInfo.packageName);
          }
        }
        try {
          entity.write(buf,0,dataSize);
        }
 catch (        IOException e) {
          Log.e(TAG,"Unable to update key file " + entityFile.getAbsolutePath());
          return TRANSPORT_ERROR;
        }
 finally {
          entity.close();
        }
      }
 else {
        entityFile.delete();
      }
    }
    return TRANSPORT_OK;
  }
 catch (  IOException e) {
    Log.v(TAG,"Exception reading backup input:",e);
    return TRANSPORT_ERROR;
  }
}
