{
  if (mRestorePackages == null)   throw new IllegalStateException("startRestore not called");
  if (mRestorePackage < 0)   throw new IllegalStateException("nextRestorePackage not called");
  if (mRestoreType != RestoreDescription.TYPE_KEY_VALUE) {
    throw new IllegalStateException("getRestoreData(fd) for non-key/value dataset");
  }
  File packageDir=new File(mRestoreSetDir,mRestorePackages[mRestorePackage].packageName);
  ArrayList<DecodedFilename> blobs=contentsByKey(packageDir);
  if (blobs == null) {
    Log.e(TAG,"No keys for package: " + packageDir);
    return BackupTransport.TRANSPORT_ERROR;
  }
  if (DEBUG)   Log.v(TAG,"  getRestoreData() found " + blobs.size() + " key files");
  BackupDataOutput out=new BackupDataOutput(outFd.getFileDescriptor());
  try {
    for (    DecodedFilename keyEntry : blobs) {
      File f=keyEntry.file;
      FileInputStream in=new FileInputStream(f);
      try {
        int size=(int)f.length();
        byte[] buf=new byte[size];
        in.read(buf);
        if (DEBUG)         Log.v(TAG,"    ... key=" + keyEntry.key + " size="+ size);
        out.writeEntityHeader(keyEntry.key,size);
        out.writeEntityData(buf,size);
      }
  finally {
        in.close();
      }
    }
    return BackupTransport.TRANSPORT_OK;
  }
 catch (  IOException e) {
    Log.e(TAG,"Unable to read backup records",e);
    return BackupTransport.TRANSPORT_ERROR;
  }
}
