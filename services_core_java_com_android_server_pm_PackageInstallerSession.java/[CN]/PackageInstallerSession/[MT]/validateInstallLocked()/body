{
  mPackageName=null;
  mVersionCode=-1;
  mSignatures=null;
  mResolvedBaseFile=null;
  mResolvedStagedFiles.clear();
  mResolvedInheritedFiles.clear();
  final File[] removedFiles=mResolvedStageDir.listFiles(sRemovedFilter);
  final List<String> removeSplitList=new ArrayList<>();
  if (!ArrayUtils.isEmpty(removedFiles)) {
    for (    File removedFile : removedFiles) {
      final String fileName=removedFile.getName();
      final String splitName=fileName.substring(0,fileName.length() - REMOVE_SPLIT_MARKER_EXTENSION.length());
      removeSplitList.add(splitName);
    }
  }
  final File[] addedFiles=mResolvedStageDir.listFiles(sAddedFilter);
  if (ArrayUtils.isEmpty(addedFiles) && removeSplitList.size() == 0) {
    throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"No packages staged");
  }
  final ArraySet<String> stagedSplits=new ArraySet<>();
  for (  File addedFile : addedFiles) {
    final ApkLite apk;
    try {
      apk=PackageParser.parseApkLite(addedFile,PackageParser.PARSE_COLLECT_CERTIFICATES);
    }
 catch (    PackageParserException e) {
      throw PackageManagerException.from(e);
    }
    if (!stagedSplits.add(apk.splitName)) {
      throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"Split " + apk.splitName + " was defined multiple times");
    }
    if (mPackageName == null) {
      mPackageName=apk.packageName;
      mVersionCode=apk.versionCode;
    }
    if (mSignatures == null) {
      mSignatures=apk.signatures;
    }
    assertApkConsistent(String.valueOf(addedFile),apk);
    final String targetName;
    if (apk.splitName == null) {
      targetName="base.apk";
    }
 else {
      targetName="split_" + apk.splitName + ".apk";
    }
    if (!FileUtils.isValidExtFilename(targetName)) {
      throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"Invalid filename: " + targetName);
    }
    final File targetFile=new File(mResolvedStageDir,targetName);
    if (!addedFile.equals(targetFile)) {
      addedFile.renameTo(targetFile);
    }
    if (apk.splitName == null) {
      mResolvedBaseFile=targetFile;
    }
    mResolvedStagedFiles.add(targetFile);
  }
  if (removeSplitList.size() > 0) {
    final int flags=mSignatures == null ? PackageManager.GET_SIGNATURES : 0;
    final PackageInfo pkg=mPm.getPackageInfo(params.appPackageName,flags,userId);
    for (    String splitName : removeSplitList) {
      if (!ArrayUtils.contains(pkg.splitNames,splitName)) {
        throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"Split not found: " + splitName);
      }
    }
    if (mPackageName == null) {
      mPackageName=pkg.packageName;
      mVersionCode=pkg.versionCode;
    }
    if (mSignatures == null) {
      mSignatures=pkg.signatures;
    }
  }
  if (params.mode == SessionParams.MODE_FULL_INSTALL) {
    if (!stagedSplits.contains(null)) {
      throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"Full install must include a base package");
    }
  }
 else {
    final ApplicationInfo app=mPm.getApplicationInfo(mPackageName,0,userId);
    if (app == null) {
      throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"Missing existing base package for " + mPackageName);
    }
    final PackageLite existing;
    final ApkLite existingBase;
    try {
      existing=PackageParser.parsePackageLite(new File(app.getCodePath()),0);
      existingBase=PackageParser.parseApkLite(new File(app.getBaseCodePath()),PackageParser.PARSE_COLLECT_CERTIFICATES);
    }
 catch (    PackageParserException e) {
      throw PackageManagerException.from(e);
    }
    assertApkConsistent("Existing base",existingBase);
    if (mResolvedBaseFile == null) {
      mResolvedBaseFile=new File(app.getBaseCodePath());
      mResolvedInheritedFiles.add(mResolvedBaseFile);
    }
    if (!ArrayUtils.isEmpty(existing.splitNames)) {
      for (int i=0; i < existing.splitNames.length; i++) {
        final String splitName=existing.splitNames[i];
        final File splitFile=new File(existing.splitCodePaths[i]);
        final boolean splitRemoved=removeSplitList.contains(splitName);
        if (!stagedSplits.contains(splitName) && !splitRemoved) {
          mResolvedInheritedFiles.add(splitFile);
        }
      }
    }
    final File packageInstallDir=(new File(app.getBaseCodePath())).getParentFile();
    mInheritedFilesBase=packageInstallDir;
    final File oatDir=new File(packageInstallDir,"oat");
    if (oatDir.exists()) {
      final File[] archSubdirs=oatDir.listFiles();
      if (archSubdirs != null && archSubdirs.length > 0) {
        final String[] instructionSets=InstructionSets.getAllDexCodeInstructionSets();
        for (        File archSubDir : archSubdirs) {
          if (!ArrayUtils.contains(instructionSets,archSubDir.getName())) {
            continue;
          }
          mResolvedInstructionSets.add(archSubDir.getName());
          List<File> oatFiles=Arrays.asList(archSubDir.listFiles());
          if (!oatFiles.isEmpty()) {
            mResolvedInheritedFiles.addAll(oatFiles);
          }
        }
      }
    }
  }
}
