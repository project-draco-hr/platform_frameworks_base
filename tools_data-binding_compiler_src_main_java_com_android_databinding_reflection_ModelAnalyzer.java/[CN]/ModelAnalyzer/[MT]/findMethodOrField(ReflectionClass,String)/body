{
  ModelClass modelClass=toModel(reflectionClass);
  for (  String methodName : new String[]{"get" + StringUtils.capitalize(name),"is" + StringUtils.capitalize(name),name}) {
    ReflectionMethod[] methods=reflectionClass.getMethods(methodName,0);
    for (    ReflectionMethod reflectionMethod : methods) {
      ModelMethod method=(ModelMethod)reflectionMethod;
      if (method.isPublic()) {
        final ModelField backingField=findField(modelClass,name,true);
        final Callable result=new Callable(Callable.Type.METHOD,methodName,method.getReturnType(null),true,isBindable(method) || (backingField != null && isBindable(backingField)));
        L.d("backing field for %s is %s",result,backingField);
        return result;
      }
    }
  }
  ModelField field=findField(modelClass,name,false);
  if (field != null && field.mField.getModifiers().contains(Modifier.PUBLIC)) {
    ModelClass fieldType=new ModelClass(field.mField.asType());
    return new Callable(Callable.Type.FIELD,name,fieldType,!field.mField.getModifiers().contains(Modifier.FINAL) || isObservable(fieldType),isBindable(field));
  }
  throw new IllegalArgumentException("cannot find " + name + " in "+ ((DeclaredType)modelClass.mTypeMirror).asElement().getSimpleName());
}
