{
  int chargingCount=0;
  int idleCount=0;
  int backoffCount=0;
  int connectivityCount=0;
  List<JobStatus> runnableJobs=null;
  ArraySet<JobStatus> jobs=mJobs.getJobs();
  for (int i=0; i < jobs.size(); i++) {
    JobStatus job=jobs.valueAt(i);
    if (isReadyToBeExecutedLocked(job)) {
      try {
        if (ActivityManagerNative.getDefault().getAppStartMode(job.getUid(),job.getJob().getService().getPackageName()) == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,"Aborting job " + job.getUid() + ":"+ job.getJob().toString()+ " -- package not allowed to start");
          mHandler.obtainMessage(MSG_STOP_JOB,job).sendToTarget();
          continue;
        }
      }
 catch (      RemoteException e) {
      }
      if (job.getNumFailures() > 0) {
        backoffCount++;
      }
      if (job.hasIdleConstraint()) {
        idleCount++;
      }
      if (job.hasConnectivityConstraint() || job.hasUnmeteredConstraint()) {
        connectivityCount++;
      }
      if (job.hasChargingConstraint()) {
        chargingCount++;
      }
      if (runnableJobs == null) {
        runnableJobs=new ArrayList<>();
      }
      runnableJobs.add(job);
    }
 else     if (isReadyToBeCancelledLocked(job)) {
      stopJobOnServiceContextLocked(job);
    }
  }
  if (backoffCount > 0 || idleCount >= MIN_IDLE_COUNT || connectivityCount >= MIN_CONNECTIVITY_COUNT || chargingCount >= MIN_CHARGING_COUNT || (runnableJobs != null && runnableJobs.size() >= MIN_READY_JOBS_COUNT)) {
    if (DEBUG) {
      Slog.d(TAG,"maybeQueueReadyJobsForExecutionLockedH: Running jobs.");
    }
    for (int i=0; i < runnableJobs.size(); i++) {
      mPendingJobs.add(runnableJobs.get(i));
    }
  }
 else {
    if (DEBUG) {
      Slog.d(TAG,"maybeQueueReadyJobsForExecutionLockedH: Not running anything.");
    }
  }
  reportActive();
  if (DEBUG) {
    Slog.d(TAG,"idle=" + idleCount + " connectivity="+ connectivityCount+ " charging="+ chargingCount+ " tot="+ runnableJobs.size());
  }
}
