{
  int chargingCount=0;
  int idleCount=0;
  int backoffCount=0;
  int connectivityCount=0;
  List<JobStatus> runnableJobs=new ArrayList<JobStatus>();
  ArraySet<JobStatus> jobs=mJobs.getJobs();
  for (int i=0; i < jobs.size(); i++) {
    JobStatus job=jobs.valueAt(i);
    if (isReadyToBeExecutedLocked(job)) {
      if (job.getNumFailures() > 0) {
        backoffCount++;
      }
      if (job.hasIdleConstraint()) {
        idleCount++;
      }
      if (job.hasConnectivityConstraint() || job.hasUnmeteredConstraint()) {
        connectivityCount++;
      }
      if (job.hasChargingConstraint()) {
        chargingCount++;
      }
      runnableJobs.add(job);
    }
 else     if (isReadyToBeCancelledLocked(job)) {
      stopJobOnServiceContextLocked(job);
    }
  }
  if (backoffCount > 0 || idleCount >= MIN_IDLE_COUNT || connectivityCount >= MIN_CONNECTIVITY_COUNT || chargingCount >= MIN_CHARGING_COUNT || runnableJobs.size() >= MIN_READY_JOBS_COUNT) {
    if (DEBUG) {
      Slog.d(TAG,"maybeQueueReadyJobsForExecutionLockedH: Running jobs.");
    }
    for (int i=0; i < runnableJobs.size(); i++) {
      mPendingJobs.add(runnableJobs.get(i));
    }
  }
 else {
    if (DEBUG) {
      Slog.d(TAG,"maybeQueueReadyJobsForExecutionLockedH: Not running anything.");
    }
  }
  if (DEBUG) {
    Slog.d(TAG,"idle=" + idleCount + " connectivity="+ connectivityCount+ " charging="+ chargingCount+ " tot="+ runnableJobs.size());
  }
}
