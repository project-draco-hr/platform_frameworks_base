{
  final long now=SystemClock.elapsedRealtime();
synchronized (mJobs) {
    pw.print("Started users: ");
    for (int i=0; i < mStartedUsers.size(); i++) {
      pw.print("u" + mStartedUsers.get(i) + " ");
    }
    pw.println();
    pw.println("Registered jobs:");
    if (mJobs.size() > 0) {
      ArraySet<JobStatus> jobs=mJobs.getJobs();
      for (int i=0; i < jobs.size(); i++) {
        JobStatus job=jobs.valueAt(i);
        pw.print("  Job #");
        pw.print(i);
        pw.print(": ");
        pw.println(job.toShortString());
        job.dump(pw,"    ");
        pw.print("    Ready: ");
        pw.print(mHandler.isReadyToBeExecutedLocked(job));
        pw.print(" (job=");
        pw.print(job.isReady());
        pw.print(" pending=");
        pw.print(mPendingJobs.contains(job));
        pw.print(" active=");
        pw.print(isCurrentlyActiveLocked(job));
        pw.print(" user=");
        pw.print(mStartedUsers.contains(job.getUserId()));
        pw.println(")");
      }
    }
 else {
      pw.println("  None.");
    }
    for (int i=0; i < mControllers.size(); i++) {
      pw.println();
      mControllers.get(i).dumpControllerState(pw);
    }
    pw.println();
    pw.println(printPendingQueue());
    pw.println();
    pw.println("Active jobs:");
    for (int i=0; i < mActiveServices.size(); i++) {
      JobServiceContext jsc=mActiveServices.get(i);
      if (jsc.getRunningJob() == null) {
        continue;
      }
 else {
        final long timeout=jsc.getTimeoutElapsed();
        pw.print("Running for: ");
        pw.print((now - jsc.getExecutionStartTimeElapsed()) / 1000);
        pw.print("s timeout=");
        pw.print(timeout);
        pw.print(" fromnow=");
        pw.println(timeout - now);
        jsc.getRunningJob().dump(pw,"  ");
      }
    }
    pw.println();
    pw.print("mReadyToRock=");
    pw.println(mReadyToRock);
    pw.print("mDeviceIdleMode=");
    pw.println(mDeviceIdleMode);
    pw.print("mReportedActive=");
    pw.println(mReportedActive);
  }
  pw.println();
}
