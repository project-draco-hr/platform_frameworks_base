{
  if (DEBUG) {
    Slog.d(TAG,printPendingQueue());
  }
  int memLevel;
  try {
    memLevel=ActivityManagerNative.getDefault().getMemoryTrimLevel();
  }
 catch (  RemoteException e) {
    memLevel=ProcessStats.ADJ_MEM_FACTOR_NORMAL;
  }
switch (memLevel) {
case ProcessStats.ADJ_MEM_FACTOR_MODERATE:
    mMaxActiveJobs=mConstants.BG_MODERATE_JOB_COUNT;
  break;
case ProcessStats.ADJ_MEM_FACTOR_LOW:
mMaxActiveJobs=mConstants.BG_LOW_JOB_COUNT;
break;
case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
mMaxActiveJobs=mConstants.BG_CRITICAL_JOB_COUNT;
break;
default :
mMaxActiveJobs=mConstants.BG_NORMAL_JOB_COUNT;
break;
}
JobStatus[] contextIdToJobMap=mTmpAssignContextIdToJobMap;
boolean[] act=mTmpAssignAct;
int[] preferredUidForContext=mTmpAssignPreferredUidForContext;
int numActive=0;
int numForeground=0;
for (int i=0; i < MAX_JOB_CONTEXTS_COUNT; i++) {
final JobServiceContext js=mActiveServices.get(i);
final JobStatus status=js.getRunningJob();
if ((contextIdToJobMap[i]=status) != null) {
numActive++;
if (status.lastEvaluatedPriority >= JobInfo.PRIORITY_TOP_APP) {
numForeground++;
}
}
act[i]=false;
preferredUidForContext[i]=js.getPreferredUid();
}
if (DEBUG) {
Slog.d(TAG,printContextIdToJobMap(contextIdToJobMap,"running jobs initial"));
}
for (int i=0; i < mPendingJobs.size(); i++) {
JobStatus nextPending=mPendingJobs.get(i);
int jobRunningContext=findJobContextIdFromMap(nextPending,contextIdToJobMap);
if (jobRunningContext != -1) {
continue;
}
final int priority=evaluateJobPriorityLocked(nextPending);
nextPending.lastEvaluatedPriority=priority;
int minPriority=Integer.MAX_VALUE;
int minPriorityContextId=-1;
for (int j=0; j < MAX_JOB_CONTEXTS_COUNT; j++) {
JobStatus job=contextIdToJobMap[j];
int preferredUid=preferredUidForContext[j];
if (job == null) {
if ((numActive < mMaxActiveJobs || (priority >= JobInfo.PRIORITY_TOP_APP && numForeground < mConstants.FG_JOB_COUNT)) && (preferredUid == nextPending.getUid() || preferredUid == JobServiceContext.NO_PREFERRED_UID)) {
minPriorityContextId=j;
break;
}
continue;
}
if (job.getUid() != nextPending.getUid()) {
continue;
}
if (evaluateJobPriorityLocked(job) >= nextPending.lastEvaluatedPriority) {
continue;
}
if (minPriority > nextPending.lastEvaluatedPriority) {
minPriority=nextPending.lastEvaluatedPriority;
minPriorityContextId=j;
}
}
if (minPriorityContextId != -1) {
contextIdToJobMap[minPriorityContextId]=nextPending;
act[minPriorityContextId]=true;
numActive++;
if (priority >= JobInfo.PRIORITY_TOP_APP) {
numForeground++;
}
}
}
if (DEBUG) {
Slog.d(TAG,printContextIdToJobMap(contextIdToJobMap,"running jobs final"));
}
mJobPackageTracker.noteConcurrency(numActive,numForeground);
for (int i=0; i < MAX_JOB_CONTEXTS_COUNT; i++) {
boolean preservePreferredUid=false;
if (act[i]) {
JobStatus js=mActiveServices.get(i).getRunningJob();
if (js != null) {
if (DEBUG) {
Slog.d(TAG,"preempting job: " + mActiveServices.get(i).getRunningJob());
}
mActiveServices.get(i).preemptExecutingJob();
preservePreferredUid=true;
}
 else {
final JobStatus pendingJob=contextIdToJobMap[i];
if (DEBUG) {
Slog.d(TAG,"About to run job on context " + String.valueOf(i) + ", job: "+ pendingJob);
}
for (int ic=0; ic < mControllers.size(); ic++) {
mControllers.get(ic).prepareForExecutionLocked(pendingJob);
}
if (!mActiveServices.get(i).executeRunnableJob(pendingJob)) {
Slog.d(TAG,"Error executing " + pendingJob);
}
if (mPendingJobs.remove(pendingJob)) {
mJobPackageTracker.noteNonpending(pendingJob);
}
}
}
if (!preservePreferredUid) {
mActiveServices.get(i).clearPreferredUid();
}
}
}
