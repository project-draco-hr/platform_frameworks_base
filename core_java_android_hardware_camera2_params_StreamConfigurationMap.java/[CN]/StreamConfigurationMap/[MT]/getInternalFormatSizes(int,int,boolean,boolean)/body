{
  SparseIntArray formatsMap=!output ? mInputFormats : dataspace == HAL_DATASPACE_DEPTH ? mDepthOutputFormats : highRes ? mHighResOutputFormats : mOutputFormats;
  int sizesCount=formatsMap.get(format);
  if (((!output || dataspace == HAL_DATASPACE_DEPTH) && sizesCount == 0) || (output && dataspace != HAL_DATASPACE_DEPTH && mAllOutputFormats.get(format) == 0)) {
    throw new IllegalArgumentException("format not available");
  }
  Size[] sizes=new Size[sizesCount];
  int sizeIndex=0;
  StreamConfiguration[] configurations=(dataspace == HAL_DATASPACE_DEPTH) ? mDepthConfigurations : mConfigurations;
  for (  StreamConfiguration config : configurations) {
    int fmt=config.getFormat();
    if (fmt == format && config.isOutput() == output) {
      if (output) {
        long duration=0;
        for (int i=0; i < mMinFrameDurations.length; i++) {
          StreamConfigurationDuration d=mMinFrameDurations[i];
          if (d.getFormat() == fmt && d.getWidth() == config.getSize().getWidth() && d.getHeight() == config.getSize().getHeight()) {
            duration=d.getDuration();
            break;
          }
        }
        if (highRes != (duration > DURATION_20FPS_NS)) {
          continue;
        }
      }
      sizes[sizeIndex++]=config.getSize();
    }
  }
  if (sizeIndex != sizesCount) {
    throw new AssertionError("Too few sizes (expected " + sizesCount + ", actual "+ sizeIndex+ ")");
  }
  return sizes;
}
