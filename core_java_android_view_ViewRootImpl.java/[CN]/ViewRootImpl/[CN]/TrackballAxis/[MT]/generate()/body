{
  int movement=0;
  nonAccelMovement=0;
  do {
    final int dir=position >= 0 ? 1 : -1;
switch (step) {
case 0:
      if (Math.abs(position) < FIRST_MOVEMENT_THRESHOLD) {
        return movement;
      }
    movement+=dir;
  nonAccelMovement+=dir;
step=1;
break;
case 1:
if (Math.abs(position) < SECOND_CUMULATIVE_MOVEMENT_THRESHOLD) {
return movement;
}
movement+=dir;
nonAccelMovement+=dir;
position-=SECOND_CUMULATIVE_MOVEMENT_THRESHOLD * dir;
step=2;
break;
default :
if (Math.abs(position) < SUBSEQUENT_INCREMENTAL_MOVEMENT_THRESHOLD) {
return movement;
}
movement+=dir;
position-=dir * SUBSEQUENT_INCREMENTAL_MOVEMENT_THRESHOLD;
float acc=acceleration;
acc*=1.1f;
acceleration=acc < MAX_ACCELERATION ? acc : acceleration;
break;
}
}
 while (true);
}
