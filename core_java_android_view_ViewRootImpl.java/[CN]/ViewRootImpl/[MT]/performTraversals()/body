{
  final View host=mView;
  if (DBG) {
    System.out.println("======================================");
    System.out.println("performTraversals");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,"View " + host + " resized to: "+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,"Visible insets changing to: " + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,"host=w:" + host.getMeasuredWidth() + ", h:"+ host.getMeasuredHeight()+ ", params="+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,"relayout: frame=" + frame.toShortString() + " overscan="+ mPendingOverscanInsets.toShortString()+ " content="+ mPendingContentInsets.toShortString()+ " visible="+ mPendingVisibleInsets.toShortString()+ " visible="+ mPendingStableInsets.toShortString()+ " outsets="+ mPendingOutsets.toShortString()+ " surface="+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,"Visible with new config: " + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      final boolean alwaysConsumeNavBarChanged=mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,"Content insets changing to: " + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,"Overscan insets changing to: " + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,"Decor insets changing to: " + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (alwaysConsumeNavBarChanged) {
        mAttachInfo.mAlwaysConsumeNavBar=mPendingAlwaysConsumeNavBar;
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,"Visible insets changing to: " + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets,mResizeMode);
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,"Relayout returned: frame=" + frame + ", surface="+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,"Ooops, something changed!  mWidth=" + mWidth + " measuredWidth="+ host.getMeasuredWidth()+ " mHeight="+ mHeight+ " measuredHeight="+ host.getMeasuredHeight()+ " coveredInsetsChanged="+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,"And hey let's measure once more: width=" + width + " height="+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,mWidth,mHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println("======================================");
      System.out.println("performTraversals -- after setFrame");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,"First: mView.hasFocus()=" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,"First: requested focused view=" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,"First: existing focused view=" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw && !newSurface) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}
