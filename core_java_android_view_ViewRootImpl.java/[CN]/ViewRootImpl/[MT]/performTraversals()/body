{
  final View host=mView;
  if (DBG) {
    System.out.println("======================================");
    System.out.println("performTraversals");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,"View " + host + " resized to: "+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,"Visible insets changing to: " + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,"host=w:" + host.getMeasuredWidth() + ", h:"+ host.getMeasuredHeight()+ ", params="+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(TAG,"relayout: frame=" + frame.toShortString() + " content="+ mPendingContentInsets.toShortString()+ " visible="+ mPendingVisibleInsets.toShortString()+ " surface="+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,"Visible with new config: " + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            layerCanvas.setViewport(mWidth,mHeight);
            layerCanvas.onPreDraw(null);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,"Not enough memory for content change anim buffer",e);
          }
 finally {
            if (layerCanvas != null) {
              layerCanvas.onPostDraw();
            }
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,"Content insets changing to: " + mAttachInfo.mContentInsets);
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,"Visible insets changing to: " + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,"Relayout returned: frame=" + frame + ", surface="+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,"Ooops, something changed!  mWidth=" + mWidth + " measuredWidth="+ host.getMeasuredWidth()+ " mHeight="+ mHeight+ " measuredHeight="+ host.getMeasuredHeight()+ " coveredInsetsChanged="+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,"And hey let's measure once more: width=" + width + " height="+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println("======================================");
      System.out.println("performTraversals -- after setFrame");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,"First: mView.hasFocus()=" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,"First: requested focused view=" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,"First: existing focused view=" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}
