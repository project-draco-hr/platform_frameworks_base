{
  if (attachInfo.mHardwareRenderer != null && !attachInfo.mHardwareRenderer.isEnabled() && attachInfo.mHardwareRenderer.isRequested()) {
    mFullRedrawNeeded=true;
    scheduleTraversals();
    return false;
  }
  Canvas canvas;
  try {
    int left=dirty.left;
    int top=dirty.top;
    int right=dirty.right;
    int bottom=dirty.bottom;
    final long lockCanvasStartTime;
    if (ViewDebug.DEBUG_LATENCY) {
      lockCanvasStartTime=System.nanoTime();
    }
    canvas=mSurface.lockCanvas(dirty);
    if (ViewDebug.DEBUG_LATENCY) {
      long now=System.nanoTime();
      Log.d(ViewDebug.DEBUG_LATENCY_TAG,"- lockCanvas() took " + ((now - lockCanvasStartTime) * 0.000001f) + "ms");
    }
    if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
      attachInfo.mIgnoreDirtyState=true;
    }
    canvas.setDensity(mDensity);
  }
 catch (  Surface.OutOfResourcesException e) {
    Log.e(TAG,"OutOfResourcesException locking surface",e);
    try {
      if (!sWindowSession.outOfMemory(mWindow)) {
        Slog.w(TAG,"No processes killed for memory; killing self");
        Process.killProcess(Process.myPid());
      }
    }
 catch (    RemoteException ex) {
    }
    mLayoutRequested=true;
    return false;
  }
catch (  IllegalArgumentException e) {
    Log.e(TAG,"Could not lock surface",e);
    mLayoutRequested=true;
    return false;
  }
  try {
    if (DEBUG_ORIENTATION || DEBUG_DRAW) {
      Log.v(TAG,"Surface " + surface + " drawing to bitmap w="+ canvas.getWidth()+ ", h="+ canvas.getHeight());
    }
    long startTime=0L;
    if (ViewDebug.DEBUG_PROFILE_DRAWING) {
      startTime=SystemClock.elapsedRealtime();
    }
    if (!canvas.isOpaque() || yoff != 0) {
      canvas.drawColor(0,PorterDuff.Mode.CLEAR);
    }
    dirty.setEmpty();
    mIsAnimating=false;
    attachInfo.mDrawingTime=SystemClock.uptimeMillis();
    mView.mPrivateFlags|=View.DRAWN;
    if (DEBUG_DRAW) {
      Context cxt=mView.getContext();
      Log.i(TAG,"Drawing: package:" + cxt.getPackageName() + ", metrics="+ cxt.getResources().getDisplayMetrics()+ ", compatibilityInfo="+ cxt.getResources().getCompatibilityInfo());
    }
    try {
      canvas.translate(0,-yoff);
      if (mTranslator != null) {
        mTranslator.translateCanvas(canvas);
      }
      canvas.setScreenDensity(scalingRequired ? DisplayMetrics.DENSITY_DEVICE : 0);
      attachInfo.mSetIgnoreDirtyState=false;
      final long drawStartTime;
      if (ViewDebug.DEBUG_LATENCY) {
        drawStartTime=System.nanoTime();
      }
      mView.draw(canvas);
      drawAccessibilityFocusedDrawableIfNeeded(canvas);
      if (ViewDebug.DEBUG_LATENCY) {
        long now=System.nanoTime();
        Log.d(ViewDebug.DEBUG_LATENCY_TAG,"- draw() took " + ((now - drawStartTime) * 0.000001f) + "ms");
      }
    }
  finally {
      if (!attachInfo.mSetIgnoreDirtyState) {
        attachInfo.mIgnoreDirtyState=false;
      }
    }
    if (false && ViewDebug.consistencyCheckEnabled) {
      mView.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_DRAWING);
    }
    if (ViewDebug.DEBUG_PROFILE_DRAWING) {
      EventLog.writeEvent(60000,SystemClock.elapsedRealtime() - startTime);
    }
  }
  finally {
    final long unlockCanvasAndPostStartTime;
    if (ViewDebug.DEBUG_LATENCY) {
      unlockCanvasAndPostStartTime=System.nanoTime();
    }
    try {
      surface.unlockCanvasAndPost(canvas);
    }
 catch (    IllegalArgumentException e) {
      Log.e(TAG,"Could not unlock surface",e);
      mLayoutRequested=true;
      return false;
    }
    if (ViewDebug.DEBUG_LATENCY) {
      long now=System.nanoTime();
      Log.d(ViewDebug.DEBUG_LATENCY_TAG,"- unlockCanvasAndPost() took " + ((now - unlockCanvasAndPostStartTime) * 0.000001f) + "ms");
    }
    if (LOCAL_LOGV) {
      Log.v(TAG,"Surface " + surface + " unlockCanvasAndPost");
    }
  }
  return true;
}
