{
  if (q != mCurrentInputEvent) {
    throw new IllegalStateException("finished input event out of order");
  }
  if (ViewDebug.DEBUG_LATENCY) {
    final long now=System.nanoTime();
    final long eventTime=q.mEvent.getEventTimeNano();
    final StringBuilder msg=new StringBuilder();
    msg.append("Spent ");
    msg.append((now - q.mReceiveTimeNanos) * 0.000001f);
    msg.append("ms processing ");
    if (q.mEvent instanceof KeyEvent) {
      final KeyEvent keyEvent=(KeyEvent)q.mEvent;
      msg.append("key event, action=");
      msg.append(KeyEvent.actionToString(keyEvent.getAction()));
    }
 else {
      final MotionEvent motionEvent=(MotionEvent)q.mEvent;
      msg.append("motion event, action=");
      msg.append(MotionEvent.actionToString(motionEvent.getAction()));
      msg.append(", historySize=");
      msg.append(motionEvent.getHistorySize());
    }
    msg.append(", handled=");
    msg.append(handled);
    msg.append(", received at +");
    msg.append((q.mReceiveTimeNanos - eventTime) * 0.000001f);
    if (q.mDeliverTimeNanos != 0) {
      msg.append("ms, delivered at +");
      msg.append((q.mDeliverTimeNanos - eventTime) * 0.000001f);
    }
    if (q.mDeliverPostImeTimeNanos != 0) {
      msg.append("ms, delivered post IME at +");
      msg.append((q.mDeliverPostImeTimeNanos - eventTime) * 0.000001f);
    }
    msg.append("ms, finished at +");
    msg.append((now - eventTime) * 0.000001f);
    msg.append("ms.");
    Log.d(ViewDebug.DEBUG_LATENCY_TAG,msg.toString());
  }
  if (q.mReceiver != null) {
    q.mReceiver.finishInputEvent(q.mEvent,handled);
  }
 else {
    q.mEvent.recycleIfNeededAfterDispatch();
  }
  recycleQueuedInputEvent(q);
  mCurrentInputEvent=null;
  if (mFirstPendingInputEvent != null) {
    scheduleProcessInputEvents();
  }
}
