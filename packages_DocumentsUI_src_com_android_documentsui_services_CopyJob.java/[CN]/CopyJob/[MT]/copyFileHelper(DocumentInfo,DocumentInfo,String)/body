{
  CancellationSignal canceller=new CancellationSignal();
  ParcelFileDescriptor srcFile=null;
  ParcelFileDescriptor dstFile=null;
  InputStream in=null;
  OutputStream out=null;
  boolean success=true;
  try {
    if (src.isVirtualDocument()) {
      final AssetFileDescriptor srcFileAsAsset=getClient(src).openTypedAssetFileDescriptor(src.derivedUri,mimeType,null,canceller);
      srcFile=srcFileAsAsset.getParcelFileDescriptor();
      in=new AssetFileDescriptor.AutoCloseInputStream(srcFileAsAsset);
    }
 else {
      srcFile=getClient(src).openFile(src.derivedUri,"r",canceller);
      in=new ParcelFileDescriptor.AutoCloseInputStream(srcFile);
    }
    dstFile=getClient(dest).openFile(dest.derivedUri,"w",canceller);
    out=new ParcelFileDescriptor.AutoCloseOutputStream(dstFile);
    byte[] buffer=new byte[32 * 1024];
    int len;
    while ((len=in.read(buffer)) != -1) {
      if (isCanceled()) {
        if (DEBUG)         Log.d(TAG,"Canceled copy mid-copy. Id:" + id);
        success=false;
        break;
      }
      out.write(buffer,0,len);
      makeCopyProgress(len);
    }
    srcFile.checkError();
  }
 catch (  IOException e) {
    success=false;
    onFileFailed(src,"Exception thrown while copying from " + src.derivedUri + " to "+ dest.derivedUri+ ".");
    if (dstFile != null) {
      try {
        dstFile.closeWithError(e.getMessage());
      }
 catch (      IOException closeError) {
        Log.e(TAG,"Error closing destination",closeError);
      }
    }
  }
 finally {
    IoUtils.closeQuietly(in);
    IoUtils.closeQuietly(out);
  }
  if (!success) {
    if (DEBUG)     Log.d(TAG,"Cleaning up failed operation leftovers.");
    canceller.cancel();
    try {
      DocumentsContract.deleteDocument(getClient(dest),dest.derivedUri);
    }
 catch (    RemoteException e) {
      Log.w(TAG,"Failed to cleanup after copy error: " + src.derivedUri,e);
      throw e;
    }
  }
  return success;
}
