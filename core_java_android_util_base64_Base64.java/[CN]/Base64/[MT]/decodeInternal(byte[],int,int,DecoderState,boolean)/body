{
  if (dstate.state == 6)   return false;
  int state=dstate.state;
  int value=dstate.value;
  final int[] decode=dstate.alphabet;
  final byte[] output=dstate.output;
  int op=0;
  int p=offset;
  len+=offset;
  while (p < len) {
    if (state == 0 && p + 4 <= len && (value=((decode[input[p] & 0xff] << 18) | (decode[input[p + 1] & 0xff] << 12) | (decode[input[p + 2] & 0xff] << 6)| (decode[input[p + 3] & 0xff]))) >= 0) {
      output[op + 2]=(byte)value;
      output[op + 1]=(byte)(value >> 8);
      output[op]=(byte)(value >> 16);
      op+=3;
      p+=4;
      continue;
    }
    int d=decode[input[p++] & 0xff];
switch (state) {
case 0:
      if (d >= 0) {
        value=d;
        ++state;
      }
 else       if (d != SKIP) {
        dstate.state=6;
        return false;
      }
    break;
case 1:
  if (d >= 0) {
    value=(value << 6) | d;
    ++state;
  }
 else   if (d != SKIP) {
    dstate.state=6;
    return false;
  }
break;
case 2:
if (d >= 0) {
value=(value << 6) | d;
++state;
}
 else if (d == EQUALS) {
output[op++]=(byte)(value >> 4);
state=4;
}
 else if (d != SKIP) {
dstate.state=6;
return false;
}
break;
case 3:
if (d >= 0) {
value=(value << 6) | d;
output[op + 2]=(byte)value;
output[op + 1]=(byte)(value >> 8);
output[op]=(byte)(value >> 16);
op+=3;
state=0;
}
 else if (d == EQUALS) {
output[op + 1]=(byte)(value >> 2);
output[op]=(byte)(value >> 10);
op+=2;
state=5;
}
 else if (d != SKIP) {
dstate.state=6;
return false;
}
break;
case 4:
if (d == EQUALS) {
++state;
}
 else if (d != SKIP) {
dstate.state=6;
return false;
}
break;
case 5:
if (d != SKIP) {
dstate.state=6;
return false;
}
break;
}
}
if (!finish) {
dstate.state=state;
dstate.value=value;
dstate.op=op;
return true;
}
switch (state) {
case 0:
break;
case 1:
dstate.state=6;
return false;
case 2:
output[op++]=(byte)(value >> 4);
break;
case 3:
output[op + 1]=(byte)(value >> 2);
output[op]=(byte)(value >> 10);
op+=2;
break;
case 4:
dstate.state=6;
return false;
case 5:
break;
}
dstate.op=op;
return true;
}
