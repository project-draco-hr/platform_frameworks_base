{
  final PublicKey pubKey=pair.getPublic();
  assertNotNull("The PublicKey for the KeyPair should be not null",pubKey);
  assertEquals(keyType,pubKey.getAlgorithm());
  if ("DSA".equalsIgnoreCase(keyType)) {
    DSAPublicKey dsaPubKey=(DSAPublicKey)pubKey;
    DSAParams actualParams=dsaPubKey.getParams();
    assertEquals(keySize,(actualParams.getP().bitLength() + 7) & ~7);
    if (spec != null) {
      DSAParameterSpec expectedParams=(DSAParameterSpec)spec;
      assertEquals(expectedParams.getP(),actualParams.getP());
      assertEquals(expectedParams.getQ(),actualParams.getQ());
      assertEquals(expectedParams.getG(),actualParams.getG());
    }
  }
 else   if ("EC".equalsIgnoreCase(keyType)) {
    assertEquals("Curve should be what was specified during initialization",keySize,((ECPublicKey)pubKey).getParams().getCurve().getField().getFieldSize());
  }
 else   if ("RSA".equalsIgnoreCase(keyType)) {
    RSAPublicKey rsaPubKey=(RSAPublicKey)pubKey;
    assertEquals("Modulus size should be what is specified during initialization",(keySize + 7) & ~7,(rsaPubKey.getModulus().bitLength() + 7) & ~7);
    if (spec != null) {
      RSAKeyGenParameterSpec params=(RSAKeyGenParameterSpec)spec;
      assertEquals((keySize + 7) & ~7,(params.getKeysize() + 7) & ~7);
      assertEquals(params.getPublicExponent(),rsaPubKey.getPublicExponent());
    }
  }
  final PrivateKey privKey=pair.getPrivate();
  assertNotNull("The PrivateKey for the KeyPair should be not null",privKey);
  assertEquals(keyType,privKey.getAlgorithm());
  final byte[] userCertBytes=mAndroidKeyStore.get(Credentials.USER_CERTIFICATE + alias);
  assertNotNull("The user certificate should exist for the generated entry",userCertBytes);
  final CertificateFactory cf=CertificateFactory.getInstance("X.509");
  final Certificate userCert=cf.generateCertificate(new ByteArrayInputStream(userCertBytes));
  assertTrue("Certificate should be in X.509 format",userCert instanceof X509Certificate);
  final X509Certificate x509userCert=(X509Certificate)userCert;
  assertEquals("PublicKey used to sign certificate should match one returned in KeyPair",pubKey,x509userCert.getPublicKey());
  assertEquals("The Subject DN should be the one passed into the params",dn,x509userCert.getSubjectDN());
  assertEquals("The Issuer DN should be the same as the Subject DN",dn,x509userCert.getIssuerDN());
  assertEquals("The Serial should be the one passed into the params",serial,x509userCert.getSerialNumber());
  assertDateEquals("The notBefore date should be the one passed into the params",start,x509userCert.getNotBefore());
  assertDateEquals("The notAfter date should be the one passed into the params",end,x509userCert.getNotAfter());
  x509userCert.verify(pubKey);
  final byte[] caCerts=mAndroidKeyStore.get(Credentials.CA_CERTIFICATE + alias);
  assertNull("A list of CA certificates should not exist for the generated entry",caCerts);
  final byte[] pubKeyBytes=mAndroidKeyStore.getPubkey(Credentials.USER_PRIVATE_KEY + alias);
  assertNotNull("The keystore should return the public key for the generated key",pubKeyBytes);
}
