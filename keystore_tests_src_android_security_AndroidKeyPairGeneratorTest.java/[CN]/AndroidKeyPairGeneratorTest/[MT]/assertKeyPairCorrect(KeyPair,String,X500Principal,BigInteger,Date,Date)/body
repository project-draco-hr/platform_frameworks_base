{
  final PublicKey pubKey=pair.getPublic();
  assertNotNull("The PublicKey for the KeyPair should be not null",pubKey);
  final PrivateKey privKey=pair.getPrivate();
  assertNotNull("The PrivateKey for the KeyPair should be not null",privKey);
  final byte[] userCertBytes=mAndroidKeyStore.get(Credentials.USER_CERTIFICATE + alias);
  assertNotNull("The user certificate should exist for the generated entry",userCertBytes);
  final CertificateFactory cf=CertificateFactory.getInstance("X.509");
  final Certificate userCert=cf.generateCertificate(new ByteArrayInputStream(userCertBytes));
  assertTrue("Certificate should be in X.509 format",userCert instanceof X509Certificate);
  final X509Certificate x509userCert=(X509Certificate)userCert;
  assertEquals("PublicKey used to sign certificate should match one returned in KeyPair",pubKey,x509userCert.getPublicKey());
  assertEquals("The Subject DN should be the one passed into the params",dn,x509userCert.getSubjectDN());
  assertEquals("The Issuer DN should be the same as the Subject DN",dn,x509userCert.getIssuerDN());
  assertEquals("The Serial should be the one passed into the params",serial,x509userCert.getSerialNumber());
  assertEquals("The notBefore date should be the one passed into the params",start,x509userCert.getNotBefore());
  assertEquals("The notAfter date should be the one passed into the params",end,x509userCert.getNotAfter());
  x509userCert.verify(pubKey);
  final byte[] caCerts=mAndroidKeyStore.get(Credentials.CA_CERTIFICATE + alias);
  assertNull("A list of CA certificates should not exist for the generated entry",caCerts);
  final byte[] pubKeyBytes=mAndroidKeyStore.getPubkey(Credentials.USER_PRIVATE_KEY + alias);
  assertNotNull("The keystore should return the public key for the generated key",pubKeyBytes);
}
