{
  LinkedList<TtmlNode> nodeStack=new LinkedList<TtmlNode>();
  int depthInUnsupportedTag=0;
  boolean active=true;
  while (!isEndOfDoc()) {
    int eventType=mParser.getEventType();
    TtmlNode parent=nodeStack.peekLast();
    if (active) {
      if (eventType == XmlPullParser.START_TAG) {
        if (!isSupportedTag(mParser.getName())) {
          Log.w(TAG,"Unsupported tag " + mParser.getName() + " is ignored.");
          depthInUnsupportedTag++;
          active=false;
        }
 else {
          TtmlNode node=parseNode(parent);
          nodeStack.addLast(node);
          if (parent != null) {
            parent.mChildren.add(node);
          }
        }
      }
 else       if (eventType == XmlPullParser.TEXT) {
        String text=TtmlUtils.applyDefaultSpacePolicy(mParser.getText());
        if (!TextUtils.isEmpty(text)) {
          parent.mChildren.add(new TtmlNode(TtmlUtils.PCDATA,"",text,0,TtmlUtils.INVALID_TIMESTAMP,parent,mCurrentRunId));
        }
      }
 else       if (eventType == XmlPullParser.END_TAG) {
        if (mParser.getName().equals(TtmlUtils.TAG_P)) {
          mListener.onTtmlNodeParsed(nodeStack.getLast());
        }
 else         if (mParser.getName().equals(TtmlUtils.TAG_TT)) {
          mListener.onRootNodeParsed(nodeStack.getLast());
        }
        nodeStack.removeLast();
      }
    }
 else {
      if (eventType == XmlPullParser.START_TAG) {
        depthInUnsupportedTag++;
      }
 else       if (eventType == XmlPullParser.END_TAG) {
        depthInUnsupportedTag--;
        if (depthInUnsupportedTag == 0) {
          active=true;
        }
      }
    }
    mParser.next();
  }
}
