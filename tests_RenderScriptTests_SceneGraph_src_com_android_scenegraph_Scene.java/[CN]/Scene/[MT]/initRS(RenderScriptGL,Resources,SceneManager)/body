{
  mRS=rs;
  mRes=res;
  long start=System.currentTimeMillis();
  mTransformRSData=mRootTransforms.getRSData(rs);
  long end=System.currentTimeMillis();
  Log.v(TIMER_TAG,"Transform init time: " + (end - start));
  start=System.currentTimeMillis();
  sceneManager.mRenderLoop.bind_gRootNode(mTransformRSData);
  end=System.currentTimeMillis();
  Log.v(TIMER_TAG,"Script init time: " + (end - start));
  start=System.currentTimeMillis();
  addDrawables(rs,res,sceneManager);
  end=System.currentTimeMillis();
  Log.v(TIMER_TAG,"Renderable init time: " + (end - start));
  addShaders(rs,res,sceneManager);
  Allocation opaqueBuffer=Allocation.createSized(rs,Element.U32(rs),mRenderables.size());
  Allocation transparentBuffer=Allocation.createSized(rs,Element.U32(rs),mRenderables.size());
  sceneManager.mRenderLoop.bind_gFrontToBack(opaqueBuffer);
  sceneManager.mRenderLoop.bind_gBackToFront(transparentBuffer);
  Allocation cameraData=Allocation.createSized(rs,Element.ALLOCATION(rs),mCameras.size());
  Allocation[] cameraAllocs=new Allocation[mCameras.size()];
  for (int i=0; i < mCameras.size(); i++) {
    cameraAllocs[i]=mCameras.get(i).getRSData(rs).getAllocation();
  }
  cameraData.copyFrom(cameraAllocs);
  sceneManager.mRenderLoop.set_gCameras(cameraData);
  if (mLights.size() != 0) {
    Allocation lightData=Allocation.createSized(rs,Element.ALLOCATION(rs),mCameras.size());
    Allocation[] lightAllocs=new Allocation[mLights.size()];
    for (int i=0; i < mLights.size(); i++) {
      lightAllocs[i]=mLights.get(i).getRSData(rs).getAllocation();
    }
    lightData.copyFrom(lightAllocs);
    sceneManager.mRenderLoop.set_gLights(lightData);
  }
}
