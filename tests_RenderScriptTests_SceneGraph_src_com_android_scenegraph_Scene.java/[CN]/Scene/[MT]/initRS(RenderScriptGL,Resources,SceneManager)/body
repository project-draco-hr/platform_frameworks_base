{
  mRS=rs;
  long start=System.currentTimeMillis();
  mTransformRSData=mRootTransforms.getRSData(rs);
  long end=System.currentTimeMillis();
  Log.v(TIMER_TAG,"Transform init time: " + (end - start));
  start=System.currentTimeMillis();
  sceneManager.mRenderLoop.bind_gRootNode(mTransformRSData);
  end=System.currentTimeMillis();
  Log.v(TIMER_TAG,"Script init time: " + (end - start));
  start=System.currentTimeMillis();
  Allocation drawableData=Allocation.createSized(rs,Element.ALLOCATION(rs),mDrawables.size());
  Allocation[] drawableAllocs=new Allocation[mDrawables.size()];
  for (int i=0; i < mDrawables.size(); i++) {
    Drawable dI=(Drawable)mDrawables.get(i);
    dI.sceneIndex=i;
    addToMeshMap(dI);
    drawableAllocs[i]=dI.getRsField(rs,res).getAllocation();
  }
  drawableData.copyFrom(drawableAllocs);
  sceneManager.mRenderLoop.set_gDrawableObjects(drawableData);
  initRenderPassRS(rs,sceneManager);
  new ImageLoaderTask().execute();
  end=System.currentTimeMillis();
  Log.v(TIMER_TAG,"Drawable init time: " + (end - start));
  Allocation opaqueBuffer=Allocation.createSized(rs,Element.U32(rs),mDrawables.size());
  Allocation transparentBuffer=Allocation.createSized(rs,Element.U32(rs),mDrawables.size());
  sceneManager.mRenderLoop.bind_gFrontToBack(opaqueBuffer);
  sceneManager.mRenderLoop.bind_gBackToFront(transparentBuffer);
  Allocation cameraData=Allocation.createSized(rs,Element.ALLOCATION(rs),mCameras.size());
  Allocation[] cameraAllocs=new Allocation[mCameras.size()];
  for (int i=0; i < mCameras.size(); i++) {
    cameraAllocs[i]=mCameras.get(i).getRSData(rs).getAllocation();
  }
  cameraData.copyFrom(cameraAllocs);
  sceneManager.mRenderLoop.set_gCameras(cameraData);
}
