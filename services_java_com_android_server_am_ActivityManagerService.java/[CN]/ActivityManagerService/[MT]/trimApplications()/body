{
synchronized (this) {
    int i;
    for (i=mRemovedProcesses.size() - 1; i >= 0; i--) {
      final ProcessRecord app=mRemovedProcesses.get(i);
      if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
        Slog.i(TAG,"Exiting empty application process " + app.processName + " ("+ (app.thread != null ? app.thread.asBinder() : null)+ ")\n");
        if (app.pid > 0 && app.pid != MY_PID) {
          EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,"empty");
          Process.killProcessQuiet(app.pid);
        }
 else {
          try {
            app.thread.scheduleExit();
          }
 catch (          Exception e) {
          }
        }
        cleanUpApplicationRecordLocked(app,false,-1);
        mRemovedProcesses.remove(i);
        if (app.persistent) {
          if (app.persistent) {
            addAppLocked(app.info);
          }
        }
      }
    }
    if (!updateOomAdjLocked()) {
      int numServiceProcs=0;
      for (i=mLruProcesses.size() - 1; i >= 0; i--) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (app.persistent || app.services.size() != 0 || app.curReceiver != null) {
          if (localLOGV)           Slog.v(TAG,"Not trimming app " + app + " with services: "+ app.services);
          numServiceProcs++;
        }
      }
      int curMaxProcs=mProcessLimit;
      if (curMaxProcs <= 0)       curMaxProcs=MAX_PROCESSES;
      if (mAlwaysFinishActivities) {
        curMaxProcs=1;
      }
      curMaxProcs+=numServiceProcs;
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        if (!app.persistent && app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
          Slog.i(TAG,"Exiting empty application process " + app.processName + " ("+ (app.thread != null ? app.thread.asBinder() : null)+ ")\n");
          if (app.pid > 0 && app.pid != MY_PID) {
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,"empty");
            Process.killProcessQuiet(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
      if (false)       Slog.v(TAG,"*** NOW HAVE " + mLruProcesses.size() + " of "+ curMaxProcs+ " processes");
      for (i=0; i < mLruProcesses.size() && mLruProcesses.size() > curMaxProcs; i++) {
        final ProcessRecord app=mLruProcesses.get(i);
        boolean canQuit=!app.persistent && app.curReceiver == null && app.services.size() == 0;
        int NUMA=app.activities.size();
        int j;
        if (false)         Slog.v(TAG,"Looking to quit " + app.processName);
        for (j=0; j < NUMA && canQuit; j++) {
          ActivityRecord r=app.activities.get(j);
          if (false)           Slog.v(TAG,"  " + r.intent.getComponent().flattenToShortString() + ": frozen="+ r.haveState+ ", visible="+ r.visible);
          canQuit=(r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped;
        }
        if (canQuit) {
          for (j=0; j < NUMA; j++) {
            ActivityRecord r=app.activities.get(j);
            if (!r.finishing) {
              r.stack.destroyActivityLocked(r,false);
            }
            r.resultTo=null;
          }
          Slog.i(TAG,"Exiting application process " + app.processName + " ("+ (app.thread != null ? app.thread.asBinder() : null)+ ")\n");
          if (app.pid > 0 && app.pid != MY_PID) {
            EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,"old background");
            Process.killProcessQuiet(app.pid);
          }
 else {
            try {
              app.thread.scheduleExit();
            }
 catch (            Exception e) {
            }
          }
          cleanUpApplicationRecordLocked(app,false,i);
          i--;
        }
      }
    }
    int curMaxActivities=MAX_ACTIVITIES;
    if (mAlwaysFinishActivities) {
      curMaxActivities=1;
    }
    for (i=0; i < mMainStack.mLRUActivities.size() && mMainStack.mLRUActivities.size() > curMaxActivities; i++) {
      final ActivityRecord r=(ActivityRecord)mMainStack.mLRUActivities.get(i);
      if ((r.haveState || !r.stateNotNeeded) && !r.visible && r.stopped&& !r.finishing) {
        final int origSize=mMainStack.mLRUActivities.size();
        r.stack.destroyActivityLocked(r,true);
        if (origSize > mMainStack.mLRUActivities.size()) {
          i--;
        }
      }
    }
  }
}
