{
  ArrayList<Integer> firstPids=new ArrayList<Integer>(5);
  SparseArray<Boolean> lastPids=new SparseArray<Boolean>(20);
  if (mController != null) {
    try {
      int res=mController.appEarlyNotResponding(app.processName,app.pid,annotation);
      if (res < 0 && app.pid != MY_PID)       Process.killProcess(app.pid);
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  long anrTime=SystemClock.uptimeMillis();
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
  }
synchronized (this) {
    if (mShuttingDown) {
      Slog.i(TAG,"During shutdown skipping ANR: " + app + " "+ annotation);
      return;
    }
 else     if (app.notResponding) {
      Slog.i(TAG,"Skipping duplicate ANR: " + app + " "+ annotation);
      return;
    }
 else     if (app.crashing) {
      Slog.i(TAG,"Crashing app skipping ANR: " + app + " "+ annotation);
      return;
    }
    app.notResponding=true;
    EventLog.writeEvent(EventLogTags.AM_ANR,app.userId,app.pid,app.processName,app.info.flags,annotation);
    firstPids.add(app.pid);
    int parentPid=app.pid;
    if (parent != null && parent.app != null && parent.app.pid > 0)     parentPid=parent.app.pid;
    if (parentPid != app.pid)     firstPids.add(parentPid);
    if (MY_PID != app.pid && MY_PID != parentPid)     firstPids.add(MY_PID);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord r=mLruProcesses.get(i);
      if (r != null && r.thread != null) {
        int pid=r.pid;
        if (pid > 0 && pid != app.pid && pid != parentPid && pid != MY_PID) {
          if (r.persistent) {
            firstPids.add(pid);
          }
 else {
            lastPids.put(pid,Boolean.TRUE);
          }
        }
      }
    }
  }
  StringBuilder info=new StringBuilder();
  info.setLength(0);
  info.append("ANR in ").append(app.processName);
  if (activity != null && activity.shortComponentName != null) {
    info.append(" (").append(activity.shortComponentName).append(")");
  }
  info.append("\n");
  if (annotation != null) {
    info.append("Reason: ").append(annotation).append("\n");
  }
  if (parent != null && parent != activity) {
    info.append("Parent: ").append(parent.shortComponentName).append("\n");
  }
  final ProcessStats processStats=new ProcessStats(true);
  File tracesFile=dumpStackTraces(true,firstPids,processStats,lastPids,null);
  String cpuInfo=null;
  if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
synchronized (mProcessStatsThread) {
      cpuInfo=mProcessStats.printCurrentState(anrTime);
    }
    info.append(processStats.printCurrentLoad());
    info.append(cpuInfo);
  }
  info.append(processStats.printCurrentState(anrTime));
  Slog.e(TAG,info.toString());
  if (tracesFile == null) {
    Process.sendSignal(app.pid,Process.SIGNAL_QUIT);
  }
  addErrorToDropBox("anr",app,app.processName,activity,parent,annotation,cpuInfo,tracesFile,null);
  if (mController != null) {
    try {
      int res=mController.appNotResponding(app.processName,app.pid,info.toString());
      if (res != 0) {
        if (res < 0 && app.pid != MY_PID)         Process.killProcess(app.pid);
        return;
      }
    }
 catch (    RemoteException e) {
      mController=null;
    }
  }
  boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
synchronized (this) {
    if (!showBackground && !app.isInterestingToUserLocked() && app.pid != MY_PID) {
      Slog.w(TAG,"Killing " + app + ": background ANR");
      EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"background ANR");
      Process.killProcessQuiet(app.pid);
      return;
    }
    makeAppNotRespondingLocked(app,activity != null ? activity.shortComponentName : null,annotation != null ? "ANR " + annotation : "ANR",info.toString());
    Message msg=Message.obtain();
    HashMap map=new HashMap();
    msg.what=SHOW_NOT_RESPONDING_MSG;
    msg.obj=map;
    map.put("app",app);
    if (activity != null) {
      map.put("activity",activity);
    }
    mHandler.sendMessage(msg);
  }
}
