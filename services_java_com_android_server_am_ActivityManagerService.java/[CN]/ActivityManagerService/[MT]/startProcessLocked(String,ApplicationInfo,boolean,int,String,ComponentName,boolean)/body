{
  ProcessRecord app=getProcessRecordLocked(processName,info.uid);
  if (DEBUG_PROCESSES)   Slog.v(TAG,"startProcess: name=" + processName + " app="+ app+ " knownToBeDead="+ knownToBeDead+ " thread="+ (app != null ? app.thread : null)+ " pid="+ (app != null ? app.pid : -1));
  if (app != null && app.pid > 0) {
    if (!knownToBeDead || app.thread == null) {
      if (DEBUG_PROCESSES)       Slog.v(TAG,"App already running: " + app);
      return app;
    }
 else {
      if (DEBUG_PROCESSES)       Slog.v(TAG,"App died: " + app);
      handleAppDiedLocked(app,true);
    }
  }
  String hostingNameStr=hostingName != null ? hostingName.flattenToShortString() : null;
  if ((intentFlags & Intent.FLAG_FROM_BACKGROUND) != 0) {
    if (mBadProcesses.get(info.processName,info.uid) != null) {
      if (DEBUG_PROCESSES)       Slog.v(TAG,"Bad process: " + info.uid + "/"+ info.processName);
      return null;
    }
  }
 else {
    if (DEBUG_PROCESSES)     Slog.v(TAG,"Clearing bad process: " + info.uid + "/"+ info.processName);
    mProcessCrashTimes.remove(info.processName,info.uid);
    if (mBadProcesses.get(info.processName,info.uid) != null) {
      EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,info.uid,info.processName);
      mBadProcesses.remove(info.processName,info.uid);
      if (app != null) {
        app.bad=false;
      }
    }
  }
  if (app == null) {
    app=newProcessRecordLocked(null,info,processName);
    mProcessNames.put(processName,info.uid,app);
  }
 else {
    app.addPackage(info.packageName);
  }
  if (!mProcessesReady && !isAllowedWhileBooting(info) && !allowWhileBooting) {
    if (!mProcessesOnHold.contains(app)) {
      mProcessesOnHold.add(app);
    }
    if (DEBUG_PROCESSES)     Slog.v(TAG,"System not ready, putting on hold: " + app);
    return app;
  }
  startProcessLocked(app,hostingType,hostingNameStr);
  return (app.pid != 0) ? app : null;
}
