{
  ProcessRecord app=null;
  String anrMessage=null;
synchronized (this) {
    if (mOrderedBroadcasts.size() == 0) {
      return;
    }
    long now=SystemClock.uptimeMillis();
    BroadcastRecord r=mOrderedBroadcasts.get(0);
    if ((r.receiverTime + BROADCAST_TIMEOUT) > now) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Premature timeout @ " + now + ": resetting BROADCAST_TIMEOUT_MSG for "+ (r.receiverTime + BROADCAST_TIMEOUT));
      Message msg=mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG);
      mHandler.sendMessageAtTime(msg,r.receiverTime + BROADCAST_TIMEOUT);
      return;
    }
    Slog.w(TAG,"Timeout of broadcast " + r + " - receiver="+ r.receiver);
    r.receiverTime=now;
    r.anrCount++;
    if (r.nextReceiver <= 0) {
      Slog.w(TAG,"Timeout on receiver with nextReceiver <= 0");
      return;
    }
    Object curReceiver=r.receivers.get(r.nextReceiver - 1);
    Slog.w(TAG,"Receiver during timeout: " + curReceiver);
    logBroadcastReceiverDiscard(r);
    if (curReceiver instanceof BroadcastFilter) {
      BroadcastFilter bf=(BroadcastFilter)curReceiver;
      if (bf.receiverList.pid != 0 && bf.receiverList.pid != MY_PID) {
synchronized (this.mPidsSelfLocked) {
          app=this.mPidsSelfLocked.get(bf.receiverList.pid);
        }
      }
    }
 else {
      app=r.curApp;
    }
    if (app != null) {
      anrMessage="Broadcast of " + r.intent.toString();
    }
    if (mPendingBroadcast == r) {
      mPendingBroadcast=null;
    }
    finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
    scheduleBroadcastsLocked();
  }
  if (anrMessage != null) {
    appNotResponding(app,null,null,anrMessage);
  }
}
