{
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG,(sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered="+ ordered+ " userid="+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,"Broadcast " + intent + " not ordered but result callback requested!");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,false,"broadcast",callerPackage);
  if (userId != UserHandle.USER_ALL && mStartedUsers.get(userId) == null) {
    if (callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
      Slog.w(TAG,"Skipping broadcast of " + intent + ": user "+ userId+ " is stopped");
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg="Permission Denial: not allowed to send broadcast " + intent.getAction() + " from pid="+ callingPid+ ", uid="+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg="Permission Denial: not allowed to send broadcast " + intent.getAction() + " from unknown caller.";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg="Permission Denial: not allowed to send broadcast " + intent.getAction() + " to "+ intent.getComponent().getPackageName()+ " from "+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,"Remote exception",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final boolean uidRemoved=Intent.ACTION_UID_REMOVED.equals(intent.getAction());
  if (Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_CHANGED.equals(intent.getAction()) || Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())|| uidRemoved) {
    if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
      if (uidRemoved) {
        final Bundle intentExtras=intent.getExtras();
        final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
        if (uid >= 0) {
          BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
            bs.removeUidStatsLocked(uid);
          }
          mAppOpsService.uidRemoved(uid);
        }
      }
 else {
        if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(intent.getAction())) {
          String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
          if (list != null && (list.length > 0)) {
            for (            String pkg : list) {
              forceStopPackageLocked(pkg,-1,false,true,true,false,userId,"storage unmount");
            }
            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
          }
        }
 else {
          Uri data=intent.getData();
          String ssp;
          if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
            boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(intent.getAction());
            if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
              forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,userId,removed ? "pkg removed" : "pkg changed");
            }
            if (removed) {
              sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
              if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING,false)) {
                mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
                removeUriPermissionsForPackageLocked(ssp,userId,true);
              }
            }
          }
        }
      }
    }
 else {
      String msg="Permission Denial: " + intent.getAction() + " broadcast from "+ callerPackage+ " (pid="+ callingPid+ ", uid="+ callingUid+ ")"+ " requires "+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
  }
 else   if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())) {
    Uri data=intent.getData();
    String ssp;
    if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
      mCompatModePackages.handlePackageAddedLocked(ssp,intent.getBooleanExtra(Intent.EXTRA_REPLACING,false));
    }
  }
  if (intent.ACTION_TIMEZONE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
  }
  if (intent.ACTION_CLEAR_DNS_CACHE.equals(intent.getAction())) {
    mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
  }
  if (Proxy.PROXY_CHANGE_ACTION.equals(intent.getAction())) {
    ProxyProperties proxy=intent.getParcelableExtra("proxy");
    mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
  }
  if (sticky) {
    if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
      String msg="Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid="+ callingUid+ " requires "+ android.Manifest.permission.BROADCAST_STICKY;
      Slog.w(TAG,msg);
      throw new SecurityException(msg);
    }
    if (requiredPermission != null) {
      Slog.w(TAG,"Can't broadcast sticky intent " + intent + " and enforce permission "+ requiredPermission);
      return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
    }
    if (intent.getComponent() != null) {
      throw new SecurityException("Sticky broadcasts can't target a specific component");
    }
    if (userId != UserHandle.USER_ALL) {
      ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
      if (stickies != null) {
        ArrayList<Intent> list=stickies.get(intent.getAction());
        if (list != null) {
          int N=list.size();
          int i;
          for (i=0; i < N; i++) {
            if (intent.filterEquals(list.get(i))) {
              throw new IllegalArgumentException("Sticky broadcast " + intent + " for user "+ userId+ " conflicts with existing global broadcast");
            }
          }
        }
      }
    }
    ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
    if (stickies == null) {
      stickies=new ArrayMap<String,ArrayList<Intent>>();
      mStickyBroadcasts.put(userId,stickies);
    }
    ArrayList<Intent> list=stickies.get(intent.getAction());
    if (list == null) {
      list=new ArrayList<Intent>();
      stickies.put(intent.getAction(),list);
    }
    int N=list.size();
    int i;
    for (i=0; i < N; i++) {
      if (intent.filterEquals(list.get(i))) {
        list.set(i,new Intent(intent));
        break;
      }
    }
    if (i >= N) {
      list.add(new Intent(intent));
    }
  }
  int[] users;
  if (userId == UserHandle.USER_ALL) {
    users=mStartedUserArray;
  }
 else {
    users=new int[]{userId};
  }
  List receivers=null;
  List<BroadcastFilter> registeredReceivers=null;
  if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
    receivers=collectReceiverComponents(intent,resolvedType,users);
  }
  if (intent.getComponent() == null) {
    registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
  }
  final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
  if (DEBUG_BROADCAST)   Slog.v(TAG,"Enqueing broadcast: " + intent.getAction() + " replacePending="+ replacePending);
  int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
  if (!ordered && NR > 0) {
    final BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,"Enqueueing parallel broadcast " + r);
    final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueParallelBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
    registeredReceivers=null;
    NR=0;
  }
  int ir=0;
  if (receivers != null) {
    String skipPackages[]=null;
    if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
      Uri data=intent.getData();
      if (data != null) {
        String pkgName=data.getSchemeSpecificPart();
        if (pkgName != null) {
          skipPackages=new String[]{pkgName};
        }
      }
    }
 else     if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
      skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
    }
    if (skipPackages != null && (skipPackages.length > 0)) {
      for (      String skipPackage : skipPackages) {
        if (skipPackage != null) {
          int NT=receivers.size();
          for (int it=0; it < NT; it++) {
            ResolveInfo curt=(ResolveInfo)receivers.get(it);
            if (curt.activityInfo.packageName.equals(skipPackage)) {
              receivers.remove(it);
              it--;
              NT--;
            }
          }
        }
      }
    }
    int NT=receivers != null ? receivers.size() : 0;
    int it=0;
    ResolveInfo curt=null;
    BroadcastFilter curr=null;
    while (it < NT && ir < NR) {
      if (curt == null) {
        curt=(ResolveInfo)receivers.get(it);
      }
      if (curr == null) {
        curr=registeredReceivers.get(ir);
      }
      if (curr.getPriority() >= curt.priority) {
        receivers.add(it,curr);
        ir++;
        curr=null;
        it++;
        NT++;
      }
 else {
        it++;
        curt=null;
      }
    }
  }
  while (ir < NR) {
    if (receivers == null) {
      receivers=new ArrayList();
    }
    receivers.add(registeredReceivers.get(ir));
    ir++;
  }
  if ((receivers != null && receivers.size() > 0) || resultTo != null) {
    BroadcastQueue queue=broadcastQueueForIntent(intent);
    BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
    if (DEBUG_BROADCAST)     Slog.v(TAG,"Enqueueing ordered broadcast " + r + ": prev had "+ queue.mOrderedBroadcasts.size());
    if (DEBUG_BROADCAST) {
      int seq=r.intent.getIntExtra("seq",-1);
      Slog.i(TAG,"Enqueueing broadcast " + r.intent.getAction() + " seq="+ seq);
    }
    boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
    if (!replaced) {
      queue.enqueueOrderedBroadcastLocked(r);
      queue.scheduleBroadcastsLocked();
    }
  }
  return ActivityManager.BROADCAST_SUCCESS;
}
