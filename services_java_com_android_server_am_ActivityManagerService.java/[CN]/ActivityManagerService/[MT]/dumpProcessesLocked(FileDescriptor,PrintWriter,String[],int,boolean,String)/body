{
  boolean needSep=false;
  int numPers=0;
  pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
  if (dumpAll) {
    for (    SparseArray<ProcessRecord> procs : mProcessNames.getMap().values()) {
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        ProcessRecord r=procs.valueAt(ia);
        if (dumpPackage != null && !dumpPackage.equals(r.info.packageName)) {
          continue;
        }
        if (!needSep) {
          pw.println("  All known processes:");
          needSep=true;
        }
        pw.print(r.persistent ? "  *PERS*" : "  *APP*");
        pw.print(" UID ");
        pw.print(procs.keyAt(ia));
        pw.print(" ");
        pw.println(r);
        r.dump(pw,"    ");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mIsolatedProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Isolated process list (sorted by uid):");
    for (int i=0; i < mIsolatedProcesses.size(); i++) {
      ProcessRecord r=mIsolatedProcesses.valueAt(i);
      if (dumpPackage != null && !dumpPackage.equals(r.info.packageName)) {
        continue;
      }
      pw.println(String.format("%sIsolated #%2d: %s","    ",i,r.toString()));
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Process LRU list (sorted by oom_adj):");
    dumpProcessOomList(pw,this,mLruProcesses,"    ","Proc","PERS",false,dumpPackage);
    needSep=true;
  }
  if (dumpAll) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.valueAt(i);
        if (dumpPackage != null && !dumpPackage.equals(r.info.packageName)) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println(" ");
          needSep=true;
          pw.println("  PID mappings:");
          printed=true;
        }
        pw.print("    PID #");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(": ");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mForegroundProcesses.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
        if (dumpPackage != null && (r == null || !dumpPackage.equals(r.info.packageName))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println(" ");
          needSep=true;
          pw.println("  Foreground Processes:");
          printed=true;
        }
        pw.print("    PID #");
        pw.print(mForegroundProcesses.keyAt(i));
        pw.print(": ");
        pw.println(mForegroundProcesses.valueAt(i));
      }
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Persisent processes that are starting:");
    dumpProcessList(pw,this,mPersistentStartingProcesses,"    ","Starting Norm","Restarting PERS",dumpPackage);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are being removed:");
    dumpProcessList(pw,this,mRemovedProcesses,"    ","Removed Norm","Removed PERS",dumpPackage);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are on old until the system is ready:");
    dumpProcessList(pw,this,mProcessesOnHold,"    ","OnHold Norm","OnHold PERS",dumpPackage);
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll,dumpPackage);
  if (mProcessCrashTimes.getMap().size() > 0) {
    boolean printed=false;
    long now=SystemClock.uptimeMillis();
    for (    Map.Entry<String,SparseArray<Long>> procs : mProcessCrashTimes.getMap().entrySet()) {
      String pname=procs.getKey();
      SparseArray<Long> uids=procs.getValue();
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        int puid=uids.keyAt(i);
        ProcessRecord r=mProcessNames.get(pname,puid);
        if (dumpPackage != null && (r == null || !dumpPackage.equals(r.info.packageName))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println(" ");
          needSep=true;
          pw.println("  Time since processes crashed:");
          printed=true;
        }
        pw.print("    Process ");
        pw.print(pname);
        pw.print(" uid ");
        pw.print(puid);
        pw.print(": last crashed ");
        TimeUtils.formatDuration(now - uids.valueAt(i),pw);
        pw.println(" ago");
      }
    }
  }
  if (mBadProcesses.getMap().size() > 0) {
    boolean printed=false;
    for (    Map.Entry<String,SparseArray<Long>> procs : mBadProcesses.getMap().entrySet()) {
      String pname=procs.getKey();
      SparseArray<Long> uids=procs.getValue();
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        int puid=uids.keyAt(i);
        ProcessRecord r=mProcessNames.get(pname,puid);
        if (dumpPackage != null && (r == null || !dumpPackage.equals(r.info.packageName))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println(" ");
          needSep=true;
          pw.println("  Bad processes:");
        }
        pw.print("    Bad process ");
        pw.print(pname);
        pw.print(" uid ");
        pw.print(puid);
        pw.print(": crashed at time ");
        pw.println(uids.valueAt(i));
      }
    }
  }
  pw.println();
  pw.println("  mStartedUsers:");
  for (int i=0; i < mStartedUsers.size(); i++) {
    UserStartedState uss=mStartedUsers.valueAt(i);
    pw.print("    User #");
    pw.print(uss.mHandle.getIdentifier());
    pw.print(": ");
    uss.dump("",pw);
  }
  pw.print("  mUserLru: [");
  for (int i=0; i < mUserLru.size(); i++) {
    if (i > 0)     pw.print(", ");
    pw.print(mUserLru.get(i));
  }
  pw.println("]");
  if (dumpAll) {
    pw.print("  mStartedUserArray: ");
    pw.println(Arrays.toString(mStartedUserArray));
  }
  pw.println("  mHomeProcess: " + mHomeProcess);
  pw.println("  mPreviousProcess: " + mPreviousProcess);
  if (dumpAll) {
    StringBuilder sb=new StringBuilder(128);
    sb.append("  mPreviousProcessVisibleTime: ");
    TimeUtils.formatDuration(mPreviousProcessVisibleTime,sb);
    pw.println(sb);
  }
  if (mHeavyWeightProcess != null) {
    pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
  }
  pw.println("  mConfiguration: " + mConfiguration);
  if (dumpAll) {
    pw.println("  mConfigWillChange: " + mMainStack.mConfigWillChange);
    if (mCompatModePackages.getPackages().size() > 0) {
      boolean printed=false;
      for (      Map.Entry<String,Integer> entry : mCompatModePackages.getPackages().entrySet()) {
        String pkg=entry.getKey();
        int mode=entry.getValue();
        if (dumpPackage != null && !dumpPackage.equals(pkg)) {
          continue;
        }
        if (!printed) {
          pw.println("  mScreenCompatPackages:");
          printed=true;
        }
        pw.print("    ");
        pw.print(pkg);
        pw.print(": ");
        pw.print(mode);
        pw.println();
      }
    }
  }
  if (mSleeping || mWentToSleep || mLockScreenShown) {
    pw.println("  mSleeping=" + mSleeping + " mWentToSleep="+ mWentToSleep+ " mLockScreenShown "+ mLockScreenShown);
  }
  if (mShuttingDown) {
    pw.println("  mShuttingDown=" + mShuttingDown);
  }
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    pw.println("  mDebugApp=" + mDebugApp + "/orig="+ mOrigDebugApp+ " mDebugTransient="+ mDebugTransient+ " mOrigWaitForDebugger="+ mOrigWaitForDebugger);
  }
  if (mOpenGlTraceApp != null) {
    pw.println("  mOpenGlTraceApp=" + mOpenGlTraceApp);
  }
  if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
    pw.println("  mProfileApp=" + mProfileApp + " mProfileProc="+ mProfileProc);
    pw.println("  mProfileFile=" + mProfileFile + " mProfileFd="+ mProfileFd);
    pw.println("  mProfileType=" + mProfileType + " mAutoStopProfiler="+ mAutoStopProfiler);
  }
  if (mAlwaysFinishActivities || mController != null) {
    pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mController="+ mController);
  }
  if (dumpAll) {
    pw.println("  Total persistent processes: " + numPers);
    pw.println("  mStartRunning=" + mStartRunning + " mProcessesReady="+ mProcessesReady+ " mSystemReady="+ mSystemReady);
    pw.println("  mBooting=" + mBooting + " mBooted="+ mBooted+ " mFactoryTest="+ mFactoryTest);
    pw.print("  mLastPowerCheckRealtime=");
    TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
    pw.println("");
    pw.print("  mLastPowerCheckUptime=");
    TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
    pw.println("");
    pw.println("  mGoingToSleep=" + mMainStack.mGoingToSleep);
    pw.println("  mLaunchingActivity=" + mMainStack.mLaunchingActivity);
    pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq="+ mLruSeq);
    pw.println("  mNumNonHiddenProcs=" + mNumNonHiddenProcs + " mNumHiddenProcs="+ mNumHiddenProcs+ " mNumServiceProcs="+ mNumServiceProcs+ " mNewNumServiceProcs="+ mNewNumServiceProcs);
  }
  return true;
}
