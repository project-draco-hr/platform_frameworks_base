{
  enforceNotIsolatedCaller("getGrantedUriPermissions");
synchronized (this) {
    final int uid=Binder.getCallingUid();
    final IPackageManager pm=AppGlobals.getPackageManager();
    final String[] callerPackages;
    try {
      callerPackages=pm.getPackagesForUid(uid);
    }
 catch (    RemoteException e) {
      throw new SecurityException("Failed to find packages for UID " + uid);
    }
    final boolean callerOwnsSource=sourcePackage != null && ArrayUtils.contains(callerPackages,sourcePackage);
    final boolean callerOwnsTarget=targetPackage != null && ArrayUtils.contains(callerPackages,targetPackage);
    if (!(callerOwnsSource || callerOwnsTarget)) {
      throw new SecurityException("Caller " + Arrays.toString(callerPackages) + " doesn't own "+ sourcePackage+ " or "+ targetPackage);
    }
    final ArrayList<Uri> result=Lists.newArrayList();
    final int size=mGrantedUriPermissions.size();
    for (int i=0; i < size; i++) {
      final ArrayMap<Uri,UriPermission> map=mGrantedUriPermissions.valueAt(i);
      final int mapSize=map.size();
      for (int j=0; j < mapSize; j++) {
        final UriPermission perm=map.valueAt(j);
        final boolean sourceMatch=sourcePackage == null || sourcePackage.equals(perm.sourcePkg);
        final boolean targetMatch=targetPackage == null || targetPackage.equals(perm.targetPkg);
        final boolean modeMatch=(perm.modeFlags & modeMask) == modeFlags;
        if (sourceMatch && targetMatch && modeMatch) {
          result.add(perm.uri);
        }
      }
    }
    return result.toArray(new Uri[result.size()]);
  }
}
