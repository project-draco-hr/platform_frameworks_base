{
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException("File descriptors passed in Bundle");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,0);
      ai=mContext.getPackageManager().getApplicationInfo(ii.targetPackage,PackageManager.GET_SHARED_LIBRARY_FILES);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      Log.w(TAG,"Unable to find instrumentation info for: " + className);
      return false;
    }
    if (ai == null) {
      Log.w(TAG,"Unable to find instrumentation target package: " + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg="Permission Denial: starting instrumentation " + className + " from pid="+ Binder.getCallingPid()+ ", uid="+ Binder.getCallingPid()+ " not allowed because package "+ ii.packageName+ " does not have a signature matching the target "+ ii.targetPackage;
      Log.w(TAG,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    uninstallPackageLocked(ii.targetPackage,-1,true);
    ProcessRecord app=addAppLocked(ai);
    app.instrumentationClass=className;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}
