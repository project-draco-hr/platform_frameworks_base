{
  ContentProviderRecord cpr;
  ContentProviderConnection conn=null;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException("Unable to find app for caller " + caller + " (pid="+ Binder.getCallingPid()+ ") when getting content provider "+ name);
      }
    }
    int userId=UserId.getUserId(r != null ? r.uid : Binder.getCallingUid());
    cpr=mProviderMap.getProviderByName(name,userId);
    boolean providerRunning=cpr != null;
    if (providerRunning) {
      cpi=cpr.info;
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (r != null && cpr.canRunHere(r)) {
        ContentProviderHolder holder=cpr.newHolder(null);
        holder.provider=null;
        return holder;
      }
      final long origId=Binder.clearCallingIdentity();
      conn=incProviderCountLocked(r,cpr,token,stable);
      if (conn != null && (conn.stableCount + conn.unstableCount) == 1) {
        if (cpr.proc != null && r.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
          updateLruProcessLocked(cpr.proc,false,true);
        }
      }
      if (cpr.proc != null) {
        if (false) {
          if (cpr.name.flattenToShortString().equals("com.android.providers.calendar/.CalendarProvider2")) {
            Slog.v(TAG,"****************** KILLING " + cpr.name.flattenToShortString());
            Process.killProcess(cpr.proc.pid);
          }
        }
        boolean success=updateOomAdjLocked(cpr.proc);
        if (DEBUG_PROVIDER)         Slog.i(TAG,"Adjust success: " + success);
        if (!success) {
          Slog.i(TAG,"Existing provider " + cpr.name.flattenToShortString() + " is crashing; detaching "+ r);
          boolean lastRef=decProviderCountLocked(conn,cpr,token,stable);
          appDiedLocked(cpr.proc,cpr.proc.pid,cpr.proc.thread);
          if (!lastRef) {
            return null;
          }
          providerRunning=false;
          conn=null;
        }
      }
      Binder.restoreCallingIdentity(origId);
    }
    if (!providerRunning) {
      try {
        cpi=AppGlobals.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS,userId);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (isSingleton(cpi.processName,cpi.applicationInfo)) {
        userId=0;
      }
      cpi.applicationInfo=getAppInfoForUser(cpi.applicationInfo,userId);
      String msg;
      if ((msg=checkContentProviderPermissionLocked(cpi,r)) != null) {
        throw new SecurityException(msg);
      }
      if (!mProcessesReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals("system")) {
        throw new IllegalArgumentException("Attempt to launch content provider before system ready");
      }
      ComponentName comp=new ComponentName(cpi.packageName,cpi.name);
      cpr=mProviderMap.getProviderByClass(comp,userId);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS,userId);
          if (ai == null) {
            Slog.w(TAG,"No package info for content provider " + cpi.name);
            return null;
          }
          ai=getAppInfoForUser(ai,userId);
          cpr=new ContentProviderRecord(this,cpi,ai,comp);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr.newHolder(null);
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException("here");
        Slog.w(TAG,"LAUNCHING REMOTE PROVIDER (myuid " + r.uid + " pruid "+ cpr.appInfo.uid+ "): "+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        try {
          try {
            AppGlobals.getPackageManager().setPackageStoppedState(cpr.appInfo.packageName,false,userId);
          }
 catch (          RemoteException e) {
          }
catch (          IllegalArgumentException e) {
            Slog.w(TAG,"Failed trying to unstop package " + cpr.appInfo.packageName + ": "+ e);
          }
          ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,"content provider",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false,false);
          if (proc == null) {
            Slog.w(TAG,"Unable to launch app " + cpi.applicationInfo.packageName + "/"+ cpi.applicationInfo.uid+ " for provider "+ name+ ": process is bad");
            return null;
          }
          cpr.launchingApp=proc;
          mLaunchingProviders.add(cpr);
        }
  finally {
          Binder.restoreCallingIdentity(origId);
        }
      }
      if (firstClass) {
        mProviderMap.putProviderByClass(comp,cpr);
      }
      mProviderMap.putProviderByName(name,cpr);
      conn=incProviderCountLocked(r,cpr,token,stable);
      if (conn != null) {
        conn.waiting=true;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Slog.w(TAG,"Unable to launch app " + cpi.applicationInfo.packageName + "/"+ cpi.applicationInfo.uid+ " for provider "+ name+ ": launching app became null");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        if (DEBUG_MU) {
          Slog.v(TAG_MU,"Waiting to start provider " + cpr + " launchingApp="+ cpr.launchingApp);
        }
        if (conn != null) {
          conn.waiting=true;
        }
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
 finally {
        if (conn != null) {
          conn.waiting=false;
        }
      }
    }
  }
  return cpr != null ? cpr.newHolder(conn) : null;
}
