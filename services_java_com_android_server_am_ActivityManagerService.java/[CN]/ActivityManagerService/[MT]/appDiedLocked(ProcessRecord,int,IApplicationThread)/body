{
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,"Process " + app.processName + " (pid "+ pid+ ") has died.");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,"Dying app: " + app + ", pid: "+ pid+ ", thread: "+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,"Low Memory: No more background processes.");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec.thread != null) {
            rec.lastRequestedGc=SystemClock.uptimeMillis();
            try {
              rec.thread.scheduleLowMemory();
            }
 catch (            RemoteException e) {
            }
          }
        }
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,"Received spurious death notification for thread " + thread.asBinder());
  }
}
