{
  final int pid=app.pid;
  boolean gone=false;
synchronized (mPidsSelfLocked) {
    ProcessRecord knownApp=mPidsSelfLocked.get(pid);
    if (knownApp != null && knownApp.thread == null) {
      mPidsSelfLocked.remove(pid);
      gone=true;
    }
  }
  if (gone) {
    Slog.w(TAG,"Process " + app + " failed to attach");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_START_TIMEOUT,pid,app.info.uid,app.processName);
    mProcessNames.remove(app.processName,app.info.uid);
    if (mHeavyWeightProcess == app) {
      mHeavyWeightProcess=null;
      mHandler.sendEmptyMessage(CANCEL_HEAVY_NOTIFICATION_MSG);
    }
    checkAppInLaunchingProvidersLocked(app,true);
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord sr=mPendingServices.get(i);
      if (app.info.uid == sr.appInfo.uid && app.processName.equals(sr.processName)) {
        Slog.w(TAG,"Forcing bringing down service: " + sr);
        mPendingServices.remove(i);
        i--;
        bringDownServiceLocked(sr,true);
      }
    }
    EventLog.writeEvent(EventLogTags.AM_KILL,pid,app.processName,app.setAdj,"start timeout");
    Process.killProcessQuiet(pid);
    if (mBackupTarget != null && mBackupTarget.app.pid == pid) {
      Slog.w(TAG,"Unattached app died before backup, skipping");
      try {
        IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
        bm.agentDisconnected(app.info.packageName);
      }
 catch (      RemoteException e) {
      }
    }
    if (mPendingBroadcast != null && mPendingBroadcast.curApp.pid == pid) {
      Slog.w(TAG,"Unattached app died before broadcast acknowledged, skipping");
      mPendingBroadcast.state=BroadcastRecord.IDLE;
      mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
      mPendingBroadcast=null;
      scheduleBroadcastsLocked();
    }
  }
 else {
    Slog.w(TAG,"Spurious process start timeout - pid not known for " + app);
  }
}
