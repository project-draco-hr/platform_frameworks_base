{
  BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
  if (mLastWakeLockCheckTime == 0) {
    doKills=false;
  }
  if (stats.isScreenOn()) {
    doKills=false;
  }
  final long curRealtime=SystemClock.elapsedRealtime();
  final long timeSince=curRealtime - mLastWakeLockCheckTime;
  mLastWakeLockCheckTime=curRealtime;
  if (timeSince < (WAKE_LOCK_CHECK_DELAY / 3)) {
    doKills=false;
  }
  int i=mLruProcesses.size();
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    if (app.curAdj >= HIDDEN_APP_MIN_ADJ) {
      long wtime;
synchronized (stats) {
        wtime=stats.getProcessWakeTime(app.info.uid,app.pid,curRealtime);
      }
      long timeUsed=wtime - app.lastWakeTime;
      if (false) {
        StringBuilder sb=new StringBuilder(128);
        sb.append("Wake for ");
        app.toShortString(sb);
        sb.append(": over ");
        TimeUtils.formatDuration(timeSince,sb);
        sb.append(" used ");
        TimeUtils.formatDuration(timeUsed,sb);
        sb.append(" (");
        sb.append((timeUsed * 100) / timeSince);
        sb.append("%)");
        Slog.i(TAG,sb.toString());
      }
      if (doKills && timeSince > 0 && ((timeUsed * 100) / timeSince) >= 50) {
        Slog.i(TAG,"Excessive wake lock in " + app.processName + " (pid "+ app.pid+ "): held "+ timeUsed+ " during "+ timeSince);
        EventLog.writeEvent(EventLogTags.AM_KILL,app.pid,app.processName,app.setAdj,"excessive wake lock");
        Process.killProcessQuiet(app.pid);
      }
 else {
        app.lastWakeTime=wtime;
      }
    }
  }
}
