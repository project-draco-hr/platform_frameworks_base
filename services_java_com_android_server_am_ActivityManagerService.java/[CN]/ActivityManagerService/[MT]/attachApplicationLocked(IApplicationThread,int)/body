{
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else {
    app=null;
  }
  if (app == null) {
    Slog.w(TAG,"No pending application record for pid " + pid + " (IApplicationThread "+ thread+ "); dropping process");
    EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcessQuiet(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true,true);
  }
  if (localLOGV)   Slog.v(TAG,"Binding process pid " + pid + " to record "+ app);
  String processName=app.processName;
  try {
    AppDeathRecipient adr=new AppDeathRecipient(app,pid,thread);
    thread.asBinder().linkToDeath(adr,0);
    app.deathRecipient=adr;
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,"link fail",processName);
    return false;
  }
  EventLog.writeEvent(EventLogTags.AM_PROC_BOUND,app.userId,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.setSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.hasShownUi=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mProcessesReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Slog.i(TAG,"Launching preboot mode app: " + app);
  }
  if (localLOGV)   Slog.v(TAG,"New app record " + app + " thread="+ thread.asBinder()+ " pid="+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    String profileFile=app.instrumentationProfileFile;
    ParcelFileDescriptor profileFd=null;
    boolean profileAutoStop=false;
    if (mProfileApp != null && mProfileApp.equals(processName)) {
      mProfileProc=app;
      profileFile=mProfileFile;
      profileFd=mProfileFd;
      profileAutoStop=mAutoStopProfiler;
    }
    boolean enableOpenGlTrace=false;
    if (mOpenGlTraceApp != null && mOpenGlTraceApp.equals(processName)) {
      enableOpenGlTrace=true;
      mOpenGlTraceApp=null;
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,"Binding proc " + processName + " with config "+ mConfiguration);
    ApplicationInfo appInfo=app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
    app.compat=compatibilityInfoForPackageLocked(appInfo);
    if (profileFd != null) {
      profileFd=profileFd.dup();
    }
    thread.bindApplication(processName,appInfo,providers,app.instrumentationClass,profileFile,profileFd,profileAutoStop,app.instrumentationArguments,app.instrumentationWatcher,app.instrumentationUiAutomationConnection,testMode,enableOpenGlTrace,isRestrictedBackupMode || !normalMode,app.persistent,new Configuration(mConfiguration),app.compat,getCommonServicesLocked(),mCoreSettingsObserver.getCoreSettingsLocked());
    updateLruProcessLocked(app,false);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Slog.w(TAG,"Exception thrown during bind!",e);
    app.resetPackageList();
    app.unlinkDeathRecipient();
    startProcessLocked(app,"bind fail",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))   Slog.v(TAG,"Attach application locked removing on hold: " + app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  ActivityRecord hr=mMainStack.topRunningActivityLocked(null);
  if (hr != null && normalMode) {
    if (hr.app == null && app.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (mHeadless) {
          Slog.e(TAG,"Starting activities not supported on headless device: " + hr);
        }
 else         if (mMainStack.realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,"Exception in new application when starting activity " + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      mMainStack.ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp) {
    try {
      didSomething|=mServices.attachApplicationLocked(app,processName);
    }
 catch (    Exception e) {
      badApp=true;
    }
  }
  if (!badApp && isPendingBroadcastProcessLocked(pid)) {
    try {
      didSomething=sendPendingBroadcastsLocked(app);
    }
 catch (    Exception e) {
      badApp=true;
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
    if (DEBUG_BACKUP)     Slog.v(TAG,"New app is backup target, launching agent for " + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,compatibilityInfoForPackageLocked(mBackupTarget.appInfo),mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Slog.w(TAG,"Exception scheduling backup agent creation: ");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false,true);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}
