{
  ProcessRecord app;
  if (pid != MY_PID && pid >= 0) {
synchronized (mPidsSelfLocked) {
      app=mPidsSelfLocked.get(pid);
    }
  }
 else   if (mStartingProcesses.size() > 0) {
    app=mStartingProcesses.remove(0);
    app.setPid(pid);
  }
 else {
    app=null;
  }
  if (app == null) {
    Slog.w(TAG,"No pending application record for pid " + pid + " (IApplicationThread "+ thread+ "); dropping process");
    EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS,pid);
    if (pid > 0 && pid != MY_PID) {
      Process.killProcess(pid);
    }
 else {
      try {
        thread.scheduleExit();
      }
 catch (      Exception e) {
      }
    }
    return false;
  }
  if (app.thread != null) {
    handleAppDiedLocked(app,true);
  }
  if (localLOGV)   Slog.v(TAG,"Binding process pid " + pid + " to record "+ app);
  String processName=app.processName;
  try {
    thread.asBinder().linkToDeath(new AppDeathRecipient(app,pid,thread),0);
  }
 catch (  RemoteException e) {
    app.resetPackageList();
    startProcessLocked(app,"link fail",processName);
    return false;
  }
  EventLog.writeEvent(EventLogTags.AM_PROC_BOUND,app.pid,app.processName);
  app.thread=thread;
  app.curAdj=app.setAdj=-100;
  app.curSchedGroup=Process.THREAD_GROUP_DEFAULT;
  app.setSchedGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  app.debugging=false;
  mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
  boolean normalMode=mProcessesReady || isAllowedWhileBooting(app.info);
  List providers=normalMode ? generateApplicationProvidersLocked(app) : null;
  if (!normalMode) {
    Slog.i(TAG,"Launching preboot mode app: " + app);
  }
  if (localLOGV)   Slog.v(TAG,"New app record " + app + " thread="+ thread.asBinder()+ " pid="+ pid);
  try {
    int testMode=IApplicationThread.DEBUG_OFF;
    if (mDebugApp != null && mDebugApp.equals(processName)) {
      testMode=mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
      app.debugging=true;
      if (mDebugTransient) {
        mDebugApp=mOrigDebugApp;
        mWaitForDebugger=mOrigWaitForDebugger;
      }
    }
    boolean isRestrictedBackupMode=false;
    if (mBackupTarget != null && mBackupAppName.equals(processName)) {
      isRestrictedBackupMode=(mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
    }
    ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
    if (app.instrumentationClass != null) {
      ensurePackageDexOpt(app.instrumentationClass.getPackageName());
    }
    if (DEBUG_CONFIGURATION)     Slog.v(TAG,"Binding proc " + processName + " with config "+ mConfiguration);
    ApplicationInfo appInfo=app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
    app.compat=compatibilityInfoForPackageLocked(appInfo);
    thread.bindApplication(processName,appInfo,providers,app.instrumentationClass,app.instrumentationProfileFile,app.instrumentationArguments,app.instrumentationWatcher,testMode,isRestrictedBackupMode || !normalMode,mConfiguration,app.compat,getCommonServicesLocked(),mCoreSettingsObserver.getCoreSettingsLocked());
    updateLruProcessLocked(app,false,true);
    app.lastRequestedGc=app.lastLowMemory=SystemClock.uptimeMillis();
  }
 catch (  Exception e) {
    Slog.w(TAG,"Exception thrown during bind!",e);
    app.resetPackageList();
    startProcessLocked(app,"bind fail",processName);
    return false;
  }
  mPersistentStartingProcesses.remove(app);
  if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))   Slog.v(TAG,"Attach application locked removing on hold: " + app);
  mProcessesOnHold.remove(app);
  boolean badApp=false;
  boolean didSomething=false;
  ActivityRecord hr=mMainStack.topRunningActivityLocked(null);
  if (hr != null && normalMode) {
    if (hr.app == null && app.info.uid == hr.info.applicationInfo.uid && processName.equals(hr.processName)) {
      try {
        if (mMainStack.realStartActivityLocked(hr,app,true,true)) {
          didSomething=true;
        }
      }
 catch (      Exception e) {
        Slog.w(TAG,"Exception in new application when starting activity " + hr.intent.getComponent().flattenToShortString(),e);
        badApp=true;
      }
    }
 else {
      mMainStack.ensureActivitiesVisibleLocked(hr,null,processName,0);
    }
  }
  if (!badApp && mPendingServices.size() > 0) {
    ServiceRecord sr=null;
    try {
      for (int i=0; i < mPendingServices.size(); i++) {
        sr=mPendingServices.get(i);
        if (app.info.uid != sr.appInfo.uid || !processName.equals(sr.processName)) {
          continue;
        }
        mPendingServices.remove(i);
        i--;
        realStartServiceLocked(sr,app);
        didSomething=true;
      }
    }
 catch (    Exception e) {
      Slog.w(TAG,"Exception in new application when starting service " + sr.shortName,e);
      badApp=true;
    }
  }
  BroadcastRecord br=mPendingBroadcast;
  if (!badApp && br != null && br.curApp == app) {
    try {
      mPendingBroadcast=null;
      processCurBroadcastLocked(br,app);
      didSomething=true;
    }
 catch (    Exception e) {
      Slog.w(TAG,"Exception in new application when starting receiver " + br.curComponent.flattenToShortString(),e);
      badApp=true;
      logBroadcastReceiverDiscardLocked(br);
      finishReceiverLocked(br.receiver,br.resultCode,br.resultData,br.resultExtras,br.resultAbort,true);
      scheduleBroadcastsLocked();
      br.state=BroadcastRecord.IDLE;
    }
  }
  if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.info.uid) {
    if (DEBUG_BACKUP)     Slog.v(TAG,"New app is backup target, launching agent for " + app);
    ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
    try {
      thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,compatibilityInfoForPackageLocked(mBackupTarget.appInfo),mBackupTarget.backupMode);
    }
 catch (    Exception e) {
      Slog.w(TAG,"Exception scheduling backup agent creation: ");
      e.printStackTrace();
    }
  }
  if (badApp) {
    handleAppDiedLocked(app,false);
    return false;
  }
  if (!didSomething) {
    updateOomAdjLocked();
  }
  return true;
}
