{
synchronized (this) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG,"processNextBroadcast: " + mParallelBroadcasts.size() + " broadcasts, "+ mOrderedBroadcasts.size()+ " ordered broadcasts");
    updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,"Processing parallel broadcast " + r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG,"Delivering non-ordered to registered " + target + ": "+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,"Done with parallel broadcast " + r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT) {
        Slog.v(TAG,"processNextBroadcast: waiting for " + mPendingBroadcast.curApp);
      }
      boolean isDead;
synchronized (mPidsSelfLocked) {
        isDead=(mPidsSelfLocked.get(mPendingBroadcast.curApp.pid) == null);
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,"pending app " + mPendingBroadcast.curApp + " died before responding to broadcast");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        scheduleAppGcsLocked();
        if (looped) {
          updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * BROADCAST_TIMEOUT * numReceivers))) {
          Slog.w(TAG,"Hung broadcast discarded after timeout failure:" + " now=" + now + " dispatchTime="+ r.dispatchTime+ " startTime="+ r.receiverTime+ " intent="+ r.intent+ " numReceivers="+ numReceivers+ " nextReceiver="+ r.nextReceiver+ " state="+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG,"processNextBroadcast() called when not idle (state=" + r.state + ")");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST) {
              int seq=r.intent.getIntExtra("seq",-1);
              Slog.i(TAG,"Finishing broadcast " + r.intent.getAction() + " seq="+ seq+ " app="+ r.callerApp);
            }
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            Slog.w(TAG,"Failure sending broadcast result of " + r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG,"Cancelling BROADCAST_TIMEOUT_MSG");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG,"Finished with ordered broadcast " + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,"Processing ordered broadcast " + r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + BROADCAST_TIMEOUT;
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Submitting BROADCAST_TIMEOUT_MSG for " + r + " at "+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Delivering ordered to registered " + filter + ": "+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG,"Quick finishing: ordered=" + r.ordered + " receiver="+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    boolean skip=false;
    int perm=checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,"Permission Denial: broadcasting " + r.intent.toString() + " from "+ r.callerPackage+ " (pid="+ r.callingPid+ ", uid="+ r.callingUid+ ")"+ " is not exported from uid "+ info.activityInfo.applicationInfo.uid+ " due to receiver "+ info.activityInfo.packageName+ "/"+ info.activityInfo.name);
      }
 else {
        Slog.w(TAG,"Permission Denial: broadcasting " + r.intent.toString() + " from "+ r.callerPackage+ " (pid="+ r.callingPid+ ", uid="+ r.callingUid+ ")"+ " requires "+ info.activityInfo.permission+ " due to receiver "+ info.activityInfo.packageName+ "/"+ info.activityInfo.name);
      }
      skip=true;
    }
    if (r.callingUid != Process.SYSTEM_UID && r.requiredPermission != null) {
      try {
        perm=AppGlobals.getPackageManager().checkPermission(r.requiredPermission,info.activityInfo.applicationInfo.packageName);
      }
 catch (      RemoteException e) {
        perm=PackageManager.PERMISSION_DENIED;
      }
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,"Permission Denial: receiving " + r.intent + " to "+ info.activityInfo.applicationInfo.packageName+ " requires "+ r.requiredPermission+ " due to sender "+ r.callerPackage+ " (uid "+ r.callingUid+ ")");
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Skipping deliver ordered " + r + " to "+ r.curApp+ ": process crashing");
      skip=true;
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Skipping delivery of ordered " + r + " for whatever reason");
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.state=BroadcastRecord.APP_RECEIVE;
    String targetProcess=info.activityInfo.processName;
    r.curComponent=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    r.curReceiver=info.activityInfo;
    ProcessRecord app=getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid);
    if (app != null && app.thread != null) {
      try {
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,"Exception when sending broadcast to " + r.curComponent,e);
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG,"Need to start app " + targetProcess + " for broadcast "+ r);
    if ((r.curApp=startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,"broadcast",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0)) == null) {
      Slog.w(TAG,"Unable to launch app " + info.activityInfo.applicationInfo.packageName + "/"+ info.activityInfo.applicationInfo.uid+ " for broadcast "+ r.intent+ ": process is bad");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r.receiver,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,true);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}
