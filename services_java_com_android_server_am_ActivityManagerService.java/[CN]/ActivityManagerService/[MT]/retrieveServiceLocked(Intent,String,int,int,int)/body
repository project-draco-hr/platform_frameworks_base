{
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG,"retrieveServiceLocked: " + service + " type="+ resolvedType+ " callingUid="+ callingUid);
  if (service.getComponent() != null) {
    r=mServiceMap.getServiceByName(service.getComponent(),userId);
  }
  if (r == null) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=mServiceMap.getServiceByIntent(filter,userId);
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG,"Unable to start service " + service + ": not found");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if (userId > 0) {
        if (isSingleton(sInfo.processName,sInfo.applicationInfo) || (sInfo.flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {
          userId=0;
        }
 else         if ((sInfo.flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {
          if (checkComponentPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,callingPid,callingUid,-1,true) == PackageManager.PERMISSION_GRANTED) {
            userId=0;
          }
 else {
            String msg="Permission Denial: Service " + name + " requests FLAG_SINGLE_USER, but app does not hold "+ android.Manifest.permission.INTERACT_ACROSS_USERS;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=mServiceMap.getServiceByName(name,userId);
      if (r == null) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServiceMap.putServiceByName(name,UserId.getUserId(r.appInfo.uid),r);
        mServiceMap.putServiceByIntent(filter,UserId.getUserId(r.appInfo.uid),r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,"Permission Denial: Accessing service " + r.name + " from pid="+ callingPid+ ", uid="+ callingUid+ " that is not exported from uid "+ r.appInfo.uid);
        return new ServiceLookupResult(null,"not exported from uid " + r.appInfo.uid);
      }
      Slog.w(TAG,"Permission Denial: Accessing service " + r.name + " from pid="+ callingPid+ ", uid="+ callingUid+ " requires "+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}
