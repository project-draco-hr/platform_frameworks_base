{
  boolean needSep=false;
  ItemMatcher matcher=new ItemMatcher();
  matcher.build(args,opti);
  pw.println("ACTIVITY MANAGER SERVICES (dumpsys activity services)");
  if (mServices.size() > 0) {
    pw.println("  Active services:");
    long nowReal=SystemClock.elapsedRealtime();
    Iterator<ServiceRecord> it=mServices.values().iterator();
    needSep=false;
    while (it.hasNext()) {
      ServiceRecord r=it.next();
      if (!matcher.match(r,r.name)) {
        continue;
      }
      if (needSep) {
        pw.println();
      }
      pw.print("  * ");
      pw.println(r);
      if (dumpAll) {
        r.dump(pw,"    ");
        needSep=true;
      }
 else {
        pw.print("    app=");
        pw.println(r.app);
        pw.print("    created=");
        TimeUtils.formatDuration(r.createTime,nowReal,pw);
        pw.print(" started=");
        pw.print(r.startRequested);
        pw.print(" connections=");
        pw.println(r.connections.size());
        if (r.connections.size() > 0) {
          pw.println("    Connections:");
          for (          ArrayList<ConnectionRecord> clist : r.connections.values()) {
            for (int i=0; i < clist.size(); i++) {
              ConnectionRecord conn=clist.get(i);
              pw.print("      ");
              pw.print(conn.binding.intent.intent.getIntent().toShortString(false,false,false));
              pw.print(" -> ");
              ProcessRecord proc=conn.binding.client;
              pw.println(proc != null ? proc.toShortString() : "null");
            }
          }
        }
      }
      if (dumpClient && r.app != null && r.app.thread != null) {
        pw.println("    Client:");
        pw.flush();
        try {
          TransferPipe tp=new TransferPipe();
          try {
            r.app.thread.dumpService(tp.getWriteFd().getFileDescriptor(),r,args);
            tp.setBufferPrefix("      ");
            tp.go(fd,2000);
          }
  finally {
            tp.kill();
          }
        }
 catch (        IOException e) {
          pw.println("      Failure while dumping the service: " + e);
        }
catch (        RemoteException e) {
          pw.println("      Got a RemoteException while dumping the service");
        }
        needSep=true;
      }
    }
    needSep=true;
  }
  if (mPendingServices.size() > 0) {
    if (needSep)     pw.println(" ");
    pw.println("  Pending services:");
    for (int i=0; i < mPendingServices.size(); i++) {
      ServiceRecord r=mPendingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      pw.print("  * Pending ");
      pw.println(r);
      r.dump(pw,"    ");
    }
    needSep=true;
  }
  if (mRestartingServices.size() > 0) {
    if (needSep)     pw.println(" ");
    pw.println("  Restarting services:");
    for (int i=0; i < mRestartingServices.size(); i++) {
      ServiceRecord r=mRestartingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      pw.print("  * Restarting ");
      pw.println(r);
      r.dump(pw,"    ");
    }
    needSep=true;
  }
  if (mStoppingServices.size() > 0) {
    if (needSep)     pw.println(" ");
    pw.println("  Stopping services:");
    for (int i=0; i < mStoppingServices.size(); i++) {
      ServiceRecord r=mStoppingServices.get(i);
      if (!matcher.match(r,r.name)) {
        continue;
      }
      pw.print("  * Stopping ");
      pw.println(r);
      r.dump(pw,"    ");
    }
    needSep=true;
  }
  if (dumpAll) {
    if (mServiceConnections.size() > 0) {
      if (needSep)       pw.println(" ");
      pw.println("  Connection bindings to services:");
      Iterator<ArrayList<ConnectionRecord>> it=mServiceConnections.values().iterator();
      while (it.hasNext()) {
        ArrayList<ConnectionRecord> r=it.next();
        for (int i=0; i < r.size(); i++) {
          ConnectionRecord cr=r.get(i);
          if (!matcher.match(cr.binding.service,cr.binding.service.name)) {
            continue;
          }
          pw.print("  * ");
          pw.println(cr);
          cr.dump(pw,"    ");
        }
      }
      needSep=true;
    }
  }
  return needSep;
}
