{
  if (checkCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
    String msg="Permission Denial: switchUser() from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid()+ " requires "+ android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
  if (userId <= 0) {
    throw new IllegalArgumentException("Can't stop primary user " + userId);
  }
synchronized (this) {
    if (mCurrentUserId == userId) {
      return ActivityManager.USER_OP_IS_CURRENT;
    }
    final UserStartedState uss=mStartedUsers.get(userId);
    if (uss == null) {
      if (callback != null) {
        mHandler.post(new Runnable(){
          @Override public void run(){
            try {
              callback.userStopped(userId);
            }
 catch (            RemoteException e) {
            }
          }
        }
);
      }
      return ActivityManager.USER_OP_SUCCESS;
    }
    if (callback != null) {
      uss.mStopCallbacks.add(callback);
    }
    if (uss.mState != UserStartedState.STATE_STOPPING) {
      uss.mState=UserStartedState.STATE_STOPPING;
      long ident=Binder.clearCallingIdentity();
      try {
        Intent intent=new Intent(Intent.ACTION_SHUTDOWN);
        final IIntentReceiver resultReceiver=new IIntentReceiver.Stub(){
          @Override public void performReceive(          Intent intent,          int resultCode,          String data,          Bundle extras,          boolean ordered,          boolean sticky){
            finishUserStop(uss);
          }
        }
;
        broadcastIntentLocked(null,null,intent,null,resultReceiver,0,null,null,null,true,false,MY_PID,Process.SYSTEM_UID,userId);
      }
  finally {
        Binder.restoreCallingIdentity(ident);
      }
    }
  }
  return ActivityManager.USER_OP_SUCCESS;
}
