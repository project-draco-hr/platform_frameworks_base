{
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  final int N=mLruProcesses.size();
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,"updateOomAdj: top=" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=ProcessList.computeEmptyProcessLimit(mProcessLimit);
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=N - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curClientCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  for (int i=N - 1; i >= 0; i--) {
    ProcessRecord app=mLruProcesses.get(i);
    if (!app.killedBackground && app.thread != null) {
      app.procStateChanged=false;
      final boolean wasKeeping=app.keeping;
      computeOomAdjLocked(app,ProcessList.UNKNOWN_ADJ,TOP_APP,true,now);
      if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
          app.curRawAdj=curCachedAdj;
        app.curAdj=app.modifyRawOomAdj(curCachedAdj);
      if (curCachedAdj != nextCachedAdj) {
        stepCached++;
        if (stepCached >= cachedFactor) {
          stepCached=0;
          curCachedAdj=nextCachedAdj;
          nextCachedAdj+=2;
          if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
            nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
          }
          if (curClientCachedAdj <= curCachedAdj) {
            curClientCachedAdj=curCachedAdj + 1;
            if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
          }
        }
      }
    break;
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
  app.curRawAdj=curClientCachedAdj;
app.curAdj=app.modifyRawOomAdj(curClientCachedAdj);
curClientCachedAdj++;
if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
break;
default :
app.curRawAdj=curEmptyAdj;
app.curAdj=app.modifyRawOomAdj(curEmptyAdj);
if (curEmptyAdj != nextEmptyAdj) {
stepEmpty++;
if (stepEmpty >= emptyFactor) {
stepEmpty=0;
curEmptyAdj=nextEmptyAdj;
nextEmptyAdj+=2;
if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
}
}
}
break;
}
}
applyOomAdjLocked(app,wasKeeping,TOP_APP,true,false,now);
switch (app.curProcState) {
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
mNumCachedHiddenProcs++;
numCached++;
if (numCached > cachedProcessLimit) {
Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): cached #"+ numCached);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"too many background");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
break;
case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): empty for "+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ "s");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"old background process");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
 else {
numEmpty++;
if (numEmpty > emptyProcessLimit) {
Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): empty #"+ numEmpty);
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"too many background");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
}
break;
default :
mNumNonCachedProcs++;
break;
}
if (app.isolated && app.services.size() <= 0) {
Slog.i(TAG,"Isolated process " + app.processName + " (pid "+ app.pid+ ") no longer needed");
EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"isolated not needed");
app.killedBackground=true;
Process.killProcessQuiet(app.pid);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
numTrimming++;
}
}
}
mNumServiceProcs=mNewNumServiceProcs;
boolean allChanged;
if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
final int numCachedAndEmpty=numCached + numEmpty;
int factor=numTrimming / 3;
int minFactor=2;
if (mHomeProcess != null) minFactor++;
if (mPreviousProcess != null) minFactor++;
if (factor < minFactor) factor=minFactor;
int step=0;
int fgTrimLevel;
int memFactor;
if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
}
 else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
}
 else {
fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
}
int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
allChanged=mProcessTracker.setMemFactorLocked(memFactor,!mSleeping,now);
final int trackerMemFactor=mProcessTracker.getMemFactorLocked();
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(trackerMemFactor,now);
}
if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedBackground) {
if (app.trimMemoryLevel < curLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,"Trimming memory of " + app.processName + " to "+ curLevel);
app.thread.scheduleTrimMemory(curLevel);
}
 catch (RemoteException e) {
}
if (false) {
if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
mStackSupervisor.scheduleDestroyAllActivities(app,"trim");
}
}
}
app.trimMemoryLevel=curLevel;
step++;
if (step >= factor) {
step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
break;
}
}
}
 else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,"Trimming memory of heavy-weight " + app.processName + " to "+ ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
if (app.trimMemoryLevel < level && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,"Trimming memory of bg-ui " + app.processName + " to "+ level);
app.thread.scheduleTrimMemory(level);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,"Trimming memory of fg " + app.processName + " to "+ fgTrimLevel);
app.thread.scheduleTrimMemory(fgTrimLevel);
}
 catch (RemoteException e) {
}
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
allChanged=mProcessTracker.setMemFactorLocked(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,!mSleeping,now);
final int trackerMemFactor=mProcessTracker.getMemFactorLocked();
for (int i=N - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.procStateChanged) {
app.setProcessTrackerState(ProcessTracker.ADJ_MEM_FACTOR_NORMAL,now);
}
if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
try {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG,"Trimming memory of ui hidden " + app.processName + " to "+ ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
}
 catch (RemoteException e) {
}
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,"always-finish");
}
if (allChanged) {
requestPssAllProcsLocked(now,false);
}
if (mProcessTracker.shouldWriteNowLocked(now)) {
mHandler.post(new Runnable(){
@Override public void run(){
synchronized (ActivityManagerService.this) {
mProcessTracker.writeStateAsyncLocked();
}
}
}
);
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,"Did OOM ADJ in " + (SystemClock.uptimeMillis() - now) + "ms");
}
}
