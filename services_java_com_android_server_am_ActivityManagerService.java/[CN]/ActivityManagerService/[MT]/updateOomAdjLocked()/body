{
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long oldTime=SystemClock.uptimeMillis() - ProcessList.MAX_EMPTY_TIME;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,"updateOomAdj: top=" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int hiddenProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=hiddenProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    hiddenProcessLimit=0;
  }
 else {
    emptyProcessLimit=(mProcessLimit * 2) / 3;
    hiddenProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.HIDDEN_APP_MAX_ADJ - ProcessList.HIDDEN_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=mLruProcesses.size() - mNumNonHiddenProcs - mNumHiddenProcs;
  if (numEmptyProcs > hiddenProcessLimit) {
    numEmptyProcs=hiddenProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int hiddenFactor=(mNumHiddenProcs > 0 ? mNumHiddenProcs : 1) / numSlots;
  if (hiddenFactor < 1)   hiddenFactor=1;
  int stepHidden=0;
  int stepEmpty=0;
  int numHidden=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonHiddenProcs=0;
  mNumHiddenProcs=0;
  int i=mLruProcesses.size();
  int curHiddenAdj=ProcessList.HIDDEN_APP_MIN_ADJ;
  int nextHiddenAdj=curHiddenAdj + 1;
  int curEmptyAdj=ProcessList.HIDDEN_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  int curClientHiddenAdj=curEmptyAdj;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    updateOomAdjLocked(app,curHiddenAdj,curClientHiddenAdj,curEmptyAdj,TOP_APP,true);
    if (!app.killedBackground) {
      if (app.curRawAdj == curHiddenAdj && app.hasActivities) {
        mNumHiddenProcs++;
        if (curHiddenAdj != nextHiddenAdj) {
          stepHidden++;
          if (stepHidden >= hiddenFactor) {
            stepHidden=0;
            curHiddenAdj=nextHiddenAdj;
            nextHiddenAdj+=2;
            if (nextHiddenAdj > ProcessList.HIDDEN_APP_MAX_ADJ) {
              nextHiddenAdj=ProcessList.HIDDEN_APP_MAX_ADJ;
            }
            if (curClientHiddenAdj <= curHiddenAdj) {
              curClientHiddenAdj=curHiddenAdj + 1;
              if (curClientHiddenAdj > ProcessList.HIDDEN_APP_MAX_ADJ) {
                curClientHiddenAdj=ProcessList.HIDDEN_APP_MAX_ADJ;
              }
            }
          }
        }
        numHidden++;
        if (numHidden > hiddenProcessLimit) {
          Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): hidden #"+ numHidden);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"too many background");
          app.killedBackground=true;
          Process.killProcessQuiet(app.pid);
        }
      }
 else       if (app.curRawAdj == curHiddenAdj && app.hasClientActivities) {
        curClientHiddenAdj++;
        if (curClientHiddenAdj > ProcessList.HIDDEN_APP_MAX_ADJ) {
          curClientHiddenAdj=ProcessList.HIDDEN_APP_MAX_ADJ;
        }
      }
 else {
        if (app.curRawAdj == curEmptyAdj || app.curRawAdj == curHiddenAdj) {
          if (curEmptyAdj != nextEmptyAdj) {
            stepEmpty++;
            if (stepEmpty >= emptyFactor) {
              stepEmpty=0;
              curEmptyAdj=nextEmptyAdj;
              nextEmptyAdj+=2;
              if (nextEmptyAdj > ProcessList.HIDDEN_APP_MAX_ADJ) {
                nextEmptyAdj=ProcessList.HIDDEN_APP_MAX_ADJ;
              }
            }
          }
        }
 else         if (app.curRawAdj < ProcessList.HIDDEN_APP_MIN_ADJ) {
          mNumNonHiddenProcs++;
        }
        if (app.curAdj >= ProcessList.HIDDEN_APP_MIN_ADJ && !app.hasClientActivities) {
          if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
            Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): empty for "+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ "s");
            EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"old background process");
            app.killedBackground=true;
            Process.killProcessQuiet(app.pid);
          }
 else {
            numEmpty++;
            if (numEmpty > emptyProcessLimit) {
              Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): empty #"+ numEmpty);
              EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"too many background");
              app.killedBackground=true;
              Process.killProcessQuiet(app.pid);
            }
          }
        }
      }
      if (app.isolated && app.services.size() <= 0) {
        Slog.i(TAG,"Isolated process " + app.processName + " (pid "+ app.pid+ ") no longer needed");
        EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"isolated not needed");
        app.killedBackground=true;
        Process.killProcessQuiet(app.pid);
      }
      if (app.nonStoppingAdj >= ProcessList.HOME_APP_ADJ && app.nonStoppingAdj != ProcessList.SERVICE_B_ADJ && !app.killedBackground) {
        numTrimming++;
      }
    }
  }
  mNumServiceProcs=mNewNumServiceProcs;
  if (numHidden <= ProcessList.TRIM_HIDDEN_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
    final int numHiddenAndEmpty=numHidden + numEmpty;
    final int N=mLruProcesses.size();
    int factor=numTrimming / 3;
    int minFactor=2;
    if (mHomeProcess != null)     minFactor++;
    if (mPreviousProcess != null)     minFactor++;
    if (factor < minFactor)     factor=minFactor;
    int step=0;
    int fgTrimLevel;
    if (numHiddenAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
      fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
    }
 else     if (numHiddenAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
      fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
    }
 else {
      fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
    }
    int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
    for (i=0; i < N; i++) {
      ProcessRecord app=mLruProcesses.get(i);
      if (app.nonStoppingAdj >= ProcessList.HOME_APP_ADJ && app.nonStoppingAdj != ProcessList.SERVICE_B_ADJ && !app.killedBackground) {
        if (app.trimMemoryLevel < curLevel && app.thread != null) {
          try {
            app.thread.scheduleTrimMemory(curLevel);
          }
 catch (          RemoteException e) {
          }
          if (false) {
            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
              final int numStacks=mStacks.size();
              for (int stackNdx=0; stackNdx < numStacks; ++stackNdx) {
                final ActivityStack stack=mStacks.get(stackNdx);
                stack.scheduleDestroyActivities(app,false,"trim");
              }
            }
          }
        }
        app.trimMemoryLevel=curLevel;
        step++;
        if (step >= factor) {
          step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
            curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
          break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
        curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
      break;
  }
}
}
 else if (app.nonStoppingAdj == ProcessList.HEAVY_WEIGHT_APP_ADJ) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
  try {
    app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
  }
 catch (  RemoteException e) {
  }
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.nonStoppingAdj > ProcessList.VISIBLE_APP_ADJ || app.systemNoUi) && app.pendingUiClean) {
  final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
  if (app.trimMemoryLevel < level && app.thread != null) {
    try {
      app.thread.scheduleTrimMemory(level);
    }
 catch (    RemoteException e) {
    }
  }
  app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
  try {
    app.thread.scheduleTrimMemory(fgTrimLevel);
  }
 catch (  RemoteException e) {
  }
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
final int N=mLruProcesses.size();
for (i=0; i < N; i++) {
ProcessRecord app=mLruProcesses.get(i);
if ((app.nonStoppingAdj > ProcessList.VISIBLE_APP_ADJ || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
  try {
    app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
 catch (  RemoteException e) {
  }
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
final int numStacks=mStacks.size();
for (int stackNdx=0; stackNdx < numStacks; ++stackNdx) {
final ActivityStack stack=mStacks.get(stackNdx);
stack.scheduleDestroyActivities(null,false,"always-finish");
}
}
}
