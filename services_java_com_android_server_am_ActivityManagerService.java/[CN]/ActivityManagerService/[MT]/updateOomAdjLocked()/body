{
  final ActivityRecord TOP_ACT=resumedAppLocked();
  final ProcessRecord TOP_APP=TOP_ACT != null ? TOP_ACT.app : null;
  final long now=SystemClock.uptimeMillis();
  final long oldTime=now - ProcessList.MAX_EMPTY_TIME;
  if (false) {
    RuntimeException e=new RuntimeException();
    e.fillInStackTrace();
    Slog.i(TAG,"updateOomAdj: top=" + TOP_ACT,e);
  }
  mAdjSeq++;
  mNewNumServiceProcs=0;
  final int emptyProcessLimit;
  final int cachedProcessLimit;
  if (mProcessLimit <= 0) {
    emptyProcessLimit=cachedProcessLimit=0;
  }
 else   if (mProcessLimit == 1) {
    emptyProcessLimit=1;
    cachedProcessLimit=0;
  }
 else {
    emptyProcessLimit=(mProcessLimit * 2) / 3;
    cachedProcessLimit=mProcessLimit - emptyProcessLimit;
  }
  int numSlots=(ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
  int numEmptyProcs=mLruProcesses.size() - mNumNonCachedProcs - mNumCachedHiddenProcs;
  if (numEmptyProcs > cachedProcessLimit) {
    numEmptyProcs=cachedProcessLimit;
  }
  int emptyFactor=numEmptyProcs / numSlots;
  if (emptyFactor < 1)   emptyFactor=1;
  int cachedFactor=(mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
  if (cachedFactor < 1)   cachedFactor=1;
  int stepCached=0;
  int stepEmpty=0;
  int numCached=0;
  int numEmpty=0;
  int numTrimming=0;
  mNumNonCachedProcs=0;
  mNumCachedHiddenProcs=0;
  int i=mLruProcesses.size();
  int curCachedAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextCachedAdj=curCachedAdj + 1;
  int curEmptyAdj=ProcessList.CACHED_APP_MIN_ADJ;
  int nextEmptyAdj=curEmptyAdj + 2;
  int curClientCachedAdj=curEmptyAdj;
  boolean changed=false;
  while (i > 0) {
    i--;
    ProcessRecord app=mLruProcesses.get(i);
    app.setAdjChanged=false;
    updateOomAdjLocked(app,curCachedAdj,curClientCachedAdj,curEmptyAdj,TOP_APP,true,now);
    changed|=app.setAdjChanged;
    if (!app.killedBackground) {
      if (app.curRawAdj == curCachedAdj && app.hasActivities) {
        mNumCachedHiddenProcs++;
        if (curCachedAdj != nextCachedAdj) {
          stepCached++;
          if (stepCached >= cachedFactor) {
            stepCached=0;
            curCachedAdj=nextCachedAdj;
            nextCachedAdj+=2;
            if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
              nextCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
            }
            if (curClientCachedAdj <= curCachedAdj) {
              curClientCachedAdj=curCachedAdj + 1;
              if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
              }
            }
          }
        }
        numCached++;
        if (numCached > cachedProcessLimit) {
          Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): cached #"+ numCached);
          EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"too many background");
          app.killedBackground=true;
          Process.killProcessQuiet(app.pid);
        }
      }
 else       if (app.curRawAdj == curCachedAdj && app.hasClientActivities) {
        curClientCachedAdj++;
        if (curClientCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
          curClientCachedAdj=ProcessList.CACHED_APP_MAX_ADJ;
        }
      }
 else {
        if (app.curRawAdj == curEmptyAdj || app.curRawAdj == curCachedAdj) {
          if (curEmptyAdj != nextEmptyAdj) {
            stepEmpty++;
            if (stepEmpty >= emptyFactor) {
              stepEmpty=0;
              curEmptyAdj=nextEmptyAdj;
              nextEmptyAdj+=2;
              if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                nextEmptyAdj=ProcessList.CACHED_APP_MAX_ADJ;
              }
            }
          }
        }
 else         if (app.curRawAdj < ProcessList.CACHED_APP_MIN_ADJ) {
          mNumNonCachedProcs++;
        }
        if (app.curAdj >= ProcessList.CACHED_APP_MIN_ADJ && !app.hasClientActivities) {
          if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
            Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): empty for "+ ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000)+ "s");
            EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"old background process");
            app.killedBackground=true;
            Process.killProcessQuiet(app.pid);
          }
 else {
            numEmpty++;
            if (numEmpty > emptyProcessLimit) {
              Slog.i(TAG,"No longer want " + app.processName + " (pid "+ app.pid+ "): empty #"+ numEmpty);
              EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"too many background");
              app.killedBackground=true;
              Process.killProcessQuiet(app.pid);
            }
          }
        }
      }
      if (app.isolated && app.services.size() <= 0) {
        Slog.i(TAG,"Isolated process " + app.processName + " (pid "+ app.pid+ ") no longer needed");
        EventLog.writeEvent(EventLogTags.AM_KILL,app.userId,app.pid,app.processName,app.setAdj,"isolated not needed");
        app.killedBackground=true;
        Process.killProcessQuiet(app.pid);
      }
      if (app.nonStoppingAdj >= ProcessList.HOME_APP_ADJ && app.nonStoppingAdj != ProcessList.SERVICE_B_ADJ && !app.killedBackground) {
        numTrimming++;
      }
    }
  }
  mNumServiceProcs=mNewNumServiceProcs;
  int memFactor=ProcessTracker.ADJ_MEM_FACTOR_NORMAL;
  if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
    final int numCachedAndEmpty=numCached + numEmpty;
    final int N=mLruProcesses.size();
    int factor=numTrimming / 3;
    int minFactor=2;
    if (mHomeProcess != null)     minFactor++;
    if (mPreviousProcess != null)     minFactor++;
    if (factor < minFactor)     factor=minFactor;
    int step=0;
    int fgTrimLevel;
    if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
      fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
      memFactor=ProcessTracker.ADJ_MEM_FACTOR_CRITICAL;
    }
 else     if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
      fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
      memFactor=ProcessTracker.ADJ_MEM_FACTOR_LOW;
    }
 else {
      fgTrimLevel=ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
      memFactor=ProcessTracker.ADJ_MEM_FACTOR_MODERATE;
    }
    int curLevel=ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
    for (i=0; i < N; i++) {
      ProcessRecord app=mLruProcesses.get(i);
      if (app.nonStoppingAdj >= ProcessList.HOME_APP_ADJ && app.nonStoppingAdj != ProcessList.SERVICE_B_ADJ && !app.killedBackground) {
        if (app.trimMemoryLevel < curLevel && app.thread != null) {
          try {
            app.thread.scheduleTrimMemory(curLevel);
          }
 catch (          RemoteException e) {
          }
          if (false) {
            if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
              mStackSupervisor.scheduleDestroyAllActivities(app,"trim");
            }
          }
        }
        app.trimMemoryLevel=curLevel;
        step++;
        if (step >= factor) {
          step=0;
switch (curLevel) {
case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
            curLevel=ComponentCallbacks2.TRIM_MEMORY_MODERATE;
          break;
case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
        curLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
      break;
  }
}
}
 else if (app.nonStoppingAdj == ProcessList.HEAVY_WEIGHT_APP_ADJ) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
  try {
    app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
  }
 catch (  RemoteException e) {
  }
}
app.trimMemoryLevel=ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
}
 else {
if ((app.nonStoppingAdj > ProcessList.VISIBLE_APP_ADJ || app.systemNoUi) && app.pendingUiClean) {
  final int level=ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
  if (app.trimMemoryLevel < level && app.thread != null) {
    try {
      app.thread.scheduleTrimMemory(level);
    }
 catch (    RemoteException e) {
    }
  }
  app.pendingUiClean=false;
}
if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
  try {
    app.thread.scheduleTrimMemory(fgTrimLevel);
  }
 catch (  RemoteException e) {
  }
}
app.trimMemoryLevel=fgTrimLevel;
}
}
}
 else {
final int N=mLruProcesses.size();
for (i=0; i < N; i++) {
ProcessRecord app=mLruProcesses.get(i);
if ((app.nonStoppingAdj > ProcessList.VISIBLE_APP_ADJ || app.systemNoUi) && app.pendingUiClean) {
if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
  try {
    app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
  }
 catch (  RemoteException e) {
  }
}
app.pendingUiClean=false;
}
app.trimMemoryLevel=0;
}
}
if (mAlwaysFinishActivities) {
mStackSupervisor.scheduleDestroyAllActivities(null,"always-finish");
}
boolean allChanged=mProcessTracker.setMemFactor(memFactor,!mSleeping,now);
if (changed || allChanged) {
memFactor=mProcessTracker.getMemFactor();
for (i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord app=mLruProcesses.get(i);
if (allChanged || app.setAdjChanged) {
app.setProcessTrackerState(TOP_APP,memFactor,now,mProcessList);
}
}
}
if (DEBUG_OOM_ADJ) {
Slog.d(TAG,"Did OOM ADJ in " + (SystemClock.uptimeMillis() - now) + "ms");
}
}
