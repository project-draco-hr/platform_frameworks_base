{
  if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
    String msg="Permission Denial: crashApplication() from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid()+ " requires "+ android.Manifest.permission.FORCE_STOP_PACKAGES;
    Slog.w(TAG,msg);
    throw new SecurityException(msg);
  }
synchronized (this) {
    ProcessRecord proc=null;
synchronized (mPidsSelfLocked) {
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord p=mPidsSelfLocked.valueAt(i);
        if (p.uid != uid) {
          continue;
        }
        if (p.pid == initialPid) {
          proc=p;
          break;
        }
        if (p.pkgList.containsKey(packageName)) {
          proc=p;
        }
      }
    }
    if (proc == null) {
      Slog.w(TAG,"crashApplication: nothing for uid=" + uid + " initialPid="+ initialPid+ " packageName="+ packageName);
      return;
    }
    if (proc.thread != null) {
      if (proc.pid == Process.myPid()) {
        Log.w(TAG,"crashApplication: trying to crash self!");
        return;
      }
      long ident=Binder.clearCallingIdentity();
      try {
        proc.thread.scheduleCrash(message);
      }
 catch (      RemoteException e) {
      }
      Binder.restoreCallingIdentity(ident);
    }
  }
}
