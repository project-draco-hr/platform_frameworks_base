{
  boolean needSep=false;
  int numPers=0;
  pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
  if (dumpAll) {
    for (    SparseArray<ProcessRecord> procs : mProcessNames.getMap().values()) {
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        if (!needSep) {
          pw.println("  All known processes:");
          needSep=true;
        }
        ProcessRecord r=procs.valueAt(ia);
        pw.print(r.persistent ? "  *PERS*" : "  *APP*");
        pw.print(" UID ");
        pw.print(procs.keyAt(ia));
        pw.print(" ");
        pw.println(r);
        r.dump(pw,"    ");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Process LRU list (most recent first):");
    dumpProcessOomList(pw,this,mLruProcesses,"    ","Proc","PERS",false);
    needSep=true;
  }
  if (dumpAll) {
synchronized (mPidsSelfLocked) {
      if (mPidsSelfLocked.size() > 0) {
        if (needSep)         pw.println(" ");
        needSep=true;
        pw.println("  PID mappings:");
        for (int i=0; i < mPidsSelfLocked.size(); i++) {
          pw.print("    PID #");
          pw.print(mPidsSelfLocked.keyAt(i));
          pw.print(": ");
          pw.println(mPidsSelfLocked.valueAt(i));
        }
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Foreground Processes:");
    for (int i=0; i < mForegroundProcesses.size(); i++) {
      pw.print("    PID #");
      pw.print(mForegroundProcesses.keyAt(i));
      pw.print(": ");
      pw.println(mForegroundProcesses.valueAt(i));
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Persisent processes that are starting:");
    dumpProcessList(pw,this,mPersistentStartingProcesses,"    ","Starting Norm","Restarting PERS");
  }
  if (mStartingProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are starting:");
    dumpProcessList(pw,this,mStartingProcesses,"    ","Starting Norm","Starting PERS");
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are being removed:");
    dumpProcessList(pw,this,mRemovedProcesses,"    ","Removed Norm","Removed PERS");
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are on old until the system is ready:");
    dumpProcessList(pw,this,mProcessesOnHold,"    ","OnHold Norm","OnHold PERS");
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll);
  if (mProcessCrashTimes.getMap().size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Time since processes crashed:");
    long now=SystemClock.uptimeMillis();
    for (    Map.Entry<String,SparseArray<Long>> procs : mProcessCrashTimes.getMap().entrySet()) {
      SparseArray<Long> uids=procs.getValue();
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        pw.print("    Process ");
        pw.print(procs.getKey());
        pw.print(" uid ");
        pw.print(uids.keyAt(i));
        pw.print(": last crashed ");
        pw.print((now - uids.valueAt(i)));
        pw.println(" ms ago");
      }
    }
  }
  if (mBadProcesses.getMap().size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Bad processes:");
    for (    Map.Entry<String,SparseArray<Long>> procs : mBadProcesses.getMap().entrySet()) {
      SparseArray<Long> uids=procs.getValue();
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        pw.print("    Bad process ");
        pw.print(procs.getKey());
        pw.print(" uid ");
        pw.print(uids.keyAt(i));
        pw.print(": crashed at time ");
        pw.println(uids.valueAt(i));
      }
    }
  }
  pw.println();
  pw.println("  mHomeProcess: " + mHomeProcess);
  if (mHeavyWeightProcess != null) {
    pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
  }
  pw.println("  mConfiguration: " + mConfiguration);
  if (dumpAll) {
    pw.println("  mConfigWillChange: " + mMainStack.mConfigWillChange);
  }
  pw.println("  mSleeping=" + mSleeping + " mShuttingDown="+ mShuttingDown);
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    pw.println("  mDebugApp=" + mDebugApp + "/orig="+ mOrigDebugApp+ " mDebugTransient="+ mDebugTransient+ " mOrigWaitForDebugger="+ mOrigWaitForDebugger);
  }
  if (mAlwaysFinishActivities || mController != null) {
    pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mController="+ mController);
  }
  if (dumpAll) {
    pw.println("  Total persistent processes: " + numPers);
    pw.println("  mStartRunning=" + mStartRunning + " mProcessesReady="+ mProcessesReady+ " mSystemReady="+ mSystemReady);
    pw.println("  mBooting=" + mBooting + " mBooted="+ mBooted+ " mFactoryTest="+ mFactoryTest);
    pw.print("  mLastPowerCheckRealtime=");
    TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
    pw.println("");
    pw.print("  mLastPowerCheckUptime=");
    TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
    pw.println("");
    pw.println("  mGoingToSleep=" + mMainStack.mGoingToSleep);
    pw.println("  mLaunchingActivity=" + mMainStack.mLaunchingActivity);
    pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq="+ mLruSeq);
  }
  return true;
}
