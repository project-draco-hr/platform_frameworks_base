{
  boolean needSep=false;
  int numPers=0;
  if (dumpAll) {
    for (    SparseArray<ProcessRecord> procs : mProcessNames.getMap().values()) {
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        if (!needSep) {
          pw.println("  All known processes:");
          needSep=true;
        }
        ProcessRecord r=procs.valueAt(ia);
        pw.print(r.persistent ? "  *PERS*" : "  *APP*");
        pw.print(" UID ");
        pw.print(procs.keyAt(ia));
        pw.print(" ");
        pw.println(r);
        r.dump(pw,"    ");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Running processes (most recent first):");
    dumpProcessList(pw,this,mLruProcesses,"    ","Proc","PERS",true);
    needSep=true;
  }
synchronized (mPidsSelfLocked) {
    if (mPidsSelfLocked.size() > 0) {
      if (needSep)       pw.println(" ");
      needSep=true;
      pw.println("  PID mappings:");
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        pw.print("    PID #");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(": ");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Foreground Processes:");
    for (int i=0; i < mForegroundProcesses.size(); i++) {
      pw.print("    PID #");
      pw.print(mForegroundProcesses.keyAt(i));
      pw.print(": ");
      pw.println(mForegroundProcesses.valueAt(i));
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Persisent processes that are starting:");
    dumpProcessList(pw,this,mPersistentStartingProcesses,"    ","Starting Norm","Restarting PERS",false);
  }
  if (mStartingProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are starting:");
    dumpProcessList(pw,this,mStartingProcesses,"    ","Starting Norm","Starting PERS",false);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are being removed:");
    dumpProcessList(pw,this,mRemovedProcesses,"    ","Removed Norm","Removed PERS",false);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are on old until the system is ready:");
    dumpProcessList(pw,this,mProcessesOnHold,"    ","OnHold Norm","OnHold PERS",false);
  }
  if (mProcessesToGc.size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Processes that are waiting to GC:");
    long now=SystemClock.uptimeMillis();
    for (int i=0; i < mProcessesToGc.size(); i++) {
      ProcessRecord proc=mProcessesToGc.get(i);
      pw.print("    Process ");
      pw.println(proc);
      pw.print("      lowMem=");
      pw.print(proc.reportLowMemory);
      pw.print(", last gced=");
      pw.print(now - proc.lastRequestedGc);
      pw.print(" ms ago, last lowMem=");
      pw.print(now - proc.lastLowMemory);
      pw.println(" ms ago");
    }
  }
  if (mProcessCrashTimes.getMap().size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Time since processes crashed:");
    long now=SystemClock.uptimeMillis();
    for (    Map.Entry<String,SparseArray<Long>> procs : mProcessCrashTimes.getMap().entrySet()) {
      SparseArray<Long> uids=procs.getValue();
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        pw.print("    Process ");
        pw.print(procs.getKey());
        pw.print(" uid ");
        pw.print(uids.keyAt(i));
        pw.print(": last crashed ");
        pw.print((now - uids.valueAt(i)));
        pw.println(" ms ago");
      }
    }
  }
  if (mBadProcesses.getMap().size() > 0) {
    if (needSep)     pw.println(" ");
    needSep=true;
    pw.println("  Bad processes:");
    for (    Map.Entry<String,SparseArray<Long>> procs : mBadProcesses.getMap().entrySet()) {
      SparseArray<Long> uids=procs.getValue();
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        pw.print("    Bad process ");
        pw.print(procs.getKey());
        pw.print(" uid ");
        pw.print(uids.keyAt(i));
        pw.print(": crashed at time ");
        pw.println(uids.valueAt(i));
      }
    }
  }
  pw.println(" ");
  pw.println("  mHomeProcess: " + mHomeProcess);
  if (mHeavyWeightProcess != null) {
    pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
  }
  pw.println("  mConfiguration: " + mConfiguration);
  pw.println("  mConfigWillChange: " + mMainStack.mConfigWillChange);
  pw.println("  mSleeping=" + mSleeping + " mShuttingDown="+ mShuttingDown);
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    pw.println("  mDebugApp=" + mDebugApp + "/orig="+ mOrigDebugApp+ " mDebugTransient="+ mDebugTransient+ " mOrigWaitForDebugger="+ mOrigWaitForDebugger);
  }
  if (mAlwaysFinishActivities || mController != null) {
    pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mController="+ mController);
  }
  if (dumpAll) {
    pw.println("  Total persistent processes: " + numPers);
    pw.println("  mStartRunning=" + mStartRunning + " mProcessesReady="+ mProcessesReady+ " mSystemReady="+ mSystemReady);
    pw.println("  mBooting=" + mBooting + " mBooted="+ mBooted+ " mFactoryTest="+ mFactoryTest);
    pw.println("  mGoingToSleep=" + mMainStack.mGoingToSleep);
    pw.println("  mLaunchingActivity=" + mMainStack.mLaunchingActivity);
    pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq="+ mLruSeq);
  }
  return true;
}
