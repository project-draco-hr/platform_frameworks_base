{
  int previousFlagPlaySound=flags & AudioManager.FLAG_PLAY_SOUND;
  if (isPlaybackActive(false) || hasFlag(MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY)) {
    flags&=~AudioManager.FLAG_PLAY_SOUND;
  }
  if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {
    int stream=AudioAttributes.toLegacyStreamType(mAudioAttrs);
    if (useSuggested) {
      if (AudioSystem.isStreamActive(stream,0)) {
        mAudioManagerInternal.adjustSuggestedStreamVolumeForUid(stream,direction,flags,packageName,uid);
      }
 else {
        flags|=previousFlagPlaySound;
        mAudioManagerInternal.adjustSuggestedStreamVolumeForUid(AudioManager.USE_DEFAULT_STREAM_TYPE,direction,flags,packageName,uid);
      }
    }
 else {
      mAudioManagerInternal.adjustStreamVolumeForUid(stream,direction,flags,packageName,uid);
    }
  }
 else {
    if (mVolumeControlType == VolumeProvider.VOLUME_CONTROL_FIXED) {
      return;
    }
    if (direction == AudioManager.ADJUST_TOGGLE_MUTE || direction == AudioManager.ADJUST_MUTE || direction == AudioManager.ADJUST_UNMUTE) {
      Log.w(TAG,"Muting remote playback is not supported");
      return;
    }
    mSessionCb.adjustVolume(direction);
    int volumeBefore=(mOptimisticVolume < 0 ? mCurrentVolume : mOptimisticVolume);
    mOptimisticVolume=volumeBefore + direction;
    mOptimisticVolume=Math.max(0,Math.min(mOptimisticVolume,mMaxVolume));
    mHandler.removeCallbacks(mClearOptimisticVolumeRunnable);
    mHandler.postDelayed(mClearOptimisticVolumeRunnable,OPTIMISTIC_VOLUME_TIMEOUT);
    if (volumeBefore != mOptimisticVolume) {
      pushVolumeUpdate();
    }
    mService.notifyRemoteVolumeChanged(flags,this);
    if (DEBUG) {
      Log.d(TAG,"Adjusted optimistic volume to " + mOptimisticVolume + " max is "+ mMaxVolume);
    }
  }
}
