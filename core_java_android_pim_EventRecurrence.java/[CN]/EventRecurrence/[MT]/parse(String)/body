{
  resetFields();
  int parseFlags=0;
  String[] parts;
  if (ALLOW_LOWER_CASE) {
    parts=recur.toUpperCase().split(";");
  }
 else {
    parts=recur.split(";");
  }
  for (  String part : parts) {
    int equalIndex=part.indexOf('=');
    if (equalIndex <= 0) {
      throw new InvalidFormatException("Missing LHS in " + part);
    }
    String lhs=part.substring(0,equalIndex);
    String rhs=part.substring(equalIndex + 1);
    if (rhs.length() == 0) {
      throw new InvalidFormatException("Missing RHS in " + part);
    }
    PartParser parser=sParsePartMap.get(lhs);
    if (parser == null) {
      if (lhs.startsWith("X-")) {
        continue;
      }
      throw new InvalidFormatException("Couldn't find parser for " + lhs);
    }
 else {
      int flag=parser.parsePart(rhs,this);
      if ((parseFlags & flag) != 0) {
        throw new InvalidFormatException("Part " + lhs + " was specified twice");
      }
      if (parseFlags == 0 && flag != PARSED_FREQ) {
        throw new InvalidFormatException("FREQ must be specified first");
      }
      parseFlags|=flag;
    }
  }
  if ((parseFlags & PARSED_WKST) == 0) {
    wkst=MO;
  }
  if ((parseFlags & PARSED_FREQ) == 0) {
    throw new InvalidFormatException("Must specify a FREQ value");
  }
  if ((parseFlags & (PARSED_UNTIL | PARSED_COUNT)) == (PARSED_UNTIL | PARSED_COUNT)) {
    if (ONLY_ONE_UNTIL_COUNT) {
      throw new InvalidFormatException("Must not specify both UNTIL and COUNT: " + recur);
    }
 else {
      Log.w(TAG,"Warning: rrule has both UNTIL and COUNT: " + recur);
    }
  }
}
