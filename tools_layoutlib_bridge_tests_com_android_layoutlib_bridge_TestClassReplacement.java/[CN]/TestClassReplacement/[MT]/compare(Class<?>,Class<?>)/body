{
  Method[] newClassMethods=newClass.getDeclaredMethods();
  Method[] oldClassMethods=oldClass.getDeclaredMethods();
  for (  Method oldMethod : oldClassMethods) {
    if (oldMethod.getName().startsWith("native")) {
      continue;
    }
    int privateStatic=Modifier.STATIC | Modifier.PRIVATE;
    if ((oldMethod.getModifiers() & privateStatic) == privateStatic) {
      continue;
    }
    boolean found=false;
    for (    Method newMethod : newClassMethods) {
      if (compareMethods(newClass,newMethod,oldClass,oldMethod)) {
        found=true;
        break;
      }
    }
    if (found == false) {
      StringBuilder sb=new StringBuilder(oldMethod.getName() + "(");
      Type[] params=oldMethod.getGenericParameterTypes();
      for (int j=0; j < params.length; j++) {
        if (params[j] instanceof Class) {
          Class theClass=(Class)params[j];
          sb.append(theClass.getName());
          int dimensions=0;
          while (theClass.isArray()) {
            dimensions++;
            theClass=theClass.getComponentType();
          }
          for (int i=0; i < dimensions; i++) {
            sb.append("[]");
          }
        }
 else {
          sb.append(params[j].toString());
        }
        if (j < (params.length - 1))         sb.append(",");
      }
      sb.append(")");
      fail(String.format("Missing %1$s.%2$s",newClass.getName(),sb.toString()));
    }
  }
}
