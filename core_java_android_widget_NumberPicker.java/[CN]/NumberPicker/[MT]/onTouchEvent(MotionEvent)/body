{
  if (!isEnabled()) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_MOVE:
    float currentMoveY=ev.getY();
  if (mCheckBeginEditOnUpEvent || mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
    int deltaDownY=(int)Math.abs(currentMoveY - mLastDownEventY);
    if (deltaDownY > mTouchSlop) {
      mCheckBeginEditOnUpEvent=false;
      onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    }
  }
int deltaMoveY=(int)(currentMoveY - mLastMotionEventY);
scrollBy(0,deltaMoveY);
invalidate();
mLastMotionEventY=currentMoveY;
break;
case MotionEvent.ACTION_UP:
if (mCheckBeginEditOnUpEvent) {
mCheckBeginEditOnUpEvent=false;
final long deltaTapTimeMillis=ev.getEventTime() - mLastUpEventTimeMillis;
if (deltaTapTimeMillis < ViewConfiguration.getDoubleTapTimeout()) {
setSelectorWheelState(SELECTOR_WHEEL_STATE_SMALL);
showInputControls(mShowInputControlsAnimimationDuration);
mInputText.requestFocus();
InputMethodManager inputMethodManager=InputMethodManager.peekInstance();
if (inputMethodManager != null) {
inputMethodManager.showSoftInput(mInputText,0);
}
mLastUpEventTimeMillis=ev.getEventTime();
return true;
}
}
VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumFlingVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
fling(initialVelocity);
onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
}
 else {
if (mAdjustScrollerOnUpEvent) {
if (mFlingScroller.isFinished() && mAdjustScroller.isFinished()) {
postAdjustScrollerCommand(0);
}
}
 else {
postAdjustScrollerCommand(SHOW_INPUT_CONTROLS_DELAY_MILLIS);
}
}
mVelocityTracker.recycle();
mVelocityTracker=null;
mLastUpEventTimeMillis=ev.getEventTime();
break;
}
return true;
}
