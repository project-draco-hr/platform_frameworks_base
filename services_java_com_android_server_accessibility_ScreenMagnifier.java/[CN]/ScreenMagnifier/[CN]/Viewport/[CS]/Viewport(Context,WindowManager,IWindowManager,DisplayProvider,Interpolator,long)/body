{
  mWindowManagerService=windowManagerService;
  mDisplayProvider=displayInfoProvider;
  mViewportFrame=new ViewportWindow(context,windowManager,displayInfoProvider);
  mShowHideFrameAnimator=ObjectAnimator.ofInt(mViewportFrame,PROPERTY_NAME_ALPHA,MIN_ALPHA,MAX_ALPHA);
  mShowHideFrameAnimator.setInterpolator(animationInterpolator);
  mShowHideFrameAnimator.setDuration(animationDuration);
  mShowHideFrameAnimator.addListener(new AnimatorListener(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mShowHideFrameAnimator.getAnimatedValue().equals(MIN_ALPHA)) {
        mViewportFrame.hide();
      }
    }
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
);
  Property<ViewportWindow,Rect> property=Property.of(ViewportWindow.class,Rect.class,PROPERTY_NAME_BOUNDS);
  TypeEvaluator<Rect> evaluator=new TypeEvaluator<Rect>(){
    private final Rect mReusableResultRect=new Rect();
    @Override public Rect evaluate(    float fraction,    Rect fromFrame,    Rect toFrame){
      Rect result=mReusableResultRect;
      result.left=(int)(fromFrame.left + (toFrame.left - fromFrame.left) * fraction);
      result.top=(int)(fromFrame.top + (toFrame.top - fromFrame.top) * fraction);
      result.right=(int)(fromFrame.right + (toFrame.right - fromFrame.right) * fraction);
      result.bottom=(int)(fromFrame.bottom + (toFrame.bottom - fromFrame.bottom) * fraction);
      return result;
    }
  }
;
  mResizeFrameAnimator=ObjectAnimator.ofObject(mViewportFrame,property,evaluator,mViewportFrame.mBounds,mViewportFrame.mBounds);
  mResizeFrameAnimator.setDuration((long)(animationDuration));
  mResizeFrameAnimator.setInterpolator(animationInterpolator);
  recomputeBounds(false);
}
