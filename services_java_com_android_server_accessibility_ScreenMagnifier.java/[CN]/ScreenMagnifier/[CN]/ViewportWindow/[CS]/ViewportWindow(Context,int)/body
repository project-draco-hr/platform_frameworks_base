{
  mWindowManager=(WindowManager)context.getSystemService(Service.WINDOW_SERVICE);
  mDisplayId=displayId;
  mDisplayManager=(DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);
  mDisplay=mDisplayManager.getDisplay(displayId);
  mDisplayManager.registerDisplayListener(this,null);
  updateDisplayInfo();
  ViewGroup.LayoutParams contentParams=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
  mWindowContent=new ContentView(context);
  mWindowContent.setLayoutParams(contentParams);
  mWindowContent.setBackgroundColor(R.color.transparent);
  mWindowParams=new WindowManager.LayoutParams(WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY);
  mWindowParams.flags|=WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
  mWindowParams.setTitle(WINDOW_TITLE);
  mWindowParams.gravity=Gravity.CENTER;
  mWindowParams.width=mDisplayInfo.logicalWidth;
  mWindowParams.height=mDisplayInfo.logicalHeight;
  mWindowParams.format=PixelFormat.TRANSLUCENT;
  Interpolator interpolator=new DecelerateInterpolator(2.5f);
  final long longAnimationDuration=context.getResources().getInteger(com.android.internal.R.integer.config_longAnimTime);
  mShowHideFrameAnimator=ObjectAnimator.ofInt(this,PROPERTY_NAME_ALPHA,MIN_ALPHA,MAX_ALPHA);
  mShowHideFrameAnimator.setInterpolator(interpolator);
  mShowHideFrameAnimator.setDuration(longAnimationDuration);
  mShowHideFrameAnimator.addListener(new AnimatorListener(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mShowHideFrameAnimator.getAnimatedValue().equals(MIN_ALPHA)) {
        hide();
      }
    }
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
);
  Property<ViewportWindow,Rect> property=Property.of(ViewportWindow.class,Rect.class,PROPERTY_NAME_BOUNDS);
  TypeEvaluator<Rect> evaluator=new TypeEvaluator<Rect>(){
    private final Rect mReusableResultRect=new Rect();
    @Override public Rect evaluate(    float fraction,    Rect fromFrame,    Rect toFrame){
      Rect result=mReusableResultRect;
      result.left=(int)(fromFrame.left + (toFrame.left - fromFrame.left) * fraction);
      result.top=(int)(fromFrame.top + (toFrame.top - fromFrame.top) * fraction);
      result.right=(int)(fromFrame.right + (toFrame.right - fromFrame.right) * fraction);
      result.bottom=(int)(fromFrame.bottom + (toFrame.bottom - fromFrame.bottom) * fraction);
      return result;
    }
  }
;
  mResizeFrameAnimator=ObjectAnimator.ofObject(this,property,evaluator,mBounds,mBounds);
  mResizeFrameAnimator.setDuration(longAnimationDuration);
  mResizeFrameAnimator.setInterpolator(interpolator);
}
