{
  boolean streamEnded=false;
  boolean contextChanged=false;
  int excludedPtrIdx=-1;
  final int action=event.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
case MotionEvent.ACTION_POINTER_DOWN:
{
      contextChanged=true;
    }
  break;
case MotionEvent.ACTION_POINTER_UP:
{
  contextChanged=true;
  excludedPtrIdx=event.getActionIndex();
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
streamEnded=true;
}
break;
}
if (mInProgress && (contextChanged || streamEnded)) {
mListener.onScaleEnd(this);
mInProgress=false;
mPrevSpan=0;
mPrevSpanX=0;
mPrevSpanY=0;
return true;
}
final long currTime=mCurrTime;
mFocusX=0;
mFocusY=0;
mCurrSpan=0;
mCurrSpanX=0;
mCurrSpanY=0;
mCurrTime=0;
mPrevTime=0;
if (!streamEnded) {
MinCircleFinder.Circle circle=mMinCircleFinder.computeMinCircleAroundPointers(event);
mFocusX=circle.centerX;
mFocusY=circle.centerY;
double sumSlope=0;
final int pointerCount=event.getPointerCount();
for (int i=0; i < pointerCount; i++) {
if (i == excludedPtrIdx) {
continue;
}
float x=event.getX(i) - mFocusX;
float y=event.getY(i) - mFocusY;
if (x == 0) {
x+=0.1f;
}
sumSlope+=y / x;
}
final double avgSlope=sumSlope / ((excludedPtrIdx < 0) ? pointerCount : pointerCount - 1);
double angle=Math.atan(avgSlope);
mCurrSpan=2 * circle.radius;
mCurrSpanX=(float)Math.abs((Math.cos(angle) * mCurrSpan));
mCurrSpanY=(float)Math.abs((Math.sin(angle) * mCurrSpan));
}
if (contextChanged || mPrevSpan == 0 || mPrevSpanX == 0 || mPrevSpanY == 0) {
mPrevSpan=mCurrSpan;
mPrevSpanX=mCurrSpanX;
mPrevSpanY=mCurrSpanY;
}
if (!mInProgress && mCurrSpan != 0 && !streamEnded) {
mInProgress=mListener.onScaleBegin(this);
}
if (mInProgress) {
mPrevTime=(currTime != 0) ? currTime : event.getEventTime();
mCurrTime=event.getEventTime();
if (mCurrSpan == 0) {
mListener.onScaleEnd(this);
mInProgress=false;
}
 else {
if (mListener.onScale(this)) {
mPrevSpanX=mCurrSpanX;
mPrevSpanY=mCurrSpanY;
mPrevSpan=mCurrSpan;
}
}
}
return true;
}
