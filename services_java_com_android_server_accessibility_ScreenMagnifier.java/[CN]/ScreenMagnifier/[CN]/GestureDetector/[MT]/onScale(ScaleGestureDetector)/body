{
switch (mCurrentState) {
case STATE_DETECTING:
case STATE_DELEGATING:
case STATE_VIEWPORT_DRAGGING:
{
      return true;
    }
case STATE_DECIDE_PAN_OR_SCALE:
{
    mCurrScaleFactor=mScaleGestureDetector.getScaleFactor();
    final float scaleDelta=Math.abs(1.0f - mCurrScaleFactor * mPrevScaleFactor);
    if (DEBUG_GESTURE_DETECTOR) {
      Slog.i(LOG_TAG,"scaleDelta: " + scaleDelta);
    }
    if (scaleDelta > DETECT_SCALING_THRESHOLD) {
      performScale(detector,true);
      clear();
      transitionToState(STATE_SCALING);
      return false;
    }
    mCurrPan=(float)MathUtils.dist(mScaleGestureDetector.getFocusX(),mScaleGestureDetector.getFocusY(),mInitialFocus.x,mInitialFocus.y);
    final float panDelta=mCurrPan + mPrevPan;
    if (DEBUG_GESTURE_DETECTOR) {
      Slog.i(LOG_TAG,"panDelta: " + panDelta);
    }
    if (panDelta > mScaledDetectPanningThreshold) {
      performPan(detector,true);
      clear();
      transitionToState(STATE_PANNING);
      return false;
    }
  }
break;
case STATE_SCALING:
{
performScale(detector,false);
}
break;
case STATE_PANNING:
{
performPan(detector,false);
}
break;
}
return false;
}
