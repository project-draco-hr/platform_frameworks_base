{
  final Entry entry=recycle != null ? recycle : new Entry();
  entry.bucketStart=start;
  entry.bucketDuration=end - start;
  entry.rxBytes=0;
  entry.txBytes=0;
  for (int i=bucketCount - 1; i >= 0; i--) {
    final long curStart=bucketStart[i];
    final long curEnd=curStart + bucketDuration;
    if (curEnd < start)     break;
    if (curStart > end)     continue;
    final boolean activeBucket=curStart < now && curEnd > now;
    final long overlap=Math.min(curEnd,end) - Math.max(curStart,start);
    if (activeBucket || overlap == bucketDuration) {
      entry.rxBytes+=rxBytes[i];
      entry.txBytes+=txBytes[i];
    }
 else     if (overlap > 0) {
      entry.rxBytes+=rxBytes[i] * overlap / bucketDuration;
      entry.txBytes+=txBytes[i] * overlap / bucketDuration;
    }
  }
  return entry;
}
