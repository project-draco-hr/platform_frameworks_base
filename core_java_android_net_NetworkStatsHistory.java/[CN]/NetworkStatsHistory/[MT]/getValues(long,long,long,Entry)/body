{
  final Entry entry=recycle != null ? recycle : new Entry();
  entry.bucketStart=start;
  entry.bucketDuration=end - start;
  entry.rxBytes=0;
  entry.rxPackets=0;
  entry.txBytes=0;
  entry.txPackets=0;
  entry.operations=0;
  for (int i=bucketCount - 1; i >= 0; i--) {
    final long curStart=bucketStart[i];
    final long curEnd=curStart + bucketDuration;
    if (curEnd < start)     break;
    if (curStart > end)     continue;
    final boolean activeBucket=curStart < now && curEnd > now;
    final long overlap=activeBucket ? bucketDuration : Math.min(curEnd,end) - Math.max(curStart,start);
    if (overlap <= 0)     continue;
    entry.rxBytes+=rxBytes[i] * overlap / bucketDuration;
    entry.rxPackets+=rxPackets[i] * overlap / bucketDuration;
    entry.txBytes+=txBytes[i] * overlap / bucketDuration;
    entry.txPackets+=txPackets[i] * overlap / bucketDuration;
    entry.operations+=operations[i] * overlap / bucketDuration;
  }
  return entry;
}
