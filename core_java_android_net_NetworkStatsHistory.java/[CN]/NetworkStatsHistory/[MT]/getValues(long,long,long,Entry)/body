{
  final Entry entry=recycle != null ? recycle : new Entry();
  entry.bucketDuration=end - start;
  entry.bucketStart=start;
  entry.activeTime=activeTime != null ? 0 : UNKNOWN;
  entry.rxBytes=rxBytes != null ? 0 : UNKNOWN;
  entry.rxPackets=rxPackets != null ? 0 : UNKNOWN;
  entry.txBytes=txBytes != null ? 0 : UNKNOWN;
  entry.txPackets=txPackets != null ? 0 : UNKNOWN;
  entry.operations=operations != null ? 0 : UNKNOWN;
  for (int i=bucketCount - 1; i >= 0; i--) {
    final long curStart=bucketStart[i];
    final long curEnd=curStart + bucketDuration;
    if (curEnd < start)     break;
    if (curStart > end)     continue;
    final boolean activeBucket=curStart < now && curEnd > now;
    final long overlap=activeBucket ? bucketDuration : Math.min(curEnd,end) - Math.max(curStart,start);
    if (overlap <= 0)     continue;
    if (activeTime != null)     entry.activeTime+=activeTime[i] * overlap / bucketDuration;
    if (rxBytes != null)     entry.rxBytes+=rxBytes[i] * overlap / bucketDuration;
    if (rxPackets != null)     entry.rxPackets+=rxPackets[i] * overlap / bucketDuration;
    if (txBytes != null)     entry.txBytes+=txBytes[i] * overlap / bucketDuration;
    if (txPackets != null)     entry.txPackets+=txPackets[i] * overlap / bucketDuration;
    if (operations != null)     entry.operations+=operations[i] * overlap / bucketDuration;
  }
  return entry;
}
