{
  mDatabase=db;
  mSql=sql.trim();
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  String prefixSql=mSql.substring(0,6);
  if (!prefixSql.equalsIgnoreCase("INSERT") && !prefixSql.equalsIgnoreCase("UPDATE") && !prefixSql.equalsIgnoreCase("REPLAC")&& !prefixSql.equalsIgnoreCase("DELETE")&& !prefixSql.equalsIgnoreCase("SELECT")) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    nStatement=mCompiledSql.nStatement;
    return;
  }
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    mCompiledSql.acquire();
    db.addToCompiledQueries(sql,mCompiledSql);
    if (SQLiteDebug.DEBUG_ACTIVE_CURSOR_FINALIZATION) {
      Log.v(TAG,"Created DbObj (id#" + mCompiledSql.nStatement + ") for sql: "+ sql);
    }
  }
 else {
    if (!mCompiledSql.acquire()) {
      int last=mCompiledSql.nStatement;
      mCompiledSql=new SQLiteCompiledSql(db,sql);
      if (SQLiteDebug.DEBUG_ACTIVE_CURSOR_FINALIZATION) {
        Log.v(TAG,"** possible bug ** Created NEW DbObj (id#" + mCompiledSql.nStatement + ") because the previously created DbObj (id#"+ last+ ") was not released for sql:"+ sql);
      }
    }
  }
  nStatement=mCompiledSql.nStatement;
}
