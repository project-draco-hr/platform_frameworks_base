{
  if ((mIsRecordingSession && mTvInputRecordingSessionImpl == null) || (!mIsRecordingSession && mTvInputSessionImpl == null)) {
    return;
  }
  long startTime=System.nanoTime();
switch (msg.what) {
case DO_RELEASE:
{
      if (mIsRecordingSession) {
        mTvInputRecordingSessionImpl.release();
        mTvInputRecordingSessionImpl=null;
      }
 else {
        mTvInputSessionImpl.release();
        mTvInputSessionImpl=null;
        if (mReceiver != null) {
          mReceiver.dispose();
          mReceiver=null;
        }
        if (mChannel != null) {
          mChannel.dispose();
          mChannel=null;
        }
      }
      break;
    }
case DO_SET_MAIN:
{
    mTvInputSessionImpl.setMain((Boolean)msg.obj);
    break;
  }
case DO_SET_SURFACE:
{
  mTvInputSessionImpl.setSurface((Surface)msg.obj);
  break;
}
case DO_DISPATCH_SURFACE_CHANGED:
{
SomeArgs args=(SomeArgs)msg.obj;
mTvInputSessionImpl.dispatchSurfaceChanged(args.argi1,args.argi2,args.argi3);
args.recycle();
break;
}
case DO_SET_STREAM_VOLUME:
{
mTvInputSessionImpl.setStreamVolume((Float)msg.obj);
break;
}
case DO_TUNE:
{
SomeArgs args=(SomeArgs)msg.obj;
if (mIsRecordingSession) {
mTvInputRecordingSessionImpl.tune((Uri)args.arg1,(Bundle)args.arg2);
}
 else {
mTvInputSessionImpl.tune((Uri)args.arg1,(Bundle)args.arg2);
}
args.recycle();
break;
}
case DO_SET_CAPTION_ENABLED:
{
mTvInputSessionImpl.setCaptionEnabled((Boolean)msg.obj);
break;
}
case DO_SELECT_TRACK:
{
SomeArgs args=(SomeArgs)msg.obj;
mTvInputSessionImpl.selectTrack((Integer)args.arg1,(String)args.arg2);
args.recycle();
break;
}
case DO_APP_PRIVATE_COMMAND:
{
SomeArgs args=(SomeArgs)msg.obj;
if (mIsRecordingSession) {
mTvInputRecordingSessionImpl.appPrivateCommand((String)args.arg1,(Bundle)args.arg2);
}
 else {
mTvInputSessionImpl.appPrivateCommand((String)args.arg1,(Bundle)args.arg2);
}
args.recycle();
break;
}
case DO_CREATE_OVERLAY_VIEW:
{
SomeArgs args=(SomeArgs)msg.obj;
mTvInputSessionImpl.createOverlayView((IBinder)args.arg1,(Rect)args.arg2);
args.recycle();
break;
}
case DO_RELAYOUT_OVERLAY_VIEW:
{
mTvInputSessionImpl.relayoutOverlayView((Rect)msg.obj);
break;
}
case DO_REMOVE_OVERLAY_VIEW:
{
mTvInputSessionImpl.removeOverlayView(true);
break;
}
case DO_UNBLOCK_CONTENT:
{
mTvInputSessionImpl.unblockContent((String)msg.obj);
break;
}
case DO_TIME_SHIFT_PLAY:
{
mTvInputSessionImpl.timeShiftPlay((Uri)msg.obj);
break;
}
case DO_TIME_SHIFT_PAUSE:
{
mTvInputSessionImpl.timeShiftPause();
break;
}
case DO_TIME_SHIFT_RESUME:
{
mTvInputSessionImpl.timeShiftResume();
break;
}
case DO_TIME_SHIFT_SEEK_TO:
{
mTvInputSessionImpl.timeShiftSeekTo((Long)msg.obj);
break;
}
case DO_TIME_SHIFT_SET_PLAYBACK_PARAMS:
{
mTvInputSessionImpl.timeShiftSetPlaybackParams((PlaybackParams)msg.obj);
break;
}
case DO_TIME_SHIFT_ENABLE_POSITION_TRACKING:
{
mTvInputSessionImpl.timeShiftEnablePositionTracking((Boolean)msg.obj);
break;
}
case DO_START_RECORDING:
{
mTvInputRecordingSessionImpl.startRecording((Uri)msg.obj);
break;
}
case DO_STOP_RECORDING:
{
mTvInputRecordingSessionImpl.stopRecording();
break;
}
default :
{
Log.w(TAG,"Unhandled message code: " + msg.what);
break;
}
}
long durationMs=(System.nanoTime() - startTime) / (1000 * 1000);
if (durationMs > EXECUTE_MESSAGE_TIMEOUT_SHORT_MILLIS) {
Log.w(TAG,"Handling message (" + msg.what + ") took too long time (duration="+ durationMs+ "ms)");
if (msg.what == DO_TUNE && durationMs > EXECUTE_MESSAGE_TUNE_TIMEOUT_MILLIS) {
throw new RuntimeException("Too much time to handle tune request. (" + durationMs + "ms > "+ EXECUTE_MESSAGE_TUNE_TIMEOUT_MILLIS+ "ms) "+ "Consider handling the tune request in a separate thread.");
}
if (durationMs > EXECUTE_MESSAGE_TIMEOUT_LONG_MILLIS) {
throw new RuntimeException("Too much time to handle a request. (type=" + msg.what + ", "+ durationMs+ "ms > "+ EXECUTE_MESSAGE_TIMEOUT_LONG_MILLIS+ "ms).");
}
}
}
