{
  long start=SystemClock.elapsedRealtime();
  if (DBG) {
    log("NITZ: " + nitz + ","+ nitzReceiveTime+ " start="+ start+ " delay="+ (start - nitzReceiveTime));
  }
  try {
    Calendar c=Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    c.clear();
    c.set(Calendar.DST_OFFSET,0);
    String[] nitzSubs=nitz.split("[/:,+-]");
    int year=2000 + Integer.parseInt(nitzSubs[0]);
    c.set(Calendar.YEAR,year);
    int month=Integer.parseInt(nitzSubs[1]) - 1;
    c.set(Calendar.MONTH,month);
    int date=Integer.parseInt(nitzSubs[2]);
    c.set(Calendar.DATE,date);
    int hour=Integer.parseInt(nitzSubs[3]);
    c.set(Calendar.HOUR,hour);
    int minute=Integer.parseInt(nitzSubs[4]);
    c.set(Calendar.MINUTE,minute);
    int second=Integer.parseInt(nitzSubs[5]);
    c.set(Calendar.SECOND,second);
    boolean sign=(nitz.indexOf('-') == -1);
    int tzOffset=Integer.parseInt(nitzSubs[6]);
    int dst=(nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
    tzOffset=(sign ? 1 : -1) * tzOffset * 15* 60* 1000;
    TimeZone zone=null;
    if (nitzSubs.length >= 9) {
      String tzname=nitzSubs[8].replace('!','/');
      zone=TimeZone.getTimeZone(tzname);
    }
    String iso=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY);
    if (zone == null) {
      if (mGotCountryCode) {
        if (iso != null && iso.length() > 0) {
          zone=TimeUtils.getTimeZone(tzOffset,dst != 0,c.getTimeInMillis(),iso);
        }
 else {
          zone=getNitzTimeZone(tzOffset,(dst != 0),c.getTimeInMillis());
        }
      }
    }
    if (zone == null) {
      mNeedFixZone=true;
      mZoneOffset=tzOffset;
      mZoneDst=dst != 0;
      mZoneTime=c.getTimeInMillis();
    }
    if (zone != null) {
      if (getAutoTimeZone()) {
        setAndBroadcastNetworkSetTimeZone(zone.getID());
      }
      saveNitzTimeZone(zone.getID());
    }
    String ignore=SystemProperties.get("gsm.ignore-nitz");
    if (ignore != null && ignore.equals("yes")) {
      log("NITZ: Not setting clock because gsm.ignore-nitz is set");
      return;
    }
    try {
      mWakeLock.acquire();
      if (getAutoTime()) {
        long millisSinceNitzReceived=SystemClock.elapsedRealtime() - nitzReceiveTime;
        if (millisSinceNitzReceived < 0) {
          if (DBG) {
            log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
          }
          return;
        }
        if (millisSinceNitzReceived > Integer.MAX_VALUE) {
          if (DBG) {
            log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60* 24)) + " days");
          }
          return;
        }
        c.add(Calendar.MILLISECOND,(int)millisSinceNitzReceived);
        if (DBG) {
          log("NITZ: Setting time of day to " + c.getTime() + " NITZ receive delay(ms): "+ millisSinceNitzReceived+ " gained(ms): "+ (c.getTimeInMillis() - System.currentTimeMillis())+ " from "+ nitz);
        }
        setAndBroadcastNetworkSetTime(c.getTimeInMillis());
        Log.i(LOG_TAG,"NITZ: after Setting time of day");
      }
      SystemProperties.set("gsm.nitz.time",String.valueOf(c.getTimeInMillis()));
      saveNitzTime(c.getTimeInMillis());
      if (false) {
        long end=SystemClock.elapsedRealtime();
        log("NITZ: end=" + end + " dur="+ (end - start));
      }
    }
  finally {
      mWakeLock.release();
    }
  }
 catch (  RuntimeException ex) {
    loge("NITZ: Parsing NITZ time " + nitz + " ex="+ ex);
  }
}
