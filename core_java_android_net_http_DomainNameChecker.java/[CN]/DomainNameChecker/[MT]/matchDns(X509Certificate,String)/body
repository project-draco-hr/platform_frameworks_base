{
  boolean hasDns=false;
  try {
    Collection subjectAltNames=certificate.getSubjectAlternativeNames();
    if (subjectAltNames != null) {
      Iterator i=subjectAltNames.iterator();
      while (i.hasNext()) {
        List altNameEntry=(List)(i.next());
        if (altNameEntry != null && 2 <= altNameEntry.size()) {
          Integer altNameType=(Integer)(altNameEntry.get(0));
          if (altNameType != null) {
            if (altNameType.intValue() == ALT_DNS_NAME) {
              hasDns=true;
              String altName=(String)(altNameEntry.get(1));
              if (altName != null) {
                if (matchDns(thisDomain,altName)) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }
 catch (  CertificateParsingException e) {
    if (HttpLog.LOGV) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="failed to parse certificate";
      }
      if (HttpLog.LOGV) {
        HttpLog.v("DomainNameChecker.matchDns(): " + errorMessage);
      }
    }
  }
  if (!hasDns) {
    X509Name xName=new X509Name(certificate.getSubjectDN().getName());
    Vector val=xName.getValues();
    Vector oid=xName.getOIDs();
    for (int i=0; i < oid.size(); i++) {
      if (oid.elementAt(i).equals(X509Name.CN)) {
        return matchDns(thisDomain,(String)(val.elementAt(i)));
      }
    }
  }
  return false;
}
