{
  final JobInfo task1=new Builder(8,mComponent).setRequiresDeviceIdle(true).setPeriodic(10000L).setRequiresCharging(true).setIsPersisted(true).build();
  final JobInfo task2=new Builder(12,mComponent).setMinimumLatency(5000L).setBackoffCriteria(15000L,JobInfo.BackoffPolicy.LINEAR).setOverrideDeadline(30000L).setRequiredNetworkCapabilities(JobInfo.NetworkType.UNMETERED).setIsPersisted(true).build();
  final JobStatus taskStatus1=new JobStatus(task1,SOME_UID);
  final JobStatus taskStatus2=new JobStatus(task2,SOME_UID);
  mTaskStoreUnderTest.add(taskStatus1);
  mTaskStoreUnderTest.add(taskStatus2);
  Thread.sleep(IO_WAIT);
  final ArraySet<JobStatus> jobStatusSet=new ArraySet<JobStatus>();
  mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
  assertEquals("Incorrect # of persisted tasks.",2,jobStatusSet.size());
  Iterator<JobStatus> it=jobStatusSet.iterator();
  JobStatus loaded1=it.next();
  JobStatus loaded2=it.next();
  assertTasksEqual(task1,loaded1.getJob());
  assertTasksEqual(task2,loaded2.getJob());
  compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus1.getEarliestRunTime(),loaded1.getEarliestRunTime());
  compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus1.getLatestRunTimeElapsed(),loaded1.getLatestRunTimeElapsed());
  compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus2.getEarliestRunTime(),loaded2.getEarliestRunTime());
  compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus2.getLatestRunTimeElapsed(),loaded2.getLatestRunTimeElapsed());
}
