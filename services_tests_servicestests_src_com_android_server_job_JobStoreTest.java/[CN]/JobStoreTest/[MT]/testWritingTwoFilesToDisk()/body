{
  final JobInfo task1=new Builder(8,mComponent).setRequiresDeviceIdle(true).setPeriodic(10000L).setRequiresCharging(true).setPersisted(true).build();
  final JobInfo task2=new Builder(12,mComponent).setMinimumLatency(5000L).setBackoffCriteria(15000L,JobInfo.BACKOFF_POLICY_LINEAR).setOverrideDeadline(30000L).setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED).setPersisted(true).build();
  final JobStatus taskStatus1=new JobStatus(this,task1,SOME_UID,null,-1);
  final JobStatus taskStatus2=new JobStatus(this,task2,SOME_UID,null,-1);
  mTaskStoreUnderTest.add(taskStatus1);
  mTaskStoreUnderTest.add(taskStatus2);
  Thread.sleep(IO_WAIT);
  final ArraySet<JobStatus> jobStatusSet=new ArraySet<JobStatus>();
  mTaskStoreUnderTest.readJobMapFromDisk(jobStatusSet);
  assertEquals("Incorrect # of persisted tasks.",2,jobStatusSet.size());
  Iterator<JobStatus> it=jobStatusSet.iterator();
  JobStatus loaded1=it.next();
  JobStatus loaded2=it.next();
  if (loaded1.getJobId() != 8) {
    JobStatus tmp=loaded1;
    loaded1=loaded2;
    loaded2=tmp;
  }
  assertTasksEqual(task1,loaded1.getJob());
  assertTasksEqual(task2,loaded2.getJob());
  assertTrue("JobStore#contains invalid.",mTaskStoreUnderTest.containsJob(taskStatus1));
  assertTrue("JobStore#contains invalid.",mTaskStoreUnderTest.containsJob(taskStatus2));
  compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus1.getEarliestRunTime(),loaded1.getEarliestRunTime());
  compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus1.getLatestRunTimeElapsed(),loaded1.getLatestRunTimeElapsed());
  compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus2.getEarliestRunTime(),loaded2.getEarliestRunTime());
  compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus2.getLatestRunTimeElapsed(),loaded2.getLatestRunTimeElapsed());
}
