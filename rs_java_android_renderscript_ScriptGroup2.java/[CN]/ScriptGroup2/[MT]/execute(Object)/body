{
  if (inputs.length < mInputs.size()) {
    Log.e(TAG,this.toString() + " receives " + inputs.length+ " inputs, "+ "less than expected "+ mInputs.size());
    return null;
  }
  if (inputs.length > mInputs.size()) {
    Log.i(TAG,this.toString() + " receives " + inputs.length+ " inputs, "+ "more than expected "+ mInputs.size());
  }
  for (int i=0; i < mInputs.size(); i++) {
    Object obj=inputs[i];
    if (obj instanceof Future || obj instanceof UnboundValue) {
      Log.e(TAG,this.toString() + ": input " + i+ " is a future or unbound value");
      return null;
    }
    UnboundValue unbound=mInputs.get(i);
    unbound.set(obj);
  }
  mRS.nScriptGroup2Execute(getID(mRS));
  Object[] outputObjs=new Object[mOutputs.length];
  int i=0;
  for (  Future f : mOutputs) {
    outputObjs[i++]=f.getValue();
  }
  return outputObjs;
}
