{
  float d=abs(randomGauss()) * GALAXY_RADIUS / 2.0f;
  particles[index + PARTICLE_STRUCT_ANGLE]=random(0.0f,(float)(Math.PI * 2.0));
  particles[index + PARTICLE_STRUCT_DISTANCE]=d;
  particles[index + PARTICLE_STRUCT_SPEED]=random(0.0015f,0.0025f) * (0.5f + (0.5f * (float)GALAXY_RADIUS / d));
  particles[index + PARTICLE_STRUCT_RADIUS]=random(1.0f,2.1f);
  int red, green, blue;
  if (d < GALAXY_RADIUS / 3.0f) {
    red=(int)(220 + (d / (float)GALAXY_RADIUS) * 35);
    green=220;
    blue=220;
  }
 else {
    red=180;
    green=180;
    blue=(int)constrain(140 + (d / (float)GALAXY_RADIUS) * 115,140,255);
  }
  final int color=0xFF000000 | red | green << 8 | blue << 16;
  final int sprite=random(PARTICLES_TEXTURES_COUNT);
  final float u1=sprite / (float)PARTICLES_TEXTURES_COUNT;
  final float u2=(sprite + 1) / (float)PARTICLES_TEXTURES_COUNT;
  final float[] floatData=mFloatData5;
  final Allocation buffer=mParticlesBuffer;
  floatData[0]=Float.intBitsToFloat(color);
  floatData[3]=u1;
  floatData[4]=1.0f;
  buffer.subData1D(bufferIndex,1,floatData);
  bufferIndex++;
  floatData[3]=u2;
  floatData[4]=1.0f;
  buffer.subData1D(bufferIndex,1,floatData);
  bufferIndex++;
  floatData[3]=u1 + (u2 - u1) / 2.0f;
  floatData[4]=0.0f;
  buffer.subData1D(bufferIndex,1,floatData);
}
