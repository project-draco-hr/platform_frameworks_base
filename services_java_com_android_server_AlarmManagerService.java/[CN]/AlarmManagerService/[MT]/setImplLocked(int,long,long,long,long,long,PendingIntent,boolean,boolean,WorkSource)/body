{
  Alarm a=new Alarm(type,when,whenElapsed,windowLength,maxWhen,interval,operation,workSource);
  removeLocked(operation);
  boolean reschedule;
  int whichBatch=(isStandalone) ? -1 : attemptCoalesceLocked(whenElapsed,maxWhen);
  if (whichBatch < 0) {
    Batch batch=new Batch(a);
    batch.standalone=isStandalone;
    reschedule=addBatchLocked(mAlarmBatches,batch);
  }
 else {
    Batch batch=mAlarmBatches.get(whichBatch);
    reschedule=batch.add(a);
    if (reschedule) {
      mAlarmBatches.remove(whichBatch);
      addBatchLocked(mAlarmBatches,batch);
    }
  }
  if (DEBUG_VALIDATE) {
    if (doValidate && !validateConsistencyLocked()) {
      Slog.v(TAG,"Tipping-point operation: type=" + type + " when="+ when+ " when(hex)="+ Long.toHexString(when)+ " whenElapsed="+ whenElapsed+ " maxWhen="+ maxWhen+ " interval="+ interval+ " op="+ operation+ " standalone="+ isStandalone);
      rebatchAllAlarmsLocked(false);
      reschedule=true;
    }
  }
  if (reschedule) {
    rescheduleKernelAlarmsLocked();
  }
}
