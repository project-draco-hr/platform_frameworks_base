{
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println("Permission Denial: can't dump AlarmManager from from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid());
    return;
  }
synchronized (mLock) {
    pw.println("Current Alarm Manager state:");
    final long nowRTC=System.currentTimeMillis();
    final long nowELAPSED=SystemClock.elapsedRealtime();
    SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    pw.print("nowRTC=");
    pw.print(nowRTC);
    pw.print("=");
    pw.print(sdf.format(new Date(nowRTC)));
    pw.print(" nowELAPSED=");
    pw.println(nowELAPSED);
    long nextWakeupRTC=mNextWakeup + (nowRTC - nowELAPSED);
    long nextNonWakeupRTC=mNextNonWakeup + (nowRTC - nowELAPSED);
    pw.print("Next alarm: ");
    pw.print(mNextNonWakeup);
    pw.print(" = ");
    pw.println(sdf.format(new Date(nextNonWakeupRTC)));
    pw.print("Next wakeup: ");
    pw.print(mNextWakeup);
    pw.print(" = ");
    pw.println(sdf.format(new Date(nextWakeupRTC)));
    if (mAlarmBatches.size() > 0) {
      pw.println();
      pw.print("Pending alarm batches: ");
      pw.println(mAlarmBatches.size());
      for (      Batch b : mAlarmBatches) {
        pw.print(b);
        pw.println(':');
        dumpAlarmList(pw,b.alarms,"  ",nowELAPSED,nowRTC);
      }
    }
    pw.println();
    pw.print("  Broadcast ref count: ");
    pw.println(mBroadcastRefCount);
    pw.println();
    if (mLog.dump(pw,"  Recent problems","    ")) {
      pw.println();
    }
    final FilterStats[] topFilters=new FilterStats[10];
    final Comparator<FilterStats> comparator=new Comparator<FilterStats>(){
      @Override public int compare(      FilterStats lhs,      FilterStats rhs){
        if (lhs.aggregateTime < rhs.aggregateTime) {
          return 1;
        }
 else         if (lhs.aggregateTime > rhs.aggregateTime) {
          return -1;
        }
        return 0;
      }
    }
;
    int len=0;
    for (    Map.Entry<String,BroadcastStats> be : mBroadcastStats.entrySet()) {
      BroadcastStats bs=be.getValue();
      for (      Map.Entry<Pair<String,ComponentName>,FilterStats> fe : bs.filterStats.entrySet()) {
        FilterStats fs=fe.getValue();
        int pos=len > 0 ? Arrays.binarySearch(topFilters,0,len,fs,comparator) : 0;
        if (pos < 0) {
          pos=-pos - 1;
        }
        if (pos < topFilters.length) {
          int copylen=topFilters.length - pos - 1;
          if (copylen > 0) {
            System.arraycopy(topFilters,pos,topFilters,pos + 1,copylen);
          }
          topFilters[pos]=fs;
          if (len < topFilters.length) {
            len++;
          }
        }
      }
    }
    if (len > 0) {
      pw.println("  Top Alarms:");
      for (int i=0; i < len; i++) {
        FilterStats fs=topFilters[i];
        pw.print("    ");
        if (fs.nesting > 0)         pw.print("*ACTIVE* ");
        TimeUtils.formatDuration(fs.aggregateTime,pw);
        pw.print(" running, ");
        pw.print(fs.numWakeup);
        pw.print(" wakeups, ");
        pw.print(fs.count);
        pw.print(" alarms: ");
        pw.print(fs.mBroadcastStats.mPackageName);
        pw.println();
        pw.print("      ");
        if (fs.mTarget.first != null) {
          pw.print(" act=");
          pw.print(fs.mTarget.first);
        }
        if (fs.mTarget.second != null) {
          pw.print(" cmp=");
          pw.print(fs.mTarget.second.toShortString());
        }
        pw.println();
      }
    }
    pw.println(" ");
    pw.println("  Alarm Stats:");
    final ArrayList<FilterStats> tmpFilters=new ArrayList<FilterStats>();
    for (    Map.Entry<String,BroadcastStats> be : mBroadcastStats.entrySet()) {
      BroadcastStats bs=be.getValue();
      pw.print("  ");
      if (bs.nesting > 0)       pw.print("*ACTIVE* ");
      pw.print(be.getKey());
      pw.print(" ");
      TimeUtils.formatDuration(bs.aggregateTime,pw);
      pw.print(" running, ");
      pw.print(bs.numWakeup);
      pw.println(" wakeups:");
      tmpFilters.clear();
      for (      Map.Entry<Pair<String,ComponentName>,FilterStats> fe : bs.filterStats.entrySet()) {
        tmpFilters.add(fe.getValue());
      }
      Collections.sort(tmpFilters,comparator);
      for (int i=0; i < tmpFilters.size(); i++) {
        FilterStats fs=tmpFilters.get(i);
        pw.print("    ");
        if (fs.nesting > 0)         pw.print("*ACTIVE* ");
        TimeUtils.formatDuration(fs.aggregateTime,pw);
        pw.print(" ");
        pw.print(fs.numWakeup);
        pw.print(" wakes ");
        pw.print(fs.count);
        pw.print(" alarms:");
        if (fs.mTarget.first != null) {
          pw.print(" act=");
          pw.print(fs.mTarget.first);
        }
        if (fs.mTarget.second != null) {
          pw.print(" cmp=");
          pw.print(fs.mTarget.second.toShortString());
        }
        pw.println();
      }
    }
    if (WAKEUP_STATS) {
      pw.println();
      pw.println("  Recent Wakeup History:");
      long last=-1;
      for (      WakeupEvent event : mRecentWakeups) {
        pw.print("    ");
        pw.print(sdf.format(new Date(event.when)));
        pw.print('|');
        if (last < 0) {
          pw.print('0');
        }
 else {
          pw.print(event.when - last);
        }
        last=event.when;
        pw.print('|');
        pw.print(event.uid);
        pw.print('|');
        pw.print(event.action);
        pw.println();
      }
      pw.println();
    }
  }
}
