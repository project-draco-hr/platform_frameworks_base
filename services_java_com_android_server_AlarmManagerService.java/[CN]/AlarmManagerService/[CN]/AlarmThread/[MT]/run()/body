{
  ArrayList<Alarm> triggerList=new ArrayList<Alarm>();
  while (true) {
    int result=waitForAlarm(mDescriptor);
    triggerList.clear();
    if ((result & TIME_CHANGED_MASK) != 0) {
      if (DEBUG_BATCH) {
        Slog.v(TAG,"Time changed notification from kernel; rebatching");
      }
      remove(mTimeTickSender);
      rebatchAllAlarms();
      mClockReceiver.scheduleTimeTickEvent();
      Intent intent=new Intent(Intent.ACTION_TIME_CHANGED);
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcastAsUser(intent,UserHandle.ALL);
    }
synchronized (mLock) {
      final long nowRTC=System.currentTimeMillis();
      final long nowELAPSED=SystemClock.elapsedRealtime();
      if (localLOGV)       Slog.v(TAG,"Checking for alarms... rtc=" + nowRTC + ", elapsed="+ nowELAPSED);
      if (WAKEUP_STATS) {
        if ((result & IS_WAKEUP_MASK) != 0) {
          long newEarliest=nowRTC - RECENT_WAKEUP_PERIOD;
          int n=0;
          for (          WakeupEvent event : mRecentWakeups) {
            if (event.when > newEarliest)             break;
            n++;
          }
          for (int i=0; i < n; i++) {
            mRecentWakeups.remove();
          }
          recordWakeupAlarms(mAlarmBatches,nowELAPSED,nowRTC);
        }
      }
      triggerAlarmsLocked(triggerList,nowELAPSED,nowRTC);
      rescheduleKernelAlarmsLocked();
      for (int i=0; i < triggerList.size(); i++) {
        Alarm alarm=triggerList.get(i);
        try {
          if (localLOGV)           Slog.v(TAG,"sending alarm " + alarm);
          alarm.operation.send(mContext,0,mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT,alarm.count),mResultReceiver,mHandler);
          if (mBroadcastRefCount == 0) {
            setWakelockWorkSource(alarm.operation,alarm.workSource);
            mWakeLock.acquire();
          }
          final InFlight inflight=new InFlight(AlarmManagerService.this,alarm.operation,alarm.workSource);
          mInFlight.add(inflight);
          mBroadcastRefCount++;
          final BroadcastStats bs=inflight.mBroadcastStats;
          bs.count++;
          if (bs.nesting == 0) {
            bs.nesting=1;
            bs.startTime=nowELAPSED;
          }
 else {
            bs.nesting++;
          }
          final FilterStats fs=inflight.mFilterStats;
          fs.count++;
          if (fs.nesting == 0) {
            fs.nesting=1;
            fs.startTime=nowELAPSED;
          }
 else {
            fs.nesting++;
          }
          if (alarm.type == ELAPSED_REALTIME_WAKEUP || alarm.type == RTC_WAKEUP) {
            bs.numWakeup++;
            fs.numWakeup++;
            ActivityManagerNative.noteWakeupAlarm(alarm.operation);
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (alarm.repeatInterval > 0) {
            remove(alarm.operation);
          }
        }
catch (        RuntimeException e) {
          Slog.w(TAG,"Failure sending alarm.",e);
        }
      }
    }
  }
}
