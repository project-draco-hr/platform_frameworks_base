{
  while (true) {
    int result=waitForAlarm(mDescriptor);
    ArrayList<Alarm> triggerList=new ArrayList<Alarm>();
    if ((result & TIME_CHANGED_MASK) != 0) {
      remove(mTimeTickSender);
      mClockReceiver.scheduleTimeTickEvent();
      Intent intent=new Intent(Intent.ACTION_TIME_CHANGED);
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
      mContext.sendBroadcast(intent);
    }
synchronized (mLock) {
      final long nowRTC=System.currentTimeMillis();
      final long nowELAPSED=SystemClock.elapsedRealtime();
      if (localLOGV)       Slog.v(TAG,"Checking for alarms... rtc=" + nowRTC + ", elapsed="+ nowELAPSED);
      if ((result & RTC_WAKEUP_MASK) != 0)       triggerAlarmsLocked(mRtcWakeupAlarms,triggerList,nowRTC);
      if ((result & RTC_MASK) != 0)       triggerAlarmsLocked(mRtcAlarms,triggerList,nowRTC);
      if ((result & ELAPSED_REALTIME_WAKEUP_MASK) != 0)       triggerAlarmsLocked(mElapsedRealtimeWakeupAlarms,triggerList,nowELAPSED);
      if ((result & ELAPSED_REALTIME_MASK) != 0)       triggerAlarmsLocked(mElapsedRealtimeAlarms,triggerList,nowELAPSED);
      Iterator<Alarm> it=triggerList.iterator();
      while (it.hasNext()) {
        Alarm alarm=it.next();
        try {
          if (localLOGV)           Slog.v(TAG,"sending alarm " + alarm);
          alarm.operation.send(mContext,0,mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT,alarm.count),mResultReceiver,mHandler);
          if (mBroadcastRefCount == 0) {
            mWakeLock.acquire();
          }
          mBroadcastRefCount++;
          BroadcastStats bs=getStatsLocked(alarm.operation);
          if (bs.nesting == 0) {
            bs.startTime=nowELAPSED;
          }
 else {
            bs.nesting++;
          }
          if (alarm.type == AlarmManager.ELAPSED_REALTIME_WAKEUP || alarm.type == AlarmManager.RTC_WAKEUP) {
            bs.numWakeup++;
            ActivityManagerNative.noteWakeupAlarm(alarm.operation);
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (alarm.repeatInterval > 0) {
            remove(alarm.operation);
          }
        }
catch (        RuntimeException e) {
          Slog.w(TAG,"Failure sending alarm.",e);
        }
      }
    }
  }
}
