{
  ArrayList<String> directories=new ArrayList<String>();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> plugins=pm.queryIntentServices(new Intent(PLUGIN_ACTION),PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
synchronized (mPluginInfoCache) {
    mPluginInfoCache.clear();
    for (    ResolveInfo info : plugins) {
      ServiceInfo serviceInfo=info.serviceInfo;
      if (serviceInfo == null) {
        Log.w(LOGTAG,"Ignore bad plugin");
        continue;
      }
      PackageInfo pkgInfo;
      try {
        pkgInfo=pm.getPackageInfo(serviceInfo.packageName,PackageManager.GET_PERMISSIONS | PackageManager.GET_SIGNATURES);
      }
 catch (      NameNotFoundException e) {
        Log.w(LOGTAG,"Can't find plugin: " + serviceInfo.packageName);
        continue;
      }
      if (pkgInfo == null) {
        continue;
      }
      String directory=pkgInfo.applicationInfo.dataDir + "/lib";
      if (directories.contains(directory)) {
        continue;
      }
      String permissions[]=pkgInfo.requestedPermissions;
      if (permissions == null) {
        continue;
      }
      boolean permissionOk=false;
      for (      String permit : permissions) {
        if (PLUGIN_PERMISSION.equals(permit)) {
          permissionOk=true;
          break;
        }
      }
      if (!permissionOk) {
        continue;
      }
      Signature signatures[]=pkgInfo.signatures;
      if (signatures == null) {
        continue;
      }
      if (SystemProperties.getBoolean("ro.secure",false)) {
        boolean signatureMatch=false;
        for (        Signature signature : signatures) {
          for (int i=0; i < SIGNATURES.length; i++) {
            if (SIGNATURES[i].equals(signature)) {
              signatureMatch=true;
              break;
            }
          }
        }
        if (!signatureMatch) {
          continue;
        }
      }
      PluginInfo pluginInfo=new PluginInfo();
      pluginInfo.packageInfo=pkgInfo;
      if (serviceInfo.metaData == null) {
        Log.e(LOGTAG,"The plugin '" + serviceInfo.name + "' has no type defined");
        continue;
      }
      String pluginType=serviceInfo.metaData.getString(PLUGIN_TYPE);
      if (TYPE_NATIVE.equals(pluginType)) {
        pluginInfo.isNative=true;
      }
 else {
        Log.e(LOGTAG,"Unrecognized plugin type: " + pluginType);
        continue;
      }
      try {
        Class<?> cls=getPluginClass(serviceInfo.packageName,serviceInfo.name);
        boolean classFound=false;
        for (        Class<?> implemented : cls.getInterfaces()) {
          if (pluginInfo.isNative && implemented.equals(NativePlugin.class)) {
            pluginInfo.pluginClass=cls.asSubclass(WebkitPlugin.class);
            classFound=true;
            break;
          }
        }
        if (!classFound) {
          Log.e(LOGTAG,"The plugin's class'" + serviceInfo.name + "' does not extend the appropriate interface.");
          continue;
        }
      }
 catch (      NameNotFoundException e) {
        Log.e(LOGTAG,"Can't find plugin: " + serviceInfo.packageName);
        continue;
      }
catch (      ClassNotFoundException e) {
        Log.e(LOGTAG,"Can't find plugin's class: " + serviceInfo.name);
        continue;
      }
      mPluginInfoCache.add(pluginInfo);
      directories.add(directory);
    }
  }
  return directories.toArray(new String[directories.size()]);
}
