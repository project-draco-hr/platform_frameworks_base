{
  for (int i=mPorts.size(); i-- > 0; ) {
    mPorts.valueAt(i).mDisposition=PortInfo.DISPOSITION_REMOVED;
  }
  if (!mSimulatedPorts.isEmpty()) {
    final int count=mSimulatedPorts.size();
    for (int i=0; i < count; i++) {
      final SimulatedPortInfo portInfo=mSimulatedPorts.valueAt(i);
      addOrUpdatePortLocked(portInfo.mPortId,portInfo.mSupportedModes,portInfo.mCurrentMode,portInfo.mCanChangeMode,portInfo.mCurrentPowerRole,portInfo.mCanChangePowerRole,portInfo.mCurrentDataRole,portInfo.mCanChangeDataRole,pw);
    }
  }
 else   if (mHaveKernelSupport) {
    final File[] portDirs=new File(SYSFS_CLASS).listFiles();
    if (portDirs != null) {
      for (      File portDir : portDirs) {
        if (!portDir.isDirectory()) {
          continue;
        }
        final String portId=portDir.getName();
        final int supportedModes=readSupportedModes(portDir);
        final int currentMode=readCurrentMode(portDir);
        final boolean canChangeMode=canChangeMode(portDir);
        final int currentPowerRole=readCurrentPowerRole(portDir);
        final boolean canChangePowerRole=canChangePowerRole(portDir);
        final int currentDataRole=readCurrentDataRole(portDir);
        final boolean canChangeDataRole=canChangeDataRole(portDir);
        addOrUpdatePortLocked(portId,supportedModes,currentMode,canChangeMode,currentPowerRole,canChangePowerRole,currentDataRole,canChangeDataRole,pw);
      }
    }
  }
  for (int i=mPorts.size(); i-- > 0; ) {
    final PortInfo portInfo=mPorts.valueAt(i);
switch (portInfo.mDisposition) {
case PortInfo.DISPOSITION_ADDED:
      handlePortAddedLocked(portInfo,pw);
    portInfo.mDisposition=PortInfo.DISPOSITION_READY;
  break;
case PortInfo.DISPOSITION_CHANGED:
handlePortChangedLocked(portInfo,pw);
portInfo.mDisposition=PortInfo.DISPOSITION_READY;
break;
case PortInfo.DISPOSITION_REMOVED:
mPorts.removeAt(i);
portInfo.mUsbPortStatus=null;
handlePortRemovedLocked(portInfo,pw);
break;
}
}
}
