{
  final SessionState sessionState=getUserStateLocked(userId).sessionStateMap.get(sessionToken);
  if (DEBUG) {
    Slog.d(TAG,"createSessionInternalLocked(name=" + sessionState.name.getClassName() + ")");
  }
  final InputChannel[] channels=InputChannel.openInputChannelPair(sessionToken.toString());
  ITvInputSessionCallback callback=new ITvInputSessionCallback.Stub(){
    @Override public void onSessionCreated(    ITvInputSession session){
      if (DEBUG) {
        Slog.d(TAG,"onSessionCreated(name=" + sessionState.name.getClassName() + ")");
      }
synchronized (mLock) {
        sessionState.session=session;
        if (session == null) {
          removeSessionStateLocked(sessionToken,userId);
          sendSessionTokenToClientLocked(sessionState.client,sessionState.name,null,null,sessionState.seq,userId);
        }
 else {
          sendSessionTokenToClientLocked(sessionState.client,sessionState.name,sessionToken,channels[0],sessionState.seq,userId);
        }
        channels[0].dispose();
      }
    }
  }
;
  try {
    service.createSession(channels[1],callback);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,"error in createSession",e);
    removeSessionStateLocked(sessionToken,userId);
    sendSessionTokenToClientLocked(sessionState.client,sessionState.name,null,null,sessionState.seq,userId);
  }
  channels[1].dispose();
}
