{
  final SessionState sessionState=getUserStateLocked(userId).sessionStateMap.get(sessionToken);
  if (DEBUG) {
    Slog.d(TAG,"createSessionInternalLocked(inputId=" + sessionState.mInputId + ")");
  }
  final InputChannel[] channels=InputChannel.openInputChannelPair(sessionToken.toString());
  ITvInputSessionCallback callback=new ITvInputSessionCallback.Stub(){
    @Override public void onSessionCreated(    ITvInputSession session){
      if (DEBUG) {
        Slog.d(TAG,"onSessionCreated(inputId=" + sessionState.mInputId + ")");
      }
synchronized (mLock) {
        sessionState.mSession=session;
        if (session == null) {
          removeSessionStateLocked(sessionToken,userId);
          sendSessionTokenToClientLocked(sessionState.mClient,sessionState.mInputId,null,null,sessionState.mSeq,userId);
        }
 else {
          try {
            session.asBinder().linkToDeath(sessionState,0);
          }
 catch (          RemoteException e) {
            Slog.e(TAG,"Session is already died.");
          }
          sendSessionTokenToClientLocked(sessionState.mClient,sessionState.mInputId,sessionToken,channels[0],sessionState.mSeq,userId);
        }
        channels[0].dispose();
      }
    }
  }
;
  try {
    service.createSession(channels[1],callback);
  }
 catch (  RemoteException e) {
    Slog.e(TAG,"error in createSession",e);
    removeSessionStateLocked(sessionToken,userId);
    sendSessionTokenToClientLocked(sessionState.mClient,sessionState.mInputId,null,null,sessionState.mSeq,userId);
  }
  channels[1].dispose();
}
