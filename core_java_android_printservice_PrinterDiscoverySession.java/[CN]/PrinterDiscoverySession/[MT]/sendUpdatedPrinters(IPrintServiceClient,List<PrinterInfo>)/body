{
  try {
    final int printerCount=printers.size();
    if (printerCount <= MAX_ITEMS_PER_CALLBACK) {
      observer.onPrintersUpdated(printers);
    }
 else {
      final int transactionCount=(printerCount / MAX_ITEMS_PER_CALLBACK) + 1;
      for (int i=0; i < transactionCount; i++) {
        final int start=i * MAX_ITEMS_PER_CALLBACK;
        final int end=Math.min(start + MAX_ITEMS_PER_CALLBACK,printerCount);
        List<PrinterInfo> subPrinters=printers.subList(start,end);
        observer.onPrintersUpdated(subPrinters);
      }
    }
  }
 catch (  RemoteException re) {
    Log.e(LOG_TAG,"Error sending updated printers",re);
  }
}
