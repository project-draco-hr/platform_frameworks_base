{
  long timeMillis=System.currentTimeMillis();
  String shortMsg=crashInfo.exceptionClassName;
  String longMsg=crashInfo.exceptionMessage;
  String stackTrace=crashInfo.stackTrace;
  if (shortMsg != null && longMsg != null) {
    longMsg=shortMsg + ": " + longMsg;
  }
 else   if (shortMsg != null) {
    longMsg=shortMsg;
  }
  AppErrorResult result=new AppErrorResult();
  TaskRecord task;
synchronized (mService) {
    if (mService.mController != null) {
      try {
        String name=r != null ? r.processName : null;
        int pid=r != null ? r.pid : Binder.getCallingPid();
        int uid=r != null ? r.info.uid : Binder.getCallingUid();
        if (!mService.mController.appCrashed(name,pid,shortMsg,longMsg,timeMillis,crashInfo.stackTrace)) {
          if ("1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE,"0")) && "Native crash".equals(crashInfo.exceptionClassName)) {
            Slog.w(TAG,"Skip killing native crashed app " + name + "("+ pid+ ") during testing");
          }
 else {
            Slog.w(TAG,"Force-killing crashed app " + name + " at watcher's request");
            if (r != null) {
              r.kill("crash",true);
            }
 else {
              Process.killProcess(pid);
              ActivityManagerService.killProcessGroup(uid,pid);
            }
          }
          return;
        }
      }
 catch (      RemoteException e) {
        mService.mController=null;
        Watchdog.getInstance().setActivityController(null);
      }
    }
    final long origId=Binder.clearCallingIdentity();
    if (r != null && r.instrumentationClass != null) {
      Slog.w(TAG,"Error in app " + r.processName + " running instrumentation "+ r.instrumentationClass+ ":");
      if (shortMsg != null)       Slog.w(TAG,"  " + shortMsg);
      if (longMsg != null)       Slog.w(TAG,"  " + longMsg);
      Bundle info=new Bundle();
      info.putString("shortMsg",shortMsg);
      info.putString("longMsg",longMsg);
      mService.finishInstrumentationLocked(r,Activity.RESULT_CANCELED,info);
      Binder.restoreCallingIdentity(origId);
      return;
    }
    if (r != null) {
      mService.mBatteryStatsService.noteProcessCrash(r.processName,r.uid);
    }
    AppErrorDialog.Data data=new AppErrorDialog.Data();
    data.result=result;
    data.proc=r;
    if (r == null || !makeAppCrashingLocked(r,shortMsg,longMsg,stackTrace,data)) {
      Binder.restoreCallingIdentity(origId);
      return;
    }
    Message msg=Message.obtain();
    msg.what=ActivityManagerService.SHOW_ERROR_UI_MSG;
    task=data.task;
    msg.obj=data;
    mService.mUiHandler.sendMessage(msg);
    Binder.restoreCallingIdentity(origId);
  }
  int res=result.get();
  Intent appErrorIntent=null;
  final long ident=Binder.clearCallingIdentity();
  try {
    MetricsLogger.action(mContext,MetricsProto.MetricsEvent.ACTION_APP_CRASH,res);
    if (res == AppErrorDialog.TIMEOUT) {
      res=AppErrorDialog.FORCE_QUIT;
    }
    if (res == AppErrorDialog.RESET) {
      String[] packageList=r.getPackageList();
      if (packageList != null) {
        PackageManager pm=mContext.getPackageManager();
        final Semaphore s=new Semaphore(0);
        for (int i=0; i < packageList.length; i++) {
          if (i < packageList.length - 1) {
            pm.deleteApplicationCacheFiles(packageList[i],null);
          }
 else {
            pm.deleteApplicationCacheFiles(packageList[i],new IPackageDataObserver.Stub(){
              @Override public void onRemoveCompleted(              String packageName,              boolean succeeded){
                s.release();
              }
            }
);
            try {
              s.acquire();
            }
 catch (            InterruptedException e) {
            }
          }
        }
      }
      res=AppErrorDialog.RESTART;
    }
synchronized (mService) {
      if (res == AppErrorDialog.MUTE) {
        stopReportingCrashesLocked(r);
      }
      if (res == AppErrorDialog.RESTART) {
        mService.removeProcessLocked(r,false,true,"crash");
        if (task != null) {
          try {
            mService.startActivityFromRecents(task.taskId,ActivityOptions.makeBasic().toBundle());
          }
 catch (          IllegalArgumentException e) {
            if (task.intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
              mService.startActivityInPackage(task.mCallingUid,task.mCallingPackage,task.intent,null,null,null,0,0,ActivityOptions.makeBasic().toBundle(),task.userId,null,null);
            }
          }
        }
      }
      if (res == AppErrorDialog.FORCE_QUIT) {
        long orig=Binder.clearCallingIdentity();
        try {
          mService.mStackSupervisor.handleAppCrashLocked(r);
          if (!r.persistent) {
            mService.removeProcessLocked(r,false,false,"crash");
            mService.mStackSupervisor.resumeFocusedStackTopActivityLocked();
          }
        }
  finally {
          Binder.restoreCallingIdentity(orig);
        }
      }
      if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) {
        appErrorIntent=createAppErrorIntentLocked(r,timeMillis,crashInfo);
      }
      if (r != null && !r.isolated && res != AppErrorDialog.RESTART) {
        mProcessCrashTimes.put(r.info.processName,r.uid,SystemClock.uptimeMillis());
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  if (appErrorIntent != null) {
    try {
      mContext.startActivityAsUser(appErrorIntent,new UserHandle(r.userId));
    }
 catch (    ActivityNotFoundException e) {
      Slog.w(TAG,"bug report receiver dissappeared",e);
    }
  }
}
