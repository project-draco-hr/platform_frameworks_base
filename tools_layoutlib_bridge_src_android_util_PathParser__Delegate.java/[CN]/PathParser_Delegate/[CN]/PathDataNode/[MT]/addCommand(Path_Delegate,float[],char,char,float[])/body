{
  int incr=2;
  float currentX=current[0];
  float currentY=current[1];
  float ctrlPointX=current[2];
  float ctrlPointY=current[3];
  float currentSegmentStartX=current[4];
  float currentSegmentStartY=current[5];
  float reflectiveCtrlPointX;
  float reflectiveCtrlPointY;
switch (cmd) {
case 'z':
case 'Z':
    path.close();
  currentX=currentSegmentStartX;
currentY=currentSegmentStartY;
ctrlPointX=currentSegmentStartX;
ctrlPointY=currentSegmentStartY;
path.moveTo(currentX,currentY);
break;
case 'm':
case 'M':
case 'l':
case 'L':
case 't':
case 'T':
incr=2;
break;
case 'h':
case 'H':
case 'v':
case 'V':
incr=1;
break;
case 'c':
case 'C':
incr=6;
break;
case 's':
case 'S':
case 'q':
case 'Q':
incr=4;
break;
case 'a':
case 'A':
incr=7;
break;
}
for (int k=0; k < val.length; k+=incr) {
switch (cmd) {
case 'm':
currentX+=val[k + 0];
currentY+=val[k + 1];
if (k > 0) {
path.rLineTo(val[k + 0],val[k + 1]);
}
 else {
path.rMoveTo(val[k + 0],val[k + 1]);
currentSegmentStartX=currentX;
currentSegmentStartY=currentY;
}
break;
case 'M':
currentX=val[k + 0];
currentY=val[k + 1];
if (k > 0) {
path.lineTo(val[k + 0],val[k + 1]);
}
 else {
path.moveTo(val[k + 0],val[k + 1]);
currentSegmentStartX=currentX;
currentSegmentStartY=currentY;
}
break;
case 'l':
path.rLineTo(val[k + 0],val[k + 1]);
currentX+=val[k + 0];
currentY+=val[k + 1];
break;
case 'L':
path.lineTo(val[k + 0],val[k + 1]);
currentX=val[k + 0];
currentY=val[k + 1];
break;
case 'h':
path.rLineTo(val[k + 0],0);
currentX+=val[k + 0];
break;
case 'H':
path.lineTo(val[k + 0],currentY);
currentX=val[k + 0];
break;
case 'v':
path.rLineTo(0,val[k + 0]);
currentY+=val[k + 0];
break;
case 'V':
path.lineTo(currentX,val[k + 0]);
currentY=val[k + 0];
break;
case 'c':
path.rCubicTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3],val[k + 4],val[k + 5]);
ctrlPointX=currentX + val[k + 2];
ctrlPointY=currentY + val[k + 3];
currentX+=val[k + 4];
currentY+=val[k + 5];
break;
case 'C':
path.cubicTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3],val[k + 4],val[k + 5]);
currentX=val[k + 4];
currentY=val[k + 5];
ctrlPointX=val[k + 2];
ctrlPointY=val[k + 3];
break;
case 's':
reflectiveCtrlPointX=0;
reflectiveCtrlPointY=0;
if (previousCmd == 'c' || previousCmd == 's' || previousCmd == 'C' || previousCmd == 'S') {
reflectiveCtrlPointX=currentX - ctrlPointX;
reflectiveCtrlPointY=currentY - ctrlPointY;
}
path.rCubicTo(reflectiveCtrlPointX,reflectiveCtrlPointY,val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
ctrlPointX=currentX + val[k + 0];
ctrlPointY=currentY + val[k + 1];
currentX+=val[k + 2];
currentY+=val[k + 3];
break;
case 'S':
reflectiveCtrlPointX=currentX;
reflectiveCtrlPointY=currentY;
if (previousCmd == 'c' || previousCmd == 's' || previousCmd == 'C' || previousCmd == 'S') {
reflectiveCtrlPointX=2 * currentX - ctrlPointX;
reflectiveCtrlPointY=2 * currentY - ctrlPointY;
}
path.cubicTo(reflectiveCtrlPointX,reflectiveCtrlPointY,val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
ctrlPointX=val[k + 0];
ctrlPointY=val[k + 1];
currentX=val[k + 2];
currentY=val[k + 3];
break;
case 'q':
path.rQuadTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
ctrlPointX=currentX + val[k + 0];
ctrlPointY=currentY + val[k + 1];
currentX+=val[k + 2];
currentY+=val[k + 3];
break;
case 'Q':
path.quadTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
ctrlPointX=val[k + 0];
ctrlPointY=val[k + 1];
currentX=val[k + 2];
currentY=val[k + 3];
break;
case 't':
reflectiveCtrlPointX=0;
reflectiveCtrlPointY=0;
if (previousCmd == 'q' || previousCmd == 't' || previousCmd == 'Q' || previousCmd == 'T') {
reflectiveCtrlPointX=currentX - ctrlPointX;
reflectiveCtrlPointY=currentY - ctrlPointY;
}
path.rQuadTo(reflectiveCtrlPointX,reflectiveCtrlPointY,val[k + 0],val[k + 1]);
ctrlPointX=currentX + reflectiveCtrlPointX;
ctrlPointY=currentY + reflectiveCtrlPointY;
currentX+=val[k + 0];
currentY+=val[k + 1];
break;
case 'T':
reflectiveCtrlPointX=currentX;
reflectiveCtrlPointY=currentY;
if (previousCmd == 'q' || previousCmd == 't' || previousCmd == 'Q' || previousCmd == 'T') {
reflectiveCtrlPointX=2 * currentX - ctrlPointX;
reflectiveCtrlPointY=2 * currentY - ctrlPointY;
}
path.quadTo(reflectiveCtrlPointX,reflectiveCtrlPointY,val[k + 0],val[k + 1]);
ctrlPointX=reflectiveCtrlPointX;
ctrlPointY=reflectiveCtrlPointY;
currentX=val[k + 0];
currentY=val[k + 1];
break;
case 'a':
drawArc(path,currentX,currentY,val[k + 5] + currentX,val[k + 6] + currentY,val[k + 0],val[k + 1],val[k + 2],val[k + 3] != 0,val[k + 4] != 0);
currentX+=val[k + 5];
currentY+=val[k + 6];
ctrlPointX=currentX;
ctrlPointY=currentY;
break;
case 'A':
drawArc(path,currentX,currentY,val[k + 5],val[k + 6],val[k + 0],val[k + 1],val[k + 2],val[k + 3] != 0,val[k + 4] != 0);
currentX=val[k + 5];
currentY=val[k + 6];
ctrlPointX=currentX;
ctrlPointY=currentY;
break;
}
previousCmd=cmd;
}
current[0]=currentX;
current[1]=currentY;
current[2]=ctrlPointX;
current[3]=ctrlPointY;
current[4]=currentSegmentStartX;
current[5]=currentSegmentStartY;
}
