{
  int incr=2;
  float cx=current[0];
  float cy=current[1];
  float cpx=current[2];
  float cpy=current[3];
  float loopX=current[4];
  float loopY=current[5];
switch (cmd) {
case 'z':
case 'Z':
    path.closePath();
  cx=loopX;
cy=loopY;
case 'm':
case 'M':
case 'l':
case 'L':
case 't':
case 'T':
incr=2;
break;
case 'h':
case 'H':
case 'v':
case 'V':
incr=1;
break;
case 'c':
case 'C':
incr=6;
break;
case 's':
case 'S':
case 'q':
case 'Q':
incr=4;
break;
case 'a':
case 'A':
incr=7;
}
for (int k=0; k < val.length; k+=incr) {
boolean reflectCtrl;
float tempReflectedX, tempReflectedY;
switch (cmd) {
case 'm':
cx+=val[k + 0];
cy+=val[k + 1];
if (k > 0) {
path.lineTo(cx,cy);
}
 else {
path.moveTo(cx,cy);
loopX=cx;
loopY=cy;
}
break;
case 'M':
cx=val[k + 0];
cy=val[k + 1];
if (k > 0) {
path.lineTo(cx,cy);
}
 else {
path.moveTo(cx,cy);
loopX=cx;
loopY=cy;
}
break;
case 'l':
cx+=val[k + 0];
cy+=val[k + 1];
path.lineTo(cx,cy);
break;
case 'L':
cx=val[k + 0];
cy=val[k + 1];
path.lineTo(cx,cy);
break;
case 'z':
case 'Z':
path.closePath();
cx=loopX;
cy=loopY;
break;
case 'h':
cx+=val[k + 0];
path.lineTo(cx,cy);
break;
case 'H':
path.lineTo(val[k + 0],cy);
cx=val[k + 0];
break;
case 'v':
cy+=val[k + 0];
path.lineTo(cx,cy);
break;
case 'V':
path.lineTo(cx,val[k + 0]);
cy=val[k + 0];
break;
case 'c':
path.curveTo(cx + val[k + 0],cy + val[k + 1],cx + val[k + 2],cy + val[k + 3],cx + val[k + 4],cy + val[k + 5]);
cpx=cx + val[k + 2];
cpy=cy + val[k + 3];
cx+=val[k + 4];
cy+=val[k + 5];
break;
case 'C':
path.curveTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3],val[k + 4],val[k + 5]);
cx=val[k + 4];
cy=val[k + 5];
cpx=val[k + 2];
cpy=val[k + 3];
break;
case 's':
reflectCtrl=(lastCmd == 'c' || lastCmd == 's' || lastCmd == 'C' || lastCmd == 'S');
path.curveTo(reflectCtrl ? 2 * cx - cpx : cx,reflectCtrl ? 2 * cy - cpy : cy,cx + val[k + 0],cy + val[k + 1],cx + val[k + 2],cy + val[k + 3]);
cpx=cx + val[k + 0];
cpy=cy + val[k + 1];
cx+=val[k + 2];
cy+=val[k + 3];
break;
case 'S':
reflectCtrl=(lastCmd == 'c' || lastCmd == 's' || lastCmd == 'C' || lastCmd == 'S');
path.curveTo(reflectCtrl ? 2 * cx - cpx : cx,reflectCtrl ? 2 * cy - cpy : cy,val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
cpx=(val[k + 0]);
cpy=(val[k + 1]);
cx=val[k + 2];
cy=val[k + 3];
break;
case 'q':
path.quadTo(cx + val[k + 0],cy + val[k + 1],cx + val[k + 2],cy + val[k + 3]);
cpx=cx + val[k + 0];
cpy=cy + val[k + 1];
cx+=val[k + 2];
cy+=val[k + 3];
break;
case 'Q':
path.quadTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
cx=val[k + 2];
cy=val[k + 3];
cpx=val[k + 0];
cpy=val[k + 1];
break;
case 't':
reflectCtrl=(lastCmd == 'q' || lastCmd == 't' || lastCmd == 'Q' || lastCmd == 'T');
tempReflectedX=reflectCtrl ? 2 * cx - cpx : cx;
tempReflectedY=reflectCtrl ? 2 * cy - cpy : cy;
path.quadTo(tempReflectedX,tempReflectedY,cx + val[k + 0],cy + val[k + 1]);
cpx=tempReflectedX;
cpy=tempReflectedY;
cx+=val[k + 0];
cy+=val[k + 1];
break;
case 'T':
reflectCtrl=(lastCmd == 'q' || lastCmd == 't' || lastCmd == 'Q' || lastCmd == 'T');
tempReflectedX=reflectCtrl ? 2 * cx - cpx : cx;
tempReflectedY=reflectCtrl ? 2 * cy - cpy : cy;
path.quadTo(tempReflectedX,tempReflectedY,val[k + 0],val[k + 1]);
cx=val[k + 0];
cy=val[k + 1];
cpx=tempReflectedX;
cpy=tempReflectedY;
break;
case 'a':
drawArc(path,cx,cy,val[k + 5] + cx,val[k + 6] + cy,val[k + 0],val[k + 1],val[k + 2],val[k + 3] != 0,val[k + 4] != 0);
cx+=val[k + 5];
cy+=val[k + 6];
cpx=cx;
cpy=cy;
break;
case 'A':
drawArc(path,cx,cy,val[k + 5],val[k + 6],val[k + 0],val[k + 1],val[k + 2],val[k + 3] != 0,val[k + 4] != 0);
cx=val[k + 5];
cy=val[k + 6];
cpx=cx;
cpy=cy;
break;
}
lastCmd=cmd;
}
current[0]=cx;
current[1]=cy;
current[2]=cpx;
current[3]=cpy;
current[4]=loopX;
current[5]=loopY;
}
