{
  if (infos.size() == 0) {
    return;
  }
  AccessibilityNodeInfo root=infos.get(0);
  final int infoCount=infos.size();
  for (int i=1; i < infoCount; i++) {
    for (int j=i; j < infoCount; j++) {
      AccessibilityNodeInfo candidate=infos.get(j);
      if (root.getParentNodeId() == candidate.getSourceNodeId()) {
        root=candidate;
        break;
      }
    }
  }
  if (root == null) {
    Log.e(LOG_TAG,"No root.");
  }
  HashSet<AccessibilityNodeInfo> seen=new HashSet<AccessibilityNodeInfo>();
  Queue<AccessibilityNodeInfo> fringe=new LinkedList<AccessibilityNodeInfo>();
  fringe.add(root);
  while (!fringe.isEmpty()) {
    AccessibilityNodeInfo current=fringe.poll();
    if (!seen.add(current)) {
      Log.e(LOG_TAG,"Duplicate node.");
      return;
    }
    final int childCount=current.getChildCount();
    for (int i=0; i < childCount; i++) {
      final long childId=current.getChildId(i);
      for (int j=0; j < infoCount; j++) {
        AccessibilityNodeInfo child=infos.get(j);
        if (child.getSourceNodeId() == childId) {
          fringe.add(child);
        }
      }
    }
  }
  final int disconnectedCount=infos.size() - seen.size();
  if (disconnectedCount > 0) {
    Log.e(LOG_TAG,disconnectedCount + " Disconnected nodes.");
  }
}
