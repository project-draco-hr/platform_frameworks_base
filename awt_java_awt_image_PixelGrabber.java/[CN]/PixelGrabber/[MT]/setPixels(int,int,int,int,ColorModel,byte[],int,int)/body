{
  if (srcY < Y) {
    int delta=Y - srcY;
    if (delta >= height) {
      return;
    }
    srcY+=delta;
    srcH-=delta;
    srcOff+=srcScan * delta;
  }
  if (srcY + srcH > Y + height) {
    srcH=Y + height - srcY;
    if (srcH <= 0) {
      return;
    }
  }
  if (srcX < X) {
    int delta=X - srcX;
    if (delta >= width) {
      return;
    }
    srcW-=delta;
    srcX+=delta;
    srcOff+=delta;
  }
  if (srcX + srcW > X + width) {
    srcW=X + width - srcX;
    if (srcW <= 0) {
      return;
    }
  }
  if (scanline == 0) {
    scanline=width;
  }
  int realOff=offset + (srcY - Y) * scanline + (srcX - X);
switch (dataType) {
case DATA_TYPE_UNDEFINED:
    cm=model;
  if (model != ColorModel.getRGBdefault()) {
    bData=new byte[width * height];
    isRGB=false;
    dataType=DATA_TYPE_BYTE;
  }
 else {
    iData=new int[width * height];
    isRGB=true;
    dataType=DATA_TYPE_INT;
  }
case DATA_TYPE_BYTE:
if (!isRGB && cm == model) {
  for (int y=0; y < srcH; y++) {
    System.arraycopy(pixels,srcOff,bData,realOff,srcW);
    srcOff+=srcScan;
    realOff+=scanline;
  }
  break;
}
forceToRGB();
case DATA_TYPE_INT:
for (int y=0; y < srcH; y++) {
for (int x=0; x < srcW; x++) {
iData[realOff + x]=cm.getRGB(pixels[srcOff + x] & 0xff);
}
srcOff+=srcScan;
realOff+=scanline;
}
}
return;
}
