{
  if (srcY < Y) {
    int delta=Y - srcY;
    if (delta >= height) {
      return;
    }
    srcY+=delta;
    srcH-=delta;
    srcOff+=srcScan * delta;
  }
  if (srcY + srcH > Y + height) {
    srcH=Y + height - srcY;
    if (srcH <= 0) {
      return;
    }
  }
  if (srcX < X) {
    int delta=X - srcX;
    if (delta >= width) {
      return;
    }
    srcW-=delta;
    srcX+=delta;
    srcOff+=delta;
  }
  if (srcX + srcW > X + width) {
    srcW=X + width - srcX;
    if (srcW <= 0) {
      return;
    }
  }
  if (scanline == 0) {
    scanline=width;
  }
  int realOff=offset + (srcY - Y) * scanline + (srcX - X);
  int mask=0xFF;
switch (dataType) {
case DATA_TYPE_UNDEFINED:
    cm=model;
  iData=new int[width * height];
dataType=DATA_TYPE_INT;
isRGB=(cm == ColorModel.getRGBdefault());
case DATA_TYPE_INT:
if (cm == model) {
for (int y=0; y < srcH; y++) {
System.arraycopy(pixels,srcOff,iData,realOff,srcW);
srcOff+=srcScan;
realOff+=scanline;
}
break;
}
mask=0xFFFFFFFF;
case DATA_TYPE_BYTE:
forceToRGB();
for (int y=0; y < srcH; y++) {
for (int x=0; x < srcW; x++) {
iData[realOff + x]=cm.getRGB(pixels[srcOff + x] & mask);
}
srcOff+=srcScan;
realOff+=scanline;
}
}
}
