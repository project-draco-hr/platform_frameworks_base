{
  mRecordingState=RECORDSTATE_STOPPED;
  if (attributes == null) {
    throw new IllegalArgumentException("Illegal null AudioAttributes");
  }
  if (format == null) {
    throw new IllegalArgumentException("Illegal null AudioFormat");
  }
  if ((mInitializationLooper=Looper.myLooper()) == null) {
    mInitializationLooper=Looper.getMainLooper();
  }
  mAudioAttributes=attributes;
  if (mAudioAttributes.getCapturePreset() == MediaRecorder.AudioSource.REMOTE_SUBMIX) {
    final Iterator<String> tagsIter=mAudioAttributes.getTags().iterator();
    while (tagsIter.hasNext()) {
      if (tagsIter.next().equalsIgnoreCase(SUBMIX_FIXED_VOLUME)) {
        mIsSubmixFullVolume=true;
        Log.v(TAG,"Will record from REMOTE_SUBMIX at full fixed volume");
        break;
      }
    }
  }
  int rate=0;
  if ((format.getPropertySetMask() & AudioFormat.AUDIO_FORMAT_HAS_PROPERTY_SAMPLE_RATE) != 0) {
    rate=format.getSampleRate();
  }
 else {
    rate=AudioSystem.getPrimaryOutputSamplingRate();
    if (rate <= 0) {
      rate=44100;
    }
  }
  int encoding=AudioFormat.ENCODING_DEFAULT;
  if ((format.getPropertySetMask() & AudioFormat.AUDIO_FORMAT_HAS_PROPERTY_ENCODING) != 0) {
    encoding=format.getEncoding();
  }
  audioParamCheck(attributes.getCapturePreset(),rate,encoding);
  mChannelCount=AudioFormat.channelCountFromInChannelMask(format.getChannelMask());
  mChannelMask=getChannelMaskFromLegacyConfig(format.getChannelMask(),false);
  audioBuffSizeCheck(bufferSizeInBytes);
  int[] session=new int[1];
  session[0]=sessionId;
  int initResult=native_setup(new WeakReference<AudioRecord>(this),mAudioAttributes,mSampleRate,mChannelMask,mAudioFormat,mNativeBufferSizeInBytes,session);
  if (initResult != SUCCESS) {
    loge("Error code " + initResult + " when initializing native AudioRecord object.");
    return;
  }
  mSessionId=session[0];
  mState=STATE_INITIALIZED;
}
