{
  mRS.validate();
  long[] vtx=new long[mVertexTypeCount];
  long[] idx=new long[mIndexTypes.size()];
  int[] prim=new int[mIndexTypes.size()];
  Allocation[] vertexBuffers=new Allocation[mVertexTypeCount];
  Allocation[] indexBuffers=new Allocation[mIndexTypes.size()];
  Primitive[] primitives=new Primitive[mIndexTypes.size()];
  for (int ct=0; ct < mVertexTypeCount; ct++) {
    Allocation alloc=null;
    Entry entry=mVertexTypes[ct];
    if (entry.t != null) {
      alloc=Allocation.createTyped(mRS,entry.t,mUsage);
    }
 else     if (entry.e != null) {
      alloc=Allocation.createSized(mRS,entry.e,entry.size,mUsage);
    }
 else {
      throw new IllegalStateException("Builder corrupt, no valid element in entry.");
    }
    vertexBuffers[ct]=alloc;
    vtx[ct]=alloc.getID(mRS);
  }
  for (int ct=0; ct < mIndexTypes.size(); ct++) {
    Allocation alloc=null;
    Entry entry=(Entry)mIndexTypes.elementAt(ct);
    if (entry.t != null) {
      alloc=Allocation.createTyped(mRS,entry.t,mUsage);
    }
 else     if (entry.e != null) {
      alloc=Allocation.createSized(mRS,entry.e,entry.size,mUsage);
    }
 else {
      throw new IllegalStateException("Builder corrupt, no valid element in entry.");
    }
    long allocID=(alloc == null) ? 0 : alloc.getID(mRS);
    indexBuffers[ct]=alloc;
    primitives[ct]=entry.prim;
    idx[ct]=allocID;
    prim[ct]=entry.prim.mID;
  }
  long id=mRS.nMeshCreate(vtx,idx,prim);
  Mesh newMesh=new Mesh(id,mRS);
  newMesh.mVertexBuffers=vertexBuffers;
  newMesh.mIndexBuffers=indexBuffers;
  newMesh.mPrimitives=primitives;
  return newMesh;
}
