{
  final TypedArray a=r.obtainAttributes(attrs,com.android.internal.R.styleable.RotateDrawable);
  super.inflateWithAttributes(r,parser,a,com.android.internal.R.styleable.RotateDrawable_visible);
  TypedValue tv=a.peekValue(com.android.internal.R.styleable.RotateDrawable_pivotX);
  final boolean pivotXRel;
  final float pivotX;
  if (tv == null) {
    pivotXRel=true;
    pivotX=0.5f;
  }
 else {
    pivotXRel=tv.type == TypedValue.TYPE_FRACTION;
    pivotX=pivotXRel ? tv.getFraction(1.0f,1.0f) : tv.getFloat();
  }
  tv=a.peekValue(com.android.internal.R.styleable.RotateDrawable_pivotY);
  final boolean pivotYRel;
  final float pivotY;
  if (tv == null) {
    pivotYRel=true;
    pivotY=0.5f;
  }
 else {
    pivotYRel=tv.type == TypedValue.TYPE_FRACTION;
    pivotY=pivotYRel ? tv.getFraction(1.0f,1.0f) : tv.getFloat();
  }
  final float fromDegrees=a.getFloat(com.android.internal.R.styleable.RotateDrawable_fromDegrees,0.0f);
  final float toDegrees=a.getFloat(com.android.internal.R.styleable.RotateDrawable_toDegrees,360.0f);
  final int res=a.getResourceId(com.android.internal.R.styleable.RotateDrawable_drawable,0);
  Drawable drawable=null;
  if (res > 0) {
    drawable=r.getDrawable(res);
  }
  a.recycle();
  final int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type != XmlPullParser.START_TAG) {
      continue;
    }
    if ((drawable=Drawable.createFromXmlInner(r,parser,attrs)) == null) {
      Log.w("drawable","Bad element under <rotate>: " + parser.getName());
    }
  }
  if (drawable == null) {
    Log.w("drawable","No drawable specified for <rotate>");
  }
  final RotateState st=mState;
  st.mDrawable=drawable;
  st.mPivotXRel=pivotXRel;
  st.mPivotX=pivotX;
  st.mPivotYRel=pivotYRel;
  st.mPivotY=pivotY;
  st.mFromDegrees=fromDegrees;
  st.mCurrentDegrees=fromDegrees;
  st.mToDegrees=toDegrees;
  if (drawable != null) {
    drawable.setCallback(this);
  }
}
