{
switch (msg.what) {
case IDLE_TIMEOUT_MSG:
{
      if (DEBUG_IDLE)       Slog.d(TAG,"handleMessage: IDLE_TIMEOUT_MSG: r=" + msg.obj);
      if (mService.mDidDexOpt) {
        mService.mDidDexOpt=false;
        Message nmsg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
        nmsg.obj=msg.obj;
        mHandler.sendMessageDelayed(nmsg,IDLE_TIMEOUT);
        return;
      }
      activityIdleInternal((ActivityRecord)msg.obj);
    }
  break;
case IDLE_NOW_MSG:
{
  if (DEBUG_IDLE)   Slog.d(TAG,"handleMessage: IDLE_NOW_MSG: r=" + msg.obj);
  activityIdleInternal((ActivityRecord)msg.obj);
}
break;
case RESUME_TOP_ACTIVITY_MSG:
{
synchronized (mService) {
resumeTopActivitiesLocked();
}
}
break;
case SLEEP_TIMEOUT_MSG:
{
synchronized (mService) {
if (mService.isSleepingOrShuttingDown()) {
Slog.w(TAG,"Sleep timeout!  Sleeping now.");
mSleepTimeout=true;
checkReadyForSleepLocked();
}
}
}
break;
case LAUNCH_TIMEOUT_MSG:
{
if (mService.mDidDexOpt) {
mService.mDidDexOpt=false;
mHandler.sendEmptyMessageDelayed(LAUNCH_TIMEOUT_MSG,LAUNCH_TIMEOUT);
return;
}
synchronized (mService) {
if (mLaunchingActivity.isHeld()) {
Slog.w(TAG,"Launch timeout has expired, giving up wake lock!");
if (VALIDATE_WAKE_LOCK_CALLER && Binder.getCallingUid() != Process.myUid()) {
throw new IllegalStateException("Calling must be system uid");
}
mLaunchingActivity.release();
}
}
}
break;
case HANDLE_DISPLAY_ADDED:
{
handleDisplayAddedLocked(msg.arg1);
}
break;
case HANDLE_DISPLAY_CHANGED:
{
handleDisplayChangedLocked(msg.arg1);
}
break;
case HANDLE_DISPLAY_REMOVED:
{
handleDisplayRemovedLocked(msg.arg1);
}
break;
case CONTAINER_CALLBACK_VISIBILITY:
{
final ActivityContainer container=(ActivityContainer)msg.obj;
try {
container.mCallback.setVisible(container.asBinder(),msg.arg1 == 1);
}
 catch (RemoteException e) {
}
}
}
}
