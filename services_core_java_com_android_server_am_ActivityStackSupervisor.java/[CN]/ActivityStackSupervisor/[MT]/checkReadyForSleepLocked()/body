{
  if (!mService.isSleepingOrShuttingDownLocked()) {
    return;
  }
  if (!mSleepTimeout) {
    boolean dontSleep=false;
    for (int displayNdx=mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
      final ArrayList<ActivityStack> stacks=mActivityDisplays.valueAt(displayNdx).mStacks;
      for (int stackNdx=stacks.size() - 1; stackNdx >= 0; --stackNdx) {
        dontSleep|=stacks.get(stackNdx).checkReadyForSleepLocked();
      }
    }
    if (mStoppingActivities.size() > 0) {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,"Sleep still need to stop " + mStoppingActivities.size() + " activities");
      scheduleIdleLocked();
      dontSleep=true;
    }
    if (mGoingToSleepActivities.size() > 0) {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,"Sleep still need to sleep " + mGoingToSleepActivities.size() + " activities");
      dontSleep=true;
    }
    if (dontSleep) {
      return;
    }
  }
  for (int displayNdx=mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
    final ArrayList<ActivityStack> stacks=mActivityDisplays.valueAt(displayNdx).mStacks;
    for (int stackNdx=stacks.size() - 1; stackNdx >= 0; --stackNdx) {
      stacks.get(stackNdx).goToSleep();
    }
  }
  removeSleepTimeouts();
  if (mGoingToSleep.isHeld()) {
    mGoingToSleep.release();
  }
  if (mService.mShuttingDown) {
    mService.notifyAll();
  }
}
