{
switch (message.what) {
case CMD_STOP_SUPPLICANT:
    if (mP2pSupported) {
      transitionTo(mWaitForP2pDisableState);
    }
 else {
      transitionTo(mSupplicantStoppingState);
    }
  break;
case WifiMonitor.SUP_DISCONNECTION_EVENT:
loge("Connection lost, restart supplicant");
handleSupplicantConnectionLoss();
handleNetworkDisconnect();
mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
if (mP2pSupported) {
transitionTo(mWaitForP2pDisableState);
}
 else {
transitionTo(mInitialState);
}
sendMessageDelayed(CMD_START_SUPPLICANT,SUPPLICANT_RESTART_INTERVAL_MSECS);
break;
case WifiMonitor.SCAN_RESULTS_EVENT:
setScanResults();
sendScanResultsAvailableBroadcast();
mScanResultIsPending=false;
break;
case CMD_PING_SUPPLICANT:
boolean ok=mWifiNative.ping();
replyToMessage(message,message.what,ok ? SUCCESS : FAILURE);
break;
case CMD_START_AP:
loge("Failed to start soft AP with a running supplicant");
setWifiApState(WIFI_AP_STATE_FAILED);
break;
case CMD_SET_OPERATIONAL_MODE:
mOperationalMode=message.arg1;
break;
default :
return NOT_HANDLED;
}
return HANDLED;
}
