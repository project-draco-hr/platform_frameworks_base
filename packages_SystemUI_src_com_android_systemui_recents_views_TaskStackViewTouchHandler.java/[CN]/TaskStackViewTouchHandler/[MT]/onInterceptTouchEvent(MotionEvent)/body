{
  boolean hasTaskViews=(mSv.getTaskViews().size() > 0);
  if (!hasTaskViews) {
    return false;
  }
  mInterceptedBySwipeHelper=mSwipeHelper.onInterceptTouchEvent(ev);
  if (mInterceptedBySwipeHelper) {
    return true;
  }
  boolean wasScrolling=mScroller.isScrolling() || (mScroller.mScrollAnimator != null && mScroller.mScrollAnimator.isRunning());
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mInitialMotionX=mLastMotionX=(int)ev.getX();
      mInitialMotionY=mLastMotionY=(int)ev.getY();
      mInitialP=mLastP=mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mLastMotionX,mLastMotionY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    if (mActivePointerId == INACTIVE_POINTER_ID)     break;
    initVelocityTrackerIfNotExists();
    mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
    int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    int y=(int)ev.getY(activePointerIndex);
    int x=(int)ev.getX(activePointerIndex);
    if (Math.abs(y - mInitialMotionY) > mScrollTouchSlop) {
      mIsScrolling=true;
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
    }
    mLastMotionX=x;
    mLastMotionY=y;
    mLastP=mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
{
  mScroller.animateBoundScroll();
  mIsScrolling=false;
  mActivePointerId=INACTIVE_POINTER_ID;
  mActiveTaskView=null;
  mTotalPMotion=0;
  recycleVelocityTracker();
  break;
}
}
return wasScrolling || mIsScrolling;
}
