{
  boolean hasTaskViews=(mSv.getTaskViews().size() > 0);
  if (!hasTaskViews) {
    return false;
  }
  if (mInterceptedBySwipeHelper && mSwipeHelper.onTouchEvent(ev)) {
    return true;
  }
  initVelocityTrackerIfNotExists();
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mInitialMotionX=mLastMotionX=(int)ev.getX();
      mInitialMotionY=mLastMotionY=(int)ev.getY();
      mInitialP=mLastP=mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mLastMotionX,mLastMotionY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mLastMotionX=(int)ev.getX(index);
    mLastMotionY=(int)ev.getY(index);
    mLastP=mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  if (mActivePointerId == INACTIVE_POINTER_ID)   break;
  mVelocityTracker.addMovement(createMotionEventForStackScroll(ev));
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int x=(int)ev.getX(activePointerIndex);
  int y=(int)ev.getY(activePointerIndex);
  int yTotal=Math.abs(y - mInitialMotionY);
  float curP=mSv.mLayoutAlgorithm.screenYToCurveProgress(y);
  float deltaP=mLastP - curP;
  if (!mIsScrolling) {
    if (yTotal > mScrollTouchSlop) {
      mIsScrolling=true;
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
    }
  }
  if (mIsScrolling) {
    float curStackScroll=mScroller.getStackScroll();
    float overScrollAmount=mScroller.getScrollAmountOutOfBounds(curStackScroll + deltaP);
    if (Float.compare(overScrollAmount,0f) != 0) {
      float maxOverScroll=mContext.getResources().getFloat(R.dimen.recents_stack_overscroll_percentage);
      deltaP*=(1f - (Math.min(maxOverScroll,overScrollAmount) / maxOverScroll));
    }
    mScroller.setStackScroll(curStackScroll + deltaP);
  }
  mLastMotionX=x;
  mLastMotionY=y;
  mLastP=mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
  mTotalPMotion+=Math.abs(deltaP);
  break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling && (Math.abs(velocity) > mMinimumVelocity)) {
  float overscrollRangePct=Math.abs((float)velocity / mMaximumVelocity);
  int overscrollRange=(int)(Math.min(1f,overscrollRangePct) * (Constants.Values.TaskStackView.TaskStackMaxOverscrollRange - Constants.Values.TaskStackView.TaskStackMinOverscrollRange));
  mScroller.mScroller.fling(0,mScroller.progressToScrollRange(mScroller.getStackScroll()),0,velocity,0,0,mScroller.progressToScrollRange(mSv.mLayoutAlgorithm.mMinScrollP),mScroller.progressToScrollRange(mSv.mLayoutAlgorithm.mMaxScrollP),0,Constants.Values.TaskStackView.TaskStackMinOverscrollRange + overscrollRange);
  mSv.invalidate();
}
 else if (mIsScrolling && mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (mActiveTaskView == null) {
  maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
mTotalPMotion=0;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
mActivePointerId=ev.getPointerId(newPointerIndex);
mLastMotionX=(int)ev.getX(newPointerIndex);
mLastMotionY=(int)ev.getY(newPointerIndex);
mLastP=mSv.mLayoutAlgorithm.screenYToCurveProgress(mLastMotionY);
mVelocityTracker.clear();
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mScroller.isScrollOutOfBounds()) {
mScroller.animateBoundScroll();
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
mTotalPMotion=0;
recycleVelocityTracker();
break;
}
}
return true;
}
