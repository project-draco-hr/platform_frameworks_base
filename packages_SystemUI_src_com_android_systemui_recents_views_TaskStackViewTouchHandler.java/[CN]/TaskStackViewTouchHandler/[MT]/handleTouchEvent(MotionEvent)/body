{
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  TaskStackViewLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mDownX=(int)ev.getX();
    mDownY=(int)ev.getY();
    mDownScrollP=mScroller.getStackScroll();
    mActivePointerId=ev.getPointerId(index);
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  if (!mIsScrolling) {
    if (Math.abs(y - mDownY) > mScrollTouchSlop) {
      mIsScrolling=true;
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float curScrollP=mDownScrollP + deltaP;
    mScroller.setStackScroll(curScrollP);
  }
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
  float curScrollP=mDownScrollP + deltaP;
  float downToCurY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,curScrollP);
  float downToMinY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float downToMaxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,(int)downToCurY,velocity,(int)downToMinY,(int)downToMaxY,mOverscrollSize);
  mSv.invalidate();
}
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mScroller.isScrollOutOfBounds()) {
mScroller.animateBoundScroll();
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}
