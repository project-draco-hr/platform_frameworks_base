{
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mDownX=(int)ev.getX();
    mDownY=(int)ev.getY();
    mDownScrollP=mScroller.getStackScroll();
    mActivePointerId=ev.getPointerId(index);
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  if (!mIsScrolling) {
    if (Math.abs(y - mDownY) > mScrollTouchSlop) {
      mIsScrolling=true;
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float curScrollP=mDownScrollP + deltaP;
    mScroller.setStackScroll(curScrollP);
    if (DEBUG) {
      Log.d(TAG,"scroll: " + curScrollP);
    }
  }
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
float curScrollP=mScroller.getStackScroll();
if (mIsScrolling) {
boolean hasFreeformTasks=mSv.mStack.hasFreeformTasks();
if (hasFreeformTasks && velocity > 0 && curScrollP > layoutAlgorithm.mStackEndScrollP) {
  float finalY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mPreferredStackEndScrollP);
  mScrollFlingAnimator=ValueAnimator.ofInt(y,(int)finalY);
  mScrollFlingAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,(Integer)animation.getAnimatedValue());
      float scroll=mDownScrollP + deltaP;
      mScroller.setStackScroll(scroll);
    }
  }
);
  mFlingAnimUtils.apply(mScrollFlingAnimator,y,finalY,velocity);
  mScrollFlingAnimator.start();
}
 else if (hasFreeformTasks && velocity < 0 && curScrollP > (layoutAlgorithm.mStackEndScrollP - layoutAlgorithm.mTaskHalfHeightPOffset)) {
  float finalY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  mScrollFlingAnimator=ValueAnimator.ofInt(y,(int)finalY);
  mScrollFlingAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,(Integer)animation.getAnimatedValue());
      float scroll=mDownScrollP + deltaP;
      mScroller.setStackScroll(scroll);
    }
  }
);
  mFlingAnimUtils.apply(mScrollFlingAnimator,y,finalY,velocity);
  mScrollFlingAnimator.start();
}
 else if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mPreferredStackEndScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}
