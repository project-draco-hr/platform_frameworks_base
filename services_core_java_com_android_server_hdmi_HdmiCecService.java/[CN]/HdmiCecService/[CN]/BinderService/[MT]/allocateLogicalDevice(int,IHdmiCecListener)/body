{
  enforceAccessPermission();
  ensureValidType(type);
  if (listener == null) {
    throw new IllegalArgumentException("listener must not be null");
  }
synchronized (mLock) {
    HdmiCecDevice device=mLogicalDevices.get(type);
    if (device != null) {
      Log.v(TAG,"Logical address already allocated. Adding listener only.");
    }
 else {
      int address=nativeAllocateLogicalAddress(mNativePtr,type);
      if (!HdmiCec.isValidAddress(address)) {
        Log.e(TAG,"Logical address was not allocated");
        return null;
      }
 else {
        device=HdmiCecDevice.create(HdmiCecService.this,type);
        if (device == null) {
          Log.e(TAG,"Device type not supported yet.");
          return null;
        }
        device.setName(HdmiCec.getDefaultDeviceName(address));
        device.initialize();
        mLogicalDevices.put(type,device);
      }
    }
    ListenerRecord record=new ListenerRecord(listener,type);
    try {
      listener.asBinder().linkToDeath(record,0);
    }
 catch (    RemoteException e) {
      Log.w(TAG,"Listener already died");
      if (!device.hasListener()) {
        removeLogicalDeviceLocked(type);
      }
      return null;
    }
    mListenerRecords.add(record);
    device.addListener(listener);
    return device.getToken();
  }
}
