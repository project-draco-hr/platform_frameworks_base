{
  int red=(rgb >> 16) & 0xff;
  int green=(rgb >> 8) & 0xff;
  int blue=rgb & 0xff;
  int alpha=rgb >>> 24;
  int pixIdx=0;
  for (int i=0; i < totalInserted; i++) {
    int idx=i * 2;
    if (rgb == cachetable[idx]) {
      return createDataObject(cachetable[idx + 1],pixel);
    }
  }
  if (!hasAlpha && grayPalette) {
    int grey=(red * 77 + green * 150 + blue * 29 + 128) >>> 8;
    int minError=255;
    int error=0;
    for (int i=0; i < mapSize; i++) {
      error=Math.abs((colorMap[i] & 0xff) - grey);
      if (error < minError) {
        pixIdx=i;
        if (error == 0) {
          break;
        }
        minError=error;
      }
    }
  }
 else   if (alpha == 0 && transparentIndex > -1) {
    pixIdx=transparentIndex;
  }
 else {
    int minAlphaError=255;
    int minError=195075;
    int alphaError;
    int error=0;
    for (int i=0; i < mapSize; i++) {
      int pix=colorMap[i];
      if (rgb == pix) {
        pixIdx=i;
        break;
      }
      alphaError=Math.abs(alpha - (pix >>> 24));
      if (alphaError <= minAlphaError) {
        minAlphaError=alphaError;
        int buf=((pix >> 16) & 0xff) - red;
        error=buf * buf;
        if (error < minError) {
          buf=((pix >> 8) & 0xff) - green;
          error+=buf * buf;
          if (error < minError) {
            buf=(pix & 0xff) - blue;
            error+=buf * buf;
            if (error < minError) {
              pixIdx=i;
              minError=error;
            }
          }
        }
      }
    }
  }
  cachetable[nextInsertIdx]=rgb;
  cachetable[nextInsertIdx + 1]=pixIdx;
  nextInsertIdx=(nextInsertIdx + 2) % (CACHESIZE * 2);
  if (totalInserted < CACHESIZE) {
    totalInserted++;
  }
  return createDataObject(pixIdx,pixel);
}
