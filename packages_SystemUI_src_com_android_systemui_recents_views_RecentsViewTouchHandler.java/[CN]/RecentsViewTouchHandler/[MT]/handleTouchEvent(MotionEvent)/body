{
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  boolean cancelled=action == MotionEvent.ACTION_CANCEL;
  if (cancelled) {
    EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,null));
  }
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,!cancelled ? mLastDropTarget : null));
  break;
}
}
}
}
