{
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  if (mDragging) {
    int width=mRv.getMeasuredWidth();
    int height=mRv.getMeasuredHeight();
    float evX=ev.getX();
    float evY=ev.getY();
    float x=evX - mTaskViewOffset.x;
    float y=evY - mTaskViewOffset.y;
    DropTarget currentDropTarget=null;
    for (    DropTarget target : mDropTargets) {
      if (target.acceptsDrop((int)evX,(int)evY,width,height)) {
        currentDropTarget=target;
        break;
      }
    }
    if (mLastDropTarget != currentDropTarget) {
      mLastDropTarget=currentDropTarget;
      EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragging) {
  ReferenceCountedTrigger postAnimationTrigger=new ReferenceCountedTrigger(mRv.getContext(),null,null,null);
  postAnimationTrigger.increment();
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,mLastDropTarget,postAnimationTrigger));
  postAnimationTrigger.decrement();
  break;
}
}
}
}
