{
  if (!createMemoryFormat(inputFormat)) {
    return;
  }
  if (mLogVerbose)   Log.v(TAG,"Allocating BackDropperFilter frames");
  int numBytes=mMaskFormat.getSize();
  byte[] initialBgMean=new byte[numBytes];
  byte[] initialBgVariance=new byte[numBytes];
  byte[] initialMaskVerify=new byte[numBytes];
  for (int i=0; i < numBytes; i++) {
    initialBgMean[i]=(byte)128;
    initialBgVariance[i]=(byte)10;
    initialMaskVerify[i]=(byte)0;
  }
  for (int i=0; i < 2; i++) {
    mBgMean[i]=(GLFrame)context.getFrameManager().newFrame(mMaskFormat);
    mBgMean[i].setData(initialBgMean,0,numBytes);
    mBgVariance[i]=(GLFrame)context.getFrameManager().newFrame(mMaskFormat);
    mBgVariance[i].setData(initialBgVariance,0,numBytes);
    mMaskVerify[i]=(GLFrame)context.getFrameManager().newFrame(mMaskFormat);
    mMaskVerify[i].setData(initialMaskVerify,0,numBytes);
  }
  if (mLogVerbose)   Log.v(TAG,"Done allocating texture for Mean and Variance objects!");
  mDistance=(GLFrame)context.getFrameManager().newFrame(mMaskFormat);
  mMask=(GLFrame)context.getFrameManager().newFrame(mMaskFormat);
  mAutoWB=(GLFrame)context.getFrameManager().newFrame(mAverageFormat);
  mVideoInput=(GLFrame)context.getFrameManager().newFrame(mMemoryFormat);
  mBgInput=(GLFrame)context.getFrameManager().newFrame(mMemoryFormat);
  mMaskAverage=(GLFrame)context.getFrameManager().newFrame(mAverageFormat);
  mBgDistProgram=new ShaderProgram(context,mSharedUtilShader + mBgDistanceShader);
  mBgDistProgram.setHostValue("subsample_level",(float)mSubsampleLevel);
  mBgMaskProgram=new ShaderProgram(context,mSharedUtilShader + mBgMaskShader);
  mBgMaskProgram.setHostValue("accept_variance",mAcceptStddev * mAcceptStddev);
  float[] yuvWeights={mLumScale,mChromaScale};
  mBgMaskProgram.setHostValue("yuv_weights",yuvWeights);
  mBgMaskProgram.setHostValue("scale_lrg",mHierarchyLrgScale);
  mBgMaskProgram.setHostValue("scale_mid",mHierarchyMidScale);
  mBgMaskProgram.setHostValue("scale_sml",mHierarchySmlScale);
  mBgMaskProgram.setHostValue("exp_lrg",(float)(mSubsampleLevel + mHierarchyLrgExp));
  mBgMaskProgram.setHostValue("exp_mid",(float)(mSubsampleLevel + mHierarchyMidExp));
  mBgMaskProgram.setHostValue("exp_sml",(float)(mSubsampleLevel + mHierarchySmlExp));
  if (mUseTheForce) {
    mBgSubtractProgram=new ShaderProgram(context,mSharedUtilShader + mBgSubtractShader + mBgSubtractForceShader);
  }
 else {
    mBgSubtractProgram=new ShaderProgram(context,mSharedUtilShader + mBgSubtractShader + "}\n");
  }
  mBgSubtractProgram.setHostValue("bg_fit_transform",DEFAULT_BG_FIT_TRANSFORM);
  mBgSubtractProgram.setHostValue("mask_blend_bg",mMaskBg);
  mBgSubtractProgram.setHostValue("mask_blend_fg",mMaskFg);
  mBgSubtractProgram.setHostValue("exposure_change",mExposureChange);
  mBgSubtractProgram.setHostValue("whitebalanceblue_change",mWhiteBalanceBlueChange);
  mBgSubtractProgram.setHostValue("whitebalancered_change",mWhiteBalanceRedChange);
  mBgUpdateMeanProgram=new ShaderProgram(context,mSharedUtilShader + mUpdateBgModelMeanShader);
  mBgUpdateMeanProgram.setHostValue("subsample_level",(float)mSubsampleLevel);
  mBgUpdateVarianceProgram=new ShaderProgram(context,mSharedUtilShader + mUpdateBgModelVarianceShader);
  mBgUpdateVarianceProgram.setHostValue("subsample_level",(float)mSubsampleLevel);
  mCopyOutProgram=ShaderProgram.createIdentity(context);
  mAutomaticWhiteBalanceProgram=new ShaderProgram(context,mSharedUtilShader + mAutomaticWhiteBalance);
  mAutomaticWhiteBalanceProgram.setHostValue("pyramid_depth",(float)mPyramidDepth);
  mAutomaticWhiteBalanceProgram.setHostValue("autowb_toggle",mAutoWBToggle);
  mMaskVerifyProgram=new ShaderProgram(context,mSharedUtilShader + mMaskVerifyShader);
  mMaskVerifyProgram.setHostValue("verify_rate",mVerifyRate);
  if (mLogVerbose)   Log.v(TAG,"Shader width set to " + mMemoryFormat.getWidth());
  mRelativeAspect=1.f;
  mFrameCount=0;
  mStartLearning=true;
}
