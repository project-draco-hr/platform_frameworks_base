{
  final boolean[] opRestrictions=getOrCreateUserRestrictionsForToken(token,userHandle);
  if (restricted) {
    final SparseArray<ArraySet<String>> opExceptions=getUserPackageExemptionsForToken(token,userHandle);
    ArraySet<String> exceptions=opExceptions.get(code);
    if (exceptionPackages != null) {
      if (exceptions == null) {
        exceptions=new ArraySet<>(exceptionPackages.length);
        opExceptions.put(code,exceptions);
      }
 else {
        exceptions.clear();
      }
      exceptions.addAll(Arrays.asList(exceptionPackages));
    }
  }
  if (opRestrictions[code] == restricted) {
    return;
  }
  opRestrictions[code]=restricted;
  if (!restricted) {
    pruneUserRestrictionsForToken(token,userHandle);
  }
  final ArrayList<Callback> clonedCallbacks;
synchronized (this) {
    ArrayList<Callback> callbacks=mOpModeWatchers.get(code);
    if (callbacks == null) {
      return;
    }
    clonedCallbacks=new ArrayList<>(callbacks);
  }
  final long identity=Binder.clearCallingIdentity();
  try {
    final int callbackCount=clonedCallbacks.size();
    for (int i=0; i < callbackCount; i++) {
      Callback callback=clonedCallbacks.get(i);
      try {
        callback.mCallback.opChanged(code,-1,null);
      }
 catch (      RemoteException e) {
        Log.w(TAG,"Error dispatching op op change",e);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}
