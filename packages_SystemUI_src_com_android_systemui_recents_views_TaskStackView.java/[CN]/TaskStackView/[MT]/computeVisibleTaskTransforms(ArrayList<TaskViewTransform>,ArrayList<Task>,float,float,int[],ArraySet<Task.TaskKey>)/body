{
  int taskCount=tasks.size();
  int frontMostVisibleIndex=-1;
  int backMostVisibleIndex=-1;
  boolean useTargetStackScroll=Float.compare(curStackScroll,targetStackScroll) != 0;
  boolean targetScrollIsInFront=targetStackScroll > curStackScroll;
  Utilities.matchTaskListSize(tasks,taskTransforms);
  TaskViewTransform frontTransform=null;
  TaskViewTransform frontTransformAtTarget=null;
  TaskViewTransform transform=null;
  TaskViewTransform transformAtTarget=null;
  for (int i=taskCount - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    transform=mLayoutAlgorithm.getStackTransform(task,curStackScroll,taskTransforms.get(i),frontTransform);
    if (useTargetStackScroll && !transform.visible) {
      transformAtTarget=mLayoutAlgorithm.getStackTransform(task,targetStackScroll,new TaskViewTransform(),frontTransformAtTarget);
      if (transformAtTarget.visible) {
        transform.copyFrom(transformAtTarget);
      }
    }
    if (ignoreTasksSet.contains(task.key)) {
      continue;
    }
    if (task.isFreeformTask()) {
      continue;
    }
    if (transform.visible) {
      if (frontMostVisibleIndex < 0) {
        frontMostVisibleIndex=i;
      }
      backMostVisibleIndex=i;
    }
 else     if (!targetScrollIsInFront) {
      if (backMostVisibleIndex != -1) {
        while (i >= 0) {
          taskTransforms.get(i).reset();
          i--;
        }
        break;
      }
    }
    frontTransform=transform;
    frontTransformAtTarget=transformAtTarget;
  }
  if (visibleRangeOut != null) {
    visibleRangeOut[0]=frontMostVisibleIndex;
    visibleRangeOut[1]=backMostVisibleIndex;
  }
  return frontMostVisibleIndex != -1 && backMostVisibleIndex != -1;
}
