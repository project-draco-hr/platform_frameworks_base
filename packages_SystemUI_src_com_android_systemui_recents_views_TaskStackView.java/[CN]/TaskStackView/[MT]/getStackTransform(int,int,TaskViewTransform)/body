{
  if (indexInStack < 0) {
    transformOut.reset();
    return transformOut;
  }
  int numPeekCards=Constants.Values.TaskStackView.StackPeekNumCards;
  float overlapHeight=Constants.Values.TaskStackView.StackOverlapPct * mTaskRect.height();
  float peekHeight=Constants.Values.TaskStackView.StackPeekHeightPct * mStackRect.height();
  float t=((indexInStack * overlapHeight) - stackScroll) / overlapHeight;
  float boundedT=Math.max(t,-(numPeekCards + 1));
  int numFrontScaledCards=3;
  float minScale=Constants.Values.TaskStackView.StackPeekMinScale;
  float scaleRange=1f - minScale;
  float scaleInc=scaleRange / (numPeekCards + numFrontScaledCards);
  float scale=Math.max(minScale,Math.min(1f,minScale + ((boundedT + (numPeekCards + 1)) * scaleInc)));
  float scaleYOffset=((1f - scale) * mTaskRect.height()) / 2;
  transformOut.scale=scale;
  if (boundedT < 0f) {
    transformOut.translationY=(int)((Math.max(-numPeekCards,boundedT) / numPeekCards) * peekHeight - scaleYOffset);
  }
 else {
    transformOut.translationY=(int)(boundedT * overlapHeight - scaleYOffset);
  }
  int minZ=mConfig.taskViewTranslationZMinPx;
  int incZ=mConfig.taskViewTranslationZIncrementPx;
  transformOut.translationZ=(int)Math.max(minZ,minZ + ((boundedT + numPeekCards) * incZ));
  transformOut.dismissAlpha=Math.max(-1f,Math.min(0f,t + 1)) + 1f;
  transformOut.rect.set(mTaskRect);
  if (t < -(numPeekCards + 1)) {
    transformOut.visible=false;
  }
 else {
    transformOut.rect.offset(0,transformOut.translationY);
    Utilities.scaleRectAboutCenter(transformOut.rect,transformOut.scale);
    transformOut.visible=Rect.intersects(mRect,transformOut.rect);
  }
  transformOut.t=t;
  return transformOut;
}
