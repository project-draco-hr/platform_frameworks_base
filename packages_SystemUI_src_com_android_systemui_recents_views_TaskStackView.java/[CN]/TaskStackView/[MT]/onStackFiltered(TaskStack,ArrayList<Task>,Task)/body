{
  mStashedScroll=getStackScroll();
  final ArrayList<TaskViewTransform> curTaskTransforms=getStackTransforms(curStack,mStashedScroll,null,true);
  updateMinMaxScroll(false);
  float overlapHeight=Constants.Values.TaskStackView.StackOverlapPct * mTaskRect.height();
  setStackScrollRaw((int)(newStack.indexOfTask(filteredTask) * overlapHeight));
  boundScrollRaw();
  final ArrayList<TaskViewTransform> taskTransforms=getStackTransforms(mStack.getTasks(),getStackScroll(),null,true);
  final ArrayList<TaskView> childrenToReturnToPool=new ArrayList<TaskView>();
  final ArrayList<Task> tasks=mStack.getTasks();
  ArrayList<Animator> childViewAnims=new ArrayList<Animator>();
  int childCount=getChildCount();
  int movement=0;
  for (int i=0; i < childCount; i++) {
    TaskView tv=(TaskView)getChildAt(i);
    Task task=tv.getTask();
    TaskViewTransform toTransform;
    int taskIndex=tasks.indexOf(task);
    boolean willBeInvisible=(taskIndex < 0) || !taskTransforms.get(taskIndex).visible;
    if (willBeInvisible) {
      TaskViewTransform fromTransform=curTaskTransforms.get(curStack.indexOf(task));
      toTransform=new TaskViewTransform(fromTransform);
      tv.updateViewPropertiesToTaskTransform(null,fromTransform,0);
      tv.prepareTaskTransformForFilterTaskHidden(toTransform);
      childrenToReturnToPool.add(tv);
    }
 else {
      toTransform=taskTransforms.get(taskIndex);
      movement=Math.max(movement,Math.abs(toTransform.translationY - (int)tv.getTranslationY()));
    }
    childViewAnims.add(tv.getAnimatorToTaskTransform(toTransform));
  }
  if (mFilterChildrenAnimator != null) {
    mFilterChildrenAnimator.cancel();
    mFilterChildrenAnimator.removeAllListeners();
  }
  final RecentsConfiguration config=RecentsConfiguration.getInstance();
  mFilterChildrenAnimator=new AnimatorSet();
  mFilterChildrenAnimator.setDuration(Utilities.calculateTranslationAnimationDuration(movement,config.filteringCurrentViewsMinAnimDuration));
  mFilterChildrenAnimator.setInterpolator(BakedBezierInterpolator.INSTANCE);
  mFilterChildrenAnimator.addListener(new AnimatorListenerAdapter(){
    boolean isCancelled;
    @Override public void onAnimationCancel(    Animator animation){
      isCancelled=true;
    }
    @Override public void onAnimationEnd(    Animator animation){
      if (isCancelled)       return;
      for (      TaskView tv : childrenToReturnToPool) {
        mViewPool.returnViewToPool(tv);
      }
      ArrayList<Animator> newViewsAnims=new ArrayList<Animator>();
      int taskCount=tasks.size();
      int movement=0;
      int offset=0;
      for (int i=0; i < taskCount; i++) {
        Task task=tasks.get(i);
        TaskViewTransform toTransform=taskTransforms.get(i);
        if (toTransform.visible) {
          TaskViewTransform fromTransform=curTaskTransforms.get(curStack.indexOf(task));
          TaskView tv=getChildViewForTask(task);
          if (tv == null) {
            tv=mViewPool.pickUpViewFromPool(task,task);
            fromTransform=new TaskViewTransform(toTransform);
            tv.prepareTaskTransformForFilterTaskHidden(fromTransform);
            tv.updateViewPropertiesToTaskTransform(null,fromTransform,0);
            Animator anim=tv.getAnimatorToTaskTransform(toTransform);
            anim.setStartDelay(offset * Constants.Values.TaskStackView.FilterStartDelay);
            newViewsAnims.add(anim);
            movement=Math.max(movement,Math.abs(toTransform.translationY - fromTransform.translationY));
            offset++;
          }
        }
        mFilterChildrenAnimator=new AnimatorSet();
        mFilterChildrenAnimator.setDuration(Utilities.calculateTranslationAnimationDuration(movement,config.filteringNewViewsMinAnimDuration));
        mFilterChildrenAnimator.setInterpolator(BakedBezierInterpolator.INSTANCE);
        mFilterChildrenAnimator.playTogether(newViewsAnims);
        mFilterChildrenAnimator.start();
      }
      invalidate();
    }
  }
);
  mFilterChildrenAnimator.playTogether(childViewAnims);
  mFilterChildrenAnimator.start();
}
