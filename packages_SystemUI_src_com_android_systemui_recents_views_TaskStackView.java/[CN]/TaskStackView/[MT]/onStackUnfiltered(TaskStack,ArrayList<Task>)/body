{
  final int curScroll=getStackScroll();
  final ArrayList<TaskViewTransform> curTaskTransforms=getStackTransforms(curStack,curScroll,null,true);
  updateMinMaxScroll(false);
  setStackScrollRaw(mStashedScroll);
  boundScrollRaw();
  final ArrayList<TaskViewTransform> taskTransforms=getStackTransforms(mStack.getTasks(),getStackScroll(),null,true);
  final ArrayList<TaskView> childrenToRemove=new ArrayList<TaskView>();
  final ArrayList<Task> tasks=mStack.getTasks();
  ArrayList<Animator> childViewAnims=new ArrayList<Animator>();
  int childCount=getChildCount();
  int movement=0;
  for (int i=0; i < childCount; i++) {
    TaskView tv=(TaskView)getChildAt(i);
    Task task=tv.getTask();
    int taskIndex=tasks.indexOf(task);
    TaskViewTransform toTransform;
    boolean willBeInvisible=taskIndex < 0 || !taskTransforms.get(taskIndex).visible;
    if (willBeInvisible) {
      toTransform=new TaskViewTransform(taskTransforms.get(taskIndex));
      tv.prepareTaskTransformForFilterTaskVisible(toTransform);
      childrenToRemove.add(tv);
    }
 else {
      toTransform=taskTransforms.get(taskIndex);
      movement=Math.max(movement,Math.abs(toTransform.translationY - (int)tv.getTranslationY()));
    }
    Animator anim=tv.getAnimatorToTaskTransform(toTransform);
    childViewAnims.add(anim);
  }
  if (mFilterChildrenAnimator != null) {
    mFilterChildrenAnimator.cancel();
    mFilterChildrenAnimator.removeAllListeners();
  }
  final RecentsConfiguration config=RecentsConfiguration.getInstance();
  mFilterChildrenAnimator=new AnimatorSet();
  mFilterChildrenAnimator.setDuration(Utilities.calculateTranslationAnimationDuration(movement,config.filteringCurrentViewsMinAnimDuration));
  mFilterChildrenAnimator.setInterpolator(BakedBezierInterpolator.INSTANCE);
  mFilterChildrenAnimator.addListener(new AnimatorListenerAdapter(){
    boolean isCancelled;
    @Override public void onAnimationCancel(    Animator animation){
      isCancelled=true;
    }
    @Override public void onAnimationEnd(    Animator animation){
      if (isCancelled)       return;
      for (      TaskView tv : childrenToRemove) {
        mViewPool.returnViewToPool(tv);
      }
      addHwLayersRefCount("unfilteredNewViews");
      ArrayList<Animator> newViewAnims=new ArrayList<Animator>();
      int taskCount=tasks.size();
      int movement=0;
      int offset=0;
      for (int i=0; i < taskCount; i++) {
        Task task=tasks.get(i);
        TaskViewTransform toTransform=taskTransforms.get(i);
        if (toTransform.visible) {
          TaskView tv=getChildViewForTask(task);
          if (tv == null) {
            tv=mViewPool.pickUpViewFromPool(task,task);
            TaskViewTransform fromTransform=new TaskViewTransform(toTransform);
            tv.prepareTaskTransformForFilterTaskHidden(fromTransform);
            tv.updateViewPropertiesToTaskTransform(null,fromTransform,0);
            Animator anim=tv.getAnimatorToTaskTransform(toTransform);
            anim.setStartDelay(offset * Constants.Values.TaskStackView.FilterStartDelay);
            newViewAnims.add(anim);
            movement=Math.max(movement,Math.abs(toTransform.translationY - fromTransform.translationY));
            offset++;
          }
        }
      }
      mFilterChildrenAnimator=new AnimatorSet();
      mFilterChildrenAnimator.setDuration(Utilities.calculateTranslationAnimationDuration(movement,config.filteringNewViewsMinAnimDuration));
      mFilterChildrenAnimator.playTogether(newViewAnims);
      mFilterChildrenAnimator.addListener(new AnimatorListenerAdapter(){
        @Override public void onAnimationEnd(        Animator animation){
          decHwLayersRefCount("unfilteredNewViews");
        }
      }
);
      mFilterChildrenAnimator.start();
      invalidate();
    }
  }
);
  mFilterChildrenAnimator.playTogether(childViewAnims);
  mFilterChildrenAnimator.start();
  mStashedScroll=0;
}
