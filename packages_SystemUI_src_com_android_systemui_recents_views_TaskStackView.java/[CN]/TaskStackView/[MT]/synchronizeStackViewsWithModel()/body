{
  if (mStackViewsDirty) {
    ArrayList<Task> tasks=mStack.getTasks();
    float stackScroll=mStackScroller.getStackScroll();
    int[] visibleStackRange=mTmpVisibleRange;
    boolean isValidVisibleStackRange=updateStackTransforms(mCurrentTaskTransforms,tasks,stackScroll,visibleStackRange,false);
    boolean hasStackBackTransform=false;
    boolean hasStackFrontTransform=false;
    if (DEBUG) {
      Log.d(TAG,"visibleRange: " + visibleStackRange[0] + " to "+ visibleStackRange[1]);
    }
    mTmpTaskViewMap.clear();
    List<TaskView> taskViews=getTaskViews();
    boolean wasLastFocusedTaskAnimated=false;
    int lastFocusedTaskIndex=-1;
    int taskViewCount=taskViews.size();
    for (int i=taskViewCount - 1; i >= 0; i--) {
      TaskView tv=taskViews.get(i);
      Task task=tv.getTask();
      int taskIndex=mStack.indexOfTask(task);
      if (task.isFreeformTask() || visibleStackRange[1] <= taskIndex && taskIndex <= visibleStackRange[0]) {
        mTmpTaskViewMap.put(task,tv);
      }
 else {
        if (tv.isFocusedTask()) {
          wasLastFocusedTaskAnimated=tv.isFocusAnimated();
          lastFocusedTaskIndex=taskIndex;
          resetFocusedTask();
        }
        if (DEBUG) {
          Log.d(TAG,"returning to pool: " + task.key);
        }
        mViewPool.returnViewToPool(tv);
      }
    }
    int firstVisStackIndex=isValidVisibleStackRange ? visibleStackRange[0] : 0;
    for (int i=mStack.getTaskCount() - 1; i > firstVisStackIndex; i--) {
      Task task=tasks.get(i);
      if (!task.isFreeformTask()) {
        continue;
      }
      TaskViewTransform transform=mLayoutAlgorithm.getStackTransform(task,stackScroll,mCurrentTaskTransforms.get(i),null);
      TaskView tv=mTmpTaskViewMap.get(task);
      if (tv == null) {
        if (DEBUG) {
          Log.d(TAG,"picking up from pool: " + task.key);
        }
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
      }
      tv.updateViewPropertiesToTaskTransform(transform,mStackViewsAnimationDuration,mRequestUpdateClippingListener);
    }
    for (int i=visibleStackRange[0]; isValidVisibleStackRange && i >= visibleStackRange[1]; i--) {
      Task task=tasks.get(i);
      TaskViewTransform transform=mCurrentTaskTransforms.get(i);
      TaskView tv=mTmpTaskViewMap.get(task);
      if (tv == null) {
        tv=mViewPool.pickUpViewFromPool(task,task);
        if (mLayersDisabled) {
          tv.disableLayersForOneFrame();
        }
        if (mStackViewsAnimationDuration > 0) {
          if (Float.compare(transform.p,0f) <= 0) {
            if (!hasStackBackTransform) {
              hasStackBackTransform=true;
              mLayoutAlgorithm.getStackTransform(0f,0f,mTmpStackBackTransform,null);
            }
            tv.updateViewPropertiesToTaskTransform(mTmpStackBackTransform,0);
          }
 else {
            if (!hasStackFrontTransform) {
              hasStackFrontTransform=true;
              mLayoutAlgorithm.getStackTransform(1f,0f,mTmpStackFrontTransform,null);
            }
            tv.updateViewPropertiesToTaskTransform(mTmpStackFrontTransform,0);
          }
        }
      }
      tv.updateViewPropertiesToTaskTransform(transform,mStackViewsAnimationDuration,mRequestUpdateClippingListener);
    }
    if (lastFocusedTaskIndex != -1) {
      if (lastFocusedTaskIndex < visibleStackRange[1]) {
        setFocusedTask(visibleStackRange[1],false,wasLastFocusedTaskAnimated);
      }
 else {
        setFocusedTask(visibleStackRange[0],false,wasLastFocusedTaskAnimated);
      }
    }
    mStackViewsAnimationDuration=0;
    mStackViewsDirty=false;
    mStackViewsClipDirty=true;
    return true;
  }
  return false;
}
