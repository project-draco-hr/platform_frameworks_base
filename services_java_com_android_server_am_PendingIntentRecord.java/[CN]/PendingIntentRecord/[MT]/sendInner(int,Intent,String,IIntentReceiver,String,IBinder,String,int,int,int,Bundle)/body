{
synchronized (owner) {
    if (!canceled) {
      sent=true;
      if ((key.flags & PendingIntent.FLAG_ONE_SHOT) != 0) {
        owner.cancelIntentSenderLocked(this,true);
        canceled=true;
      }
      Intent finalIntent=key.requestIntent != null ? new Intent(key.requestIntent) : new Intent();
      if (intent != null) {
        int changes=finalIntent.fillIn(intent,key.flags);
        if ((changes & Intent.FILL_IN_DATA) == 0) {
          resolvedType=key.requestResolvedType;
        }
      }
 else {
        resolvedType=key.requestResolvedType;
      }
      flagsMask&=~Intent.IMMUTABLE_FLAGS;
      flagsValues&=flagsMask;
      finalIntent.setFlags((finalIntent.getFlags() & ~flagsMask) | flagsValues);
      final long origId=Binder.clearCallingIdentity();
      boolean sendFinish=finishedReceiver != null;
      int userId=key.userId;
      if (userId == UserHandle.USER_CURRENT) {
        userId=owner.getCurrentUserIdLocked();
      }
switch (key.type) {
case ActivityManager.INTENT_SENDER_ACTIVITY:
        if (options == null) {
          options=key.options;
        }
 else         if (key.options != null) {
          Bundle opts=new Bundle(key.options);
          opts.putAll(options);
          options=opts;
        }
      try {
        if (key.allIntents != null && key.allIntents.length > 1) {
          Intent[] allIntents=new Intent[key.allIntents.length];
          String[] allResolvedTypes=new String[key.allIntents.length];
          System.arraycopy(key.allIntents,0,allIntents,0,key.allIntents.length);
          if (key.allResolvedTypes != null) {
            System.arraycopy(key.allResolvedTypes,0,allResolvedTypes,0,key.allResolvedTypes.length);
          }
          allIntents[allIntents.length - 1]=finalIntent;
          allResolvedTypes[allResolvedTypes.length - 1]=resolvedType;
          owner.startActivitiesInPackage(uid,allIntents,allResolvedTypes,resultTo,options,userId);
        }
 else {
          owner.startActivityInPackage(uid,finalIntent,resolvedType,resultTo,resultWho,requestCode,0,options,userId);
        }
      }
 catch (      RuntimeException e) {
        Slog.w(ActivityManagerService.TAG,"Unable to send startActivity intent",e);
      }
    break;
case ActivityManager.INTENT_SENDER_ACTIVITY_RESULT:
  key.activity.stack.sendActivityResultLocked(-1,key.activity,key.who,key.requestCode,code,finalIntent);
break;
case ActivityManager.INTENT_SENDER_BROADCAST:
try {
owner.broadcastIntentInPackage(key.packageName,uid,finalIntent,resolvedType,finishedReceiver,code,null,null,requiredPermission,(finishedReceiver != null),false,userId);
sendFinish=false;
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Unable to send startActivity intent",e);
}
break;
case ActivityManager.INTENT_SENDER_SERVICE:
try {
owner.startServiceInPackage(uid,finalIntent,resolvedType,userId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Unable to send startService intent",e);
}
break;
}
if (sendFinish) {
try {
finishedReceiver.performReceive(new Intent(finalIntent),0,null,null,false,false,key.userId);
}
 catch (RemoteException e) {
}
}
Binder.restoreCallingIdentity(origId);
return 0;
}
}
return ActivityManager.START_CANCELED;
}
