{
  if (!uidDeleted && !isUidValidForWhitelistRules(uid)) {
    if (LOGD)     Slog.d(TAG,"no need to update restrict data rules for uid " + uid);
    return;
  }
  final int uidPolicy=mUidPolicy.get(uid,POLICY_NONE);
  final int oldUidRules=mUidRules.get(uid,RULE_NONE);
  final boolean isForeground=isUidForegroundOnRestrictBackgroundLocked(uid);
  final boolean isDsBlacklisted=(uidPolicy & POLICY_REJECT_METERED_BACKGROUND) != 0;
  final boolean isDsWhitelisted=mRestrictBackgroundWhitelistUids.get(uid);
  int newDsRule=RULE_NONE;
  final int oldDsRule=oldUidRules & MASK_METERED_NETWORKS;
  if (isForeground) {
    if (isDsBlacklisted || (mRestrictBackground && !isDsWhitelisted)) {
      newDsRule=RULE_TEMPORARY_ALLOW_METERED;
    }
  }
 else {
    if (isDsBlacklisted) {
      newDsRule=RULE_REJECT_METERED;
    }
 else     if (isDsWhitelisted) {
      newDsRule=RULE_ALLOW_METERED;
    }
  }
  final int newUidRules=newDsRule;
  if (LOGV) {
    Log.v(TAG,"updateRuleForRestrictBackgroundLocked(" + uid + "):"+ " isForeground="+ isForeground+ ", isBlacklisted: "+ isDsBlacklisted+ ", isDsWhitelisted: "+ isDsWhitelisted+ ", newUidRule: "+ uidRulesToString(newUidRules)+ ", oldUidRule: "+ uidRulesToString(oldUidRules));
  }
  if (newUidRules == RULE_NONE) {
    mUidRules.delete(uid);
  }
 else {
    mUidRules.put(uid,newUidRules);
  }
  if (newDsRule != oldDsRule) {
    if ((newDsRule & RULE_TEMPORARY_ALLOW_METERED) != 0) {
      setMeteredNetworkWhitelist(uid,true);
      if (isDsBlacklisted) {
        setMeteredNetworkBlacklist(uid,false);
      }
    }
 else     if ((oldDsRule & RULE_TEMPORARY_ALLOW_METERED) != 0) {
      if (!isDsWhitelisted) {
        setMeteredNetworkWhitelist(uid,false);
      }
      if (isDsBlacklisted) {
        setMeteredNetworkBlacklist(uid,true);
      }
    }
 else     if ((newDsRule & RULE_REJECT_METERED) != 0 || (oldDsRule & RULE_REJECT_METERED) != 0) {
      setMeteredNetworkBlacklist(uid,isDsBlacklisted);
      if ((oldDsRule & RULE_REJECT_METERED) != 0 && isDsWhitelisted) {
        setMeteredNetworkWhitelist(uid,isDsWhitelisted);
      }
    }
 else     if ((newDsRule & RULE_ALLOW_METERED) != 0 || (oldDsRule & RULE_ALLOW_METERED) != 0) {
      setMeteredNetworkWhitelist(uid,isDsWhitelisted);
    }
 else {
      Log.wtf(TAG,"Unexpected change of metered UID state for " + uid + ": foreground="+ isForeground+ ", whitelisted="+ isDsWhitelisted+ ", blacklisted="+ isDsBlacklisted+ ", newRules="+ uidRulesToString(newUidRules)+ ", oldRules="+ uidRulesToString(oldUidRules));
    }
    mHandler.obtainMessage(MSG_RULES_CHANGED,uid,newUidRules).sendToTarget();
  }
}
