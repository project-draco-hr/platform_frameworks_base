{
  if (!isUidValidForRules(uid))   return;
  final int uidPolicy=mUidPolicy.get(uid,POLICY_NONE);
  final boolean uidForeground=isUidForegroundLocked(uid);
  int newRule=RULE_ALLOW_ALL;
  if (!uidForeground) {
    if (((uidPolicy & POLICY_REJECT_METERED_BACKGROUND) != 0) || (mRestrictBackground && !mRestrictBackgroundWhitelistUids.get(uid))) {
      newRule=RULE_REJECT_METERED;
    }
  }
  final int oldRule=mUidRules.get(uid);
  if (LOGV) {
    Log.v(TAG,"updateRulesForRestrictBackgroundLocked(" + uid + "): oldRule = "+ ruleToString(oldRule)+ ", newRule = "+ ruleToString(newRule));
  }
  if (newRule == RULE_ALLOW_ALL) {
    mUidRules.delete(uid);
  }
 else {
    mUidRules.put(uid,newRule);
  }
  if (oldRule != newRule) {
    final boolean rejectMetered=(newRule == RULE_REJECT_METERED);
    setUidNetworkRules(uid,rejectMetered);
    mHandler.obtainMessage(MSG_RULES_CHANGED,uid,newRule).sendToTarget();
  }
}
