{
  if (LOGV)   Slog.v(TAG,"updateNotificationsLocked()");
  final ArraySet<String> beforeNotifs=new ArraySet<String>(mActiveNotifs);
  mActiveNotifs.clear();
  mNotificationSequenceNumber++;
  boolean hasNotifications=false;
  final long currentTime=currentTimeMillis();
  for (int i=mNetworkPolicy.size() - 1; i >= 0; i--) {
    final NetworkPolicy policy=mNetworkPolicy.valueAt(i);
    if (!isTemplateRelevant(policy.template))     continue;
    if (!policy.hasCycle())     continue;
    final long start=computeLastCycleBoundary(currentTime,policy);
    final long end=currentTime;
    final long totalBytes=getTotalBytes(policy.template,start,end);
    if (policy.isOverLimit(totalBytes)) {
      hasNotifications=true;
      if (policy.lastLimitSnooze >= start) {
        enqueueNotification(policy,TYPE_LIMIT_SNOOZED,totalBytes);
      }
 else {
        enqueueNotification(policy,TYPE_LIMIT,totalBytes);
        notifyOverLimitLocked(policy.template);
      }
    }
 else {
      notifyUnderLimitLocked(policy.template);
      if (policy.isOverWarning(totalBytes) && policy.lastWarningSnooze < start) {
        enqueueNotification(policy,TYPE_WARNING,totalBytes);
        hasNotifications=true;
      }
    }
  }
  if (!hasNotifications) {
    sendNotificationToCustomComponent(null,TYPE_NONE,0);
  }
  if (mRestrictBackground) {
    enqueueRestrictedNotification(TAG_ALLOW_BACKGROUND);
  }
  for (int i=beforeNotifs.size() - 1; i >= 0; i--) {
    final String tag=beforeNotifs.valueAt(i);
    if (!mActiveNotifs.contains(tag)) {
      cancelNotification(tag);
    }
  }
}
