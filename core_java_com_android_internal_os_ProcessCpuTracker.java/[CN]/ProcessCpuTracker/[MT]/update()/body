{
  if (DEBUG)   Slog.v(TAG,"Update: " + this);
  final long nowUptime=SystemClock.uptimeMillis();
  final long nowRealtime=SystemClock.elapsedRealtime();
  final long nowWallTime=System.currentTimeMillis();
  final long[] sysCpu=mSystemCpuData;
  if (Process.readProcFile("/proc/stat",SYSTEM_CPU_FORMAT,null,sysCpu,null)) {
    final long usertime=(sysCpu[0] + sysCpu[1]) * mJiffyMillis;
    final long systemtime=sysCpu[2] * mJiffyMillis;
    final long idletime=sysCpu[3] * mJiffyMillis;
    final long iowaittime=sysCpu[4] * mJiffyMillis;
    final long irqtime=sysCpu[5] * mJiffyMillis;
    final long softirqtime=sysCpu[6] * mJiffyMillis;
    if (true || (usertime >= mBaseUserTime && systemtime >= mBaseSystemTime && iowaittime >= mBaseIoWaitTime && irqtime >= mBaseIrqTime && softirqtime >= mBaseSoftIrqTime && idletime >= mBaseIdleTime)) {
      mRelUserTime=(int)(usertime - mBaseUserTime);
      mRelSystemTime=(int)(systemtime - mBaseSystemTime);
      mRelIoWaitTime=(int)(iowaittime - mBaseIoWaitTime);
      mRelIrqTime=(int)(irqtime - mBaseIrqTime);
      mRelSoftIrqTime=(int)(softirqtime - mBaseSoftIrqTime);
      mRelIdleTime=(int)(idletime - mBaseIdleTime);
      mRelStatsAreGood=true;
      if (DEBUG) {
        Slog.i("Load","Total U:" + (sysCpu[0] * mJiffyMillis) + " N:"+ (sysCpu[1] * mJiffyMillis)+ " S:"+ (sysCpu[2] * mJiffyMillis)+ " I:"+ (sysCpu[3] * mJiffyMillis)+ " W:"+ (sysCpu[4] * mJiffyMillis)+ " Q:"+ (sysCpu[5] * mJiffyMillis)+ " O:"+ (sysCpu[6] * mJiffyMillis));
        Slog.i("Load","Rel U:" + mRelUserTime + " S:"+ mRelSystemTime+ " I:"+ mRelIdleTime+ " Q:"+ mRelIrqTime);
      }
      mBaseUserTime=usertime;
      mBaseSystemTime=systemtime;
      mBaseIoWaitTime=iowaittime;
      mBaseIrqTime=irqtime;
      mBaseSoftIrqTime=softirqtime;
      mBaseIdleTime=idletime;
    }
 else {
      mRelUserTime=0;
      mRelSystemTime=0;
      mRelIoWaitTime=0;
      mRelIrqTime=0;
      mRelSoftIrqTime=0;
      mRelIdleTime=0;
      mRelStatsAreGood=false;
      Slog.w(TAG,"/proc/stats has gone backwards; skipping CPU update");
      return;
    }
  }
  mLastSampleTime=mCurrentSampleTime;
  mCurrentSampleTime=nowUptime;
  mLastSampleRealTime=mCurrentSampleRealTime;
  mCurrentSampleRealTime=nowRealtime;
  mLastSampleWallTime=mCurrentSampleWallTime;
  mCurrentSampleWallTime=nowWallTime;
  final StrictMode.ThreadPolicy savedPolicy=StrictMode.allowThreadDiskReads();
  try {
    mCurPids=collectStats("/proc",-1,mFirst,mCurPids,mProcStats);
  }
  finally {
    StrictMode.setThreadPolicy(savedPolicy);
  }
  final float[] loadAverages=mLoadAverageData;
  if (Process.readProcFile("/proc/loadavg",LOAD_AVERAGE_FORMAT,null,null,loadAverages)) {
    float load1=loadAverages[0];
    float load5=loadAverages[1];
    float load15=loadAverages[2];
    if (load1 != mLoad1 || load5 != mLoad5 || load15 != mLoad15) {
      mLoad1=load1;
      mLoad5=load5;
      mLoad15=load15;
      onLoadChanged(load1,load5,load15);
    }
  }
  if (DEBUG)   Slog.i(TAG,"*** TIME TO COLLECT STATS: " + (SystemClock.uptimeMillis() - mCurrentSampleTime));
  mWorkingProcsSorted=false;
  mFirst=false;
}
