{
  int[] flagses={Base64.DEFAULT,Base64.NO_PADDING,Base64.NO_WRAP,Base64.NO_PADDING | Base64.NO_WRAP,Base64.CRLF,Base64.WEB_SAFE};
  int[] writeLengths={-10,-5,-1,0,1,1,2,2,3,10,100};
  Random rng=new Random(32176L);
  byte[] input=("Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + "Quisque congue eleifend odio, eu ornare nulla facilisis eget. " + "Integer eget elit diam, sit amet laoreet nibh. Quisque enim "+ "urna, pharetra vitae consequat eget, adipiscing eu ante. "+ "Aliquam venenatis arcu nec nibh imperdiet tempor. In id dui "+ "eget lorem aliquam rutrum vel vitae eros. In placerat ornare "+ "pretium. Curabitur non fringilla mi. Fusce ultricies, turpis "+ "eu ultrices suscipit, ligula nisi consectetur eros, dapibus "+ "aliquet dui sapien a turpis. Donec ultricies varius ligula, "+ "ut hendrerit arcu malesuada at. Praesent sed elit pretium "+ "eros luctus gravida. In ac dolor lorem. Cras condimentum "+ "convallis elementum. Phasellus vel felis in nulla ultrices "+ "venenatis. Nam non tortor non orci convallis convallis. "+ "Nam tristique lacinia hendrerit. Pellentesque habitant morbi "+ "tristique senectus et netus et malesuada fames ac turpis "+ "egestas. Vivamus cursus, nibh eu imperdiet porta, magna "+ "ipsum mollis mauris, sit amet fringilla mi nisl eu mi. "+ "Phasellus posuere, leo at ultricies vehicula, massa risus "+ "volutpat sapien, eu tincidunt diam ipsum eget nulla. Cras "+ "molestie dapibus commodo. Ut vel tellus at massa gravida "+ "semper non sed orci.").getBytes();
  for (int f=0; f < flagses.length; ++f) {
    int flags=flagses[f];
    byte[] expected=Base64.encode(input,flags);
    ByteArrayOutputStream baos;
    Base64OutputStream b64os;
    byte[] actual;
    int p;
    baos=new ByteArrayOutputStream();
    b64os=new Base64OutputStream(baos,flags);
    b64os.write(input);
    b64os.close();
    actual=baos.toByteArray();
    assertEquals(expected,actual);
    baos=new ByteArrayOutputStream();
    b64os=new Base64OutputStream(baos,flags);
    for (int i=0; i < input.length; ++i) {
      b64os.write(input[i]);
    }
    b64os.close();
    actual=baos.toByteArray();
    assertEquals(expected,actual);
    baos=new ByteArrayOutputStream();
    b64os=new Base64OutputStream(baos,flags);
    p=0;
    while (p < input.length) {
      int l=writeLengths[rng.nextInt(writeLengths.length)];
      l=Math.min(l,input.length - p);
      if (l >= 0) {
        b64os.write(input,p,l);
        p+=l;
      }
 else {
        l=Math.min(-l,input.length - p);
        for (int i=0; i < l; ++i) {
          b64os.write(input[p + i]);
        }
        p+=l;
      }
    }
    b64os.close();
    actual=baos.toByteArray();
    assertEquals(expected,actual);
    baos=new ByteArrayOutputStream();
    b64os=new Base64OutputStream(baos,flags,false);
    b64os.write(expected);
    b64os.close();
    actual=baos.toByteArray();
    assertEquals(input,actual);
    baos=new ByteArrayOutputStream();
    b64os=new Base64OutputStream(baos,flags,false);
    for (int i=0; i < expected.length; ++i) {
      b64os.write(expected[i]);
    }
    b64os.close();
    actual=baos.toByteArray();
    assertEquals(input,actual);
    baos=new ByteArrayOutputStream();
    b64os=new Base64OutputStream(baos,flags,false);
    p=0;
    while (p < expected.length) {
      int l=writeLengths[rng.nextInt(writeLengths.length)];
      l=Math.min(l,expected.length - p);
      if (l >= 0) {
        b64os.write(expected,p,l);
        p+=l;
      }
 else {
        l=Math.min(-l,expected.length - p);
        for (int i=0; i < l; ++i) {
          b64os.write(expected[p + i]);
        }
        p+=l;
      }
    }
    b64os.close();
    actual=baos.toByteArray();
    assertEquals(input,actual);
  }
}
