{
  if ((sampleRateInHz < AudioFormat.SAMPLE_RATE_HZ_MIN || sampleRateInHz > AudioFormat.SAMPLE_RATE_HZ_MAX) && sampleRateInHz != AudioFormat.SAMPLE_RATE_UNSPECIFIED) {
    throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
  }
  mSampleRate=sampleRateInHz;
  mChannelConfiguration=channelConfig;
switch (channelConfig) {
case AudioFormat.CHANNEL_OUT_DEFAULT:
case AudioFormat.CHANNEL_OUT_MONO:
case AudioFormat.CHANNEL_CONFIGURATION_MONO:
    mChannelCount=1;
  mChannelMask=AudioFormat.CHANNEL_OUT_MONO;
break;
case AudioFormat.CHANNEL_OUT_STEREO:
case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
mChannelCount=2;
mChannelMask=AudioFormat.CHANNEL_OUT_STEREO;
break;
default :
if (channelConfig == AudioFormat.CHANNEL_INVALID && channelIndexMask != 0) {
mChannelCount=0;
break;
}
if (!isMultichannelConfigSupported(channelConfig)) {
throw new IllegalArgumentException("Unsupported channel configuration.");
}
mChannelMask=channelConfig;
mChannelCount=AudioFormat.channelCountFromOutChannelMask(channelConfig);
}
mChannelIndexMask=channelIndexMask;
if (mChannelIndexMask != 0) {
final int indexMask=(1 << CHANNEL_COUNT_MAX) - 1;
if ((channelIndexMask & ~indexMask) != 0) {
throw new IllegalArgumentException("Unsupported channel index configuration " + channelIndexMask);
}
int channelIndexCount=Integer.bitCount(channelIndexMask);
if (mChannelCount == 0) {
mChannelCount=channelIndexCount;
}
 else if (mChannelCount != channelIndexCount) {
throw new IllegalArgumentException("Channel count must match");
}
}
if (audioFormat == AudioFormat.ENCODING_DEFAULT) {
audioFormat=AudioFormat.ENCODING_PCM_16BIT;
}
if (!AudioFormat.isPublicEncoding(audioFormat)) {
throw new IllegalArgumentException("Unsupported audio encoding.");
}
mAudioFormat=audioFormat;
if (((mode != MODE_STREAM) && (mode != MODE_STATIC)) || ((mode != MODE_STREAM) && !AudioFormat.isEncodingLinearPcm(mAudioFormat))) {
throw new IllegalArgumentException("Invalid mode.");
}
mDataLoadMode=mode;
}
