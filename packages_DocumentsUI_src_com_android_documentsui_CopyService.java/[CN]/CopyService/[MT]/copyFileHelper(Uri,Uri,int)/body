{
  CancellationSignal canceller=new CancellationSignal();
  ParcelFileDescriptor srcFile=null;
  ParcelFileDescriptor dstFile=null;
  InputStream src=null;
  OutputStream dst=null;
  IOException copyError=null;
  try {
    srcFile=mSrcClient.openFile(srcUri,"r",canceller);
    dstFile=mDstClient.openFile(dstUri,"w",canceller);
    src=new ParcelFileDescriptor.AutoCloseInputStream(srcFile);
    dst=new ParcelFileDescriptor.AutoCloseOutputStream(dstFile);
    byte[] buffer=new byte[8192];
    int len;
    while (!mIsCancelled && ((len=src.read(buffer)) != -1)) {
      dst.write(buffer,0,len);
      makeProgress(len);
    }
    srcFile.checkError();
  }
 catch (  IOException e) {
    copyError=e;
    try {
      DocumentInfo info=DocumentInfo.fromUri(getContentResolver(),srcUri);
      mFailedFiles.add(info);
      Log.e(TAG,"Error while copying " + info.displayName + " ("+ info.derivedUri+ ")",copyError);
    }
 catch (    FileNotFoundException ignore) {
      DocumentInfo info=new DocumentInfo();
      info.derivedUri=srcUri;
      info.displayName="Unknown [" + srcUri + "]";
      mFailedFiles.add(info);
      Log.e(TAG,"Error while copying " + srcUri,copyError);
    }
    if (dstFile != null) {
      try {
        dstFile.closeWithError(copyError.getMessage());
      }
 catch (      IOException closeError) {
        Log.e(TAG,"Error closing destination",closeError);
      }
    }
  }
 finally {
    IoUtils.closeQuietly(src);
    IoUtils.closeQuietly(dst);
  }
  if (copyError != null || mIsCancelled) {
    canceller.cancel();
    try {
      DocumentsContract.deleteDocument(mDstClient,dstUri);
    }
 catch (    RemoteException e) {
      Log.w(TAG,"Failed to clean up after copy error: " + dstUri,e);
      throw e;
    }
  }
 else   if (mode == TRANSFER_MODE_MOVE) {
    try {
      DocumentsContract.deleteDocument(mSrcClient,srcUri);
    }
 catch (    RemoteException e) {
      Log.w(TAG,"Failed to clean up after move: " + srcUri,e);
      throw e;
    }
  }
}
