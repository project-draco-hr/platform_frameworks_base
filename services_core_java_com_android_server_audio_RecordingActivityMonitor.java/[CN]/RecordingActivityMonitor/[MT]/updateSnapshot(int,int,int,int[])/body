{
synchronized (mRecordConfigs) {
switch (event) {
case AudioManager.RECORD_CONFIG_EVENT_STOP:
      return (mRecordConfigs.remove(new Integer(session)) != null);
case AudioManager.RECORD_CONFIG_EVENT_START:
    final AudioFormat clientFormat=new AudioFormat.Builder().setEncoding(recordingInfo[0]).setChannelMask(recordingInfo[1]).setSampleRate(recordingInfo[2]).build();
  final AudioFormat deviceFormat=new AudioFormat.Builder().setEncoding(recordingInfo[3]).setChannelMask(recordingInfo[4]).setSampleRate(recordingInfo[5]).build();
final int patchHandle=recordingInfo[6];
final Integer sessionKey=new Integer(session);
if (mRecordConfigs.containsKey(sessionKey)) {
final AudioRecordConfiguration updatedConfig=new AudioRecordConfiguration(session,source,clientFormat,deviceFormat,patchHandle);
if (updatedConfig.equals(mRecordConfigs.get(sessionKey))) {
return false;
}
 else {
mRecordConfigs.remove(sessionKey);
mRecordConfigs.put(sessionKey,updatedConfig);
return true;
}
}
 else {
mRecordConfigs.put(sessionKey,new AudioRecordConfiguration(session,source,clientFormat,deviceFormat,patchHandle));
return true;
}
default :
Log.e(TAG,String.format("Unknown event %d for session %d, source %d",event,session,source));
return false;
}
}
}
