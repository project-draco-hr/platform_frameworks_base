{
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,"**** ro.build.version.sdk not set!");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt="eng".equals(SystemProperties.get("ro.build.type"));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLPw("android.uid.system",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.phone",RADIO_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.log",LOG_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLPw("android.uid.nfc",NFC_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get("debug.separate_processes");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if ("*".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,"Running with debug.separate_processes: * (ALL)");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(",");
      Slog.w(TAG,"Running with debug.separate_processes: " + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=new Installer();
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,"data");
      mAsecInternalPath=new File(dataDir,"app-asec").getPath();
      mUserAppDataDir=new File(dataDir,"user");
      mDrmAppPrivateInstallDir=new File(dataDir,"app-private");
      sUserManager=new UserManager(mInstaller,mUserAppDataDir);
      readPermissions();
      mRestoredSettings=mSettings.readLPw(getUsers());
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,"Running ENG build: no pre-dexopt!");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),"framework");
      mDalvikCacheDir=new File(dataDir,"dalvik-cache");
      boolean didDexOpt=false;
      String bootClassPath=System.getProperty("java.boot.class.path");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
              libFiles.add(paths[i]);
              mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,"Boot class path not found: " + paths[i]);
          }
catch (          IOException e) {
            Slog.w(TAG,"Cannot dexopt " + paths[i] + "; is it an APK or JAR? "+ e.getMessage());
          }
        }
      }
 else {
        Slog.w(TAG,"No BOOTCLASSPATH found!");
      }
      if (mSharedLibraries.size() > 0) {
        Iterator<String> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next();
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              libFiles.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,"Library not found: " + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,"Cannot dexopt " + lib + "; is it an APK or JAR? "+ e.getMessage());
          }
        }
      }
      libFiles.add(mFrameworkDir.getPath() + "/framework-res.apk");
      String[] frameworkFiles=mFrameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(mFrameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (libFiles.contains(path)) {
            continue;
          }
          if (!path.endsWith(".apk") && !path.endsWith(".jar")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,"Jar not found: " + path);
          }
catch (          IOException e) {
            Slog.w(TAG,"Exception reading jar: " + path,e);
          }
        }
      }
      if (didDexOpt) {
        String[] files=mDalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith("data@app@") || fn.startsWith("data@app-private@")) {
              Slog.i(TAG,"Pruning dalvik file: " + fn);
              (new File(mDalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),"app");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File("/vendor/app");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,"Running installd update commands");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          if (mPackages.containsKey(ps.name)) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              mPackages.remove(ps.name);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg="System package " + ps.name + " no longer exists; wiping its data";
            reportSettingsProblem(Log.WARN,msg);
            mInstaller.remove(ps.name,0);
            sUserManager.removePackageForAllUsers(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      mAppInstallDir=new File(dataDir,"app");
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg="Updated system package " + deletedAppName + " no longer exists; wiping its data";
            mInstaller.remove(deletedAppName,0);
            sUserManager.removePackageForAllUsers(deletedAppName);
          }
 else {
            msg="Updated system app + " + deletedAppName + " no longer present; removing system privileges for "+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,"Time to scan packages: " + ((SystemClock.uptimeMillis() - startTime) / 1000f) + " seconds");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,"Platform changed from " + mSettings.mInternalSdkPlatform + " to "+ mSdkVersion+ "; regranting permissions for internal storage");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (mActivities.mActivities.get(pa.mPref.mComponent) == null) {
          removed.add(pa);
        }
      }
      for (int i=0; i < removed.size(); i++) {
        PreferredActivity pa=removed.get(i);
        Slog.w(TAG,"Removing dangling preferred activity: " + pa.mPref.mComponent);
        mSettings.mPreferredActivities.removeFilter(pa);
      }
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}
