{
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,"**** ro.build.version.sdk not set!");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mNoDexOpt="eng".equals(SystemProperties.get("ro.build.type"));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(context);
  mSettings.addSharedUserLPw("android.uid.system",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.phone",RADIO_UID,ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.log",LOG_UID,ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.nfc",NFC_UID,ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.bluetooth",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.shell",SHELL_UID,ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PRIVILEGED);
  String separateProcesses=SystemProperties.get("debug.separate_processes");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if ("*".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,"Running with debug.separate_processes: * (ALL)");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(",");
      Slog.w(TAG,"Running with debug.separate_processes: " + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      Watchdog.getInstance().addThread(mHandler,mHandlerThread.getName(),WATCHDOG_TIMEOUT);
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,"data");
      mAppInstallDir=new File(dataDir,"app");
      mAppLibInstallDir=new File(dataDir,"app-lib");
      mAsecInternalPath=new File(dataDir,"app-asec").getPath();
      mUserAppDataDir=new File(dataDir,"user");
      mDrmAppPrivateInstallDir=new File(dataDir,"app-private");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      readPermissions();
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      String customResolverActivity=Resources.getSystem().getString(R.string.config_customResolverActivity);
      if (TextUtils.isEmpty(customResolverActivity)) {
        customResolverActivity=null;
      }
 else {
        mCustomResolverComponentName=ComponentName.unflattenFromString(customResolverActivity);
      }
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS | SCAN_DEFER_DEX| SCAN_BOOTING;
      if (mNoDexOpt) {
        Slog.w(TAG,"Running ENG build: no pre-dexopt!");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> alreadyDexOpted=new HashSet<String>();
      String bootClassPath=System.getProperty("java.boot.class.path");
      if (bootClassPath != null) {
        String[] paths=splitString(bootClassPath,':');
        for (int i=0; i < paths.length; i++) {
          alreadyDexOpted.add(paths[i]);
        }
      }
 else {
        Slog.w(TAG,"No BOOTCLASSPATH found!");
      }
      boolean didDexOpt=false;
      if (mSharedLibraries.size() > 0) {
        Iterator<SharedLibraryEntry> libs=mSharedLibraries.values().iterator();
        while (libs.hasNext()) {
          String lib=libs.next().path;
          if (lib == null) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
              alreadyDexOpted.add(lib);
              mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,"Library not found: " + lib);
          }
catch (          IOException e) {
            Slog.w(TAG,"Cannot dexopt " + lib + "; is it an APK or JAR? "+ e.getMessage());
          }
        }
      }
      File frameworkDir=new File(Environment.getRootDirectory(),"framework");
      alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");
      alreadyDexOpted.add(frameworkDir.getPath() + "/core-libart.jar");
      String[] frameworkFiles=frameworkDir.list();
      if (frameworkFiles != null) {
        for (int i=0; i < frameworkFiles.length; i++) {
          File libPath=new File(frameworkDir,frameworkFiles[i]);
          String path=libPath.getPath();
          if (alreadyDexOpted.contains(path)) {
            continue;
          }
          if (!path.endsWith(".apk") && !path.endsWith(".jar")) {
            continue;
          }
          try {
            if (dalvik.system.DexFile.isDexOptNeeded(path)) {
              mInstaller.dexopt(path,Process.SYSTEM_UID,true);
              didDexOpt=true;
            }
          }
 catch (          FileNotFoundException e) {
            Slog.w(TAG,"Jar not found: " + path);
          }
catch (          IOException e) {
            Slog.w(TAG,"Exception reading jar: " + path,e);
          }
        }
      }
      if (didDexOpt) {
        File dalvikCacheDir=new File(dataDir,"dalvik-cache");
        String[] files=dalvikCacheDir.list();
        if (files != null) {
          for (int i=0; i < files.length; i++) {
            String fn=files[i];
            if (fn.startsWith("data@app@") || fn.startsWith("data@app-private@")) {
              Slog.i(TAG,"Pruning dalvik file: " + fn);
              (new File(dalvikCacheDir,fn)).delete();
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(frameworkDir.getPath(),OBSERVER_EVENTS,true,false);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(frameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      File privilegedAppDir=new File(Environment.getRootDirectory(),"priv-app");
      mPrivilegedInstallObserver=new AppDirObserver(privilegedAppDir.getPath(),OBSERVER_EVENTS,true,true);
      mPrivilegedInstallObserver.startWatching();
      scanDirLI(privilegedAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED,scanMode,0);
      File systemAppDir=new File(Environment.getRootDirectory(),"app");
      mSystemInstallObserver=new AppDirObserver(systemAppDir.getPath(),OBSERVER_EVENTS,true,false);
      mSystemInstallObserver.startWatching();
      scanDirLI(systemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      File vendorAppDir=new File("/vendor/app");
      mVendorInstallObserver=new AppDirObserver(vendorAppDir.getPath(),OBSERVER_EVENTS,true,false);
      mVendorInstallObserver.startWatching();
      scanDirLI(vendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,"Running installd update commands");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              Slog.i(TAG,"Expecting better updatd system app for " + ps.name + "; removing system app");
              removePackageLI(ps,true);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            String msg="System package " + ps.name + " no longer exists; wiping its data";
            reportSettingsProblem(Log.WARN,msg);
            removeDataDirsLI(ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      mSettings.pruneSharedUsersLPw();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false,false);
        mAppInstallObserver.startWatching();
        scanDirLI(mAppInstallDir,0,scanMode,0);
        mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false,false);
        mDrmAppInstallObserver.startWatching();
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg="Updated system package " + deletedAppName + " no longer exists; wiping its data";
            removeDataDirsLI(deletedAppName);
          }
 else {
            msg="Updated system app + " + deletedAppName + " no longer present; removing system privileges for "+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          reportSettingsProblem(Log.WARN,msg);
        }
      }
 else {
        mAppInstallObserver=null;
        mDrmAppInstallObserver=null;
      }
      updateAllSharedLibrariesLPw();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,"Time to scan packages: " + ((SystemClock.uptimeMillis() - startTime) / 1000f) + " seconds");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,"Platform changed from " + mSettings.mInternalSdkPlatform + " to "+ mSdkVersion+ "; regranting permissions for internal storage");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLPw(null,null,UPDATE_PERMISSIONS_ALL | (regrantPermissions ? (UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL) : 0));
      if (!mRestoredSettings && !onlyCore) {
        mSettings.readDefaultPreferredAppsLPw(this,0);
      }
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
      mRequiredVerifierPackage=getRequiredVerifierLPr();
    }
  }
}
