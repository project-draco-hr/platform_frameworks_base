{
switch (msg.what) {
case INIT_COPY:
{
      if (DEBUG_INSTALL)       Slog.i(TAG,"init_copy");
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,"idx=" + idx);
      if (!mBound) {
        if (!connectToService()) {
          Slog.e(TAG,"Failed to bind to media container service");
          params.serviceError();
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,"mcs_bound");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mContainerService == null) {
      Slog.e(TAG,"Cannot bind to media container service");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,"Checking for more work or unbind...");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,"Posting delayed MCS_UNBIND");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,"Posting MCS_BOUND for next woek");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
      }
    }
 else {
      Slog.w(TAG,"Empty queue");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,"mcs_reconnect");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,"Failed to bind to media container service");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,"mcs_unbind");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,"calling disconnectService()");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,"mcs_giveup too many retries");
mPendingInstalls.remove(0);
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
int i=0;
while (it.hasNext() && i < size) {
Map.Entry<String,ArrayList<String>> ent=it.next();
packages[i]=ent.getKey();
components[i]=ent.getValue();
PackageSetting ps=mSettings.mPackages.get(ent.getKey());
uids[i]=(ps != null) ? ps.appId : -1;
i++;
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
PackageCleanItem item=new PackageCleanItem((String)msg.obj,msg.arg2 != 0);
synchronized (mPackages) {
if (msg.arg1 == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(user,item);
}
}
 else {
mSettings.addPackageToCleanLPw(msg.arg1,item);
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages(-1);
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,"Handling post-install for " + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras,null,null,res.users);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras,null,null,res.users);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,res.pkg.applicationInfo.packageName,null,res.users);
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Slog.i(TAG,"Observer no longer exists.");
}
}
}
 else {
Slog.e(TAG,"Bogus post-install token " + msg.arg1);
}
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,"Got message UPDATED_MEDIA_STATUS");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,"reportStatus=" + reportStatus + ", doGc = "+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings("unchecked") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,"Unloading all containers");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,"Invoking MountService call back");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,"MountService not running?");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
Slog.i(TAG,"Verification timed out for " + args.packageURI.toString());
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,"Continuing with installation of " + args.packageURI.toString());
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,"Could not contact the ContainerService");
}
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,"Invalid verification token " + verificationId + " received");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,"Could not contact the ContainerService");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
}
}
