{
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Slog.w(TAG," Code and resource paths haven't been set correctly");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if ((parseFlags & PackageParser.PARSE_IS_PRIVILEGED) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_PRIVILEGED;
  }
  if (mCustomResolverComponentName != null && mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {
    setUpCustomResolverActivity(pkg);
  }
  if (pkg.packageName.equals("android")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,"*************************************************");
        Slog.w(TAG,"Core android package being redefined.  Skipping.");
        Slog.w(TAG," file=" + mScanningPath);
        Slog.w(TAG,"*************************************************");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      if (!mResolverReplaced) {
        mResolveActivity.applicationInfo=mAndroidApplication;
        mResolveActivity.name=ResolverActivity.class.getName();
        mResolveActivity.packageName=mAndroidApplication.packageName;
        mResolveActivity.processName="system:ui";
        mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
        mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
        mResolveActivity.theme=com.android.internal.R.style.Theme_Holo_Dialog_Alert;
        mResolveActivity.exported=true;
        mResolveActivity.enabled=true;
        mResolveInfo.activityInfo=mResolveActivity;
        mResolveInfo.priority=0;
        mResolveInfo.preferredOrder=0;
        mResolveInfo.match=0;
        mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
      }
    }
  }
  if (DEBUG_PACKAGE_SCANNING) {
    if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)     Log.d(TAG,"Scanning package " + pkg.packageName);
  }
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    Slog.w(TAG,"Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if (!isSystemApp(pkg)) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
      if (!updateSharedLibrariesLPw(pkg,null)) {
        return null;
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLPw(pkg.mSharedUserId,0,true);
      if (suid == null) {
        Slog.w(TAG,"Creating application package " + pkg.packageName + " for shared user failed");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)         Log.d(TAG,"Shared UserID " + pkg.mSharedUserId + " (uid="+ suid.userId+ "): packages="+ suid.packages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      final String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdateLPr(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,"Unable to migrate data from " + origPackage.name + " to "+ pkg.packageName+ ": old uid "+ origPackage.sharedUser.name+ " differs from "+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,"Renaming new package " + pkg.packageName + " to old name "+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,"Package " + pkg.packageName + " was transferred to another, but its .apk remains");
    }
    pkgSetting=mSettings.getPackageLPw(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.nativeLibraryDir,pkg.applicationInfo.flags,user,false);
    if (pkgSetting == null) {
      Slog.w(TAG,"Creating application package " + pkg.packageName + " failed");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg="New package " + pkgSetting.realName + " renamed to replace old package "+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    if (mFoundPolicyFile) {
      SELinuxMMAC.assignSeinfoValue(pkg);
    }
    pkg.applicationInfo.uid=pkgSetting.appId;
    pkg.mExtras=pkgSetting;
    if (!verifySignaturesLP(pkgSetting,pkg)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
          Log.w(TAG,"Signature mismatch for shared user : " + pkgSetting.sharedUser);
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      String msg="System package " + pkg.packageName + " signature changed; retaining data.";
      reportSettingsProblem(Log.WARN,msg);
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      final int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(";");
          for (int j=0; j < names.length; j++) {
            if (mProvidersByAuthority.containsKey(names[j])) {
              PackageParser.Provider other=mProvidersByAuthority.get(names[j]);
              Slog.w(TAG,"Can't install because provider name " + names[j] + " (in package "+ pkg.applicationInfo.packageName+ ") is already used by "+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
              mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mAdoptPermissions != null) {
      for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
        final String origName=pkg.mAdoptPermissions.get(i);
        final PackageSetting orig=mSettings.peekPackageLPr(origName);
        if (orig != null) {
          if (verifyPackageUpdateLPr(orig,pkg)) {
            Slog.i(TAG,"Adopting permissions from " + origName + " to "+ pkg.packageName);
            mSettings.transferPermissionsLPw(origName,pkg.packageName);
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  final long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),"system");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    dataPath=getDataPathForPackage(pkg.packageName,0);
    boolean uidError=false;
    if (dataPath.exists()) {
      int currentUid=0;
      try {
        StructStat stat=Libcore.os.stat(dataPath.getPath());
        currentUid=stat.st_uid;
      }
 catch (      ErrnoException e) {
        Slog.e(TAG,"Couldn't stat path " + dataPath.getPath(),e);
      }
      if (currentUid != pkg.applicationInfo.uid) {
        boolean recovered=false;
        if (currentUid == 0) {
          int ret=mInstaller.fixUid(pkgName,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
          if (ret >= 0) {
            recovered=true;
            String msg="Package " + pkg.packageName + " unexpectedly changed to uid 0; recovered to "+ +pkg.applicationInfo.uid;
            reportSettingsProblem(Log.WARN,msg);
          }
        }
        if (!recovered && ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 || (scanMode & SCAN_BOOTING) != 0)) {
          int ret=removeDataDirsLI(pkgName);
          if (ret >= 0) {
            String prefix=(parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 ? "System package " : "Third party package ";
            String msg=prefix + pkg.packageName + " has changed from uid: "+ currentUid+ " to "+ pkg.applicationInfo.uid+ "; old data erased";
            reportSettingsProblem(Log.WARN,msg);
            recovered=true;
            ret=createDataDirsLI(pkgName,pkg.applicationInfo.uid,pkg.applicationInfo.seinfo);
            if (ret == -1) {
              msg=prefix + pkg.packageName + " could not have data directory re-created after delete.";
              reportSettingsProblem(Log.WARN,msg);
              mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
              return null;
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
 else         if (!recovered) {
          mLastScanError=PackageManager.INSTALL_FAILED_UID_CHANGED;
          return null;
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir="/mismatched_uid/settings_" + pkg.applicationInfo.uid + "/fs_"+ currentUid;
          pkg.applicationInfo.nativeLibraryDir=pkg.applicationInfo.dataDir;
          String msg="Package " + pkg.packageName + " has mismatched uid: "+ currentUid+ " on disk, "+ pkg.applicationInfo.uid+ " in settings";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)         Log.v(TAG,"Want this data dir: " + dataPath);
      }
      int ret=createDataDirsLI(pkgName,pkg.applicationInfo.uid,pkg.applicationInfo.seinfo);
      if (ret < 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,"Unable to create data directory: " + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    if (pkg.applicationInfo.nativeLibraryDir == null && pkg.applicationInfo.dataDir != null) {
      if (pkgSetting.nativeLibraryPathString == null) {
        setInternalAppNativeLibraryPath(pkg,pkgSetting);
      }
 else {
        pkg.applicationInfo.nativeLibraryDir=pkgSetting.nativeLibraryPathString;
      }
    }
    pkgSetting.uidError=uidError;
  }
  String path=scanFile.getPath();
  if (pkg.applicationInfo.nativeLibraryDir != null) {
    try {
      File nativeLibraryDir=new File(pkg.applicationInfo.nativeLibraryDir);
      final String dataPathString=dataPath.getCanonicalPath();
      if (isSystemApp(pkg) && !isUpdatedSystemApp(pkg)) {
        if (NativeLibraryHelper.removeNativeBinariesFromDirLI(nativeLibraryDir)) {
          Log.i(TAG,"removed obsolete native libraries for system package " + path);
        }
      }
 else {
        if (!isForwardLocked(pkg) && !isExternal(pkg)) {
          if (nativeLibraryDir.getPath().startsWith(dataPathString)) {
            setInternalAppNativeLibraryPath(pkg,pkgSetting);
            nativeLibraryDir=new File(pkg.applicationInfo.nativeLibraryDir);
          }
          try {
            if (copyNativeLibrariesForInternalApp(scanFile,nativeLibraryDir) != PackageManager.INSTALL_SUCCEEDED) {
              Slog.e(TAG,"Unable to copy native libraries");
              mLastScanError=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
              return null;
            }
          }
 catch (          IOException e) {
            Slog.e(TAG,"Unable to copy native libraries",e);
            mLastScanError=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
            return null;
          }
        }
        if (DEBUG_INSTALL)         Slog.i(TAG,"Linking native library dir for " + path);
        final int[] userIds=sUserManager.getUserIds();
synchronized (mInstallLock) {
          for (          int userId : userIds) {
            if (mInstaller.linkNativeLibraryDirectory(pkg.packageName,pkg.applicationInfo.nativeLibraryDir,userId) < 0) {
              Slog.w(TAG,"Failed linking native library dir (user=" + userId + ")");
              mLastScanError=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
              return null;
            }
          }
        }
      }
    }
 catch (    IOException ioe) {
      Slog.e(TAG,"Unable to get canonical file " + ioe.toString());
    }
  }
  pkg.mScanPath=path;
  if ((scanMode & SCAN_NO_DEX) == 0) {
    if (performDexOptLI(pkg,forceDex,(scanMode & SCAN_DEFER_DEX) != 0,false) == DEX_OPT_FAILED) {
      mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
      return null;
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  ArrayList<PackageParser.Package> clientLibPkgs=null;
synchronized (mPackages) {
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
      if (pkg.libraryNames != null) {
        for (int i=0; i < pkg.libraryNames.size(); i++) {
          String name=pkg.libraryNames.get(i);
          boolean allowed=false;
          if (isUpdatedSystemApp(pkg)) {
            final PackageSetting sysPs=mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
              for (int j=0; j < sysPs.pkg.libraryNames.size(); j++) {
                if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                  allowed=true;
                  allowed=true;
                  break;
                }
              }
            }
          }
 else {
            allowed=true;
          }
          if (allowed) {
            if (!mSharedLibraries.containsKey(name)) {
              mSharedLibraries.put(name,new SharedLibraryEntry(null,pkg.packageName));
            }
 else             if (!name.equals(pkg.packageName)) {
              Slog.w(TAG,"Package " + pkg.packageName + " library "+ name+ " already exists; skipping");
            }
          }
 else {
            Slog.w(TAG,"Package " + pkg.packageName + " declares lib "+ name+ " that is not declared on system image; skipping");
          }
        }
        if ((scanMode & SCAN_BOOTING) == 0) {
          clientLibPkgs=updateAllSharedLibrariesLPw(pkg);
        }
      }
    }
  }
  if (clientLibPkgs != null) {
    if ((scanMode & SCAN_NO_DEX) == 0) {
      for (int i=0; i < clientLibPkgs.size(); i++) {
        PackageParser.Package clientPkg=clientLibPkgs.get(i);
        if (performDexOptLI(clientPkg,forceDex,(scanMode & SCAN_DEFER_DEX) != 0,false) == DEX_OPT_FAILED) {
          mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
          return null;
        }
      }
    }
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    if (isForwardLocked(pkg) || isExternal(pkg)) {
      if (DEBUG_INSTALL) {
        Slog.i(TAG,"upgrading pkg " + pkg + " is ASEC-hosted -> UNAVAILABLE");
      }
      final int[] uidArray=new int[]{pkg.applicationInfo.uid};
      final ArrayList<String> pkgList=new ArrayList<String>(1);
      pkgList.add(pkg.applicationInfo.packageName);
      sendResourcesChangedBroadcast(false,true,pkgList,uidArray,null);
    }
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid,"update pkg");
  }
  if (clientLibPkgs != null) {
    for (int i=0; i < clientLibPkgs.size(); i++) {
      PackageParser.Package clientPkg=clientLibPkgs.get(i);
      killApplication(clientPkg.applicationInfo.packageName,clientPkg.applicationInfo.uid,"update lib");
    }
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.mPath,pkg);
    }
    mSettings.insertPackageSettingLPw(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    final Iterator<PackageCleanItem> iter=mSettings.mPackagesToBeCleaned.iterator();
    while (iter.hasNext()) {
      PackageCleanItem item=iter.next();
      if (pkgName.equals(item.packageName)) {
        iter.remove();
      }
    }
    if (currentTime != 0) {
      if (pkgSetting.firstInstallTime == 0) {
        pkgSetting.firstInstallTime=pkgSetting.lastUpdateTime=currentTime;
      }
 else       if ((scanMode & SCAN_UPDATE_TIME) != 0) {
        pkgSetting.lastUpdateTime=currentTime;
      }
    }
 else     if (pkgSetting.firstInstallTime == 0) {
      pkgSetting.firstInstallTime=pkgSetting.lastUpdateTime=scanFileTime;
    }
 else     if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
      if (scanFileTime != pkgSetting.timeStamp) {
        pkgSetting.lastUpdateTime=scanFileTime;
      }
    }
    KeySetManager ksm=mSettings.mKeySetManager;
    try {
      ksm.addSigningKeySetToPackage(pkg.packageName,pkg.mSigningKeys);
      if (pkg.mKeySetMapping != null) {
        for (        Map.Entry<String,Set<PublicKey>> entry : pkg.mKeySetMapping.entrySet()) {
          if (entry.getValue() != null) {
            ksm.addDefinedKeySetToPackage(pkg.packageName,entry.getValue(),entry.getKey());
          }
        }
      }
    }
 catch (    NullPointerException e) {
      Slog.e(TAG,"Could not add KeySet to " + pkg.packageName,e);
    }
catch (    IllegalArgumentException e) {
      Slog.e(TAG,"Could not add KeySet to malformed package" + pkg.packageName,e);
    }
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProviders.addProvider(p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(";");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProvidersByAuthority.containsKey(names[j])) {
            mProvidersByAuthority.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ";" + names[j];
            }
            if (DEBUG_PACKAGE_SCANNING) {
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)               Log.d(TAG,"Registered content provider: " + names[j] + ", className = "+ p.info.name+ ", isSyncable = "+ p.info.isSyncable);
            }
          }
 else {
            PackageParser.Provider other=mProvidersByAuthority.get(names[j]);
            Slog.w(TAG,"Skipping provider name " + names[j] + " (in package "+ pkg.applicationInfo.packageName+ "): name already used by "+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Providers: " + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Services: " + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,"receiver");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Receivers: " + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,"activity");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Activities: " + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,"Permission group " + pg.info.name + " from package "+ pg.info.packageName+ " ignored: original from "+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append("DUP:");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Permission Groups: " + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: base tree "+ tree.name+ " is from package "+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: original from "+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append("DUP:");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: no group "+ p.group);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Permissions: " + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      a.info.nativeLibraryDir=pkg.applicationInfo.nativeLibraryDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Instrumentation: " + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}
