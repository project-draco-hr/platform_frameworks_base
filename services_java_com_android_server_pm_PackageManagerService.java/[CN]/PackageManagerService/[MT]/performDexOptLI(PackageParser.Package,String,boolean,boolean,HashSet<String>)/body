{
  final String instructionSet=instructionSetOverride != null ? instructionSetOverride : getAppInstructionSet(pkg.applicationInfo);
  final String dexCodeInstructionSet=getDexCodeInstructionSet(instructionSet);
  if (done != null) {
    done.add(pkg.packageName);
    if (pkg.usesLibraries != null) {
      performDexOptLibsLI(pkg.usesLibraries,dexCodeInstructionSet,forceDex,defer,done);
    }
    if (pkg.usesOptionalLibraries != null) {
      performDexOptLibsLI(pkg.usesOptionalLibraries,dexCodeInstructionSet,forceDex,defer,done);
    }
  }
  final boolean vmSafeMode=(pkg.applicationInfo.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0;
  boolean performed=false;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_HAS_CODE) != 0) {
    String path=pkg.mScanPath;
    try {
      byte isDexOptNeededInternal=DexFile.isDexOptNeededInternal(path,pkg.packageName,dexCodeInstructionSet,defer);
      if (forceDex || (!defer && isDexOptNeededInternal == DexFile.DEXOPT_NEEDED)) {
        Log.i(TAG,"Running dexopt on: " + pkg.applicationInfo.packageName + " vmSafeMode="+ vmSafeMode);
        final int sharedGid=UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
        int ret=mInstaller.dexopt(path,sharedGid,!isForwardLocked(pkg),pkg.packageName,dexCodeInstructionSet,vmSafeMode);
        pkg.mDexOptNeeded=false;
        if (ret < 0) {
          return DEX_OPT_FAILED;
        }
        return DEX_OPT_PERFORMED;
      }
 else       if (!defer && isDexOptNeededInternal == DexFile.PATCHOAT_NEEDED) {
        Log.i(TAG,"Running patchoat on: " + pkg.applicationInfo.packageName);
        final int sharedGid=UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
        int ret=mInstaller.patchoat(path,sharedGid,!isForwardLocked(pkg),pkg.packageName,instructionSet);
        pkg.mDexOptNeeded=false;
        if (ret < 0) {
          return DEX_OPT_FAILED;
        }
        return DEX_OPT_PERFORMED;
      }
      if (defer && isDexOptNeededInternal != DexFile.UP_TO_DATE) {
        if (mDeferredDexOpt == null) {
          mDeferredDexOpt=new HashSet<PackageParser.Package>();
        }
        mDeferredDexOpt.add(pkg);
        return DEX_OPT_DEFERRED;
      }
      pkg.mDexOptNeeded=false;
      return DEX_OPT_SKIPPED;
    }
 catch (    FileNotFoundException e) {
      Slog.w(TAG,"Apk not found for dexopt: " + path);
      return DEX_OPT_FAILED;
    }
catch (    IOException e) {
      Slog.w(TAG,"IOException reading apk: " + path,e);
      return DEX_OPT_FAILED;
    }
catch (    StaleDexCacheError e) {
      Slog.w(TAG,"StaleDexCacheError when reading apk: " + path,e);
      return DEX_OPT_FAILED;
    }
catch (    Exception e) {
      Slog.w(TAG,"Exception when doing dexopt : ",e);
      return DEX_OPT_FAILED;
    }
  }
  return DEX_OPT_SKIPPED;
}
