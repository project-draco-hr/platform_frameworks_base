{
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  final GrantedPermissions gp=ps.sharedUser != null ? ps.sharedUser : ps;
  HashSet<String> origPermissions=gp.grantedPermissions;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    if (gp == ps) {
      origPermissions=new HashSet<String>(gp.grantedPermissions);
      gp.grantedPermissions.clear();
      gp.gids=mGlobalGids;
    }
  }
  if (gp.gids == null) {
    gp.gids=mGlobalGids;
  }
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    final String name=pkg.requestedPermissions.get(i);
    final boolean required=pkg.requestedPermissionsRequired.get(i);
    final BasePermission bp=mSettings.mPermissions.get(name);
    if (DEBUG_INSTALL) {
      if (gp != ps) {
        Log.i(TAG,"Package " + pkg.packageName + " checking "+ name+ ": "+ bp);
      }
    }
    if (bp == null || bp.packageSetting == null) {
      Slog.w(TAG,"Unknown permission " + name + " in package "+ pkg.packageName);
      continue;
    }
    final String perm=bp.name;
    boolean allowed;
    boolean allowedSig=false;
    final int level=bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;
    if (level == PermissionInfo.PROTECTION_NORMAL || level == PermissionInfo.PROTECTION_DANGEROUS) {
      allowed=(required || origPermissions.contains(perm));
    }
 else     if (bp.packageSetting == null) {
      allowed=false;
    }
 else     if (level == PermissionInfo.PROTECTION_SIGNATURE) {
      allowed=doSignaturePermission(perm,pkg,bp,origPermissions);
      if (allowed) {
        allowedSig=true;
      }
    }
 else {
      allowed=false;
    }
    if (DEBUG_INSTALL) {
      if (gp != ps) {
        Log.i(TAG,"Package " + pkg.packageName + " granting "+ perm);
      }
    }
    if (allowed) {
      if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0 && ps.permissionsFixed) {
        if (!allowedSig && !gp.grantedPermissions.contains(perm)) {
          allowed=false;
          final int NP=PackageParser.NEW_PERMISSIONS.length;
          for (int ip=0; ip < NP; ip++) {
            final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
            if (npi.name.equals(perm) && pkg.applicationInfo.targetSdkVersion < npi.sdkVersion) {
              allowed=true;
              Log.i(TAG,"Auto-granting " + perm + " to old pkg "+ pkg.packageName);
              break;
            }
          }
        }
      }
      if (allowed) {
        if (!gp.grantedPermissions.contains(perm)) {
          changedPermission=true;
          gp.grantedPermissions.add(perm);
          gp.gids=appendInts(gp.gids,bp.gids);
        }
 else         if (!ps.haveGids) {
          gp.gids=appendInts(gp.gids,bp.gids);
        }
      }
 else {
        Slog.w(TAG,"Not granting permission " + perm + " to package "+ pkg.packageName+ " because it was previously installed without");
      }
    }
 else {
      if (gp.grantedPermissions.remove(perm)) {
        changedPermission=true;
        gp.gids=removeInts(gp.gids,bp.gids);
        Slog.i(TAG,"Un-granting permission " + perm + " from package "+ pkg.packageName+ " (protectionLevel="+ bp.protectionLevel+ " flags=0x"+ Integer.toHexString(pkg.applicationInfo.flags)+ ")");
      }
 else {
        Slog.w(TAG,"Not granting permission " + perm + " to package "+ pkg.packageName+ " (protectionLevel="+ bp.protectionLevel+ " flags=0x"+ Integer.toHexString(pkg.applicationInfo.flags)+ ")");
      }
    }
  }
  if ((changedPermission || replace) && !ps.permissionsFixed && ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) || ((ps.pkgFlags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)) {
    ps.permissionsFixed=true;
  }
  ps.haveGids=true;
}
