{
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG," Package " + mp.packageName + " doesn't exist. Aborting move");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
            Slog.w(TAG,"Package " + mp.packageName + " code path changed from "+ mp.srcArgs.getCodePath()+ " to "+ pkg.applicationInfo.sourceDir+ " Aborting move and returning error");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,true,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG," Package " + mp.packageName + " doesn't exist. Aborting move");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.sourceDir)) {
                Slog.w(TAG,"Package " + mp.packageName + " code path changed from "+ mp.srcArgs.getCodePath()+ " to "+ pkg.applicationInfo.sourceDir+ " Aborting move and returning error");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                final String oldCodePath=pkg.mPath;
                final String newCodePath=mp.targetArgs.getCodePath();
                final String newResPath=mp.targetArgs.getResourcePath();
                final String newNativePath=mp.targetArgs.getNativeLibraryPath();
                final File newNativeDir=new File(newNativePath);
                if (!isForwardLocked(pkg) && !isExternal(pkg)) {
                  NativeLibraryHelper.copyNativeBinariesIfNeededLI(new File(newCodePath),newNativeDir);
                }
                final int[] users=sUserManager.getUserIds();
                for (                int user : users) {
                  if (mInstaller.linkNativeLibraryDirectory(pkg.packageName,newNativePath,user) < 0) {
                    returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                  }
                }
                if (returnCode == PackageManager.MOVE_SUCCEEDED) {
                  pkg.mPath=newCodePath;
                  if (moveDexFilesLI(pkg) != PackageManager.INSTALL_SUCCEEDED) {
                    pkg.mPath=pkg.mScanPath;
                    returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                  }
                }
                if (returnCode == PackageManager.MOVE_SUCCEEDED) {
                  pkg.mScanPath=newCodePath;
                  pkg.applicationInfo.sourceDir=newCodePath;
                  pkg.applicationInfo.publicSourceDir=newResPath;
                  pkg.applicationInfo.nativeLibraryDir=newNativePath;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.sourceDir);
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.publicSourceDir);
                  ps.resourcePathString=ps.resourcePath.getPath();
                  ps.nativeLibraryPathString=newNativePath;
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLPr();
                }
              }
            }
          }
          sendResourcesChangedBroadcast(true,false,pkgList,uidArr,null);
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR,-1);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      if (returnCode != PackageManager.MOVE_FAILED_OPERATION_PENDING) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg != null) {
            pkg.mOperationPending=false;
          }
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,"Observer no longer exists.");
        }
      }
    }
  }
);
}
