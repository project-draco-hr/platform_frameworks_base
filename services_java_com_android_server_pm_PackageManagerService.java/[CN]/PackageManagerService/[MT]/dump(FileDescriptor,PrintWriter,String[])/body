{
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println("Permission Denial: can't dump ActivityManager from from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid()+ " without permission "+ android.Manifest.permission.DUMP);
    return;
  }
  DumpState dumpState=new DumpState();
  String packageName=null;
  int opti=0;
  while (opti < args.length) {
    String opt=args[opti];
    if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
      break;
    }
    opti++;
    if ("-a".equals(opt)) {
    }
 else     if ("-h".equals(opt)) {
      pw.println("Package manager dump options:");
      pw.println("  [-h] [-f] [cmd] ...");
      pw.println("    -f: print details of intent filters");
      pw.println("    -h: print this help");
      pw.println("  cmd may be one of:");
      pw.println("    l[ibraries]: list known shared libraries");
      pw.println("    f[ibraries]: list device features");
      pw.println("    r[esolvers]: dump intent resolvers");
      pw.println("    perm[issions]: dump permissions");
      pw.println("    prov[iders]: dump content providers");
      pw.println("    p[ackages]: dump installed packages");
      pw.println("    s[hared-users]: dump shared user IDs");
      pw.println("    m[essages]: print collected runtime messages");
      pw.println("    <package.name>: info about given package");
      return;
    }
 else     if ("-f".equals(opt)) {
      dumpState.setOptionEnabled(DumpState.OPTION_SHOW_FILTERS);
    }
 else {
      pw.println("Unknown argument: " + opt + "; use -h for help");
    }
  }
  if (opti < args.length) {
    String cmd=args[opti];
    opti++;
    if ("android".equals(cmd) || cmd.contains(".")) {
      packageName=cmd;
    }
 else     if ("l".equals(cmd) || "libraries".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_LIBS);
    }
 else     if ("f".equals(cmd) || "features".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_FEATURES);
    }
 else     if ("r".equals(cmd) || "resolvers".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_RESOLVERS);
    }
 else     if ("perm".equals(cmd) || "permissions".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_PERMISSIONS);
    }
 else     if ("p".equals(cmd) || "packages".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_PACKAGES);
    }
 else     if ("s".equals(cmd) || "shared-users".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_SHARED_USERS);
    }
 else     if ("prov".equals(cmd) || "providers".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_PROVIDERS);
    }
 else     if ("m".equals(cmd) || "messages".equals(cmd)) {
      dumpState.setDump(DumpState.DUMP_MESSAGES);
    }
  }
synchronized (mPackages) {
    if (dumpState.isDumping(DumpState.DUMP_LIBS) && packageName == null) {
      if (dumpState.onTitlePrinted())       pw.println(" ");
      pw.println("Libraries:");
      final Iterator<String> it=mSharedLibraries.keySet().iterator();
      while (it.hasNext()) {
        String name=it.next();
        pw.print("  ");
        pw.print(name);
        pw.print(" -> ");
        pw.println(mSharedLibraries.get(name));
      }
    }
    if (dumpState.isDumping(DumpState.DUMP_FEATURES) && packageName == null) {
      if (dumpState.onTitlePrinted())       pw.println(" ");
      pw.println("Features:");
      Iterator<String> it=mAvailableFeatures.keySet().iterator();
      while (it.hasNext()) {
        String name=it.next();
        pw.print("  ");
        pw.println(name);
      }
    }
    if (dumpState.isDumping(DumpState.DUMP_RESOLVERS)) {
      if (mActivities.dump(pw,dumpState.getTitlePrinted() ? "\nActivity Resolver Table:" : "Activity Resolver Table:","  ",packageName,dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS))) {
        dumpState.setTitlePrinted(true);
      }
      if (mReceivers.dump(pw,dumpState.getTitlePrinted() ? "\nReceiver Resolver Table:" : "Receiver Resolver Table:","  ",packageName,dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS))) {
        dumpState.setTitlePrinted(true);
      }
      if (mServices.dump(pw,dumpState.getTitlePrinted() ? "\nService Resolver Table:" : "Service Resolver Table:","  ",packageName,dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS))) {
        dumpState.setTitlePrinted(true);
      }
      if (mSettings.mPreferredActivities.dump(pw,dumpState.getTitlePrinted() ? "\nPreferred Activities:" : "Preferred Activities:","  ",packageName,dumpState.isOptionEnabled(DumpState.OPTION_SHOW_FILTERS))) {
        dumpState.setTitlePrinted(true);
      }
    }
    if (dumpState.isDumping(DumpState.DUMP_PERMISSIONS)) {
      mSettings.dumpPermissionsLPr(pw,packageName,dumpState);
    }
    if (dumpState.isDumping(DumpState.DUMP_PROVIDERS)) {
      boolean printedSomething=false;
      for (      PackageParser.Provider p : mProviders.values()) {
        if (packageName != null && !packageName.equals(p.info.packageName)) {
          continue;
        }
        if (!printedSomething) {
          if (dumpState.onTitlePrinted())           pw.println(" ");
          pw.println("Registered ContentProviders:");
          printedSomething=true;
        }
        pw.print("  [");
        pw.print(p.info.authority);
        pw.print("]: ");
        pw.println(p.toString());
      }
    }
    if (dumpState.isDumping(DumpState.DUMP_PACKAGES)) {
      mSettings.dumpPackagesLPr(pw,packageName,dumpState);
    }
    if (dumpState.isDumping(DumpState.DUMP_SHARED_USERS)) {
      mSettings.dumpSharedUsersLPr(pw,packageName,dumpState);
    }
    if (dumpState.isDumping(DumpState.DUMP_MESSAGES) && packageName == null) {
      if (dumpState.onTitlePrinted())       pw.println(" ");
      mSettings.dumpReadMessagesLPr(pw,dumpState);
      pw.println(" ");
      pw.println("Package warning messages:");
      final File fname=getSettingsProblemFile();
      FileInputStream in=null;
      try {
        in=new FileInputStream(fname);
        final int avail=in.available();
        final byte[] data=new byte[avail];
        in.read(data);
        pw.print(new String(data));
      }
 catch (      FileNotFoundException e) {
      }
catch (      IOException e) {
      }
 finally {
        if (in != null) {
          try {
            in.close();
          }
 catch (          IOException e) {
          }
        }
      }
    }
  }
}
