{
  Matrix tr=new Matrix();
  tr.setTranslate(-centroid[0],-centroid[1]);
  tr.mapPoints(points);
  double[][] array=computeCoVariance(points);
  double[] targetVector=computeOrientation(array);
  float angle;
  if (targetVector[0] == 0 && targetVector[1] == 0) {
    angle=-90;
  }
 else {
    angle=(float)Math.atan2(targetVector[1],targetVector[0]);
    angle=(float)(180 * angle / Math.PI);
    Matrix trans=new Matrix();
    trans.setRotate(-angle);
    trans.mapPoints(points);
  }
  float minx=Float.MAX_VALUE;
  float miny=Float.MAX_VALUE;
  float maxx=Float.MIN_VALUE;
  float maxy=Float.MIN_VALUE;
  int count=points.length;
  for (int i=0; i < count; i++) {
    if (points[i] < minx) {
      minx=points[i];
    }
    if (points[i] > maxx) {
      maxx=points[i];
    }
    i++;
    if (points[i] < miny) {
      miny=points[i];
    }
    if (points[i] > maxy) {
      maxy=points[i];
    }
  }
  return new OrientedBoundingBox(angle,centroid[0],centroid[1],maxx - minx,maxy - miny);
}
