{
  final float targetPatchSize=sampleMatrixDimension - 1;
  float[] sample=new float[sampleMatrixDimension * sampleMatrixDimension];
  Arrays.fill(sample,0);
  RectF rect=gesture.getBoundingBox();
  final float gestureWidth=rect.width();
  final float gestureHeight=rect.height();
  float sx=targetPatchSize / gestureWidth;
  float sy=targetPatchSize / gestureHeight;
  if (uniformScaling) {
    float scale=sx < sy ? sx : sy;
    sx=scale;
    sy=scale;
  }
 else {
    float aspectRatio=gestureWidth / gestureHeight;
    if (aspectRatio > 1) {
      aspectRatio=1 / aspectRatio;
    }
    if (aspectRatio < SCALING_THRESHOLD) {
      float scale=sx < sy ? sx : sy;
      sx=scale;
      sy=scale;
    }
 else {
      if (sx > sy) {
        float scale=sy * NONUNIFORM_SCALE;
        if (scale < sx) {
          sx=scale;
        }
      }
 else {
        float scale=sx * NONUNIFORM_SCALE;
        if (scale < sy) {
          sy=scale;
        }
      }
    }
  }
  float preDx=-rect.centerX();
  float preDy=-rect.centerY();
  float postDx=targetPatchSize / 2;
  float postDy=targetPatchSize / 2;
  final ArrayList<GestureStroke> strokes=gesture.getStrokes();
  final int count=strokes.size();
  int size;
  float xpos;
  float ypos;
  for (int index=0; index < count; index++) {
    final GestureStroke stroke=strokes.get(index);
    float[] strokepoints=stroke.points;
    size=strokepoints.length;
    final float[] pts=new float[size];
    for (int i=0; i < size; i+=2) {
      pts[i]=(strokepoints[i] + preDx) * sx + postDx;
      pts[i + 1]=(strokepoints[i + 1] + preDy) * sy + postDy;
    }
    float segmentEndX=-1;
    float segmentEndY=-1;
    for (int i=0; i < size; i+=2) {
      float segmentStartX=pts[i] < 0 ? 0 : pts[i];
      float segmentStartY=pts[i + 1] < 0 ? 0 : pts[i + 1];
      if (segmentStartX > targetPatchSize) {
        segmentStartX=targetPatchSize;
      }
      if (segmentStartY > targetPatchSize) {
        segmentStartY=targetPatchSize;
      }
      plot(segmentStartX,segmentStartY,sample,sampleMatrixDimension);
      if (segmentEndX != -1) {
        if (segmentEndX > segmentStartX) {
          xpos=(float)Math.ceil(segmentStartX);
          float slope=(segmentEndY - segmentStartY) / (segmentEndX - segmentStartX);
          while (xpos < segmentEndX) {
            ypos=slope * (xpos - segmentStartX) + segmentStartY;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            xpos++;
          }
        }
 else         if (segmentEndX < segmentStartX) {
          xpos=(float)Math.ceil(segmentEndX);
          float slope=(segmentEndY - segmentStartY) / (segmentEndX - segmentStartX);
          while (xpos < segmentStartX) {
            ypos=slope * (xpos - segmentStartX) + segmentStartY;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            xpos++;
          }
        }
        if (segmentEndY > segmentStartY) {
          ypos=(float)Math.ceil(segmentStartY);
          float invertSlope=(segmentEndX - segmentStartX) / (segmentEndY - segmentStartY);
          while (ypos < segmentEndY) {
            xpos=invertSlope * (ypos - segmentStartY) + segmentStartX;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            ypos++;
          }
        }
 else         if (segmentEndY < segmentStartY) {
          ypos=(float)Math.ceil(segmentEndY);
          float invertSlope=(segmentEndX - segmentStartX) / (segmentEndY - segmentStartY);
          while (ypos < segmentStartY) {
            xpos=invertSlope * (ypos - segmentStartY) + segmentStartX;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            ypos++;
          }
        }
      }
      segmentEndX=segmentStartX;
      segmentEndY=segmentStartY;
    }
  }
  return sample;
}
