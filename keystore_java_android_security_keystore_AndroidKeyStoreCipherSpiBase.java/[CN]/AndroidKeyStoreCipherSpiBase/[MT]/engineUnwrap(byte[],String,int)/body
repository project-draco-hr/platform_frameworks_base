{
  if (mKey == null) {
    throw new IllegalStateException("Not initilized");
  }
  if (isEncrypting()) {
    throw new IllegalStateException("Cipher must be initialized in Cipher.WRAP_MODE to wrap keys");
  }
  if (wrappedKey == null) {
    throw new NullPointerException("wrappedKey == null");
  }
  byte[] encoded;
  try {
    encoded=engineDoFinal(wrappedKey,0,wrappedKey.length);
  }
 catch (  IllegalBlockSizeException|BadPaddingException e) {
    throw new InvalidKeyException("Failed to unwrap key",e);
  }
switch (wrappedKeyType) {
case Cipher.SECRET_KEY:
{
      return new SecretKeySpec(encoded,wrappedKeyAlgorithm);
    }
case Cipher.PRIVATE_KEY:
{
    KeyFactory keyFactory=KeyFactory.getInstance(wrappedKeyAlgorithm);
    try {
      return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encoded));
    }
 catch (    InvalidKeySpecException e) {
      throw new InvalidKeyException("Failed to create private key from its PKCS#8 encoded form",e);
    }
  }
case Cipher.PUBLIC_KEY:
{
  KeyFactory keyFactory=KeyFactory.getInstance(wrappedKeyAlgorithm);
  try {
    return keyFactory.generatePublic(new X509EncodedKeySpec(encoded));
  }
 catch (  InvalidKeySpecException e) {
    throw new InvalidKeyException("Failed to create public key from its X.509 encoded form",e);
  }
}
default :
throw new InvalidParameterException("Unsupported wrappedKeyType: " + wrappedKeyType);
}
}
