{
  if (!TILES_SETTING.equals(key)) {
    return;
  }
  if (DEBUG)   Log.d(TAG,"Recreating tiles");
  final List<String> tileSpecs=loadTileSpecs(mContext,newValue);
  if (tileSpecs.equals(mTileSpecs))   return;
  for (  Map.Entry<String,QSTile<?>> tile : mTiles.entrySet()) {
    if (!tileSpecs.contains(tile.getKey())) {
      if (DEBUG)       Log.d(TAG,"Destroying tile: " + tile.getKey());
      tile.getValue().destroy();
    }
  }
  final LinkedHashMap<String,QSTile<?>> newTiles=new LinkedHashMap<>();
  for (  String tileSpec : tileSpecs) {
    if (mTiles.containsKey(tileSpec)) {
      QSTile<?> tile=mTiles.get(tileSpec);
      if (DEBUG)       Log.d(TAG,"Adding " + tile);
      newTiles.put(tileSpec,tile);
    }
 else {
      if (DEBUG)       Log.d(TAG,"Creating tile: " + tileSpec);
      try {
        QSTile<?> tile=createTile(tileSpec);
        if (tile != null) {
          tile.setTileSpec(tileSpec);
          newTiles.put(tileSpec,tile);
        }
      }
 catch (      Throwable t) {
        Log.w(TAG,"Error creating tile for spec: " + tileSpec,t);
      }
    }
  }
  mTileSpecs.clear();
  mTileSpecs.addAll(tileSpecs);
  mTiles.clear();
  mTiles.putAll(newTiles);
  for (int i=0; i < mCallbacks.size(); i++) {
    mCallbacks.get(i).onTilesChanged();
  }
}
