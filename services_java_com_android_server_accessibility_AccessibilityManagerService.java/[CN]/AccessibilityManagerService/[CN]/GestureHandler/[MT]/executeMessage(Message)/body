{
  final int type=message.what;
switch (type) {
case MSG_HANDLE_GESTURE:
{
      IAccessibilityServiceClient service=(IAccessibilityServiceClient)message.obj;
      final int gestureId=message.arg1;
      final int interactionId=message.arg2;
      try {
        service.onGesture(gestureId,this,interactionId);
      }
 catch (      RemoteException re) {
        Slog.e(LOG_TAG,"Error dispatching a gesture to a client.",re);
        return;
      }
      long waitTimeMillis=0;
      final long startTimeMillis=SystemClock.uptimeMillis();
synchronized (mGestureLock) {
        while (true) {
          try {
            if (mInteractionId == interactionId) {
              break;
            }
            if (mInteractionId > interactionId) {
              break;
            }
            final long elapsedTimeMillis=SystemClock.uptimeMillis() - startTimeMillis;
            waitTimeMillis=TIMEOUT_INTERACTION_MILLIS - elapsedTimeMillis;
            if (waitTimeMillis <= 0) {
              break;
            }
            mGestureLock.wait(waitTimeMillis);
          }
 catch (          InterruptedException ie) {
          }
        }
        handleGestureIfNeededAndResetLocked(gestureId);
      }
    }
  break;
case MSG_HANDLE_GESTURE_DEFAULT:
{
  final int gestureId=message.arg1;
  handleGestureDefault(gestureId);
}
break;
default :
{
throw new IllegalArgumentException("Unknown message type: " + type);
}
}
}
