{
  if (sms == null) {
    return;
  }
  boolean handled=false;
  if (sms.isMWISetMessage()) {
    mPhone.updateMessageWaitingIndicator(true);
    if (sms.isMwiDontStore()) {
      handled=true;
    }
    if (Config.LOGD) {
      Log.d(TAG,"Received voice mail indicator set SMS shouldStore=" + !handled);
    }
  }
 else   if (sms.isMWIClearMessage()) {
    mPhone.updateMessageWaitingIndicator(false);
    if (sms.isMwiDontStore()) {
      handled=true;
    }
    if (Config.LOGD) {
      Log.d(TAG,"Received voice mail indicator clear SMS shouldStore=" + !handled);
    }
  }
  if (handled) {
    return;
  }
  int referenceNumber=-1;
  int count=0;
  int sequence=0;
  int destPort=-1;
  SmsHeader header=sms.getUserDataHeader();
  if (header != null) {
    for (    SmsHeader.Element element : header.getElements()) {
switch (element.getID()) {
case SmsHeader.CONCATENATED_8_BIT_REFERENCE:
{
          byte[] data=element.getData();
          referenceNumber=data[0] & 0xff;
          count=data[1] & 0xff;
          sequence=data[2] & 0xff;
          break;
        }
case SmsHeader.CONCATENATED_16_BIT_REFERENCE:
{
        byte[] data=element.getData();
        referenceNumber=(data[0] & 0xff) * 256 + (data[1] & 0xff);
        count=data[2] & 0xff;
        sequence=data[3] & 0xff;
        break;
      }
case SmsHeader.APPLICATION_PORT_ADDRESSING_16_BIT:
{
      byte[] data=element.getData();
      destPort=(data[0] & 0xff) << 8;
      destPort|=(data[1] & 0xff);
      break;
    }
}
}
}
if (referenceNumber == -1) {
byte[][] pdus=new byte[1][];
pdus[0]=sms.getPdu();
if (destPort != -1) {
if (destPort == SmsHeader.PORT_WAP_PUSH) {
  mWapPush.dispatchWapPdu(sms.getUserData());
}
dispatchPortAddressedPdus(pdus,destPort);
}
 else {
dispatchPdus(pdus);
}
}
 else {
processMessagePart(sms,referenceNumber,sequence,count,destPort);
}
}
