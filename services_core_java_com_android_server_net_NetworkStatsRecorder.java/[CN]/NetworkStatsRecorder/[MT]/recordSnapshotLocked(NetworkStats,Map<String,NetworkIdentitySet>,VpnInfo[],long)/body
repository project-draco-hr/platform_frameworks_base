{
  final HashSet<String> unknownIfaces=Sets.newHashSet();
  if (snapshot == null)   return;
  if (mLastSnapshot == null) {
    mLastSnapshot=snapshot;
    return;
  }
  final NetworkStatsCollection complete=mComplete != null ? mComplete.get() : null;
  final NetworkStats delta=NetworkStats.subtract(snapshot,mLastSnapshot,mObserver,mCookie);
  final long end=currentTimeMillis;
  final long start=end - delta.getElapsedRealtime();
  if (vpnArray != null) {
    for (    VpnInfo info : vpnArray) {
      delta.migrateTun(info.ownerUid,info.vpnIface,info.primaryUnderlyingIface);
    }
  }
  NetworkStats.Entry entry=null;
  for (int i=0; i < delta.size(); i++) {
    entry=delta.getValues(i,entry);
    final NetworkIdentitySet ident=ifaceIdent.get(entry.iface);
    if (ident == null) {
      unknownIfaces.add(entry.iface);
      continue;
    }
    if (entry.isEmpty())     continue;
    if ((entry.tag == TAG_NONE) != mOnlyTags) {
      if (mPending != null) {
        mPending.recordData(ident,entry.uid,entry.set,entry.tag,start,end,entry);
      }
      if (mSinceBoot != null) {
        mSinceBoot.recordData(ident,entry.uid,entry.set,entry.tag,start,end,entry);
      }
      if (complete != null) {
        complete.recordData(ident,entry.uid,entry.set,entry.tag,start,end,entry);
      }
    }
  }
  mLastSnapshot=snapshot;
  if (LOGV && unknownIfaces.size() > 0) {
    Slog.w(TAG,"unknown interfaces " + unknownIfaces + ", ignoring those stats");
  }
}
