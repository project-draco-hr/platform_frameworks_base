{
  if (!isOpen()) {
    throw new IllegalStateException("database not open");
  }
  if (values == null || values.size() == 0) {
    throw new IllegalArgumentException("Empty values");
  }
  StringBuilder sql=new StringBuilder(120);
  sql.append("UPDATE ");
  sql.append(CONFLICT_VALUES[conflictAlgorithm]);
  sql.append(table);
  sql.append(" SET ");
  Set<Map.Entry<String,Object>> entrySet=values.valueSet();
  Iterator<Map.Entry<String,Object>> entriesIter=entrySet.iterator();
  while (entriesIter.hasNext()) {
    Map.Entry<String,Object> entry=entriesIter.next();
    sql.append(entry.getKey());
    sql.append("=?");
    if (entriesIter.hasNext()) {
      sql.append(", ");
    }
  }
  if (!TextUtils.isEmpty(whereClause)) {
    sql.append(" WHERE ");
    sql.append(whereClause);
  }
  lock();
  SQLiteStatement statement=null;
  try {
    statement=compileStatement(sql.toString());
    int size=entrySet.size();
    entriesIter=entrySet.iterator();
    int bindArg=1;
    for (int i=0; i < size; i++) {
      Map.Entry<String,Object> entry=entriesIter.next();
      DatabaseUtils.bindObjectToProgram(statement,bindArg,entry.getValue());
      bindArg++;
    }
    if (whereArgs != null) {
      size=whereArgs.length;
      for (int i=0; i < size; i++) {
        statement.bindString(bindArg,whereArgs[i]);
        bindArg++;
      }
    }
    statement.execute();
    statement.close();
    int numChangedRows=lastChangeCount();
    if (Config.LOGD && Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,"Updated " + numChangedRows + " using "+ values+ " and "+ sql);
    }
    return numChangedRows;
  }
 catch (  SQLiteDatabaseCorruptException e) {
    onCorruption();
    throw e;
  }
catch (  SQLException e) {
    Log.e(TAG,"Error updating " + values + " using "+ sql);
    throw e;
  }
 finally {
    if (statement != null) {
      statement.close();
    }
    unlock();
  }
}
