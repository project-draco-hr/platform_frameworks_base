{
  Editable editable=(Editable)mTextView.getText();
  final int start;
  if (mIsSentenceSpellCheckSupported) {
    start=Math.max(0,editable.getSpanStart(mRange) - MIN_SENTENCE_LENGTH);
  }
 else {
    start=editable.getSpanStart(mRange);
  }
  final int end=editable.getSpanEnd(mRange);
  int wordIteratorWindowEnd=Math.min(end,start + WORD_ITERATOR_INTERVAL);
  mWordIterator.setCharSequence(editable,start,wordIteratorWindowEnd);
  int wordStart=mWordIterator.preceding(start);
  int wordEnd;
  if (wordStart == BreakIterator.DONE) {
    wordEnd=mWordIterator.following(start);
    if (wordEnd != BreakIterator.DONE) {
      wordStart=mWordIterator.getBeginning(wordEnd);
    }
  }
 else {
    wordEnd=mWordIterator.getEnd(wordStart);
  }
  if (wordEnd == BreakIterator.DONE) {
    if (DBG) {
      Log.i(TAG,"No more spell check.");
    }
    removeRangeSpan(editable);
    return;
  }
  SpellCheckSpan[] spellCheckSpans=editable.getSpans(start - 1,end + 1,SpellCheckSpan.class);
  SuggestionSpan[] suggestionSpans=editable.getSpans(start - 1,end + 1,SuggestionSpan.class);
  int wordCount=0;
  boolean scheduleOtherSpellCheck=false;
  if (mIsSentenceSpellCheckSupported) {
    if (wordIteratorWindowEnd < end) {
      if (DBG) {
        Log.i(TAG,"schedule other spell check.");
      }
      scheduleOtherSpellCheck=true;
    }
    int spellCheckEnd=mWordIterator.preceding(wordIteratorWindowEnd);
    boolean correct=spellCheckEnd != BreakIterator.DONE;
    if (correct) {
      spellCheckEnd=mWordIterator.getEnd(spellCheckEnd);
      correct=spellCheckEnd != BreakIterator.DONE;
    }
    if (!correct) {
      if (DBG) {
        Log.i(TAG,"Incorrect range span.");
      }
      removeRangeSpan(editable);
      return;
    }
    do {
      int spellCheckStart=wordStart;
      boolean createSpellCheckSpan=true;
      for (int i=0; i < mLength; ++i) {
        final SpellCheckSpan spellCheckSpan=mSpellCheckSpans[i];
        if (mIds[i] < 0 || spellCheckSpan.isSpellCheckInProgress()) {
          continue;
        }
        final int spanStart=editable.getSpanStart(spellCheckSpan);
        final int spanEnd=editable.getSpanEnd(spellCheckSpan);
        if (spanEnd < spellCheckStart || spellCheckEnd < spanStart) {
          continue;
        }
        if (spanStart <= spellCheckStart && spellCheckEnd <= spanEnd) {
          createSpellCheckSpan=false;
          if (DBG) {
            Log.i(TAG,"The range is overrapped. Skip spell check.");
          }
          break;
        }
        removeSpellCheckSpan(spellCheckSpan);
        spellCheckStart=Math.min(spanStart,spellCheckStart);
        spellCheckEnd=Math.max(spanEnd,spellCheckEnd);
      }
      if (DBG) {
        Log.d(TAG,"addSpellCheckSpan: " + ", End = " + spellCheckEnd + ", Start = "+ spellCheckStart+ ", next = "+ scheduleOtherSpellCheck+ "\n"+ editable.subSequence(spellCheckStart,spellCheckEnd));
      }
      if (spellCheckEnd < start) {
        break;
      }
      if (spellCheckEnd <= spellCheckStart) {
        break;
      }
      if (createSpellCheckSpan) {
        addSpellCheckSpan(editable,spellCheckStart,spellCheckEnd);
      }
    }
 while (false);
    wordStart=spellCheckEnd;
  }
 else {
    while (wordStart <= end) {
      if (wordEnd >= start && wordEnd > wordStart) {
        if (wordCount >= MAX_NUMBER_OF_WORDS) {
          scheduleOtherSpellCheck=true;
          break;
        }
        if (wordStart < start && wordEnd > start) {
          removeSpansAt(editable,start,spellCheckSpans);
          removeSpansAt(editable,start,suggestionSpans);
        }
        if (wordStart < end && wordEnd > end) {
          removeSpansAt(editable,end,spellCheckSpans);
          removeSpansAt(editable,end,suggestionSpans);
        }
        boolean createSpellCheckSpan=true;
        if (wordEnd == start) {
          for (int i=0; i < spellCheckSpans.length; i++) {
            final int spanEnd=editable.getSpanEnd(spellCheckSpans[i]);
            if (spanEnd == start) {
              createSpellCheckSpan=false;
              break;
            }
          }
        }
        if (wordStart == end) {
          for (int i=0; i < spellCheckSpans.length; i++) {
            final int spanStart=editable.getSpanStart(spellCheckSpans[i]);
            if (spanStart == end) {
              createSpellCheckSpan=false;
              break;
            }
          }
        }
        if (createSpellCheckSpan) {
          addSpellCheckSpan(editable,wordStart,wordEnd);
        }
        wordCount++;
      }
      int originalWordEnd=wordEnd;
      wordEnd=mWordIterator.following(wordEnd);
      if ((wordIteratorWindowEnd < end) && (wordEnd == BreakIterator.DONE || wordEnd >= wordIteratorWindowEnd)) {
        wordIteratorWindowEnd=Math.min(end,originalWordEnd + WORD_ITERATOR_INTERVAL);
        mWordIterator.setCharSequence(editable,originalWordEnd,wordIteratorWindowEnd);
        wordEnd=mWordIterator.following(originalWordEnd);
      }
      if (wordEnd == BreakIterator.DONE)       break;
      wordStart=mWordIterator.getBeginning(wordEnd);
      if (wordStart == BreakIterator.DONE) {
        break;
      }
    }
  }
  if (scheduleOtherSpellCheck) {
    setRangeSpan(editable,wordStart,end);
  }
 else {
    removeRangeSpan(editable);
  }
  spellCheck();
}
