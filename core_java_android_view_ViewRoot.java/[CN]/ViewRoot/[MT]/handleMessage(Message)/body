{
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing("ViewRoot");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v("ViewRoot","Dispatching key " + msg.obj + " to "+ mView);
deliverKeyEvent((KeyEvent)msg.obj,true);
break;
case DISPATCH_POINTER:
MotionEvent event=(MotionEvent)msg.obj;
boolean didFinish;
if (event == null) {
try {
event=sWindowSession.getPendingPointerMove(mWindow);
}
 catch (RemoteException e) {
}
didFinish=true;
}
 else {
didFinish=event.getAction() == MotionEvent.ACTION_OUTSIDE;
}
try {
boolean handled;
if (mView != null && mAdded && event != null) {
boolean isDown=event.getAction() == MotionEvent.ACTION_DOWN;
if (isDown) {
ensureTouchMode(true);
}
if (Config.LOGV) {
captureMotionLog("captureDispatchPointer",event);
}
event.offsetLocation(0,mCurScrollY);
handled=mView.dispatchTouchEvent(event);
if (!handled && isDown) {
int edgeSlop=mViewConfiguration.getScaledEdgeSlop();
final int edgeFlags=event.getEdgeFlags();
int direction=View.FOCUS_UP;
int x=(int)event.getX();
int y=(int)event.getY();
final int[] deltas=new int[2];
if ((edgeFlags & MotionEvent.EDGE_TOP) != 0) {
direction=View.FOCUS_DOWN;
if ((edgeFlags & MotionEvent.EDGE_LEFT) != 0) {
deltas[0]=edgeSlop;
x+=edgeSlop;
}
 else if ((edgeFlags & MotionEvent.EDGE_RIGHT) != 0) {
deltas[0]=-edgeSlop;
x-=edgeSlop;
}
}
 else if ((edgeFlags & MotionEvent.EDGE_BOTTOM) != 0) {
direction=View.FOCUS_UP;
if ((edgeFlags & MotionEvent.EDGE_LEFT) != 0) {
deltas[0]=edgeSlop;
x+=edgeSlop;
}
 else if ((edgeFlags & MotionEvent.EDGE_RIGHT) != 0) {
deltas[0]=-edgeSlop;
x-=edgeSlop;
}
}
 else if ((edgeFlags & MotionEvent.EDGE_LEFT) != 0) {
direction=View.FOCUS_RIGHT;
}
 else if ((edgeFlags & MotionEvent.EDGE_RIGHT) != 0) {
direction=View.FOCUS_LEFT;
}
if (edgeFlags != 0 && mView instanceof ViewGroup) {
View nearest=FocusFinder.getInstance().findNearestTouchable(((ViewGroup)mView),x,y,direction,deltas);
if (nearest != null) {
event.offsetLocation(deltas[0],deltas[1]);
event.setEdgeFlags(0);
mView.dispatchTouchEvent(event);
}
}
}
}
}
  finally {
if (!didFinish) {
try {
sWindowSession.finishKey(mWindow);
}
 catch (RemoteException e) {
}
}
if (event != null) {
event.recycle();
}
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,"Done dispatching!");
}
break;
case DISPATCH_TRACKBALL:
deliverTrackballEvent((MotionEvent)msg.obj);
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
Rect coveredInsets=((Rect[])msg.obj)[0];
Rect visibleInsets=((Rect[])msg.obj)[1];
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(coveredInsets) && mPendingVisibleInsets.equals(visibleInsets)) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((Rect[])msg.obj)[0]);
mPendingVisibleInsets.set(((Rect[])msg.obj)[1]);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mGlWanted) {
checkEglErrors();
if (mGlWanted && !mUseGL) {
initializeGL();
if (mGlCanvas != null) {
mGlCanvas.setViewport(mWidth,mHeight);
}
}
}
}
if (mView != null) {
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.onWindowFocus(mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
}
}
break;
case DIE:
dispatchDetachedFromWindow();
break;
case DISPATCH_KEY_FROM_IME:
if (true) Log.v("ViewRoot","Dispatching key " + msg.obj + " from IME to "+ mView);
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus((View)msg.obj);
}
}
break;
}
}
