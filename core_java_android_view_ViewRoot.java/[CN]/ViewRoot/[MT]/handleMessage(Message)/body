{
switch (msg.what) {
case View.AttachInfo.INVALIDATE_MSG:
    ((View)msg.obj).invalidate();
  break;
case View.AttachInfo.INVALIDATE_RECT_MSG:
final View.AttachInfo.InvalidateInfo info=(View.AttachInfo.InvalidateInfo)msg.obj;
info.target.invalidate(info.left,info.top,info.right,info.bottom);
info.release();
break;
case DO_TRAVERSAL:
if (mProfile) {
Debug.startMethodTracing("ViewRoot");
}
performTraversals();
if (mProfile) {
Debug.stopMethodTracing();
mProfile=false;
}
break;
case FINISHED_EVENT:
handleFinishedEvent(msg.arg1,msg.arg2 != 0);
break;
case DISPATCH_KEY:
if (LOCAL_LOGV) Log.v(TAG,"Dispatching key " + msg.obj + " to "+ mView);
deliverKeyEvent((KeyEvent)msg.obj,msg.arg1 != 0);
break;
case DISPATCH_POINTER:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverPointerEvent(event);
}
  finally {
event.recycle();
if (msg.arg1 != 0) {
finishInputEvent();
}
if (LOCAL_LOGV || WATCH_POINTER) Log.i(TAG,"Done dispatching!");
}
}
break;
case DISPATCH_TRACKBALL:
{
MotionEvent event=(MotionEvent)msg.obj;
try {
deliverTrackballEvent(event);
}
  finally {
event.recycle();
if (msg.arg1 != 0) {
finishInputEvent();
}
}
}
break;
case DISPATCH_APP_VISIBILITY:
handleAppVisibility(msg.arg1 != 0);
break;
case DISPATCH_GET_NEW_SURFACE:
handleGetNewSurface();
break;
case RESIZED:
ResizedInfo ri=(ResizedInfo)msg.obj;
if (mWinFrame.width() == msg.arg1 && mWinFrame.height() == msg.arg2 && mPendingContentInsets.equals(ri.coveredInsets) && mPendingVisibleInsets.equals(ri.visibleInsets) && ((ResizedInfo)msg.obj).newConfig == null) {
break;
}
case RESIZED_REPORT:
if (mAdded) {
Configuration config=((ResizedInfo)msg.obj).newConfig;
if (config != null) {
updateConfiguration(config,false);
}
mWinFrame.left=0;
mWinFrame.right=msg.arg1;
mWinFrame.top=0;
mWinFrame.bottom=msg.arg2;
mPendingContentInsets.set(((ResizedInfo)msg.obj).coveredInsets);
mPendingVisibleInsets.set(((ResizedInfo)msg.obj).visibleInsets);
if (msg.what == RESIZED_REPORT) {
mReportNextDraw=true;
}
if (mView != null) {
forceLayout(mView);
}
requestLayout();
}
break;
case WINDOW_FOCUS_CHANGED:
{
if (mAdded) {
boolean hasWindowFocus=msg.arg1 != 0;
mAttachInfo.mHasWindowFocus=hasWindowFocus;
if (hasWindowFocus) {
boolean inTouchMode=msg.arg2 != 0;
ensureTouchModeLocally(inTouchMode);
if (mAttachInfo.mHardwareRenderer != null && mSurface != null && mSurface.isValid()) {
mAttachInfo.mHardwareRenderer.initializeIfNeeded(mWidth,mHeight,mAttachInfo,mHolder);
}
}
mLastWasImTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
InputMethodManager imm=InputMethodManager.peekInstance();
if (mView != null) {
if (hasWindowFocus && imm != null && mLastWasImTarget) {
imm.startGettingWindowFocus(mView);
}
mAttachInfo.mKeyDispatchState.reset();
mView.dispatchWindowFocusChanged(hasWindowFocus);
}
if (hasWindowFocus) {
if (imm != null && mLastWasImTarget) {
imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
}
mWindowAttributes.softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
((WindowManager.LayoutParams)mView.getLayoutParams()).softInputMode&=~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
mHasHadWindowFocus=true;
}
if (hasWindowFocus && mView != null) {
sendAccessibilityEvents();
}
}
}
break;
case DIE:
doDie();
break;
case DISPATCH_KEY_FROM_IME:
{
if (LOCAL_LOGV) Log.v(TAG,"Dispatching key " + msg.obj + " from IME to "+ mView);
KeyEvent event=(KeyEvent)msg.obj;
if ((event.getFlags() & KeyEvent.FLAG_FROM_SYSTEM) != 0) {
event=KeyEvent.changeFlags(event,event.getFlags() & ~KeyEvent.FLAG_FROM_SYSTEM);
}
deliverKeyEventToViewHierarchy((KeyEvent)msg.obj,false);
}
break;
case FINISH_INPUT_CONNECTION:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.reportFinishInputConnection((InputConnection)msg.obj);
}
}
break;
case CHECK_FOCUS:
{
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null) {
imm.checkFocus();
}
}
break;
case CLOSE_SYSTEM_DIALOGS:
{
if (mView != null) {
mView.onCloseSystemDialogs((String)msg.obj);
}
}
break;
case DISPATCH_DRAG_EVENT:
case DISPATCH_DRAG_LOCATION_EVENT:
{
handleDragEvent((DragEvent)msg.obj);
}
break;
}
}
