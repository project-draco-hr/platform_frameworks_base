{
  Surface surface=mSurface;
  if (surface == null || !surface.isValid()) {
    return;
  }
  scrollToRectOrFocus(null,false);
  if (mAttachInfo.mViewScrollChanged) {
    mAttachInfo.mViewScrollChanged=false;
    mAttachInfo.mTreeObserver.dispatchOnScrollChanged();
  }
  int yoff;
  final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
  if (scrolling) {
    yoff=mScroller.getCurrY();
  }
 else {
    yoff=mScrollY;
  }
  if (mCurScrollY != yoff) {
    mCurScrollY=yoff;
    fullRedrawNeeded=true;
  }
  float appScale=mAttachInfo.mApplicationScale;
  boolean scalingRequired=mAttachInfo.mScalingRequired;
  Rect dirty=mDirty;
  if (mUseGL) {
    if (!dirty.isEmpty()) {
      Canvas canvas=mGlCanvas;
      if (mGL != null && canvas != null) {
        mGL.glDisable(GL_SCISSOR_TEST);
        mGL.glClearColor(0,0,0,0);
        mGL.glClear(GL_COLOR_BUFFER_BIT);
        mGL.glEnable(GL_SCISSOR_TEST);
        mAttachInfo.mDrawingTime=SystemClock.uptimeMillis();
        mAttachInfo.mIgnoreDirtyState=true;
        mView.mPrivateFlags|=View.DRAWN;
        int saveCount=canvas.save(Canvas.MATRIX_SAVE_FLAG);
        try {
          canvas.translate(0,-yoff);
          if (mTranslator != null) {
            mTranslator.translateCanvas(canvas);
          }
          mView.draw(canvas);
          if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
            mView.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_DRAWING);
          }
        }
  finally {
          canvas.restoreToCount(saveCount);
        }
        mAttachInfo.mIgnoreDirtyState=false;
        mEgl.eglSwapBuffers(mEglDisplay,mEglSurface);
        checkEglErrors();
        if (Config.DEBUG && ViewDebug.showFps) {
          int now=(int)SystemClock.elapsedRealtime();
          if (sDrawTime != 0) {
            nativeShowFPS(canvas,now - sDrawTime);
          }
          sDrawTime=now;
        }
      }
    }
    if (scrolling) {
      mFullRedrawNeeded=true;
      scheduleTraversals();
    }
    return;
  }
  if (fullRedrawNeeded) {
    mAttachInfo.mIgnoreDirtyState=true;
    dirty.union(0,0,(int)(mWidth * appScale + 0.5f),(int)(mHeight * appScale + 0.5f));
  }
  if (DEBUG_ORIENTATION || DEBUG_DRAW) {
    Log.v("ViewRoot","Draw " + mView + "/"+ mWindowAttributes.getTitle()+ ": dirty={"+ dirty.left+ ","+ dirty.top+ ","+ dirty.right+ ","+ dirty.bottom+ "} surface="+ surface+ " surface.isValid()="+ surface.isValid()+ ", appScale:"+ appScale+ ", width="+ mWidth+ ", height="+ mHeight);
  }
  Canvas canvas;
  try {
    int left=dirty.left;
    int top=dirty.top;
    int right=dirty.right;
    int bottom=dirty.bottom;
    canvas=surface.lockCanvas(dirty);
    if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
      mAttachInfo.mIgnoreDirtyState=true;
    }
    canvas.setDensity(mDensity);
  }
 catch (  Surface.OutOfResourcesException e) {
    Log.e("ViewRoot","OutOfResourcesException locking surface",e);
    return;
  }
  try {
    if (!dirty.isEmpty() || mIsAnimating) {
      long startTime=0L;
      if (DEBUG_ORIENTATION || DEBUG_DRAW) {
        Log.v("ViewRoot","Surface " + surface + " drawing to bitmap w="+ canvas.getWidth()+ ", h="+ canvas.getHeight());
      }
      if (Config.DEBUG && ViewDebug.profileDrawing) {
        startTime=SystemClock.elapsedRealtime();
      }
      if (!canvas.isOpaque() || yoff != 0) {
        canvas.drawColor(0,PorterDuff.Mode.CLEAR);
      }
      dirty.setEmpty();
      mIsAnimating=false;
      mAttachInfo.mDrawingTime=SystemClock.uptimeMillis();
      mView.mPrivateFlags|=View.DRAWN;
      if (DEBUG_DRAW) {
        Context cxt=mView.getContext();
        Log.i(TAG,"Drawing: package:" + cxt.getPackageName() + ", metrics="+ cxt.getResources().getDisplayMetrics()+ ", compatibilityInfo="+ cxt.getResources().getCompatibilityInfo());
      }
      int saveCount=canvas.save(Canvas.MATRIX_SAVE_FLAG);
      try {
        canvas.translate(0,-yoff);
        if (mTranslator != null) {
          mTranslator.translateCanvas(canvas);
        }
        mView.draw(canvas);
      }
  finally {
        mAttachInfo.mIgnoreDirtyState=false;
        canvas.restoreToCount(saveCount);
      }
      if (Config.DEBUG && ViewDebug.consistencyCheckEnabled) {
        mView.dispatchConsistencyCheck(ViewDebug.CONSISTENCY_DRAWING);
      }
      if (Config.DEBUG && ViewDebug.showFps) {
        int now=(int)SystemClock.elapsedRealtime();
        if (sDrawTime != 0) {
          nativeShowFPS(canvas,now - sDrawTime);
        }
        sDrawTime=now;
      }
      if (Config.DEBUG && ViewDebug.profileDrawing) {
        EventLog.writeEvent(60000,SystemClock.elapsedRealtime() - startTime);
      }
    }
  }
  finally {
    surface.unlockCanvasAndPost(canvas);
  }
  if (LOCAL_LOGV) {
    Log.v("ViewRoot","Surface " + surface + " unlockCanvasAndPost");
  }
  if (scrolling) {
    mFullRedrawNeeded=true;
    scheduleTraversals();
  }
}
