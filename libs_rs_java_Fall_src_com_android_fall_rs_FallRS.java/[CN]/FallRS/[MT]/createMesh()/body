{
  final RenderScript rs=mRS;
  rs.triangleMeshBegin(Element.NORM_ST_XYZ_F32,Element.INDEX_16);
  int wResolution;
  int hResolution;
  final int width=mWidth;
  final int height=mHeight;
  if (width < height) {
    wResolution=MESH_RESOLUTION;
    hResolution=(int)(MESH_RESOLUTION * height / (float)width);
  }
 else {
    wResolution=(int)(MESH_RESOLUTION * width / (float)height);
    hResolution=MESH_RESOLUTION;
  }
  mGlHeight=2.0f * height / (float)width;
  final float quadWidth=2.0f / (float)wResolution;
  final float quadHeight=mGlHeight / (float)hResolution;
  wResolution+=2;
  hResolution+=2;
  for (int y=0; y <= hResolution; y++) {
    final float yOffset=y * quadHeight - mGlHeight / 2.0f - quadHeight;
    final float t=1.0f - y / (float)hResolution;
    for (int x=0; x <= wResolution; x++) {
      rs.triangleMeshAddVertex_XYZ_ST_NORM(-1.0f + x * quadWidth - quadWidth,yOffset,0.0f,x / (float)wResolution,t,0.0f,0.0f,-1.0f);
    }
  }
  for (int y=0; y < hResolution; y++) {
    for (int x=0; x < wResolution; x++) {
      final int index=y * (wResolution + 1) + x;
      final int iWR1=index + wResolution + 1;
      rs.triangleMeshAddTriangle(index,index + 1,iWR1);
      rs.triangleMeshAddTriangle(index + 1,iWR1,iWR1 + 1);
    }
  }
  mMesh=rs.triangleMeshCreate();
  mMesh.setName("mesh");
  mMeshWidth=wResolution + 1;
  mMeshHeight=hResolution + 1;
}
