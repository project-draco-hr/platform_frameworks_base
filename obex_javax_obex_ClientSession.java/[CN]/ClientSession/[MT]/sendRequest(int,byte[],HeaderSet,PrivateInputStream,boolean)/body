{
  if (head != null) {
    if ((head.length + 3) > ObexHelper.MAX_PACKET_SIZE_INT) {
      throw new IOException("header too large ");
    }
  }
  boolean skipSend=false;
  boolean skipReceive=false;
  if (srmActive == true) {
    if (opCode == ObexHelper.OBEX_OPCODE_PUT) {
      skipReceive=true;
    }
 else     if (opCode == ObexHelper.OBEX_OPCODE_GET) {
      skipReceive=true;
    }
 else     if (opCode == ObexHelper.OBEX_OPCODE_GET_FINAL) {
      skipSend=true;
    }
  }
  int bytesReceived;
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  out.write((byte)opCode);
  if (head == null) {
    out.write(0x00);
    out.write(0x03);
  }
 else {
    out.write((byte)((head.length + 3) >> 8));
    out.write((byte)(head.length + 3));
    out.write(head);
  }
  if (!skipSend) {
    mOutput.write(out.toByteArray());
    mOutput.flush();
  }
  if (!skipReceive) {
    header.responseCode=mInput.read();
    int length=((mInput.read() << 8) | (mInput.read()));
    if (length > ObexHelper.getMaxRxPacketSize(mTransport)) {
      throw new IOException("Packet received exceeds packet size limit");
    }
    if (length > ObexHelper.BASE_PACKET_LENGTH) {
      byte[] data=null;
      if (opCode == ObexHelper.OBEX_OPCODE_CONNECT) {
        @SuppressWarnings("unused") int version=mInput.read();
        @SuppressWarnings("unused") int flags=mInput.read();
        mMaxTxPacketSize=(mInput.read() << 8) + mInput.read();
        if (mMaxTxPacketSize > ObexHelper.MAX_CLIENT_PACKET_SIZE) {
          mMaxTxPacketSize=ObexHelper.MAX_CLIENT_PACKET_SIZE;
        }
        if (mMaxTxPacketSize > ObexHelper.getMaxTxPacketSize(mTransport)) {
          Log.w(TAG,"An OBEX packet size of " + mMaxTxPacketSize + "was"+ " requested. Transport only allows: "+ ObexHelper.getMaxTxPacketSize(mTransport)+ " Lowering limit to this value.");
          mMaxTxPacketSize=ObexHelper.getMaxTxPacketSize(mTransport);
        }
        if (length > 7) {
          data=new byte[length - 7];
          bytesReceived=mInput.read(data);
          while (bytesReceived != (length - 7)) {
            bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
          }
        }
 else {
          return true;
        }
      }
 else {
        data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != (length - 3)) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        if (opCode == ObexHelper.OBEX_OPCODE_ABORT) {
          return true;
        }
      }
      byte[] body=ObexHelper.updateHeaderSet(header,data);
      if ((privateInput != null) && (body != null)) {
        privateInput.writeBytes(body,1);
      }
      if (header.mConnectionID != null) {
        mConnectionId=new byte[4];
        System.arraycopy(header.mConnectionID,0,mConnectionId,0,4);
      }
      if (header.mAuthResp != null) {
        if (!handleAuthResp(header.mAuthResp)) {
          setRequestInactive();
          throw new IOException("Authentication Failed");
        }
      }
      if ((header.responseCode == ResponseCodes.OBEX_HTTP_UNAUTHORIZED) && (header.mAuthChall != null)) {
        if (handleAuthChall(header)) {
          out.write((byte)HeaderSet.AUTH_RESPONSE);
          out.write((byte)((header.mAuthResp.length + 3) >> 8));
          out.write((byte)(header.mAuthResp.length + 3));
          out.write(header.mAuthResp);
          header.mAuthChall=null;
          header.mAuthResp=null;
          byte[] sendHeaders=new byte[out.size() - 3];
          System.arraycopy(out.toByteArray(),3,sendHeaders,0,sendHeaders.length);
          return sendRequest(opCode,sendHeaders,header,privateInput,false);
        }
      }
    }
  }
  return true;
}
