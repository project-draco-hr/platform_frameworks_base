{
switch (mBluetoothState) {
case BluetoothAdapter.STATE_OFF:
    pw.println("Bluetooth OFF\n");
  return;
case BluetoothAdapter.STATE_TURNING_ON:
pw.println("Bluetooth TURNING ON\n");
return;
case BluetoothAdapter.STATE_TURNING_OFF:
pw.println("Bluetooth TURNING OFF\n");
return;
case BluetoothAdapter.STATE_ON:
pw.println("Bluetooth ON\n");
}
pw.println("mIsAirplaneSensitive = " + mIsAirplaneSensitive);
pw.println("mIsAirplaneToggleable = " + mIsAirplaneToggleable);
pw.println("Local address = " + getAddress());
pw.println("Local name = " + getName());
pw.println("isDiscovering() = " + isDiscovering());
mAdapter.getProfileProxy(mContext,mBluetoothProfileServiceListener,BluetoothProfile.HEADSET);
pw.println("\n--Known devices--");
for (String address : mDeviceProperties.keySet()) {
int bondState=mBondState.getBondState(address);
pw.printf("%s %10s (%d) %s\n",address,toBondStateString(bondState),mBondState.getAttempt(address),getRemoteName(address));
Map<ParcelUuid,Integer> uuidChannels=mDeviceServiceChannelCache.get(address);
if (uuidChannels == null) {
pw.println("\tuuids = null");
}
 else {
for (ParcelUuid uuid : uuidChannels.keySet()) {
Integer channel=uuidChannels.get(uuid);
if (channel == null) {
pw.println("\t" + uuid);
}
 else {
pw.println("\t" + uuid + " RFCOMM channel = "+ channel);
}
}
}
for (RemoteService service : mUuidCallbackTracker.keySet()) {
if (service.address.equals(address)) {
pw.println("\tPENDING CALLBACK: " + service.uuid);
}
}
}
String value=getProperty("Devices");
String[] devicesObjectPath=null;
if (value != null) {
devicesObjectPath=value.split(",");
}
pw.println("\n--ACL connected devices--");
if (devicesObjectPath != null) {
for (String device : devicesObjectPath) {
pw.println(getAddressFromObjectPath(device));
}
}
pw.println("\n--Headset Service--");
if (mBluetoothHeadset != null) {
Set<BluetoothDevice> deviceSet=mBluetoothHeadset.getConnectedDevices();
if (deviceSet.size() == 0) {
pw.println("\n--No headsets connected--");
}
BluetoothDevice device=(BluetoothDevice)deviceSet.toArray()[0];
switch (mBluetoothHeadset.getConnectionState(device)) {
case BluetoothHeadset.STATE_DISCONNECTED:
pw.println("getConnectionState() = STATE_DISCONNECTED");
break;
case BluetoothHeadset.STATE_CONNECTING:
pw.println("getConnectionState() = STATE_CONNECTING");
break;
case BluetoothHeadset.STATE_CONNECTED:
pw.println("getConnectionState() = STATE_CONNECTED");
break;
case BluetoothHeadset.STATE_DISCONNECTING:
pw.println("getConnectionState() = STATE_DISCONNECTING");
break;
case BluetoothHeadset.STATE_AUDIO_CONNECTED:
pw.println("getConnectionState() = STATE_AUDIO_CONNECTED");
break;
}
deviceSet.clear();
deviceSet=mBluetoothHeadset.getDevicesMatchingConnectionStates(new int[]{BluetoothProfile.STATE_CONNECTED,BluetoothProfile.STATE_DISCONNECTED});
pw.println("\n--Connected and Disconnected Headsets");
for (BluetoothDevice dev : deviceSet) {
pw.println(device);
if (mBluetoothHeadset.isAudioConnected(device)) {
pw.println("SCO audio connected to device:" + device);
}
}
pw.println("\ngetCurrentHeadset() = " + device);
pw.println("getBatteryUsageHint() = " + mBluetoothHeadset.getBatteryUsageHint(device));
mAdapter.closeProfileProxy(BluetoothProfile.HEADSET,mBluetoothHeadset);
}
pw.println("\n--Application Service Records--");
for (Integer handle : mServiceRecordToPid.keySet()) {
Integer pid=mServiceRecordToPid.get(handle);
pw.println("\tpid " + pid + " handle "+ Integer.toHexString(handle));
}
}
