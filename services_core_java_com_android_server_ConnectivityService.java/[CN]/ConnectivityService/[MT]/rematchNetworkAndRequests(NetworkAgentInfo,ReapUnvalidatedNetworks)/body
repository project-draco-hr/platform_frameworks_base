{
  if (!newNetwork.everConnected)   return;
  boolean keep=newNetwork.isVPN();
  boolean isNewDefault=false;
  NetworkAgentInfo oldDefaultNetwork=null;
  if (VDBG)   log("rematching " + newNetwork.name());
  ArrayList<NetworkAgentInfo> affectedNetworks=new ArrayList<NetworkAgentInfo>();
  ArrayList<NetworkRequestInfo> addedRequests=new ArrayList<NetworkRequestInfo>();
  if (VDBG)   log(" network has: " + newNetwork.networkCapabilities);
  for (  NetworkRequestInfo nri : mNetworkRequests.values()) {
    final NetworkAgentInfo currentNetwork=mNetworkForRequestId.get(nri.request.requestId);
    final boolean satisfies=newNetwork.satisfies(nri.request);
    if (newNetwork == currentNetwork && satisfies) {
      if (VDBG) {
        log("Network " + newNetwork.name() + " was already satisfying"+ " request "+ nri.request.requestId+ ". No change.");
      }
      keep=true;
      continue;
    }
    if (VDBG)     log("  checking if request is satisfied: " + nri.request);
    if (satisfies) {
      if (!nri.isRequest()) {
        if (newNetwork.addRequest(nri.request))         addedRequests.add(nri);
        continue;
      }
      if (VDBG) {
        log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = "+ newNetwork.getCurrentScore());
      }
      if (currentNetwork == null || currentNetwork.getCurrentScore() < newNetwork.getCurrentScore()) {
        if (VDBG)         log("rematch for " + newNetwork.name());
        if (currentNetwork != null) {
          if (VDBG)           log("   accepting network in place of " + currentNetwork.name());
          currentNetwork.networkRequests.remove(nri.request.requestId);
          currentNetwork.networkLingered.add(nri.request);
          affectedNetworks.add(currentNetwork);
        }
 else {
          if (VDBG)           log("   accepting network in place of null");
        }
        unlinger(newNetwork);
        mNetworkForRequestId.put(nri.request.requestId,newNetwork);
        if (!newNetwork.addRequest(nri.request)) {
          Slog.wtf(TAG,"BUG: " + newNetwork.name() + " already has "+ nri.request);
        }
        addedRequests.add(nri);
        keep=true;
        sendUpdatedScoreToFactories(nri.request,newNetwork.getCurrentScore());
        if (mDefaultRequest.requestId == nri.request.requestId) {
          isNewDefault=true;
          oldDefaultNetwork=currentNetwork;
        }
      }
    }
 else     if (newNetwork.networkRequests.get(nri.request.requestId) != null) {
      if (DBG) {
        log("Network " + newNetwork.name() + " stopped satisfying"+ " request "+ nri.request.requestId);
      }
      newNetwork.networkRequests.remove(nri.request.requestId);
      if (currentNetwork == newNetwork) {
        mNetworkForRequestId.remove(nri.request.requestId);
        sendUpdatedScoreToFactories(nri.request,0);
      }
 else {
        if (nri.isRequest()) {
          Slog.wtf(TAG,"BUG: Removing request " + nri.request.requestId + " from "+ newNetwork.name()+ " without updating mNetworkForRequestId or factories!");
        }
      }
      callCallbackForRequest(nri,newNetwork,ConnectivityManager.CALLBACK_LOST);
    }
  }
  for (  NetworkAgentInfo nai : affectedNetworks) {
    if (nai.lingering) {
    }
 else     if (unneeded(nai)) {
      linger(nai);
    }
 else {
      unlinger(nai);
    }
  }
  if (isNewDefault) {
    makeDefault(newNetwork,oldDefaultNetwork);
synchronized (ConnectivityService.this) {
      if (mNetTransitionWakeLock.isHeld()) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK,mNetTransitionWakeLockSerialNumber,0),1000);
      }
    }
  }
  for (  NetworkRequestInfo nri : addedRequests)   notifyNetworkCallback(newNetwork,nri);
  if (isNewDefault) {
    if (oldDefaultNetwork != null) {
      mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(),oldDefaultNetwork,true);
    }
    mDefaultInetConditionPublished=newNetwork.lastValidated ? 100 : 0;
    mLegacyTypeTracker.add(newNetwork.networkInfo.getType(),newNetwork);
    notifyLockdownVpn(newNetwork);
  }
  if (keep) {
    try {
      final IBatteryStats bs=BatteryStatsService.getService();
      final int type=newNetwork.networkInfo.getType();
      final String baseIface=newNetwork.linkProperties.getInterfaceName();
      bs.noteNetworkInterfaceType(baseIface,type);
      for (      LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
        final String stackedIface=stacked.getInterfaceName();
        bs.noteNetworkInterfaceType(stackedIface,type);
        NetworkStatsFactory.noteStackedIface(stackedIface,baseIface);
      }
    }
 catch (    RemoteException ignored) {
    }
    for (int i=0; i < newNetwork.networkRequests.size(); i++) {
      NetworkRequest nr=newNetwork.networkRequests.valueAt(i);
      if (nr.legacyType != TYPE_NONE && isRequest(nr)) {
        mLegacyTypeTracker.add(nr.legacyType,newNetwork);
      }
    }
    if (newNetwork.isVPN()) {
      mLegacyTypeTracker.add(TYPE_VPN,newNetwork);
    }
  }
  if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
    for (    NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
      if (unneeded(nai)) {
        if (DBG)         log("Reaping " + nai.name());
        teardownUnneededNetwork(nai);
      }
    }
  }
}
