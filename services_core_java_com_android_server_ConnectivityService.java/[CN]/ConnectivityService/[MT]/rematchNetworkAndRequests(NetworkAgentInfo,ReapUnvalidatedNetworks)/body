{
  if (!newNetwork.created)   return;
  boolean keep=newNetwork.isVPN();
  boolean isNewDefault=false;
  NetworkAgentInfo oldDefaultNetwork=null;
  if (DBG)   log("rematching " + newNetwork.name());
  ArrayList<NetworkAgentInfo> affectedNetworks=new ArrayList<NetworkAgentInfo>();
  ArrayList<NetworkRequestInfo> addedRequests=new ArrayList<NetworkRequestInfo>();
  if (VDBG)   log(" network has: " + newNetwork.networkCapabilities);
  for (  NetworkRequestInfo nri : mNetworkRequests.values()) {
    NetworkAgentInfo currentNetwork=mNetworkForRequestId.get(nri.request.requestId);
    if (newNetwork == currentNetwork) {
      if (VDBG) {
        log("Network " + newNetwork.name() + " was already satisfying"+ " request "+ nri.request.requestId+ ". No change.");
      }
      keep=true;
      continue;
    }
    if (VDBG)     log("  checking if request is satisfied: " + nri.request);
    if (newNetwork.satisfies(nri.request)) {
      if (!nri.isRequest) {
        if (newNetwork.addRequest(nri.request))         addedRequests.add(nri);
        continue;
      }
      if (VDBG) {
        log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = "+ newNetwork.getCurrentScore());
      }
      if (currentNetwork == null || currentNetwork.getCurrentScore() < newNetwork.getCurrentScore()) {
        if (currentNetwork != null) {
          if (DBG)           log("   accepting network in place of " + currentNetwork.name());
          currentNetwork.networkRequests.remove(nri.request.requestId);
          currentNetwork.networkLingered.add(nri.request);
          affectedNetworks.add(currentNetwork);
        }
 else {
          if (DBG)           log("   accepting network in place of null");
        }
        unlinger(newNetwork);
        mNetworkForRequestId.put(nri.request.requestId,newNetwork);
        if (!newNetwork.addRequest(nri.request)) {
          Slog.wtf(TAG,"BUG: " + newNetwork.name() + " already has "+ nri.request);
        }
        addedRequests.add(nri);
        keep=true;
        sendUpdatedScoreToFactories(nri.request,newNetwork.getCurrentScore());
        if (mDefaultRequest.requestId == nri.request.requestId) {
          isNewDefault=true;
          oldDefaultNetwork=currentNetwork;
        }
      }
    }
  }
  for (  NetworkAgentInfo nai : affectedNetworks) {
    if (nai.everValidated && unneeded(nai)) {
      linger(nai);
    }
 else {
      unlinger(nai);
    }
  }
  if (keep) {
    if (isNewDefault) {
      makeDefault(newNetwork);
synchronized (ConnectivityService.this) {
        if (mNetTransitionWakeLock.isHeld()) {
          mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK,mNetTransitionWakeLockSerialNumber,0),1000);
        }
      }
    }
    for (    NetworkRequestInfo nri : addedRequests)     notifyNetworkCallback(newNetwork,nri);
    if (isNewDefault) {
      if (oldDefaultNetwork != null) {
        mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(),oldDefaultNetwork,true);
      }
      mDefaultInetConditionPublished=newNetwork.everValidated ? 100 : 0;
      mLegacyTypeTracker.add(newNetwork.networkInfo.getType(),newNetwork);
      notifyLockdownVpn(newNetwork);
    }
    try {
      final IBatteryStats bs=BatteryStatsService.getService();
      final int type=newNetwork.networkInfo.getType();
      final String baseIface=newNetwork.linkProperties.getInterfaceName();
      bs.noteNetworkInterfaceType(baseIface,type);
      for (      LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
        final String stackedIface=stacked.getInterfaceName();
        bs.noteNetworkInterfaceType(stackedIface,type);
        NetworkStatsFactory.noteStackedIface(stackedIface,baseIface);
      }
    }
 catch (    RemoteException ignored) {
    }
    for (int i=0; i < newNetwork.networkRequests.size(); i++) {
      NetworkRequest nr=newNetwork.networkRequests.valueAt(i);
      if (nr.legacyType != TYPE_NONE && isRequest(nr)) {
        mLegacyTypeTracker.add(nr.legacyType,newNetwork);
      }
    }
    if (newNetwork.isVPN()) {
      mLegacyTypeTracker.add(TYPE_VPN,newNetwork);
    }
  }
  if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
    for (    NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
      if (unneeded(nai)) {
        if (DBG)         log("Reaping " + nai.name());
        teardownUnneededNetwork(nai);
      }
    }
  }
}
