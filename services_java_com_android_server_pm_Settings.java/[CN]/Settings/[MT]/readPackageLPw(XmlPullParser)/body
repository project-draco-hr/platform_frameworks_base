{
  String name=null;
  String realName=null;
  String idStr=null;
  String sharedIdStr=null;
  String codePathStr=null;
  String resourcePathStr=null;
  String nativeLibraryPathStr=null;
  String systemStr=null;
  String installerPackageName=null;
  String uidError=null;
  int pkgFlags=0;
  long timeStamp=0;
  long firstInstallTime=0;
  long lastUpdateTime=0;
  PackageSettingBase packageSetting=null;
  String version=null;
  int versionCode=0;
  try {
    name=parser.getAttributeValue(null,"name");
    realName=parser.getAttributeValue(null,"realName");
    idStr=parser.getAttributeValue(null,"userId");
    uidError=parser.getAttributeValue(null,"uidError");
    sharedIdStr=parser.getAttributeValue(null,"sharedUserId");
    codePathStr=parser.getAttributeValue(null,"codePath");
    resourcePathStr=parser.getAttributeValue(null,"resourcePath");
    nativeLibraryPathStr=parser.getAttributeValue(null,"nativeLibraryPath");
    version=parser.getAttributeValue(null,"version");
    if (version != null) {
      try {
        versionCode=Integer.parseInt(version);
      }
 catch (      NumberFormatException e) {
      }
    }
    installerPackageName=parser.getAttributeValue(null,"installer");
    systemStr=parser.getAttributeValue(null,"flags");
    if (systemStr != null) {
      try {
        pkgFlags=Integer.parseInt(systemStr);
      }
 catch (      NumberFormatException e) {
      }
    }
 else {
      systemStr=parser.getAttributeValue(null,"system");
      if (systemStr != null) {
        pkgFlags|=("true".equalsIgnoreCase(systemStr)) ? ApplicationInfo.FLAG_SYSTEM : 0;
      }
 else {
        pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
    String timeStampStr=parser.getAttributeValue(null,"ft");
    if (timeStampStr != null) {
      try {
        timeStamp=Long.parseLong(timeStampStr,16);
      }
 catch (      NumberFormatException e) {
      }
    }
 else {
      timeStampStr=parser.getAttributeValue(null,"ts");
      if (timeStampStr != null) {
        try {
          timeStamp=Long.parseLong(timeStampStr);
        }
 catch (        NumberFormatException e) {
        }
      }
    }
    timeStampStr=parser.getAttributeValue(null,"it");
    if (timeStampStr != null) {
      try {
        firstInstallTime=Long.parseLong(timeStampStr,16);
      }
 catch (      NumberFormatException e) {
      }
    }
    timeStampStr=parser.getAttributeValue(null,"ut");
    if (timeStampStr != null) {
      try {
        lastUpdateTime=Long.parseLong(timeStampStr,16);
      }
 catch (      NumberFormatException e) {
      }
    }
    if (PackageManagerService.DEBUG_SETTINGS)     Log.v(PackageManagerService.TAG,"Reading package: " + name + " userId="+ idStr+ " sharedUserId="+ sharedIdStr);
    int userId=idStr != null ? Integer.parseInt(idStr) : 0;
    if (resourcePathStr == null) {
      resourcePathStr=codePathStr;
    }
    if (realName != null) {
      realName=realName.intern();
    }
    if (name == null) {
      PackageManagerService.reportSettingsProblem(Log.WARN,"Error in package manager settings: <package> has no name at " + parser.getPositionDescription());
    }
 else     if (codePathStr == null) {
      PackageManagerService.reportSettingsProblem(Log.WARN,"Error in package manager settings: <package> has no codePath at " + parser.getPositionDescription());
    }
 else     if (userId > 0) {
      packageSetting=addPackageLPw(name.intern(),realName,new File(codePathStr),new File(resourcePathStr),nativeLibraryPathStr,userId,versionCode,pkgFlags);
      if (PackageManagerService.DEBUG_SETTINGS)       Log.i(PackageManagerService.TAG,"Reading package " + name + ": userId="+ userId+ " pkg="+ packageSetting);
      if (packageSetting == null) {
        PackageManagerService.reportSettingsProblem(Log.ERROR,"Failure adding uid " + userId + " while parsing settings at "+ parser.getPositionDescription());
      }
 else {
        packageSetting.setTimeStamp(timeStamp);
        packageSetting.firstInstallTime=firstInstallTime;
        packageSetting.lastUpdateTime=lastUpdateTime;
      }
    }
 else     if (sharedIdStr != null) {
      userId=sharedIdStr != null ? Integer.parseInt(sharedIdStr) : 0;
      if (userId > 0) {
        packageSetting=new PendingPackage(name.intern(),realName,new File(codePathStr),new File(resourcePathStr),nativeLibraryPathStr,userId,versionCode,pkgFlags);
        packageSetting.setTimeStamp(timeStamp);
        packageSetting.firstInstallTime=firstInstallTime;
        packageSetting.lastUpdateTime=lastUpdateTime;
        mPendingPackages.add((PendingPackage)packageSetting);
        if (PackageManagerService.DEBUG_SETTINGS)         Log.i(PackageManagerService.TAG,"Reading package " + name + ": sharedUserId="+ userId+ " pkg="+ packageSetting);
      }
 else {
        PackageManagerService.reportSettingsProblem(Log.WARN,"Error in package manager settings: package " + name + " has bad sharedId "+ sharedIdStr+ " at "+ parser.getPositionDescription());
      }
    }
 else {
      PackageManagerService.reportSettingsProblem(Log.WARN,"Error in package manager settings: package " + name + " has bad userId "+ idStr+ " at "+ parser.getPositionDescription());
    }
  }
 catch (  NumberFormatException e) {
    PackageManagerService.reportSettingsProblem(Log.WARN,"Error in package manager settings: package " + name + " has bad userId "+ idStr+ " at "+ parser.getPositionDescription());
  }
  if (packageSetting != null) {
    packageSetting.uidError="true".equals(uidError);
    packageSetting.installerPackageName=installerPackageName;
    packageSetting.nativeLibraryPathString=nativeLibraryPathStr;
    final String enabledStr=parser.getAttributeValue(null,"enabled");
    if (enabledStr != null) {
      try {
        packageSetting.enabled=Integer.parseInt(enabledStr);
      }
 catch (      NumberFormatException e) {
        if (enabledStr.equalsIgnoreCase("true")) {
          packageSetting.enabled=COMPONENT_ENABLED_STATE_ENABLED;
        }
 else         if (enabledStr.equalsIgnoreCase("false")) {
          packageSetting.enabled=COMPONENT_ENABLED_STATE_DISABLED;
        }
 else         if (enabledStr.equalsIgnoreCase("default")) {
          packageSetting.enabled=COMPONENT_ENABLED_STATE_DEFAULT;
        }
 else {
          PackageManagerService.reportSettingsProblem(Log.WARN,"Error in package manager settings: package " + name + " has bad enabled value: "+ idStr+ " at "+ parser.getPositionDescription());
        }
      }
    }
 else {
      packageSetting.enabled=COMPONENT_ENABLED_STATE_DEFAULT;
    }
    final String installStatusStr=parser.getAttributeValue(null,"installStatus");
    if (installStatusStr != null) {
      if (installStatusStr.equalsIgnoreCase("false")) {
        packageSetting.installStatus=PackageSettingBase.PKG_INSTALL_INCOMPLETE;
      }
 else {
        packageSetting.installStatus=PackageSettingBase.PKG_INSTALL_COMPLETE;
      }
    }
    int outerDepth=parser.getDepth();
    int type;
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals("disabled-components")) {
        readDisabledComponentsLPw(packageSetting,parser);
      }
 else       if (tagName.equals("enabled-components")) {
        readEnabledComponentsLPw(packageSetting,parser);
      }
 else       if (tagName.equals("sigs")) {
        packageSetting.signatures.readXml(parser,mPastSignatures);
      }
 else       if (tagName.equals("perms")) {
        readGrantedPermissionsLPw(parser,packageSetting.grantedPermissions);
        packageSetting.permissionsFixed=true;
      }
 else {
        PackageManagerService.reportSettingsProblem(Log.WARN,"Unknown element under <package>: " + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
  }
 else {
    XmlUtils.skipCurrentTag(parser);
  }
}
