{
  final long time=AnimationUtils.currentAnimationTimeMillis();
  final long currentTime=time - mStartTime;
  if (currentTime > mDuration) {
    return false;
  }
  double distance=0.0;
switch (mState) {
case TO_EDGE:
{
      final float t=(float)currentTime / mSplineDuration;
      final int index=(int)(NB_SAMPLES * t);
      float distanceCoef=1.f;
      float velocityCoef=0.f;
      if (index < NB_SAMPLES) {
        final float t_inf=(float)index / NB_SAMPLES;
        final float t_sup=(float)(index + 1) / NB_SAMPLES;
        final float d_inf=SPLINE_POSITION[index];
        final float d_sup=SPLINE_POSITION[index + 1];
        velocityCoef=(d_sup - d_inf) / (t_sup - t_inf);
        distanceCoef=d_inf + (t - t_inf) * velocityCoef;
      }
      distance=distanceCoef * mSplineDistance;
      mCurrVelocity=velocityCoef * mSplineDistance / mSplineDuration * 1000;
      break;
    }
case TO_BOUNCE:
{
    final float t=currentTime / 1000.0f;
    mCurrVelocity=mVelocity + mDeceleration * t;
    distance=mVelocity * t + mDeceleration * t * t / 2.0f;
    break;
  }
case TO_BOUNDARY:
{
  final float t=currentTime / 1000.0f;
  final float d=t * Math.abs(mVelocity) / mOver;
  mCurrVelocity=mVelocity * (float)Math.cos(d);
  distance=(mVelocity > 0 ? mOver : -mOver) * Math.sin(d);
  break;
}
}
mCurrentPosition=mStart + (int)Math.round(distance);
return true;
}
