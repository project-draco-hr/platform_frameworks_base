{
  if (start > min && start < max) {
    mFinished=true;
    return;
  }
  final boolean positive=start > max;
  final int edge=positive ? max : min;
  final int overDistance=start - edge;
  boolean keepIncreasing=overDistance * velocity >= 0;
  if (keepIncreasing) {
    startBounceAfterEdge(start,edge,velocity);
  }
 else {
    final double l=Math.log(START_TENSION * Math.abs(velocity) / ALPHA);
    final double totalDistance=(ALPHA * Math.exp(DECELERATION_RATE / (DECELERATION_RATE - 1.0) * l));
    if (totalDistance > Math.abs(overDistance)) {
      fling(start,velocity,positive ? min : start,positive ? start : max,mOver);
    }
 else {
      startSpringback(start,edge,velocity);
    }
  }
}
