{
  mState=TO_EDGE;
  mOver=over;
  mFinished=false;
  mStart=start;
  mStartTime=AnimationUtils.currentAnimationTimeMillis();
  mVelocity=velocity;
  mDeceleration=getDeceleration(velocity);
  mDuration=(int)(-1000.0f * velocity / mDeceleration);
  mFinal=start - Math.round((velocity * velocity) / (2.0f * mDeceleration));
  if (mFinal < min) {
    mFinal=min;
    mDuration=computeDuration(mStart,min,mVelocity,mDeceleration);
  }
  if (mFinal > max) {
    mFinal=max;
    mDuration=computeDuration(mStart,max,mVelocity,mDeceleration);
  }
  if (start > max) {
    if (start >= max + over) {
      springback(max + over,min,max);
    }
 else {
      if (velocity <= 0) {
        springback(start,min,max);
      }
 else {
        long time=AnimationUtils.currentAnimationTimeMillis();
        final double durationSinceEdge=Math.atan((start - max) * TIME_COEF / velocity) / TIME_COEF;
        mStartTime=(int)(time - 1000.0f * durationSinceEdge);
        mStart=max;
        mVelocity=(int)(velocity / Math.cos(durationSinceEdge * TIME_COEF));
        onEdgeReached();
      }
    }
  }
 else {
    if (start < min) {
      if (start <= min - over) {
        springback(min - over,min,max);
      }
 else {
        if (velocity >= 0) {
          springback(start,min,max);
        }
 else {
          long time=AnimationUtils.currentAnimationTimeMillis();
          final double durationSinceEdge=Math.atan((start - min) * TIME_COEF / velocity) / TIME_COEF;
          mStartTime=(int)(time - 1000.0f * durationSinceEdge);
          mStart=min;
          mVelocity=(int)(velocity / Math.cos(durationSinceEdge * TIME_COEF));
          onEdgeReached();
        }
      }
    }
  }
}
