{
switch (mState) {
case TO_EDGE:
    int duration=(int)(-1000.0f * mVelocity / mDeceleration);
  if (mDuration < duration) {
    mStart=mFinal;
    mVelocity=(int)(mVelocity + mDeceleration * mDuration / 1000.0f);
    mStartTime+=mDuration;
    onEdgeReached();
  }
 else {
    return false;
  }
break;
case TO_BOUNDARY:
mStartTime+=mDuration;
mStart=mFinal;
mFinal=mStart - (mVelocity > 0 ? mOver : -mOver);
mVelocity=0;
mDuration=(int)(1000.0f * Math.sqrt(Math.abs(2.0f * mOver / mDeceleration)));
mState=TO_BOUNCE;
break;
case TO_BOUNCE:
float edgeVelocity=mVelocity + mDeceleration * mDuration / 1000.0f;
mVelocity=(int)(-edgeVelocity * BOUNCE_COEFFICIENT);
if (Math.abs(mVelocity) < MINIMUM_VELOCITY_FOR_BOUNCE) {
return false;
}
mStart=mFinal;
mStartTime+=mDuration;
mDuration=(int)(-2000.0f * mVelocity / mDeceleration);
break;
}
update();
return true;
}
