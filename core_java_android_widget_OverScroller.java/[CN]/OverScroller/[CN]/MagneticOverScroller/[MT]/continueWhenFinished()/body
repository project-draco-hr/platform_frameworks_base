{
switch (mState) {
case TO_EDGE:
    int duration=(int)(-1000.0f * mVelocity / mDeceleration);
  if (mDuration < duration) {
    mStart=mFinal;
    mVelocity=(int)(mVelocity + mDeceleration * mDuration / 1000.0f);
    mStartTime+=mDuration;
    onEdgeReached();
  }
 else {
    return false;
  }
break;
case TO_BOUNDARY:
mStartTime+=mDuration;
startSpringback(mFinal,mFinal - (mVelocity > 0 ? mOver : -mOver),mVelocity > 0);
break;
case TO_BOUNCE:
mVelocity=(int)(mVelocity * mBounceCoefficient);
if (Math.abs(mVelocity) < MINIMUM_VELOCITY_FOR_BOUNCE) {
return false;
}
mStartTime+=mDuration;
break;
}
update();
return true;
}
