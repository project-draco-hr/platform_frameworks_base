{
switch (mState) {
case TO_EDGE:
    if (mDuration < mSplineDuration) {
      mStart=mFinal;
      mVelocity=(int)mCurrVelocity;
      mDeceleration=getDeceleration(mVelocity);
      mStartTime+=mDuration;
      onEdgeReached();
    }
 else {
      return false;
    }
  break;
case TO_BOUNDARY:
mStartTime+=mDuration;
startSpringback(mFinal,mFinal - (mVelocity > 0 ? mOver : -mOver),0);
break;
case TO_BOUNCE:
mVelocity=(int)(mVelocity * mBounceCoefficient);
if (Math.abs(mVelocity) < MINIMUM_VELOCITY_FOR_BOUNCE) {
return false;
}
mStartTime+=mDuration;
mDuration=-(int)(mVelocity / mDeceleration);
break;
}
update();
return true;
}
