{
  boolean inProgress=mCurrScroller.computeScrollOffset();
switch (mScrollMode) {
case MODE_OVERFLING:
    if (!inProgress) {
      if (springback(mCurrScroller.getCurrX(),mCurrScroller.getCurrY(),mMinimumX,mMaximumX,mMinimumY,mMaximumY,mAccelDecelScroller)) {
        return mCurrScroller.computeScrollOffset();
      }
 else {
        mCurrScroller=mDefaultScroller;
        mScrollMode=MODE_DEFAULT;
      }
    }
  break;
case MODE_SPRINGBACK:
if (!inProgress) {
  mCurrScroller=mDefaultScroller;
  mScrollMode=MODE_DEFAULT;
}
break;
case MODE_DEFAULT:
if (inProgress) {
Scroller scroller=mCurrScroller;
final int x=scroller.getCurrX();
final int y=scroller.getCurrY();
final int minX=mMinimumX;
final int maxX=mMaximumX;
final int minY=mMinimumY;
final int maxY=mMaximumY;
if (x < minX || x > maxX || y < minY || y > maxY) {
final int startx=scroller.getStartX();
final int starty=scroller.getStartY();
final int time=scroller.timePassed();
final float timeSecs=time / 1000.f;
final float xvel=((x - startx) / timeSecs);
final float yvel=((y - starty) / timeSecs);
if ((x < minX && xvel > 0) || (y < minY && yvel > 0) || (x > maxX && xvel < 0)|| (y > maxY && yvel < 0)) {
  if (springback(x,y,minX,maxX,minY,maxY)) {
    return mCurrScroller.computeScrollOffset();
  }
}
 else {
  overfling(x,y,xvel,yvel);
  return mCurrScroller.computeScrollOffset();
}
}
}
break;
}
return inProgress;
}
