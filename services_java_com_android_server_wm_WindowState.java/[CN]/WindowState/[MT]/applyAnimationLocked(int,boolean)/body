{
  if (mWinAnimator.mLocalAnimating && mWinAnimator.mAnimationIsEntrance == isEntrance) {
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(this,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=AnimationUtils.loadAnimation(mContext,anim);
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.loadAnimation(mAttrs,attr);
}
}
if (WindowManagerService.DEBUG_ANIM) Slog.v(WindowManagerService.TAG,"applyAnimation: win=" + this + " anim="+ anim+ " attr=0x"+ Integer.toHexString(attr)+ " mAnimation="+ mWinAnimator.mAnimation+ " isEntrance="+ isEntrance);
if (a != null) {
if (WindowManagerService.DEBUG_ANIM) {
RuntimeException e=null;
if (!WindowManagerService.HIDE_STACK_CRAWLS) {
e=new RuntimeException();
e.fillInStackTrace();
}
Slog.v(WindowManagerService.TAG,"Loaded animation " + a + " for "+ this,e);
}
mWinAnimator.setAnimation(a);
mWinAnimator.mAnimationIsEntrance=isEntrance;
}
}
 else {
mWinAnimator.clearAnimation();
}
return mWinAnimator.mAnimation != null;
}
