{
  super(context);
  mHandler=new Handler(this);
  mConfiguration=context.getResources().getConfiguration();
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get("keyguard.no_require_sim"));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mHasOverlay=false;
  mUpdateMonitor.registerInfoCallback(this);
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen,false);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED && !mLockPatternUtils.isPukUnlockScreenEnable())) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen,false);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen,false);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(    Configuration config){
      removeCallbacks(mRecreateRunnable);
      post(mRecreateRunnable);
    }
    public void takeEmergencyCallAction(){
      mHasOverlay=true;
      if (usingFaceLock() && mFaceLockServiceRunning) {
        showFaceLockAreaWithTimeout(FACELOCK_VIEW_AREA_EMERGENCY_DIALER_TIMEOUT);
      }
      stopAndUnbindFromFaceLock();
      pokeWakelock(EMERGENCY_CALL_TIMEOUT);
      if (TelephonyManager.getDefault().getCallState() == TelephonyManager.CALL_STATE_OFFHOOK) {
        mLockPatternUtils.resumeCall();
      }
 else {
        Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        getContext().startActivity(intent);
      }
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
      mSavedState=null;
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedUnlockAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,"reportFailedPatternAttempt: #" + failedAttempts + " (enableFallback="+ mEnableFallback+ ")");
      final boolean usingPattern=mLockPatternUtils.getKeyguardStoredPasswordQuality() == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING;
      final int failedAttemptsBeforeWipe=mLockPatternUtils.getDevicePolicyManager().getMaximumFailedPasswordsForWipe(null);
      final int failedAttemptWarning=LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
      final int remainingBeforeWipe=failedAttemptsBeforeWipe > 0 ? (failedAttemptsBeforeWipe - failedAttempts) : Integer.MAX_VALUE;
      if (remainingBeforeWipe < LockPatternUtils.FAILED_ATTEMPTS_BEFORE_WIPE_GRACE) {
        if (remainingBeforeWipe > 0) {
          showAlmostAtWipeDialog(failedAttempts,remainingBeforeWipe);
        }
 else {
          Slog.i(TAG,"Too many unlock attempts; device will be wiped!");
          showWipeDialog(failedAttempts);
        }
      }
 else {
        boolean showTimeout=(failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0;
        if (usingPattern && mEnableFallback) {
          if (failedAttempts == failedAttemptWarning) {
            showAlmostAtAccountLoginDialog();
            showTimeout=false;
          }
 else           if (failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
            mLockPatternUtils.setPermanentlyLocked(true);
            updateScreen(mMode,false);
            showTimeout=false;
          }
        }
        if (showTimeout) {
          showTimeoutDialog();
        }
      }
      mLockPatternUtils.reportFailedPasswordAttempt();
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
    public void reportSuccessfulUnlockAttempt(){
      mFailedFaceUnlockAttempts=0;
      mLockPatternUtils.reportSuccessfulPasswordAttempt();
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  updateScreen(getInitialMode(),false);
  maybeEnableFallback(context);
}
