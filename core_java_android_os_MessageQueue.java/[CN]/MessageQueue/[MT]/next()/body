{
  int pendingIdleHandlerCount=-1;
  int nextPollTimeoutMillis=0;
  for (; ; ) {
    if (nextPollTimeoutMillis != 0) {
      Binder.flushPendingCommands();
    }
    nativePollOnce(mPtr,nextPollTimeoutMillis);
synchronized (this) {
      final long now=SystemClock.uptimeMillis();
      Message prevMsg=null;
      Message msg=mMessages;
      for (; ; ) {
        if (msg == null) {
          nextPollTimeoutMillis=-1;
          break;
        }
        final long when=msg.when;
        if (now < when) {
          nextPollTimeoutMillis=(int)Math.min(when - now,Integer.MAX_VALUE);
          break;
        }
        if (mBarrierNestCount == 0 || msg.isAsynchronous()) {
          mBlocked=false;
          if (prevMsg != null) {
            prevMsg.next=msg.next;
          }
 else {
            mMessages=msg.next;
          }
          msg.next=null;
          if (false)           Log.v("MessageQueue","Returning message: " + msg);
          msg.markInUse();
          return msg;
        }
        prevMsg=msg;
        msg=msg.next;
      }
      if (pendingIdleHandlerCount < 0 && msg == mMessages) {
        pendingIdleHandlerCount=mIdleHandlers.size();
      }
      if (pendingIdleHandlerCount <= 0) {
        mBlocked=true;
        continue;
      }
      if (mPendingIdleHandlers == null) {
        mPendingIdleHandlers=new IdleHandler[Math.max(pendingIdleHandlerCount,4)];
      }
      mPendingIdleHandlers=mIdleHandlers.toArray(mPendingIdleHandlers);
    }
    for (int i=0; i < pendingIdleHandlerCount; i++) {
      final IdleHandler idler=mPendingIdleHandlers[i];
      mPendingIdleHandlers[i]=null;
      boolean keep=false;
      try {
        keep=idler.queueIdle();
      }
 catch (      Throwable t) {
        Log.wtf("MessageQueue","IdleHandler threw exception",t);
      }
      if (!keep) {
synchronized (this) {
          mIdleHandlers.remove(idler);
        }
      }
    }
    pendingIdleHandlerCount=0;
    nextPollTimeoutMillis=0;
  }
}
