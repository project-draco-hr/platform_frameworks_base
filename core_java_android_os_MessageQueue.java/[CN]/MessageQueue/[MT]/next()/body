{
  boolean tryIdle=true;
  long timeToNextEventMillis=0;
  while (true) {
    long now;
    Object[] idlers=null;
    nativeWaitForNext(timeToNextEventMillis);
synchronized (this) {
      now=SystemClock.uptimeMillis();
      Message msg=pullNextLocked(now);
      if (msg != null)       return msg;
      if (tryIdle && mIdleHandlers.size() > 0) {
        idlers=mIdleHandlers.toArray();
      }
    }
    boolean didIdle=false;
    if (idlers != null) {
      for (      Object idler : idlers) {
        boolean keep=false;
        try {
          didIdle=true;
          keep=((IdleHandler)idler).queueIdle();
        }
 catch (        Throwable t) {
          Log.wtf("MessageQueue","IdleHandler threw exception",t);
        }
        if (!keep) {
synchronized (this) {
            mIdleHandlers.remove(idler);
          }
        }
      }
    }
    if (didIdle) {
      tryIdle=false;
      continue;
    }
synchronized (this) {
      if (mMessages != null) {
        if (mMessages.when - now > 0) {
          Binder.flushPendingCommands();
          timeToNextEventMillis=mMessages.when - now;
        }
      }
 else {
        Binder.flushPendingCommands();
        timeToNextEventMillis=-1;
      }
    }
  }
}
