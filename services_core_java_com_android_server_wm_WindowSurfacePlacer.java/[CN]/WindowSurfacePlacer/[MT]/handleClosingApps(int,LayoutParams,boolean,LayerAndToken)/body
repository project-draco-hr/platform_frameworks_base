{
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    wtoken.markSavedSurfaceExiting();
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,"Now closing app " + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.setNullAnimation();
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}
