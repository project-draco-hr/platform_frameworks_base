{
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,"performSurfacePlacementInner: entry. Called by " + Debug.getCallers(3));
  }
  int i;
  boolean updateInputWindowsNeeded=false;
  if (mService.mFocusMayChange) {
    mService.mFocusMayChange=false;
    updateInputWindowsNeeded=mService.updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
  }
  final int numDisplays=mService.mDisplayContents.size();
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    for (i=displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
      displayContent.mExitingTokens.get(i).hasVisible=false;
    }
  }
  for (int stackNdx=mService.mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mService.mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (int tokenNdx=exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
      exitingAppTokens.get(tokenNdx).hasVisible=false;
    }
  }
  mHoldScreen=null;
  mScreenBrightness=-1;
  mButtonBrightness=-1;
  mUserActivityTimeout=-1;
  mObscureApplicationContentOnSecondaryDisplays=false;
  mService.mTransactionSequence++;
  final DisplayContent defaultDisplay=mService.getDefaultDisplayContentLocked();
  final DisplayInfo defaultInfo=defaultDisplay.getDisplayInfo();
  final int defaultDw=defaultInfo.logicalWidth;
  final int defaultDh=defaultInfo.logicalHeight;
  if (SHOW_LIGHT_TRANSACTIONS)   Slog.i(TAG,">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
  SurfaceControl.openTransaction();
  try {
    if (mService.mWatermark != null) {
      mService.mWatermark.positionSurface(defaultDw,defaultDh);
    }
    if (mService.mStrictModeFlash != null) {
      mService.mStrictModeFlash.positionSurface(defaultDw,defaultDh);
    }
    if (mService.mCircularDisplayMask != null) {
      mService.mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mService.mRotation);
    }
    if (mService.mEmulatorDisplayOverlay != null) {
      mService.mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mService.mRotation);
    }
    boolean focusDisplayed=false;
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
      boolean updateAllDrawn=false;
      WindowList windows=displayContent.getWindowList();
      DisplayInfo displayInfo=displayContent.getDisplayInfo();
      final int displayId=displayContent.getDisplayId();
      final int dw=displayInfo.logicalWidth;
      final int dh=displayInfo.logicalHeight;
      final int innerDw=displayInfo.appWidth;
      final int innerDh=displayInfo.appHeight;
      final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
      mDisplayHasContent=false;
      mPreferredRefreshRate=0;
      mPreferredModeId=0;
      int repeats=0;
      do {
        repeats++;
        if (repeats > 6) {
          Slog.w(TAG,"Animation repeat aborted after too many iterations");
          displayContent.layoutNeeded=false;
          break;
        }
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats("On entry to LockedInner",displayContent.pendingLayoutChanges);
        if ((displayContent.pendingLayoutChanges & FINISH_LAYOUT_REDO_WALLPAPER) != 0 && mWallpaperControllerLocked.adjustWallpaperWindows()) {
          mService.assignLayersLocked(windows);
          displayContent.layoutNeeded=true;
        }
        if (isDefaultDisplay && (displayContent.pendingLayoutChanges & FINISH_LAYOUT_REDO_CONFIG) != 0) {
          if (DEBUG_LAYOUT)           Slog.v(TAG,"Computing new config from layout");
          if (mService.updateOrientationFromAppTokensLocked(true)) {
            displayContent.layoutNeeded=true;
            mService.mH.sendEmptyMessage(SEND_NEW_CONFIGURATION);
          }
        }
        if ((displayContent.pendingLayoutChanges & FINISH_LAYOUT_REDO_LAYOUT) != 0) {
          displayContent.layoutNeeded=true;
        }
        if (repeats < LAYOUT_REPEAT_THRESHOLD) {
          performLayoutLockedInner(displayContent,repeats == 1,false);
        }
 else {
          Slog.w(TAG,"Layout repeat skipped after too many iterations");
        }
        displayContent.pendingLayoutChanges=0;
        if (isDefaultDisplay) {
          mService.mPolicy.beginPostLayoutPolicyLw(dw,dh);
          for (i=windows.size() - 1; i >= 0; i--) {
            WindowState w=windows.get(i);
            if (w.mHasSurface) {
              mService.mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
            }
          }
          displayContent.pendingLayoutChanges|=mService.mPolicy.finishPostLayoutPolicyLw();
          if (DEBUG_LAYOUT_REPEATS)           debugLayoutRepeats("after finishPostLayoutPolicyLw",displayContent.pendingLayoutChanges);
        }
      }
 while (displayContent.pendingLayoutChanges != 0);
      mObscured=false;
      mSyswin=false;
      displayContent.resetDimming();
      final boolean someoneLosingFocus=!mService.mLosingFocus.isEmpty();
      final int N=windows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=windows.get(i);
        final Task task=w.getTask();
        if (task == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
          continue;
        }
        final boolean obscuredChanged=w.mObscured != mObscured;
        w.mObscured=mObscured;
        if (!mObscured) {
          handleNotObscuredLocked(w,innerDw,innerDh);
        }
        if (task != null && !task.getContinueDimming()) {
          w.handleFlagDimBehind();
        }
        if (isDefaultDisplay && obscuredChanged && mWallpaperControllerLocked.isWallpaperTarget(w)&& w.isVisibleLw()) {
          mWallpaperControllerLocked.updateWallpaperVisibility();
        }
        final WindowStateAnimator winAnimator=w.mWinAnimator;
        if (w.hasMoved()) {
          final int left=w.mFrame.left;
          final int top=w.mFrame.top;
          if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
            Animation a=AnimationUtils.loadAnimation(mService.mContext,com.android.internal.R.anim.window_move_from_decor);
            winAnimator.setAnimation(a);
            winAnimator.mAnimDw=w.mLastFrame.left - left;
            winAnimator.mAnimDh=w.mLastFrame.top - top;
            winAnimator.mAnimateMove=true;
            winAnimator.mAnimatingMove=true;
          }
          if (mService.mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
            mService.mAccessibilityController.onSomeWindowResizedOrMovedLocked();
          }
          try {
            w.mClient.moved(left,top);
          }
 catch (          RemoteException e) {
          }
        }
        w.mContentChanged=false;
        if (w.mHasSurface) {
          final boolean committed=winAnimator.commitFinishDrawingLocked();
          if (isDefaultDisplay && committed) {
            if (w.mAttrs.type == TYPE_DREAM) {
              displayContent.pendingLayoutChanges|=FINISH_LAYOUT_REDO_LAYOUT;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats("dream and commitFinishDrawingLocked true",displayContent.pendingLayoutChanges);
              }
            }
            if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER_LIGHT)               Slog.v(TAG,"First draw done in potential wallpaper target " + w);
              mWallpaperMayChange=true;
              displayContent.pendingLayoutChanges|=FINISH_LAYOUT_REDO_WALLPAPER;
              if (DEBUG_LAYOUT_REPEATS) {
                debugLayoutRepeats("wallpaper and commitFinishDrawingLocked true",displayContent.pendingLayoutChanges);
              }
            }
          }
          winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
          Slog.d(TAG,"updateWindows: starting " + w + " isOnScreen="+ w.isOnScreen()+ " allDrawn="+ atoken.allDrawn+ " freezingScreen="+ atoken.mAppAnimator.freezingScreen);
        }
        if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
          if (atoken.lastTransactionSequence != mService.mTransactionSequence) {
            atoken.lastTransactionSequence=mService.mTransactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Slog.v(TAG,"Eval win " + w + ": isDrawn="+ w.isDrawnLw()+ ", isAnimating="+ winAnimator.isAnimating());
              if (!w.isDrawnLw()) {
                Slog.v(TAG,"Not displayed: s=" + winAnimator.mSurfaceControl + " pv="+ w.mPolicyVisibility+ " mDrawState="+ winAnimator.drawStateToString()+ " ah="+ w.mAttachedHidden+ " th="+ atoken.hiddenRequested+ " a="+ winAnimator.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Slog.v(TAG,"tokenMayBeDrawn: " + atoken + " freezingScreen="+ atoken.mAppAnimator.freezingScreen+ " mAppFreezing="+ w.mAppFreezing);
                  updateAllDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
        if (isDefaultDisplay && someoneLosingFocus && (w == mService.mCurrentFocus)&& w.isDisplayedLw()) {
          focusDisplayed=true;
        }
        mService.updateResizingWindows(w);
      }
      mService.mDisplayManagerInternal.setDisplayProperties(displayId,mDisplayHasContent,mPreferredRefreshRate,mPreferredModeId,true);
      mService.getDisplayContentLocked(displayId).stopDimmingIfNeeded();
      if (updateAllDrawn) {
        updateAllDrawnLocked(displayContent);
      }
    }
    if (focusDisplayed) {
      mService.mH.sendEmptyMessage(REPORT_LOSING_FOCUS);
    }
    mService.mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
  }
 catch (  RuntimeException e) {
    Slog.wtf(TAG,"Unhandled exception in Window Manager",e);
  }
 finally {
    SurfaceControl.closeTransaction();
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,"<<< CLOSE TRANSACTION performLayoutAndPlaceSurfaces");
  }
  final WindowList defaultWindows=defaultDisplay.getWindowList();
  if (mService.mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=handleAppTransitionReadyLocked(defaultWindows);
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats("after handleAppTransitionReadyLocked",defaultDisplay.pendingLayoutChanges);
  }
  if (!mService.mAnimator.mAppWindowAnimating && mService.mAppTransition.isRunning()) {
    defaultDisplay.pendingLayoutChanges|=mService.handleAnimatingStoppedAndTransitionLocked();
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats("after handleAnimStopAndXitionLock",defaultDisplay.pendingLayoutChanges);
  }
  if (mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mService.mAppTransition.isReady()) {
    defaultDisplay.pendingLayoutChanges|=FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats("after animateAwayWallpaperLocked",defaultDisplay.pendingLayoutChanges);
  }
  mWallpaperForceHidingChanged=false;
  if (mWallpaperMayChange) {
    if (DEBUG_WALLPAPER_LIGHT)     Slog.v(TAG,"Wallpaper may change!  Adjusting");
    defaultDisplay.pendingLayoutChanges|=FINISH_LAYOUT_REDO_WALLPAPER;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats("WallpaperMayChange",defaultDisplay.pendingLayoutChanges);
  }
  if (mService.mFocusMayChange) {
    mService.mFocusMayChange=false;
    if (mService.updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false)) {
      updateInputWindowsNeeded=true;
      defaultDisplay.pendingLayoutChanges|=FINISH_LAYOUT_REDO_ANIM;
    }
  }
  if (mService.needsLayout()) {
    defaultDisplay.pendingLayoutChanges|=FINISH_LAYOUT_REDO_LAYOUT;
    if (DEBUG_LAYOUT_REPEATS)     debugLayoutRepeats("mLayoutNeeded",defaultDisplay.pendingLayoutChanges);
  }
  for (i=mService.mResizingWindows.size() - 1; i >= 0; i--) {
    WindowState win=mService.mResizingWindows.get(i);
    if (win.mAppFreezing) {
      continue;
    }
    win.reportResized();
    mService.mResizingWindows.remove(i);
  }
  if (DEBUG_ORIENTATION && mService.mDisplayFrozen)   Slog.v(TAG,"With display frozen, orientationChangeComplete=" + mOrientationChangeComplete);
  if (mOrientationChangeComplete) {
    if (mService.mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
      mService.mWindowsFreezingScreen=WINDOWS_FREEZING_SCREENS_NONE;
      mService.mLastFinishedFreezeSource=mLastWindowFreezeSource;
      mService.mH.removeMessages(WINDOW_FREEZE_TIMEOUT);
    }
    mService.stopFreezingDisplayLocked();
  }
  boolean wallpaperDestroyed=false;
  i=mService.mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mService.mDestroySurface.get(i);
      win.mDestroying=false;
      if (mService.mInputMethodWindow == win) {
        mService.mInputMethodWindow=null;
      }
      if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
        wallpaperDestroyed=true;
      }
      win.mWinAnimator.destroySurfaceLocked();
    }
 while (i > 0);
    mService.mDestroySurface.clear();
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    ArrayList<WindowToken> exitingTokens=displayContent.mExitingTokens;
    for (i=exitingTokens.size() - 1; i >= 0; i--) {
      WindowToken token=exitingTokens.get(i);
      if (!token.hasVisible) {
        exitingTokens.remove(i);
        if (token.windowType == TYPE_WALLPAPER) {
          mWallpaperControllerLocked.removeWallpaperToken(token);
        }
      }
    }
  }
  for (int stackNdx=mService.mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
    final AppTokenList exitingAppTokens=mService.mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
    for (i=exitingAppTokens.size() - 1; i >= 0; i--) {
      AppWindowToken token=exitingAppTokens.get(i);
      if (!token.hasVisible && !mService.mClosingApps.contains(token) && (!token.mIsExiting || token.allAppWindows.isEmpty())) {
        token.mAppAnimator.clearAnimation();
        token.mAppAnimator.animating=false;
        if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)         Slog.v(TAG,"performLayout: App token exiting now removed" + token);
        token.removeAppFromTaskLocked();
      }
    }
  }
  if (wallpaperDestroyed) {
    defaultDisplay.pendingLayoutChanges|=FINISH_LAYOUT_REDO_WALLPAPER;
    defaultDisplay.layoutNeeded=true;
  }
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    if (displayContent.pendingLayoutChanges != 0) {
      displayContent.layoutNeeded=true;
    }
  }
  mService.mInputMonitor.updateInputWindowsLw(true);
  mService.setHoldScreenLocked(mHoldScreen);
  if (!mService.mDisplayFrozen) {
    if (mScreenBrightness < 0 || mScreenBrightness > 1.0f) {
      mService.mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mService.mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mScreenBrightness));
    }
    if (mButtonBrightness < 0 || mButtonBrightness > 1.0f) {
      mService.mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
    }
 else {
      mService.mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mButtonBrightness));
    }
    mService.mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mUserActivityTimeout);
  }
  if (mService.mTurnOnScreen) {
    if (mService.mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mService.mContext.getContentResolver(),Settings.Global.THEATER_MODE_ON,0) == 0) {
      if (DEBUG_VISIBILITY || DEBUG_POWER) {
        Slog.v(TAG,"Turning screen on after layout!");
      }
      mService.mPowerManager.wakeUp(SystemClock.uptimeMillis(),"android.server.wm:TURN_ON");
    }
    mService.mTurnOnScreen=false;
  }
  if (mUpdateRotation) {
    if (DEBUG_ORIENTATION)     Slog.d(TAG,"Performing post-rotate rotation");
    if (mService.updateRotationUncheckedLocked(false)) {
      mService.mH.sendEmptyMessage(SEND_NEW_CONFIGURATION);
    }
 else {
      mUpdateRotation=false;
    }
  }
  if (mService.mWaitingForDrawnCallback != null || (mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mUpdateRotation)) {
    mService.checkDrawnWindowsLocked();
  }
  final int N=mService.mPendingRemove.size();
  if (N > 0) {
    if (mService.mPendingRemoveTmp.length < N) {
      mService.mPendingRemoveTmp=new WindowState[N + 10];
    }
    mService.mPendingRemove.toArray(mService.mPendingRemoveTmp);
    mService.mPendingRemove.clear();
    DisplayContentList displayList=new DisplayContentList();
    for (i=0; i < N; i++) {
      WindowState w=mService.mPendingRemoveTmp[i];
      mService.removeWindowInnerLocked(w);
      final DisplayContent displayContent=w.getDisplayContent();
      if (displayContent != null && !displayList.contains(displayContent)) {
        displayList.add(displayContent);
      }
    }
    for (    DisplayContent displayContent : displayList) {
      mService.assignLayersLocked(displayContent.getWindowList());
      displayContent.layoutNeeded=true;
    }
  }
  for (int displayNdx=mService.mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
    mService.mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
  }
  if (updateInputWindowsNeeded) {
    mService.mInputMonitor.updateInputWindowsLw(false);
  }
  mService.setFocusTaskRegion();
  mService.enableScreenIfNeededLocked();
  mService.scheduleAnimationLocked();
  if (DEBUG_WINDOW_TRACE) {
    Slog.e(TAG,"performSurfacePlacementInner exit: animating=" + mService.mAnimator.mAnimating);
  }
}
