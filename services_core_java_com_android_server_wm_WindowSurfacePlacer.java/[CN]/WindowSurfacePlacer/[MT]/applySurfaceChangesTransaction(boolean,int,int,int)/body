{
  if (mService.mWatermark != null) {
    mService.mWatermark.positionSurface(defaultDw,defaultDh);
  }
  if (mService.mStrictModeFlash != null) {
    mService.mStrictModeFlash.positionSurface(defaultDw,defaultDh);
  }
  if (mService.mCircularDisplayMask != null) {
    mService.mCircularDisplayMask.positionSurface(defaultDw,defaultDh,mService.mRotation);
  }
  if (mService.mEmulatorDisplayOverlay != null) {
    mService.mEmulatorDisplayOverlay.positionSurface(defaultDw,defaultDh,mService.mRotation);
  }
  boolean focusDisplayed=false;
  for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
    final DisplayContent displayContent=mService.mDisplayContents.valueAt(displayNdx);
    boolean updateAllDrawn=false;
    WindowList windows=displayContent.getWindowList();
    DisplayInfo displayInfo=displayContent.getDisplayInfo();
    final int displayId=displayContent.getDisplayId();
    final int dw=displayInfo.logicalWidth;
    final int dh=displayInfo.logicalHeight;
    final int innerDw=displayInfo.appWidth;
    final int innerDh=displayInfo.appHeight;
    final boolean isDefaultDisplay=(displayId == Display.DEFAULT_DISPLAY);
    mDisplayHasContent=false;
    mPreferredRefreshRate=0;
    mPreferredModeId=0;
    int repeats=0;
    do {
      repeats++;
      if (repeats > 6) {
        Slog.w(TAG,"Animation repeat aborted after too many iterations");
        displayContent.layoutNeeded=false;
        break;
      }
      if (DEBUG_LAYOUT_REPEATS)       debugLayoutRepeats("On entry to LockedInner",displayContent.pendingLayoutChanges);
      if ((displayContent.pendingLayoutChanges & FINISH_LAYOUT_REDO_WALLPAPER) != 0 && mWallpaperControllerLocked.adjustWallpaperWindows()) {
        mService.assignLayersLocked(windows);
        displayContent.layoutNeeded=true;
      }
      if (isDefaultDisplay && (displayContent.pendingLayoutChanges & FINISH_LAYOUT_REDO_CONFIG) != 0) {
        if (DEBUG_LAYOUT)         Slog.v(TAG,"Computing new config from layout");
        if (mService.updateOrientationFromAppTokensLocked(true)) {
          displayContent.layoutNeeded=true;
          mService.mH.sendEmptyMessage(SEND_NEW_CONFIGURATION);
        }
      }
      if ((displayContent.pendingLayoutChanges & FINISH_LAYOUT_REDO_LAYOUT) != 0) {
        displayContent.layoutNeeded=true;
      }
      if (repeats < LAYOUT_REPEAT_THRESHOLD) {
        performLayoutLockedInner(displayContent,repeats == 1,false);
      }
 else {
        Slog.w(TAG,"Layout repeat skipped after too many iterations");
      }
      displayContent.pendingLayoutChanges=0;
      if (isDefaultDisplay) {
        mService.mPolicy.beginPostLayoutPolicyLw(dw,dh);
        for (int i=windows.size() - 1; i >= 0; i--) {
          WindowState w=windows.get(i);
          if (w.mHasSurface) {
            mService.mPolicy.applyPostLayoutPolicyLw(w,w.mAttrs,w.mAttachedWindow);
          }
        }
        displayContent.pendingLayoutChanges|=mService.mPolicy.finishPostLayoutPolicyLw();
        if (DEBUG_LAYOUT_REPEATS)         debugLayoutRepeats("after finishPostLayoutPolicyLw",displayContent.pendingLayoutChanges);
      }
    }
 while (displayContent.pendingLayoutChanges != 0);
    mObscured=false;
    mSyswin=false;
    displayContent.resetDimming();
    final boolean someoneLosingFocus=!mService.mLosingFocus.isEmpty();
    for (int i=windows.size() - 1; i >= 0; i--) {
      WindowState w=windows.get(i);
      final Task task=w.getTask();
      if (task == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
        continue;
      }
      final boolean obscuredChanged=w.mObscured != mObscured;
      w.mObscured=mObscured;
      if (!mObscured) {
        handleNotObscuredLocked(w,innerDw,innerDh);
      }
      if (task != null && !task.getContinueDimming()) {
        w.handleFlagDimBehind();
      }
      if (isDefaultDisplay && obscuredChanged && mWallpaperControllerLocked.isWallpaperTarget(w)&& w.isVisibleLw()) {
        mWallpaperControllerLocked.updateWallpaperVisibility();
      }
      final WindowStateAnimator winAnimator=w.mWinAnimator;
      if (w.hasMoved()) {
        final int left=w.mFrame.left;
        final int top=w.mFrame.top;
        if ((w.mAttrs.privateFlags & PRIVATE_FLAG_NO_MOVE_ANIMATION) == 0) {
          Animation a=AnimationUtils.loadAnimation(mService.mContext,com.android.internal.R.anim.window_move_from_decor);
          winAnimator.setAnimation(a);
          winAnimator.mAnimDw=w.mLastFrame.left - left;
          winAnimator.mAnimDh=w.mLastFrame.top - top;
          winAnimator.mAnimateMove=true;
          winAnimator.mAnimatingMove=true;
        }
        if (mService.mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
          mService.mAccessibilityController.onSomeWindowResizedOrMovedLocked();
        }
        try {
          w.mClient.moved(left,top);
        }
 catch (        RemoteException e) {
        }
      }
      w.mContentChanged=false;
      if (w.mHasSurface) {
        final boolean committed=winAnimator.commitFinishDrawingLocked();
        if (isDefaultDisplay && committed) {
          if (w.mAttrs.type == TYPE_DREAM) {
            displayContent.pendingLayoutChanges|=FINISH_LAYOUT_REDO_LAYOUT;
            if (DEBUG_LAYOUT_REPEATS) {
              debugLayoutRepeats("dream and commitFinishDrawingLocked true",displayContent.pendingLayoutChanges);
            }
          }
          if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
            if (DEBUG_WALLPAPER_LIGHT)             Slog.v(TAG,"First draw done in potential wallpaper target " + w);
            mWallpaperMayChange=true;
            displayContent.pendingLayoutChanges|=FINISH_LAYOUT_REDO_WALLPAPER;
            if (DEBUG_LAYOUT_REPEATS) {
              debugLayoutRepeats("wallpaper and commitFinishDrawingLocked true",displayContent.pendingLayoutChanges);
            }
          }
        }
        winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
      }
      final AppWindowToken atoken=w.mAppToken;
      if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
        Slog.d(TAG,"updateWindows: starting " + w + " isOnScreen="+ w.isOnScreen()+ " allDrawn="+ atoken.allDrawn+ " freezingScreen="+ atoken.mAppAnimator.freezingScreen);
      }
      if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
        if (atoken.lastTransactionSequence != mService.mTransactionSequence) {
          atoken.lastTransactionSequence=mService.mTransactionSequence;
          atoken.numInterestingWindows=atoken.numDrawnWindows=0;
          atoken.startingDisplayed=false;
        }
        if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
          if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
            Slog.v(TAG,"Eval win " + w + ": isDrawn="+ w.isDrawnLw()+ ", isAnimating="+ winAnimator.isAnimating());
            if (!w.isDrawnLw()) {
              Slog.v(TAG,"Not displayed: s=" + winAnimator.mSurfaceControl + " pv="+ w.mPolicyVisibility+ " mDrawState="+ winAnimator.drawStateToString()+ " ah="+ w.mAttachedHidden+ " th="+ atoken.hiddenRequested+ " a="+ winAnimator.mAnimating);
            }
          }
          if (w != atoken.startingWindow) {
            if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
              atoken.numInterestingWindows++;
              if (w.isDrawnLw()) {
                atoken.numDrawnWindows++;
                if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                 Slog.v(TAG,"tokenMayBeDrawn: " + atoken + " freezingScreen="+ atoken.mAppAnimator.freezingScreen+ " mAppFreezing="+ w.mAppFreezing);
                updateAllDrawn=true;
              }
            }
          }
 else           if (w.isDrawnLw()) {
            atoken.startingDisplayed=true;
          }
        }
      }
      if (isDefaultDisplay && someoneLosingFocus && w == mService.mCurrentFocus && w.isDisplayedLw()) {
        focusDisplayed=true;
      }
      mService.updateResizingWindows(w);
    }
    mService.mDisplayManagerInternal.setDisplayProperties(displayId,mDisplayHasContent,mPreferredRefreshRate,mPreferredModeId,true);
    mService.getDisplayContentLocked(displayId).stopDimmingIfNeeded();
    if (updateAllDrawn) {
      updateAllDrawnLocked(displayContent);
    }
  }
  if (focusDisplayed) {
    mService.mH.sendEmptyMessage(REPORT_LOSING_FOCUS);
  }
  mService.mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
}
