{
switch (me.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
{
      if (isPointInside(me.getX(),me.getY())) {
        beginDrag();
        return true;
      }
    }
  break;
case MotionEvent.ACTION_UP:
{
  if (mHasPendingDrag) {
    beginDrag();
    final float pos=getPosFromMotionEvent(me.getY());
    setThumbPos(pos);
    scrollTo(pos);
    cancelPendingDrag();
  }
  if (mState == STATE_DRAGGING) {
    if (mList != null) {
      mList.requestDisallowInterceptTouchEvent(false);
      mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
    }
    setState(STATE_VISIBLE);
    mList.postDelayed(mDeferHide,FADE_TIMEOUT);
    return true;
  }
}
break;
case MotionEvent.ACTION_MOVE:
{
if (mHasPendingDrag && Math.abs(me.getY() - mInitialTouchY) > mScaledTouchSlop) {
setState(STATE_DRAGGING);
if (mListAdapter == null && mList != null) {
  getSectionsFromIndexer();
}
if (mList != null) {
  mList.requestDisallowInterceptTouchEvent(true);
  mList.reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
}
cancelFling();
cancelPendingDrag();
}
if (mState == STATE_DRAGGING) {
final float pos=getPosFromMotionEvent(me.getY());
setThumbPos(pos);
if (mScrollCompleted) {
  scrollTo(pos);
}
return true;
}
}
break;
case MotionEvent.ACTION_CANCEL:
{
cancelPendingDrag();
}
break;
}
return false;
}
