{
  mService=service;
  mUserId=userId;
  mClient=new ITvInputClient.Stub(){
    @Override public void onSessionCreated(    String inputId,    IBinder token,    InputChannel channel,    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for " + token);
          return;
        }
        Session session=null;
        if (token != null) {
          session=new Session(token,channel,mService,mUserId,seq,mSessionCallbackRecordMap);
        }
        record.postSessionCreated(session);
      }
    }
    @Override public void onSessionReleased(    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        mSessionCallbackRecordMap.delete(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq:" + seq);
          return;
        }
        record.mSession.releaseInternal();
        record.postSessionReleased();
      }
    }
    @Override public void onChannelRetuned(    Uri channelUri,    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq " + seq);
          return;
        }
        record.postChannelRetuned(channelUri);
      }
    }
    @Override public void onTrackInfoChanged(    List<TvTrackInfo> tracks,    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq " + seq);
          return;
        }
        record.postTrackInfoChanged(tracks);
      }
    }
    @Override public void onVideoAvailable(    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq " + seq);
          return;
        }
        record.postVideoAvailable();
      }
    }
    @Override public void onVideoUnavailable(    int reason,    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq " + seq);
          return;
        }
        record.postVideoUnavailable(reason);
      }
    }
    @Override public void onContentBlocked(    String rating,    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq " + seq);
          return;
        }
        record.postContentBlocked(TvContentRating.unflattenFromString(rating));
      }
    }
    @Override public void onSessionEvent(    String eventType,    Bundle eventArgs,    int seq){
synchronized (mSessionCallbackRecordMap) {
        SessionCallbackRecord record=mSessionCallbackRecordMap.get(seq);
        if (record == null) {
          Log.e(TAG,"Callback not found for seq " + seq);
          return;
        }
        record.postSessionEvent(eventType,eventArgs);
      }
    }
  }
;
  mCallback=new ITvInputManagerCallback.Stub(){
    @Override public void onInputStateChanged(    String inputId,    int state){
synchronized (mLock) {
        mStateMap.put(inputId,state);
        for (        TvInputListenerRecord record : mTvInputListenerRecordsList) {
          record.postStateChanged(inputId,state);
        }
      }
    }
  }
;
  try {
    mService.registerCallback(mCallback,mUserId);
  }
 catch (  RemoteException e) {
    Log.e(TAG,"mService.registerCallback failed: " + e);
  }
}
