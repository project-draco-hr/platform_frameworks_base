{
  final LayoutToAnimatorParams layoutToAnim=mService.mLayoutToAnim;
synchronized (layoutToAnim) {
    layoutToAnim.mAnimationScheduled=false;
    if (!layoutToAnim.mParamsModified) {
      return;
    }
    layoutToAnim.mParamsModified=false;
    if ((layoutToAnim.mChanges & LayoutToAnimatorParams.WALLPAPER_TOKENS_CHANGED) != 0) {
      layoutToAnim.mChanges&=~LayoutToAnimatorParams.WALLPAPER_TOKENS_CHANGED;
      mWallpaperTokens=new ArrayList<WindowToken>(layoutToAnim.mWallpaperTokens);
    }
    mWinAnimators=new ArrayList<WindowStateAnimator>(layoutToAnim.mWinAnimators);
    mWallpaperTarget=layoutToAnim.mWallpaperTarget;
    mWpAppAnimator=mWallpaperTarget == null ? null : mWallpaperTarget.mAppToken == null ? null : mWallpaperTarget.mAppToken.mAppAnimator;
    mLowerWallpaperTarget=layoutToAnim.mLowerWallpaperTarget;
    mUpperWallpaperTarget=layoutToAnim.mUpperWallpaperTarget;
    DimAnimator.Parameters dimParams=layoutToAnim.mDimParams;
    if (dimParams == null) {
      mDimParams=dimParams;
    }
 else {
      final WindowStateAnimator newWinAnimator=dimParams.mDimWinAnimator;
      final WindowStateAnimator existingDimWinAnimator=mDimParams == null ? null : mDimParams.mDimWinAnimator;
      if (newWinAnimator.mSurfaceShown && (existingDimWinAnimator == null || !existingDimWinAnimator.mSurfaceShown || existingDimWinAnimator.mAnimLayer < newWinAnimator.mAnimLayer)) {
        mDimParams=dimParams;
      }
    }
    mAppAnimators.clear();
    final int N=layoutToAnim.mAppWindowAnimParams.size();
    for (int i=0; i < N; i++) {
      final AppWindowAnimParams params=layoutToAnim.mAppWindowAnimParams.get(i);
      AppWindowAnimator appAnimator=params.mAppAnimator;
      appAnimator.mAllAppWinAnimators=new ArrayList<WindowStateAnimator>(params.mWinAnimators);
      mAppAnimators.add(appAnimator);
    }
  }
}
