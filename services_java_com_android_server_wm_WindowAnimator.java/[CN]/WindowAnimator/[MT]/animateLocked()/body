{
  if (!mInitialized) {
    return;
  }
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,"!!! animate: entry time=" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,">>> OPEN TRANSACTION animateLocked");
  Surface.openTransaction();
  Surface.setAnimationTransaction();
  try {
    updateAppWindowsLocked();
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    testTokenMayBeDrawnLocked();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      final DimLayer dimAnimator=displayAnimator.mDimAnimator;
      final WindowStateAnimator winAnimator=displayAnimator.mDimWinAnimator;
      final int dimLayer;
      final float dimAmount;
      if (winAnimator == null) {
        dimLayer=dimAnimator.getLayer();
        dimAmount=0;
      }
 else {
        dimLayer=winAnimator.mAnimLayer - WindowManagerService.LAYER_OFFSET_DIM;
        dimAmount=winAnimator.mWin.mAttrs.dimAmount;
      }
      final float targetAlpha=dimAnimator.getTargetAlpha();
      if (targetAlpha != dimAmount) {
        if (winAnimator == null) {
          dimAnimator.hide(DEFAULT_DIM_DURATION);
        }
 else {
          long duration=(winAnimator.mAnimating && winAnimator.mAnimation != null) ? winAnimator.mAnimation.computeDurationHint() : DEFAULT_DIM_DURATION;
          if (targetAlpha > dimAmount) {
            duration=getDimBehindFadeDuration(duration);
          }
          dimAnimator.show(dimLayer,dimAmount,duration);
        }
      }
 else       if (dimAnimator.getLayer() != dimLayer) {
        dimAnimator.setLayer(dimLayer);
      }
      if (dimAnimator.isAnimating()) {
        if (!mService.okToDisplay()) {
          dimAnimator.show();
        }
 else {
          mAnimating|=dimAnimator.stepAnimation();
        }
      }
      if (mService.mDisplayMagnifier != null && displayId == Display.DEFAULT_DISPLAY) {
        mService.mDisplayMagnifier.drawMagnifiedRegionBorderIfNeededLocked();
      }
    }
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,"Unhandled exception in Window Manager",e);
  }
 finally {
    Surface.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,"<<< CLOSE TRANSACTION animateLocked");
  }
  boolean hasPendingLayoutChanges=false;
  DisplayContentsIterator iterator=mService.new DisplayContentsIterator();
  while (iterator.hasNext()) {
    final DisplayContent displayContent=iterator.next();
    final int pendingChanges=getPendingLayoutChanges(displayContent.getDisplayId());
    if ((pendingChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
    if (pendingChanges != 0) {
      hasPendingLayoutChanges=true;
    }
  }
  boolean doRequest=false;
  if (mBulkUpdateParams != 0) {
    doRequest=mService.copyAnimToLayoutParamsLocked();
  }
  if (hasPendingLayoutChanges || doRequest) {
    mService.requestTraversalLocked();
  }
  if (mAnimating) {
    mService.scheduleAnimationLocked();
  }
 else   if (wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,"!!! animate: exit mAnimating=" + mAnimating + " mBulkUpdateParams="+ Integer.toHexString(mBulkUpdateParams)+ " mPendingLayoutChanges(DEFAULT_DISPLAY)="+ Integer.toHexString(getPendingLayoutChanges(Display.DEFAULT_DISPLAY)));
  }
}
