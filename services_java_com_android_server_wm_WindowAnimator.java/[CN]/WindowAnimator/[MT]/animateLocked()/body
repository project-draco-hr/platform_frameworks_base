{
  if (!mInitialized) {
    return;
  }
  mPendingLayoutChanges.clear();
  mCurrentTime=SystemClock.uptimeMillis();
  mBulkUpdateParams=SET_ORIENTATION_CHANGE_COMPLETE;
  boolean wasAnimating=mAnimating;
  mAnimating=false;
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,"!!! animate: entry time=" + mCurrentTime);
  }
  if (WindowManagerService.SHOW_TRANSACTIONS)   Slog.i(TAG,">>> OPEN TRANSACTION animateLocked");
  Surface.openTransaction();
  Surface.setAnimationTransaction();
  try {
    updateAppWindowsLocked();
    final int numDisplays=mDisplayContentsAnimators.size();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) {
          mAnimating=true;
        }
 else {
          mBulkUpdateParams|=SET_UPDATE_ROTATION;
          screenRotationAnimation.kill();
          displayAnimator.mScreenRotationAnimation=null;
        }
      }
      performAnimationsLocked(displayId);
      final WindowList windows=mService.getWindowListLocked(displayId);
      final int N=windows.size();
      for (int j=0; j < N; j++) {
        windows.get(j).mWinAnimator.prepareSurfaceLocked(true);
      }
    }
    testTokenMayBeDrawnLocked();
    for (int i=0; i < numDisplays; i++) {
      final int displayId=mDisplayContentsAnimators.keyAt(i);
      DisplayContentsAnimator displayAnimator=mDisplayContentsAnimators.valueAt(i);
      final ScreenRotationAnimation screenRotationAnimation=displayAnimator.mScreenRotationAnimation;
      if (screenRotationAnimation != null) {
        screenRotationAnimation.updateSurfacesInTransaction();
      }
      final DimAnimator.Parameters dimParams=displayAnimator.mDimParams;
      final DimAnimator dimAnimator=displayAnimator.mDimAnimator;
      if (dimAnimator != null && dimParams != null) {
        dimAnimator.updateParameters(mContext.getResources(),dimParams,mCurrentTime);
      }
      if (dimAnimator != null && dimAnimator.mDimShown) {
        mAnimating|=dimAnimator.updateSurface(isDimmingLocked(displayId),mCurrentTime,!mService.okToDisplay());
      }
    }
    if (mService.mWatermark != null) {
      mService.mWatermark.drawIfNeeded();
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,"Unhandled exception in Window Manager",e);
  }
 finally {
    Surface.closeTransaction();
    if (WindowManagerService.SHOW_TRANSACTIONS)     Slog.i(TAG,"<<< CLOSE TRANSACTION animateLocked");
  }
  for (int i=mPendingLayoutChanges.size() - 1; i >= 0; i--) {
    if ((mPendingLayoutChanges.valueAt(i) & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      mBulkUpdateParams|=SET_WALLPAPER_ACTION_PENDING;
    }
  }
  if (mBulkUpdateParams != 0 || mPendingLayoutChanges.size() > 0) {
    if (mService.copyAnimToLayoutParamsLocked()) {
      mService.requestTraversalLocked();
    }
  }
  if (mAnimating) {
    mService.scheduleAnimationLocked();
  }
 else   if (wasAnimating) {
    mService.requestTraversalLocked();
  }
  if (WindowManagerService.DEBUG_WINDOW_TRACE) {
    Slog.i(TAG,"!!! animate: exit mAnimating=" + mAnimating + " mBulkUpdateParams="+ Integer.toHexString(mBulkUpdateParams)+ " mPendingLayoutChanges(DEFAULT_DISPLAY)="+ Integer.toHexString(mPendingLayoutChanges.get(Display.DEFAULT_DISPLAY)));
  }
}
