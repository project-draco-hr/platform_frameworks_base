{
  if (mStartTime == -1) {
    mStartTime=currentTime;
  }
  final long startOffset=getStartOffset();
  final long duration=mDuration;
  float normalizedTime;
  if (duration != 0) {
    normalizedTime=((float)(currentTime - (mStartTime + startOffset))) / (float)duration;
  }
 else {
    normalizedTime=currentTime < mStartTime ? 0.0f : 1.0f;
  }
  final boolean expired=normalizedTime >= 1.0f;
  mMore=!expired;
  if (!mFillEnabled)   normalizedTime=Math.max(Math.min(normalizedTime,1.0f),0.0f);
  if ((normalizedTime >= 0.0f || mFillBefore) && (normalizedTime <= 1.0f || mFillAfter)) {
    if (!mStarted) {
      if (mListener != null) {
        mListener.onAnimationStart(this);
      }
      mStarted=true;
      if (USE_CLOSEGUARD) {
        guard.open("cancel or detach or getTransformation");
      }
    }
    if (mFillEnabled)     normalizedTime=Math.max(Math.min(normalizedTime,1.0f),0.0f);
    if (mCycleFlip) {
      normalizedTime=1.0f - normalizedTime;
    }
    final float interpolatedTime=mInterpolator.getInterpolation(normalizedTime);
    applyTransformation(interpolatedTime,outTransformation);
  }
  if (expired) {
    if (mRepeatCount == mRepeated) {
      if (!mEnded) {
        mEnded=true;
        guard.close();
        if (mListener != null) {
          mListener.onAnimationEnd(this);
        }
      }
    }
 else {
      if (mRepeatCount > 0) {
        mRepeated++;
      }
      if (mRepeatMode == REVERSE) {
        mCycleFlip=!mCycleFlip;
      }
      mStartTime=-1;
      mMore=true;
      if (mListener != null) {
        mListener.onAnimationRepeat(this);
      }
    }
  }
  if (!mMore && mOneMoreTime) {
    mOneMoreTime=false;
    return true;
  }
  return mMore;
}
