{
  if (mKeyStore == null || mSpec == null) {
    throw new IllegalStateException("Not initialized");
  }
  final int flags=(mEncryptionAtRestRequired) ? KeyStore.FLAG_ENCRYPTED : 0;
  if (((flags & KeyStore.FLAG_ENCRYPTED) != 0) && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
    throw new IllegalStateException("Encryption at rest using secure lock screen credential requested for key pair" + ", but the user has not yet entered the credential");
  }
  final String alias=mSpec.getKeystoreAlias();
  byte[][] args=getArgsForKeyType(mKeyType,mSpec.getAlgorithmParameterSpec());
  final String privateKeyAlias=Credentials.USER_PRIVATE_KEY + alias;
  boolean success=false;
  try {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    if (!mKeyStore.generate(privateKeyAlias,KeyStore.UID_SELF,mKeyType,mKeySize,flags,args)) {
      throw new IllegalStateException("could not generate key in keystore");
    }
    final PrivateKey privKey;
    final OpenSSLEngine engine=OpenSSLEngine.getInstance("keystore");
    try {
      privKey=engine.getPrivateKeyById(privateKeyAlias);
    }
 catch (    InvalidKeyException e) {
      throw new RuntimeException("Can't get key",e);
    }
    ExportResult exportResult=mKeyStore.exportKey(privateKeyAlias,KeymasterDefs.KM_KEY_FORMAT_X509,null,null);
    if (exportResult == null) {
      throw new KeyStoreConnectException();
    }
 else     if (exportResult.resultCode != KeyStore.NO_ERROR) {
      throw new ProviderException("Failed to obtain public key in X.509 format",KeyStore.getKeyStoreException(exportResult.resultCode));
    }
    final byte[] pubKeyBytes=exportResult.exportData;
    final PublicKey pubKey;
    try {
      final KeyFactory keyFact=KeyFactory.getInstance(mKeyAlgorithm);
      pubKey=keyFact.generatePublic(new X509EncodedKeySpec(pubKeyBytes));
    }
 catch (    NoSuchAlgorithmException e) {
      throw new IllegalStateException("Can't instantiate key generator",e);
    }
catch (    InvalidKeySpecException e) {
      throw new IllegalStateException("keystore returned invalid key encoding",e);
    }
    final X509Certificate cert;
    try {
      cert=generateCertificate(privKey,pubKey);
    }
 catch (    Exception e) {
      throw new IllegalStateException("Can't generate certificate",e);
    }
    byte[] certBytes;
    try {
      certBytes=cert.getEncoded();
    }
 catch (    CertificateEncodingException e) {
      throw new IllegalStateException("Can't get encoding of certificate",e);
    }
    if (!mKeyStore.put(Credentials.USER_CERTIFICATE + alias,certBytes,KeyStore.UID_SELF,flags)) {
      throw new IllegalStateException("Can't store certificate in AndroidKeyStore");
    }
    KeyPair result=new KeyPair(pubKey,privKey);
    success=true;
    return result;
  }
  finally {
    if (!success) {
      Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    }
  }
}
