{
  if (mKeyStore == null || mSpec == null) {
    throw new IllegalStateException("Not initialized");
  }
  final int flags=(mEncryptionAtRestRequired) ? KeyStore.FLAG_ENCRYPTED : 0;
  if (((flags & KeyStore.FLAG_ENCRYPTED) != 0) && (mKeyStore.state() != KeyStore.State.UNLOCKED)) {
    throw new IllegalStateException("Encryption at rest using secure lock screen credential requested for key pair" + ", but the user has not yet entered the credential");
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE,mKeySizeBits);
  args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM,mKeymasterAlgorithm);
  args.addEnums(KeymasterDefs.KM_TAG_PURPOSE,mKeymasterPurposes);
  args.addEnums(KeymasterDefs.KM_TAG_BLOCK_MODE,mKeymasterBlockModes);
  args.addEnums(KeymasterDefs.KM_TAG_PADDING,mKeymasterEncryptionPaddings);
  args.addEnums(KeymasterDefs.KM_TAG_PADDING,mKeymasterSignaturePaddings);
  args.addEnums(KeymasterDefs.KM_TAG_DIGEST,mKeymasterDigests);
  KeymasterUtils.addUserAuthArgs(args,mSpec.isUserAuthenticationRequired(),mSpec.getUserAuthenticationValidityDurationSeconds());
  args.addDateIfNotNull(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,mSpec.getKeyValidityStart());
  args.addDateIfNotNull(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,mSpec.getKeyValidityForOriginationEnd());
  args.addDateIfNotNull(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,mSpec.getKeyValidityForConsumptionEnd());
  addAlgorithmSpecificParameters(args);
  byte[] additionalEntropy=KeyStoreCryptoOperationUtils.getRandomBytesToMixIntoKeystoreRng(mRng,(mKeySizeBits + 7) / 8);
  final String privateKeyAlias=Credentials.USER_PRIVATE_KEY + mEntryAlias;
  boolean success=false;
  try {
    Credentials.deleteAllTypesForAlias(mKeyStore,mEntryAlias,mEntryUid);
    KeyCharacteristics resultingKeyCharacteristics=new KeyCharacteristics();
    int errorCode=mKeyStore.generateKey(privateKeyAlias,args,additionalEntropy,mEntryUid,flags,resultingKeyCharacteristics);
    if (errorCode != KeyStore.NO_ERROR) {
      throw new ProviderException("Failed to generate key pair",KeyStore.getKeyStoreException(errorCode));
    }
    KeyPair result;
    try {
      result=AndroidKeyStoreProvider.loadAndroidKeyStoreKeyPairFromKeystore(mKeyStore,privateKeyAlias,mEntryUid);
    }
 catch (    UnrecoverableKeyException e) {
      throw new ProviderException("Failed to load generated key pair from keystore",e);
    }
    if (!mJcaKeyAlgorithm.equalsIgnoreCase(result.getPrivate().getAlgorithm())) {
      throw new ProviderException("Generated key pair algorithm does not match requested algorithm: " + result.getPrivate().getAlgorithm() + " vs "+ mJcaKeyAlgorithm);
    }
    final X509Certificate cert;
    try {
      cert=generateSelfSignedCertificate(result.getPrivate(),result.getPublic());
    }
 catch (    Exception e) {
      throw new ProviderException("Failed to generate self-signed certificate",e);
    }
    byte[] certBytes;
    try {
      certBytes=cert.getEncoded();
    }
 catch (    CertificateEncodingException e) {
      throw new ProviderException("Failed to obtain encoded form of self-signed certificate",e);
    }
    int insertErrorCode=mKeyStore.insert(Credentials.USER_CERTIFICATE + mEntryAlias,certBytes,mEntryUid,flags);
    if (insertErrorCode != KeyStore.NO_ERROR) {
      throw new ProviderException("Failed to store self-signed certificate",KeyStore.getKeyStoreException(insertErrorCode));
    }
    success=true;
    return result;
  }
  finally {
    if (!success) {
      Credentials.deleteAllTypesForAlias(mKeyStore,mEntryAlias,mEntryUid);
    }
  }
}
