{
  Iterator<BasePermission> it=mSettings.mPermissionTrees.values().iterator();
  while (it.hasNext()) {
    final BasePermission bp=it.next();
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,"Removing dangling permission tree: " + bp.name + " from package "+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,"Removing old permission tree: " + bp.name + " from package "+ bp.sourcePackage);
        flags|=UPDATE_PERMISSIONS_ALL;
        it.remove();
      }
    }
  }
  it=mSettings.mPermissions.values().iterator();
  while (it.hasNext()) {
    final BasePermission bp=it.next();
    if (bp.type == BasePermission.TYPE_DYNAMIC) {
      if (DEBUG_SETTINGS)       Log.v(TAG,"Dynamic permission: name=" + bp.name + " pkg="+ bp.sourcePackage+ " info="+ bp.pendingInfo);
      if (bp.packageSetting == null && bp.pendingInfo != null) {
        final BasePermission tree=findPermissionTreeLP(bp.name);
        if (tree != null && tree.perm != null) {
          bp.packageSetting=tree.packageSetting;
          bp.perm=new PackageParser.Permission(tree.perm.owner,new PermissionInfo(bp.pendingInfo));
          bp.perm.info.packageName=tree.perm.info.packageName;
          bp.perm.info.name=bp.name;
          bp.uid=tree.uid;
        }
      }
    }
    if (bp.packageSetting == null) {
      bp.packageSetting=mSettings.mPackages.get(bp.sourcePackage);
    }
    if (bp.packageSetting == null) {
      Slog.w(TAG,"Removing dangling permission: " + bp.name + " from package "+ bp.sourcePackage);
      it.remove();
    }
 else     if (changingPkg != null && changingPkg.equals(bp.sourcePackage)) {
      if (pkgInfo == null || !hasPermission(pkgInfo,bp.name)) {
        Slog.i(TAG,"Removing old permission: " + bp.name + " from package "+ bp.sourcePackage);
        flags|=UPDATE_PERMISSIONS_ALL;
        it.remove();
      }
    }
  }
  if ((flags & UPDATE_PERMISSIONS_ALL) != 0) {
    for (    PackageParser.Package pkg : mPackages.values()) {
      if (pkg != pkgInfo) {
        final String volumeUuid=getVolumeUuidForPackage(pkg);
        final boolean replace=((flags & UPDATE_PERMISSIONS_REPLACE_ALL) != 0) && Objects.equals(replaceVolumeUuid,volumeUuid);
        grantPermissionsLPw(pkg,replace,changingPkg);
      }
    }
  }
  if (pkgInfo != null) {
    final String volumeUuid=getVolumeUuidForPackage(pkgInfo);
    final boolean replace=((flags & UPDATE_PERMISSIONS_REPLACE_PKG) != 0) && Objects.equals(replaceVolumeUuid,volumeUuid);
    grantPermissionsLPw(pkgInfo,replace,changingPkg);
  }
}
