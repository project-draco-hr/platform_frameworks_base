{
  enforceSystemOrRoot("Only the system can request dexopt be performed");
  try {
    IMountService ms=PackageHelper.getMountService();
    if (ms != null) {
      final boolean isUpgrade=isUpgrade();
      boolean doTrim=isUpgrade;
      if (doTrim) {
        Slog.w(TAG,"Running disk maintenance immediately due to system update");
      }
 else {
        final long interval=android.provider.Settings.Global.getLong(mContext.getContentResolver(),android.provider.Settings.Global.FSTRIM_MANDATORY_INTERVAL,DEFAULT_MANDATORY_FSTRIM_INTERVAL);
        if (interval > 0) {
          final long timeSinceLast=System.currentTimeMillis() - ms.lastMaintenance();
          if (timeSinceLast > interval) {
            doTrim=true;
            Slog.w(TAG,"No disk maintenance in " + timeSinceLast + "; running immediately");
          }
        }
      }
      if (doTrim) {
        if (!isFirstBoot()) {
          try {
            ActivityManagerNative.getDefault().showBootMessage(mContext.getResources().getString(R.string.android_upgrading_fstrim),true);
          }
 catch (          RemoteException e) {
          }
        }
        ms.runMaintenance();
      }
    }
 else {
      Slog.e(TAG,"Mount service unavailable!");
    }
  }
 catch (  RemoteException e) {
  }
  final ArraySet<PackageParser.Package> pkgs;
synchronized (mPackages) {
    pkgs=mPackageDexOptimizer.clearDeferredDexOptPackages();
  }
  if (pkgs != null) {
    ArrayList<PackageParser.Package> sortedPkgs=new ArrayList<PackageParser.Package>();
    for (Iterator<PackageParser.Package> it=pkgs.iterator(); it.hasNext(); ) {
      PackageParser.Package pkg=it.next();
      if (pkg.coreApp) {
        if (DEBUG_DEXOPT) {
          Log.i(TAG,"Adding core app " + sortedPkgs.size() + ": "+ pkg.packageName);
        }
        sortedPkgs.add(pkg);
        it.remove();
      }
    }
    Intent intent=new Intent(Intent.ACTION_PRE_BOOT_COMPLETED);
    ArraySet<String> pkgNames=getPackageNamesForIntent(intent);
    for (Iterator<PackageParser.Package> it=pkgs.iterator(); it.hasNext(); ) {
      PackageParser.Package pkg=it.next();
      if (pkgNames.contains(pkg.packageName)) {
        if (DEBUG_DEXOPT) {
          Log.i(TAG,"Adding pre boot system app " + sortedPkgs.size() + ": "+ pkg.packageName);
        }
        sortedPkgs.add(pkg);
        it.remove();
      }
    }
    filterRecentlyUsedApps(pkgs);
    for (    PackageParser.Package pkg : pkgs) {
      if (DEBUG_DEXOPT) {
        Log.i(TAG,"Adding app " + sortedPkgs.size() + ": "+ pkg.packageName);
      }
      sortedPkgs.add(pkg);
    }
    if (mLazyDexOpt) {
      filterRecentlyUsedApps(sortedPkgs);
    }
    int i=0;
    int total=sortedPkgs.size();
    File dataDir=Environment.getDataDirectory();
    long lowThreshold=StorageManager.from(mContext).getStorageLowBytes(dataDir);
    if (lowThreshold == 0) {
      throw new IllegalStateException("Invalid low memory threshold");
    }
    for (    PackageParser.Package pkg : sortedPkgs) {
      long usableSpace=dataDir.getUsableSpace();
      if (usableSpace < lowThreshold) {
        Log.w(TAG,"Not running dexopt on remaining apps due to low memory: " + usableSpace);
        break;
      }
      performBootDexOpt(pkg,++i,total);
    }
  }
}
