{
  if (!opkg.mTrustedOverlay) {
    Slog.w(TAG,"Skipping target and overlay pair " + pkg.baseCodePath + " and "+ opkg.baseCodePath+ ": overlay not trusted");
    return false;
  }
  HashMap<String,PackageParser.Package> overlaySet=mOverlays.get(pkg.packageName);
  if (overlaySet == null) {
    Slog.e(TAG,"was about to create idmap for " + pkg.baseCodePath + " and "+ opkg.baseCodePath+ " but target package has no known overlays");
    return false;
  }
  final int sharedGid=UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
  if (mInstaller.idmap(pkg.baseCodePath,opkg.baseCodePath,sharedGid) != 0) {
    Slog.e(TAG,"Failed to generate idmap for " + pkg.baseCodePath + " and "+ opkg.baseCodePath);
    return false;
  }
  PackageParser.Package[] overlayArray=overlaySet.values().toArray(new PackageParser.Package[0]);
  Comparator<PackageParser.Package> cmp=new Comparator<PackageParser.Package>(){
    public int compare(    PackageParser.Package p1,    PackageParser.Package p2){
      return p1.mOverlayPriority - p2.mOverlayPriority;
    }
  }
;
  Arrays.sort(overlayArray,cmp);
  pkg.applicationInfo.resourceDirs=new String[overlayArray.length];
  int i=0;
  for (  PackageParser.Package p : overlayArray) {
    pkg.applicationInfo.resourceDirs[i++]=p.applicationInfo.sourceDir;
  }
  return true;
}
