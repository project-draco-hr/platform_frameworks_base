{
  final PackageParser.Package oldPackage;
  final String pkgName=pkg.packageName;
  final int[] allUsers;
  final boolean[] perUserInstalled;
  final boolean weFroze;
synchronized (mPackages) {
    oldPackage=mPackages.get(pkgName);
    if (DEBUG_INSTALL)     Slog.d(TAG,"replacePackageLI: new=" + pkg + ", old="+ oldPackage);
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
      if (!checkUpgradeKeySetLP(ps,pkg)) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,"New package not signed by keys specified by upgrade-keysets: " + pkgName);
        return;
      }
    }
 else {
      if (compareSignatures(oldPackage.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
        res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,"New package has a different signature: " + pkgName);
        return;
      }
    }
    allUsers=sUserManager.getUserIds();
    perUserInstalled=new boolean[allUsers.length];
    for (int i=0; i < allUsers.length; i++) {
      perUserInstalled[i]=ps != null ? ps.getInstalled(allUsers[i]) : false;
    }
    if (!ps.frozen) {
      ps.frozen=true;
      weFroze=true;
    }
 else {
      weFroze=false;
    }
  }
  killApplication(pkgName,oldPackage.applicationInfo.uid,"replace pkg");
  try {
    boolean sysPkg=(isSystemApp(oldPackage));
    if (sysPkg) {
      replaceSystemPackageLI(oldPackage,pkg,parseFlags,scanFlags,user,allUsers,perUserInstalled,installerPackageName,volumeUuid,res);
    }
 else {
      replaceNonSystemPackageLI(oldPackage,pkg,parseFlags,scanFlags,user,allUsers,perUserInstalled,installerPackageName,volumeUuid,res);
    }
  }
  finally {
    if (weFroze) {
      unfreezePackage(pkgName);
    }
  }
}
