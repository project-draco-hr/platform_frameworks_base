{
  final int installFlags=args.installFlags;
  final String installerPackageName=args.installerPackageName;
  final String volumeUuid=args.volumeUuid;
  final File tmpPackageFile=new File(args.getCodePath());
  final boolean forwardLocked=((installFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
  final boolean onExternal=(((installFlags & PackageManager.INSTALL_EXTERNAL) != 0) || (args.volumeUuid != null));
  final boolean ephemeral=((installFlags & PackageManager.INSTALL_EPHEMERAL) != 0);
  boolean replace=false;
  int scanFlags=SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
  if (args.move != null) {
    scanFlags|=SCAN_INITIAL;
  }
  if ((installFlags & PackageManager.INSTALL_DONT_KILL_APP) != 0) {
    scanFlags|=SCAN_DONT_KILL_APP;
  }
  res.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
  if (DEBUG_INSTALL)   Slog.d(TAG,"installPackageLI: path=" + tmpPackageFile);
  if (ephemeral && (forwardLocked || onExternal)) {
    Slog.i(TAG,"Incompatible ephemeral install; fwdLocked=" + forwardLocked + " external="+ onExternal);
    res.setReturnCode(PackageManager.INSTALL_FAILED_EPHEMERAL_INVALID);
    return;
  }
  final int parseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | PackageParser.PARSE_ENFORCE_CODE| (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0)| (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0)| (ephemeral ? PackageParser.PARSE_IS_EPHEMERAL : 0);
  PackageParser pp=new PackageParser();
  pp.setSeparateProcesses(mSeparateProcesses);
  pp.setDisplayMetrics(mMetrics);
  Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER,"parsePackage");
  final PackageParser.Package pkg;
  try {
    pkg=pp.parsePackage(tmpPackageFile,parseFlags);
  }
 catch (  PackageParserException e) {
    res.setError("Failed parse during installPackageLI",e);
    return;
  }
 finally {
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
  }
  if (pkg.childPackages != null) {
synchronized (mPackages) {
      final int childCount=pkg.childPackages.size();
      for (int i=0; i < childCount; i++) {
        PackageParser.Package childPkg=pkg.childPackages.get(i);
        PackageInstalledInfo childRes=new PackageInstalledInfo();
        childRes.setReturnCode(PackageManager.INSTALL_SUCCEEDED);
        childRes.pkg=childPkg;
        childRes.name=childPkg.packageName;
        PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
        if (childPs != null) {
          childRes.origUsers=childPs.queryInstalledUsers(sUserManager.getUserIds(),true);
        }
        if ((mPackages.containsKey(childPkg.packageName))) {
          childRes.removedInfo=new PackageRemovedInfo();
          childRes.removedInfo.removedPackage=childPkg.packageName;
        }
        if (res.addedChildPackages == null) {
          res.addedChildPackages=new ArrayMap<>();
        }
        res.addedChildPackages.put(childPkg.packageName,childRes);
      }
    }
  }
  if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
    pkg.cpuAbiOverride=args.abiOverride;
  }
  String pkgName=res.name=pkg.packageName;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
    if ((installFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
      res.setError(INSTALL_FAILED_TEST_ONLY,"installPackageLI");
      return;
    }
  }
  try {
    PackageParser.collectCertificates(pkg,parseFlags);
  }
 catch (  PackageParserException e) {
    res.setError("Failed collect during installPackageLI",e);
    return;
  }
  pp=null;
  String oldCodePath=null;
  boolean systemApp=false;
synchronized (mPackages) {
    if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
      String oldName=mSettings.mRenamedPackages.get(pkgName);
      if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
        pkg.setPackageName(oldName);
        pkgName=pkg.packageName;
        replace=true;
        if (DEBUG_INSTALL)         Slog.d(TAG,"Replacing existing renamed package: oldName=" + oldName + " pkgName="+ pkgName);
      }
 else       if (mPackages.containsKey(pkgName)) {
        replace=true;
        if (DEBUG_INSTALL)         Slog.d(TAG,"Replace existing pacakge: " + pkgName);
      }
      if (pkg.parentPackage != null) {
        res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME,"Package " + pkg.packageName + " is child of package "+ pkg.parentPackage.parentPackage+ ". Child packages "+ "can be updated only through the parent package.");
        return;
      }
      if (replace) {
        PackageParser.Package oldPackage=mPackages.get(pkgName);
        final int oldTargetSdk=oldPackage.applicationInfo.targetSdkVersion;
        final int newTargetSdk=pkg.applicationInfo.targetSdkVersion;
        if (oldTargetSdk > Build.VERSION_CODES.LOLLIPOP_MR1 && newTargetSdk <= Build.VERSION_CODES.LOLLIPOP_MR1) {
          res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE,"Package " + pkg.packageName + " new target SDK "+ newTargetSdk+ " doesn't support runtime permissions but the old"+ " target SDK "+ oldTargetSdk+ " does.");
          return;
        }
        if (oldPackage.parentPackage != null) {
          res.setError(PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME,"Package " + pkg.packageName + " is child of package "+ oldPackage.parentPackage+ ". Child packages "+ "can be updated only through the parent package.");
          return;
        }
      }
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (ps != null) {
      if (DEBUG_INSTALL)       Slog.d(TAG,"Existing package: " + ps);
      if (shouldCheckUpgradeKeySetLP(ps,scanFlags)) {
        if (!checkUpgradeKeySetLP(ps,pkg)) {
          res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE,"Package " + pkg.packageName + " upgrade keys do not match the "+ "previously installed version");
          return;
        }
      }
 else {
        try {
          verifySignaturesLP(ps,pkg);
        }
 catch (        PackageManagerException e) {
          res.setError(e.error,e.getMessage());
          return;
        }
      }
      oldCodePath=mSettings.mPackages.get(pkgName).codePathString;
      if (ps.pkg != null && ps.pkg.applicationInfo != null) {
        systemApp=(ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
      }
      res.origUsers=ps.queryInstalledUsers(sUserManager.getUserIds(),true);
    }
    int N=pkg.permissions.size();
    for (int i=N - 1; i >= 0; i--) {
      PackageParser.Permission perm=pkg.permissions.get(i);
      BasePermission bp=mSettings.mPermissions.get(perm.info.name);
      if (bp != null) {
        final boolean sigsOk;
        if (bp.sourcePackage.equals(pkg.packageName) && (bp.packageSetting instanceof PackageSetting) && (shouldCheckUpgradeKeySetLP((PackageSetting)bp.packageSetting,scanFlags))) {
          sigsOk=checkUpgradeKeySetLP((PackageSetting)bp.packageSetting,pkg);
        }
 else {
          sigsOk=compareSignatures(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
        }
        if (!sigsOk) {
          if (!bp.sourcePackage.equals("android")) {
            res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION,"Package " + pkg.packageName + " attempting to redeclare permission "+ perm.info.name+ " already owned by "+ bp.sourcePackage);
            res.origPermission=perm.info.name;
            res.origPackage=bp.sourcePackage;
            return;
          }
 else {
            Slog.w(TAG,"Package " + pkg.packageName + " attempting to redeclare system permission "+ perm.info.name+ "; ignoring new declaration");
            pkg.permissions.remove(i);
          }
        }
      }
    }
  }
  if (systemApp) {
    if (onExternal) {
      res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION,"Cannot install updates to system apps on sdcard");
      return;
    }
 else     if (ephemeral) {
      res.setError(INSTALL_FAILED_EPHEMERAL_INVALID,"Cannot update a system app with an ephemeral app");
      return;
    }
  }
  if (args.move != null) {
    scanFlags|=SCAN_NO_DEX;
    scanFlags|=SCAN_MOVE;
synchronized (mPackages) {
      final PackageSetting ps=mSettings.mPackages.get(pkgName);
      if (ps == null) {
        res.setError(INSTALL_FAILED_INTERNAL_ERROR,"Missing settings for moved package " + pkgName);
      }
      pkg.applicationInfo.primaryCpuAbi=ps.primaryCpuAbiString;
      pkg.applicationInfo.secondaryCpuAbi=ps.secondaryCpuAbiString;
    }
  }
 else   if (!forwardLocked && !pkg.applicationInfo.isExternalAsec()) {
    scanFlags|=SCAN_NO_DEX;
    try {
      String abiOverride=(TextUtils.isEmpty(pkg.cpuAbiOverride) ? args.abiOverride : pkg.cpuAbiOverride);
      derivePackageAbi(pkg,new File(pkg.codePath),abiOverride,true);
    }
 catch (    PackageManagerException pme) {
      Slog.e(TAG,"Error deriving application ABI",pme);
      res.setError(INSTALL_FAILED_INTERNAL_ERROR,"Error deriving application ABI");
      return;
    }
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER,"dexopt");
    int result=mPackageDexOptimizer.performDexOpt(pkg,null,false,getCompilerFilterForReason(REASON_INSTALL));
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
      String msg="Extracking package failed for " + pkgName;
      res.setError(INSTALL_FAILED_DEXOPT,msg);
      return;
    }
  }
  if (!args.doRename(res.returnCode,pkg,oldCodePath)) {
    res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE,"Failed rename");
    return;
  }
  startIntentFilterVerifications(args.user.getIdentifier(),replace,pkg);
  if (replace) {
    replacePackageLI(pkg,parseFlags,scanFlags | SCAN_REPLACING,args.user,installerPackageName,res);
  }
 else {
    installNewPackageLI(pkg,parseFlags,scanFlags | SCAN_DELETE_DATA_ON_FAILURES,args.user,installerPackageName,volumeUuid,res);
  }
synchronized (mPackages) {
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (ps != null) {
      res.newUsers=ps.queryInstalledUsers(sUserManager.getUserIds(),true);
    }
    final int childCount=(pkg.childPackages != null) ? pkg.childPackages.size() : 0;
    for (int i=0; i < childCount; i++) {
      PackageParser.Package childPkg=pkg.childPackages.get(i);
      PackageInstalledInfo childRes=res.addedChildPackages.get(childPkg.packageName);
      PackageSetting childPs=mSettings.peekPackageLPr(childPkg.packageName);
      if (childPs != null) {
        childRes.newUsers=childPs.queryInstalledUsers(sUserManager.getUserIds(),true);
      }
    }
  }
}
