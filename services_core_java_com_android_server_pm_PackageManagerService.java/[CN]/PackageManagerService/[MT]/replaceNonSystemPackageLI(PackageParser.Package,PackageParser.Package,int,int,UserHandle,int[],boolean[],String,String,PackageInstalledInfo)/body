{
  String pkgName=deletedPackage.packageName;
  boolean deletedPkg=true;
  boolean updatedSettings=false;
  if (DEBUG_INSTALL)   Slog.d(TAG,"replaceNonSystemPackageLI: new=" + pkg + ", old="+ deletedPackage);
  long origUpdateTime;
  if (pkg.mExtras != null) {
    origUpdateTime=((PackageSetting)pkg.mExtras).lastUpdateTime;
  }
 else {
    origUpdateTime=0;
  }
  if (!deletePackageLI(pkgName,null,true,null,null,PackageManager.DELETE_KEEP_DATA,res.removedInfo,true)) {
    res.setError(INSTALL_FAILED_REPLACE_COULDNT_DELETE,"replaceNonSystemPackageLI");
    deletedPkg=false;
  }
 else {
    if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {
      if (DEBUG_INSTALL) {
        Slog.i(TAG,"upgrading pkg " + deletedPackage + " is ASEC-hosted -> UNAVAILABLE");
      }
      final int[] uidArray=new int[]{deletedPackage.applicationInfo.uid};
      final ArrayList<String> pkgList=new ArrayList<String>(1);
      pkgList.add(deletedPackage.applicationInfo.packageName);
      sendResourcesChangedBroadcast(false,true,pkgList,uidArray,null);
    }
    deleteCodeCacheDirsLI(pkg.volumeUuid,pkgName);
    try {
      final PackageParser.Package newPackage=scanPackageTracedLI(pkg,parseFlags,scanFlags | SCAN_UPDATE_TIME,System.currentTimeMillis(),user);
      updateSettingsLI(newPackage,installerPackageName,volumeUuid,allUsers,perUserInstalled,res,user);
      updatedSettings=true;
    }
 catch (    PackageManagerException e) {
      res.setError("Package couldn't be installed in " + pkg.codePath,e);
    }
  }
  if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {
    if (updatedSettings) {
      if (DEBUG_INSTALL)       Slog.d(TAG,"Install failed, rolling pack: " + pkgName);
      deletePackageLI(pkgName,null,true,allUsers,perUserInstalled,PackageManager.DELETE_KEEP_DATA,res.removedInfo,true);
    }
    if (deletedPkg) {
      if (DEBUG_INSTALL)       Slog.d(TAG,"Install failed, reinstalling: " + deletedPackage);
      File restoreFile=new File(deletedPackage.codePath);
      boolean oldExternal=isExternal(deletedPackage);
      int oldParseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (deletedPackage.isForwardLocked() ? PackageParser.PARSE_FORWARD_LOCK : 0)| (oldExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);
      int oldScanFlags=SCAN_UPDATE_SIGNATURE | SCAN_UPDATE_TIME;
      try {
        scanPackageTracedLI(restoreFile,oldParseFlags,oldScanFlags,origUpdateTime,null);
      }
 catch (      PackageManagerException e) {
        Slog.e(TAG,"Failed to restore package : " + pkgName + " after failed upgrade: "+ e.getMessage());
        return;
      }
synchronized (mPackages) {
        updatePermissionsLPw(deletedPackage.packageName,deletedPackage,UPDATE_PERMISSIONS_ALL);
        mSettings.writeLPr();
      }
      Slog.i(TAG,"Successfully restored package : " + pkgName + " after failed upgrade");
    }
  }
}
