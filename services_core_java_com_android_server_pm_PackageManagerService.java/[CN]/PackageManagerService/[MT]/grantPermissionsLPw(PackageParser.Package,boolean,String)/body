{
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  PermissionsState permissionsState=ps.getPermissionsState();
  PermissionsState origPermissions=permissionsState;
  final int[] currentUserIds=UserManagerService.getInstance().getUserIds();
  int[] upgradeUserIds=PermissionsState.USERS_NONE;
  boolean changedPermission=false;
  if (replace) {
    ps.permissionsFixed=false;
    origPermissions=new PermissionsState(permissionsState);
    permissionsState.reset();
  }
  permissionsState.setGlobalGids(mGlobalGids);
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    final String name=pkg.requestedPermissions.get(i);
    final BasePermission bp=mSettings.mPermissions.get(name);
    if (DEBUG_INSTALL) {
      Log.i(TAG,"Package " + pkg.packageName + " checking "+ name+ ": "+ bp);
    }
    if (bp == null || bp.packageSetting == null) {
      if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
        Slog.w(TAG,"Unknown permission " + name + " in package "+ pkg.packageName);
      }
      continue;
    }
    final String perm=bp.name;
    boolean allowedSig=false;
    int grant=GRANT_DENIED;
    if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
      ArraySet<String> pkgs=mAppOpPermissionPackages.get(bp.name);
      if (pkgs == null) {
        pkgs=new ArraySet<>();
        mAppOpPermissionPackages.put(bp.name,pkgs);
      }
      pkgs.add(pkg.packageName);
    }
    final int level=bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;
switch (level) {
case PermissionInfo.PROTECTION_NORMAL:
{
        grant=GRANT_INSTALL;
      }
    break;
case PermissionInfo.PROTECTION_DANGEROUS:
{
    if (!RUNTIME_PERMISSIONS_ENABLED || pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1) {
      grant=GRANT_INSTALL;
    }
 else     if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
      final int[] updatedUserIds=ps.getPermissionsUpdatedForUserIds();
      if (origPermissions.hasInstallPermission(bp.name)) {
        grant=GRANT_UPGRADE;
        upgradeUserIds=currentUserIds;
      }
 else       if (!Arrays.equals(updatedUserIds,currentUserIds)) {
        grant=GRANT_UPGRADE;
        upgradeUserIds=currentUserIds;
        for (        int userId : updatedUserIds) {
          upgradeUserIds=ArrayUtils.removeInt(upgradeUserIds,userId);
        }
      }
 else {
        grant=GRANT_RUNTIME;
      }
    }
 else     if (origPermissions.hasInstallPermission(bp.name)) {
      grant=GRANT_UPGRADE;
      upgradeUserIds=currentUserIds;
    }
 else     if (replace) {
      grant=GRANT_RUNTIME;
    }
  }
break;
case PermissionInfo.PROTECTION_SIGNATURE:
{
allowedSig=grantSignaturePermission(perm,pkg,bp,origPermissions);
if (allowedSig) {
  grant=GRANT_INSTALL;
}
}
break;
}
if (DEBUG_INSTALL) {
Log.i(TAG,"Package " + pkg.packageName + " granting "+ perm);
}
if (grant != GRANT_DENIED) {
if (!isSystemApp(ps) && ps.permissionsFixed) {
if (!allowedSig && !origPermissions.hasInstallPermission(perm)) {
if (!isNewPlatformPermissionForPackage(perm,pkg)) {
grant=GRANT_DENIED;
}
}
}
switch (grant) {
case GRANT_INSTALL:
{
if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedPermission=true;
}
}
break;
case GRANT_RUNTIME:
{
for (int userId : UserManagerService.getInstance().getUserIds()) {
if (origPermissions.hasRuntimePermission(bp.name,userId)) {
if (permissionsState.grantRuntimePermission(bp,userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedPermission=true;
}
}
}
}
break;
case GRANT_UPGRADE:
{
permissionsState.revokeInstallPermission(bp);
for (int userId : upgradeUserIds) {
if (permissionsState.grantRuntimePermission(bp,userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedPermission=true;
}
}
}
break;
default :
{
if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
Slog.w(TAG,"Not granting permission " + perm + " to package "+ pkg.packageName+ " because it was previously installed without");
}
}
break;
}
}
 else {
if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedPermission=true;
Slog.i(TAG,"Un-granting permission " + perm + " from package "+ pkg.packageName+ " (protectionLevel="+ bp.protectionLevel+ " flags=0x"+ Integer.toHexString(pkg.applicationInfo.flags)+ ")");
}
 else if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) == 0) {
if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
Slog.w(TAG,"Not granting permission " + perm + " to package "+ pkg.packageName+ " (protectionLevel="+ bp.protectionLevel+ " flags=0x"+ Integer.toHexString(pkg.applicationInfo.flags)+ ")");
}
}
}
}
if ((changedPermission || replace) && !ps.permissionsFixed && !isSystemApp(ps) || isUpdatedSystemApp(ps)) {
ps.permissionsFixed=true;
}
ps.setPermissionsUpdatedForUserIds(currentUserIds);
}
