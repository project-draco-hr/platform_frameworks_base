{
  final PackageSetting ps=(PackageSetting)pkg.mExtras;
  if (ps == null) {
    return;
  }
  PermissionsState permissionsState=ps.getPermissionsState();
  PermissionsState origPermissions=permissionsState;
  final int[] currentUserIds=UserManagerService.getInstance().getUserIds();
  int[] changedRuntimePermissionUserIds=EMPTY_INT_ARRAY;
  boolean changedInstallPermission=false;
  if (replace) {
    ps.installPermissionsFixed=false;
    if (!ps.isSharedUser()) {
      origPermissions=new PermissionsState(permissionsState);
      permissionsState.reset();
    }
  }
  permissionsState.setGlobalGids(mGlobalGids);
  final int N=pkg.requestedPermissions.size();
  for (int i=0; i < N; i++) {
    final String name=pkg.requestedPermissions.get(i);
    final BasePermission bp=mSettings.mPermissions.get(name);
    if (DEBUG_INSTALL) {
      Log.i(TAG,"Package " + pkg.packageName + " checking "+ name+ ": "+ bp);
    }
    if (bp == null || bp.packageSetting == null) {
      if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
        Slog.w(TAG,"Unknown permission " + name + " in package "+ pkg.packageName);
      }
      continue;
    }
    final String perm=bp.name;
    boolean allowedSig=false;
    int grant=GRANT_DENIED;
    if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
      ArraySet<String> pkgs=mAppOpPermissionPackages.get(bp.name);
      if (pkgs == null) {
        pkgs=new ArraySet<>();
        mAppOpPermissionPackages.put(bp.name,pkgs);
      }
      pkgs.add(pkg.packageName);
    }
    final int level=bp.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE;
switch (level) {
case PermissionInfo.PROTECTION_NORMAL:
{
        grant=GRANT_INSTALL;
      }
    break;
case PermissionInfo.PROTECTION_DANGEROUS:
{
    if (pkg.applicationInfo.targetSdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1) {
      grant=GRANT_INSTALL_LEGACY;
    }
 else     if (origPermissions.hasInstallPermission(bp.name)) {
      grant=GRANT_UPGRADE;
    }
 else     if (mPromoteSystemApps && isSystemApp(ps) && mExistingSystemPackages.contains(ps.name)) {
      grant=GRANT_UPGRADE;
    }
 else {
      grant=GRANT_RUNTIME;
    }
  }
break;
case PermissionInfo.PROTECTION_SIGNATURE:
{
allowedSig=grantSignaturePermission(perm,pkg,bp,origPermissions);
if (allowedSig) {
  grant=GRANT_INSTALL;
}
}
break;
}
if (DEBUG_INSTALL) {
Log.i(TAG,"Package " + pkg.packageName + " granting "+ perm);
}
if (grant != GRANT_DENIED) {
if (!isSystemApp(ps) && ps.installPermissionsFixed) {
if (!allowedSig && !origPermissions.hasInstallPermission(perm)) {
if (!isNewPlatformPermissionForPackage(perm,pkg)) {
grant=GRANT_DENIED;
}
}
}
switch (grant) {
case GRANT_INSTALL:
{
for (int userId : UserManagerService.getInstance().getUserIds()) {
if (origPermissions.getRuntimePermissionState(bp.name,userId) != null) {
  origPermissions.revokeRuntimePermission(bp,userId);
  origPermissions.updatePermissionFlags(bp,userId,PackageManager.MASK_PERMISSION_FLAGS,0);
  changedRuntimePermissionUserIds=ArrayUtils.appendInt(changedRuntimePermissionUserIds,userId);
}
}
if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedInstallPermission=true;
}
}
break;
case GRANT_INSTALL_LEGACY:
{
if (permissionsState.grantInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedInstallPermission=true;
}
}
break;
case GRANT_RUNTIME:
{
for (int userId : UserManagerService.getInstance().getUserIds()) {
PermissionState permissionState=origPermissions.getRuntimePermissionState(bp.name,userId);
final int flags=permissionState != null ? permissionState.getFlags() : 0;
if (origPermissions.hasRuntimePermission(bp.name,userId)) {
if (permissionsState.grantRuntimePermission(bp,userId) == PermissionsState.PERMISSION_OPERATION_FAILURE) {
changedRuntimePermissionUserIds=ArrayUtils.appendInt(changedRuntimePermissionUserIds,userId);
}
}
permissionsState.updatePermissionFlags(bp,userId,flags,flags);
}
}
break;
case GRANT_UPGRADE:
{
PermissionState permissionState=origPermissions.getInstallPermissionState(bp.name);
final int flags=permissionState != null ? permissionState.getFlags() : 0;
if (origPermissions.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
origPermissions.updatePermissionFlags(bp,UserHandle.USER_ALL,PackageManager.MASK_PERMISSION_FLAGS,0);
changedInstallPermission=true;
}
if ((flags & PackageManager.FLAG_PERMISSION_REVOKE_ON_UPGRADE) == 0) {
for (int userId : currentUserIds) {
if (permissionsState.grantRuntimePermission(bp,userId) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
permissionsState.updatePermissionFlags(bp,userId,flags,flags);
changedRuntimePermissionUserIds=ArrayUtils.appendInt(changedRuntimePermissionUserIds,userId);
}
}
}
}
break;
default :
{
if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
Slog.w(TAG,"Not granting permission " + perm + " to package "+ pkg.packageName+ " because it was previously installed without");
}
}
break;
}
}
 else {
if (permissionsState.revokeInstallPermission(bp) != PermissionsState.PERMISSION_OPERATION_FAILURE) {
permissionsState.updatePermissionFlags(bp,UserHandle.USER_ALL,PackageManager.MASK_PERMISSION_FLAGS,0);
changedInstallPermission=true;
Slog.i(TAG,"Un-granting permission " + perm + " from package "+ pkg.packageName+ " (protectionLevel="+ bp.protectionLevel+ " flags=0x"+ Integer.toHexString(pkg.applicationInfo.flags)+ ")");
}
 else if ((bp.protectionLevel & PermissionInfo.PROTECTION_FLAG_APPOP) == 0) {
if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) {
Slog.w(TAG,"Not granting permission " + perm + " to package "+ pkg.packageName+ " (protectionLevel="+ bp.protectionLevel+ " flags=0x"+ Integer.toHexString(pkg.applicationInfo.flags)+ ")");
}
}
}
}
if ((changedInstallPermission || replace) && !ps.installPermissionsFixed && !isSystemApp(ps) || isUpdatedSystemApp(ps)) {
ps.installPermissionsFixed=true;
}
for (int userId : changedRuntimePermissionUserIds) {
mSettings.writeRuntimePermissionsForUserLPr(userId,false);
}
}
