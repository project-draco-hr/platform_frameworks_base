{
  Preconditions.checkNotNull(user);
  if (DEBUG_INSTALL)   Slog.d(TAG,"Parsing: " + scanFile);
  parseFlags|=mDefParseFlags;
  PackageParser pp=new PackageParser();
  pp.setSeparateProcesses(mSeparateProcesses);
  pp.setOnlyCoreApps(mOnlyCore);
  pp.setDisplayMetrics(mMetrics);
  if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
    parseFlags|=PackageParser.PARSE_TRUSTED_OVERLAY;
  }
  final PackageParser.Package pkg;
  try {
    pkg=pp.parsePackage(scanFile,parseFlags);
  }
 catch (  PackageParserException e) {
    throw PackageManagerException.from(e);
  }
  PackageSetting ps=null;
  PackageSetting updatedPkg;
synchronized (mPackages) {
    String oldName=mSettings.mRenamedPackages.get(pkg.packageName);
    if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
      ps=mSettings.peekPackageLPr(oldName);
    }
    if (ps == null) {
      ps=mSettings.peekPackageLPr(pkg.packageName);
    }
    updatedPkg=mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
    if (DEBUG_INSTALL && updatedPkg != null)     Slog.d(TAG,"updatedPkg = " + updatedPkg);
  }
  boolean updatedPkgBetter=false;
  if (updatedPkg != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    if (locationIsPrivileged(scanFile)) {
      updatedPkg.pkgPrivateFlags|=ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }
 else {
      updatedPkg.pkgPrivateFlags&=~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }
    if (ps != null && !ps.codePath.equals(scanFile)) {
      if (DEBUG_INSTALL)       Slog.d(TAG,"Path changing from " + ps.codePath);
      if (pkg.mVersionCode <= ps.versionCode) {
        if (DEBUG_INSTALL)         Slog.i(TAG,"Package " + ps.name + " at "+ scanFile+ " ignored: updated version "+ ps.versionCode+ " better than this "+ pkg.mVersionCode);
        if (!updatedPkg.codePath.equals(scanFile)) {
          Slog.w(PackageManagerService.TAG,"Code path for hidden system pkg : " + ps.name + " changing from "+ updatedPkg.codePathString+ " to "+ scanFile);
          updatedPkg.codePath=scanFile;
          updatedPkg.codePathString=scanFile.toString();
          updatedPkg.resourcePath=scanFile;
          updatedPkg.resourcePathString=scanFile.toString();
        }
        updatedPkg.pkg=pkg;
        throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,"Package " + ps.name + " at "+ scanFile+ " ignored: updated version "+ ps.versionCode+ " better than this "+ pkg.mVersionCode);
      }
 else {
synchronized (mPackages) {
          mPackages.remove(ps.name);
        }
        logCriticalInfo(Log.WARN,"Package " + ps.name + " at "+ scanFile+ " reverting from "+ ps.codePathString+ ": new version "+ pkg.mVersionCode+ " better than installed "+ ps.versionCode);
        InstallArgs args=createInstallArgsForExisting(packageFlagsToInstallFlags(ps),ps.codePathString,ps.resourcePathString,getAppDexInstructionSets(ps));
synchronized (mInstallLock) {
          args.cleanUpResourcesLI();
        }
synchronized (mPackages) {
          mSettings.enableSystemPackageLPw(ps.name);
        }
        updatedPkgBetter=true;
      }
    }
  }
  if (updatedPkg != null) {
    parseFlags|=PackageParser.PARSE_IS_SYSTEM;
    if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
      parseFlags|=PackageParser.PARSE_IS_PRIVILEGED;
    }
  }
  collectCertificatesLI(pp,ps,pkg,scanFile,parseFlags);
  boolean shouldHideSystemApp=false;
  if (updatedPkg == null && ps != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
    if (compareSignatures(ps.signatures.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
      logCriticalInfo(Log.WARN,"Package " + ps.name + " appeared on system, but"+ " signatures don't match existing userdata copy; removing");
      deletePackageLI(pkg.packageName,null,true,null,null,0,null,false);
      ps=null;
    }
 else {
      if (pkg.mVersionCode <= ps.versionCode) {
        shouldHideSystemApp=true;
        logCriticalInfo(Log.INFO,"Package " + ps.name + " appeared at "+ scanFile+ " but new version "+ pkg.mVersionCode+ " better than installed "+ ps.versionCode+ "; hiding system");
      }
 else {
        logCriticalInfo(Log.WARN,"Package " + ps.name + " at "+ scanFile+ " reverting from "+ ps.codePathString+ ": new version "+ pkg.mVersionCode+ " better than installed "+ ps.versionCode);
        InstallArgs args=createInstallArgsForExisting(packageFlagsToInstallFlags(ps),ps.codePathString,ps.resourcePathString,getAppDexInstructionSets(ps));
synchronized (mInstallLock) {
          args.cleanUpResourcesLI();
        }
      }
    }
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
    if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
      parseFlags|=PackageParser.PARSE_FORWARD_LOCK;
    }
  }
  String resourcePath=null;
  String baseResourcePath=null;
  if ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !updatedPkgBetter) {
    if (ps != null && ps.resourcePathString != null) {
      resourcePath=ps.resourcePathString;
      baseResourcePath=ps.resourcePathString;
    }
 else {
      Slog.e(TAG,"Resource path not set for pkg : " + pkg.packageName);
    }
  }
 else {
    resourcePath=pkg.codePath;
    baseResourcePath=pkg.baseCodePath;
  }
  pkg.applicationInfo.volumeUuid=pkg.volumeUuid;
  pkg.applicationInfo.setCodePath(pkg.codePath);
  pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
  pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
  pkg.applicationInfo.setResourcePath(resourcePath);
  pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
  pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
  PackageParser.Package scannedPkg=scanPackageLI(pkg,parseFlags,scanFlags | SCAN_UPDATE_SIGNATURE,currentTime,user);
  if (shouldHideSystemApp) {
synchronized (mPackages) {
      mSettings.disableSystemPackageLPw(pkg.packageName);
    }
  }
  return scannedPkg;
}
