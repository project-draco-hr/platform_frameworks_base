{
  mHandler.post(new Runnable(){
    public void run(){
      mHandler.removeCallbacks(this);
      int returnCode=currentStatus;
      if (currentStatus == PackageManager.MOVE_SUCCEEDED) {
        int uidArr[]=null;
        ArrayList<String> pkgList=null;
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg == null) {
            Slog.w(TAG," Package " + mp.packageName + " doesn't exist. Aborting move");
            returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
          }
 else           if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.getCodePath())) {
            Slog.w(TAG,"Package " + mp.packageName + " code path changed from "+ mp.srcArgs.getCodePath()+ " to "+ pkg.applicationInfo.getCodePath()+ " Aborting move and returning error");
            returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
          }
 else {
            uidArr=new int[]{pkg.applicationInfo.uid};
            pkgList=new ArrayList<String>();
            pkgList.add(mp.packageName);
          }
        }
        if (returnCode == PackageManager.MOVE_SUCCEEDED) {
          sendResourcesChangedBroadcast(false,true,pkgList,uidArr,null);
synchronized (mInstallLock) {
synchronized (mPackages) {
              PackageParser.Package pkg=mPackages.get(mp.packageName);
              if (pkg == null) {
                Slog.w(TAG," Package " + mp.packageName + " doesn't exist. Aborting move");
                returnCode=PackageManager.MOVE_FAILED_DOESNT_EXIST;
              }
 else               if (!mp.srcArgs.getCodePath().equals(pkg.applicationInfo.getCodePath())) {
                Slog.w(TAG,"Package " + mp.packageName + " code path changed from "+ mp.srcArgs.getCodePath()+ " to "+ pkg.applicationInfo.getCodePath()+ " Aborting move and returning error");
                returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
              }
 else {
                final String oldCodePath=pkg.codePath;
                final String newCodePath=mp.targetArgs.getCodePath();
                final String newResPath=mp.targetArgs.getResourcePath();
                final String newNativeRoot=new File(pkg.codePath,LIB_DIR_NAME).getAbsolutePath();
                final File newNativeDir=new File(newNativeRoot);
                if (!isForwardLocked(pkg) && !isExternal(pkg)) {
                  NativeLibraryHelper.Handle handle=null;
                  try {
                    handle=NativeLibraryHelper.Handle.create(new File(newCodePath));
                    final int abi=NativeLibraryHelper.findSupportedAbi(handle,Build.SUPPORTED_ABIS);
                    if (abi >= 0) {
                      NativeLibraryHelper.copyNativeBinariesIfNeededLI(handle,newNativeDir,Build.SUPPORTED_ABIS[abi]);
                    }
                  }
 catch (                  IOException ioe) {
                    Slog.w(TAG,"Unable to extract native libs for package :" + mp.packageName,ioe);
                    returnCode=PackageManager.MOVE_FAILED_INTERNAL_ERROR;
                  }
 finally {
                    IoUtils.closeQuietly(handle);
                  }
                }
                final int[] users=sUserManager.getUserIds();
                if (returnCode == PackageManager.MOVE_SUCCEEDED) {
                  for (                  int user : users) {
                    if (mInstaller.linkNativeLibraryDirectory(pkg.packageName,newNativeRoot,user) < 0) {
                      returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                    }
                  }
                }
                if (returnCode == PackageManager.MOVE_SUCCEEDED) {
                  pkg.codePath=newCodePath;
                  pkg.baseCodePath=newCodePath;
                  if (moveDexFilesLI(oldCodePath,pkg) != PackageManager.INSTALL_SUCCEEDED) {
                    pkg.codePath=oldCodePath;
                    pkg.baseCodePath=oldCodePath;
                    returnCode=PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE;
                  }
                }
                if (returnCode == PackageManager.MOVE_SUCCEEDED) {
                  pkg.applicationInfo.setCodePath(newCodePath);
                  pkg.applicationInfo.setBaseCodePath(newCodePath);
                  pkg.applicationInfo.setSplitCodePaths(null);
                  pkg.applicationInfo.setResourcePath(newResPath);
                  pkg.applicationInfo.setBaseResourcePath(newResPath);
                  pkg.applicationInfo.setSplitResourcePaths(null);
                  pkg.applicationInfo.legacyNativeLibraryDir=null;
                  PackageSetting ps=(PackageSetting)pkg.mExtras;
                  ps.codePath=new File(pkg.applicationInfo.getCodePath());
                  ps.codePathString=ps.codePath.getPath();
                  ps.resourcePath=new File(pkg.applicationInfo.getResourcePath());
                  ps.resourcePathString=ps.resourcePath.getPath();
                  ps.legacyNativeLibraryPathString=null;
                  if ((mp.flags & PackageManager.INSTALL_EXTERNAL) != 0) {
                    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
 else {
                    pkg.applicationInfo.flags&=~ApplicationInfo.FLAG_EXTERNAL_STORAGE;
                  }
                  ps.setFlags(pkg.applicationInfo.flags);
                  mAppDirs.remove(oldCodePath);
                  mAppDirs.put(newCodePath,pkg);
                  mSettings.writeLPr();
                }
              }
            }
          }
          sendResourcesChangedBroadcast(true,false,pkgList,uidArr,null);
        }
      }
      if (returnCode != PackageManager.MOVE_SUCCEEDED) {
        if (mp.targetArgs != null) {
          mp.targetArgs.doPostInstall(PackageManager.INSTALL_FAILED_INTERNAL_ERROR,-1);
        }
      }
 else {
        Runtime.getRuntime().gc();
synchronized (mInstallLock) {
          mp.srcArgs.doPostDeleteLI(true);
        }
      }
      if (returnCode != PackageManager.MOVE_FAILED_OPERATION_PENDING) {
synchronized (mPackages) {
          PackageParser.Package pkg=mPackages.get(mp.packageName);
          if (pkg != null) {
            pkg.mOperationPending=false;
          }
        }
      }
      IPackageMoveObserver observer=mp.observer;
      if (observer != null) {
        try {
          observer.packageMoved(mp.packageName,returnCode);
        }
 catch (        RemoteException e) {
          Log.i(TAG,"Observer no longer exists.");
        }
      }
    }
  }
);
}
