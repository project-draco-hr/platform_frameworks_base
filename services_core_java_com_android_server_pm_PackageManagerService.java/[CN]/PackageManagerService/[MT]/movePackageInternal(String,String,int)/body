{
  final UserHandle user=new UserHandle(UserHandle.getCallingUserId());
  final PackageManager pm=mContext.getPackageManager();
  final boolean currentAsec;
  final String currentVolumeUuid;
  final File codeFile;
  final String installerPackageName;
  final String packageAbiOverride;
  final int appId;
  final String seinfo;
  final String label;
synchronized (mPackages) {
    final PackageParser.Package pkg=mPackages.get(packageName);
    final PackageSetting ps=mSettings.mPackages.get(packageName);
    if (pkg == null || ps == null) {
      throw new PackageManagerException(MOVE_FAILED_DOESNT_EXIST,"Missing package");
    }
    if (pkg.applicationInfo.isSystemApp()) {
      throw new PackageManagerException(MOVE_FAILED_SYSTEM_PACKAGE,"Cannot move system application");
    }
 else     if (pkg.mOperationPending) {
      throw new PackageManagerException(MOVE_FAILED_OPERATION_PENDING,"Attempt to move package which has pending operations");
    }
    pkg.mOperationPending=true;
    currentAsec=pkg.applicationInfo.isForwardLocked() || pkg.applicationInfo.isExternalAsec();
    currentVolumeUuid=ps.volumeUuid;
    codeFile=new File(pkg.codePath);
    installerPackageName=ps.installerPackageName;
    packageAbiOverride=ps.cpuAbiOverrideString;
    appId=UserHandle.getAppId(pkg.applicationInfo.uid);
    seinfo=pkg.applicationInfo.seinfo;
    label=String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
  }
  final Bundle extras=new Bundle();
  extras.putString(Intent.EXTRA_PACKAGE_NAME,packageName);
  extras.putString(Intent.EXTRA_TITLE,label);
  mMoveCallbacks.notifyCreated(moveId,extras);
  int installFlags;
  final boolean moveData;
  if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,volumeUuid)) {
    installFlags=INSTALL_INTERNAL;
    moveData=!currentAsec;
  }
 else   if (Objects.equals(StorageManager.UUID_PRIMARY_PHYSICAL,volumeUuid)) {
    installFlags=INSTALL_EXTERNAL;
    moveData=false;
  }
 else {
    final StorageManager storage=mContext.getSystemService(StorageManager.class);
    final VolumeInfo volume=storage.findVolumeByUuid(volumeUuid);
    if (volume == null || volume.getType() != VolumeInfo.TYPE_PRIVATE || !volume.isMountedWritable()) {
      throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,"Move location not mounted private volume");
    }
    Preconditions.checkState(!currentAsec);
    installFlags=INSTALL_INTERNAL;
    moveData=true;
  }
  Slog.d(TAG,"Moving " + packageName + " from "+ currentVolumeUuid+ " to "+ volumeUuid);
  mMoveCallbacks.notifyStatusChanged(moveId,10);
  if (moveData) {
synchronized (mInstallLock) {
      if (mInstaller.moveUserDataDirs(currentVolumeUuid,volumeUuid,packageName,appId,seinfo) != 0) {
synchronized (mPackages) {
          final PackageParser.Package pkg=mPackages.get(packageName);
          if (pkg != null) {
            pkg.mOperationPending=false;
          }
        }
        throw new PackageManagerException(MOVE_FAILED_INTERNAL_ERROR,"Failed to move private data");
      }
    }
  }
  mMoveCallbacks.notifyStatusChanged(moveId,50);
  final IPackageInstallObserver2 installObserver=new IPackageInstallObserver2.Stub(){
    @Override public void onUserActionRequired(    Intent intent) throws RemoteException {
      throw new IllegalStateException();
    }
    @Override public void onPackageInstalled(    String basePackageName,    int returnCode,    String msg,    Bundle extras) throws RemoteException {
      Slog.d(TAG,"Install result for move: " + PackageManager.installStatusToString(returnCode,msg));
synchronized (mPackages) {
        final PackageParser.Package pkg=mPackages.get(packageName);
        if (pkg != null) {
          pkg.mOperationPending=false;
        }
      }
      final int status=PackageManager.installStatusToPublicStatus(returnCode);
switch (status) {
case PackageInstaller.STATUS_SUCCESS:
        mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_SUCCEEDED);
      break;
case PackageInstaller.STATUS_FAILURE_STORAGE:
    mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INSUFFICIENT_STORAGE);
  break;
default :
mMoveCallbacks.notifyStatusChanged(moveId,PackageManager.MOVE_FAILED_INTERNAL_ERROR);
break;
}
}
}
;
installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
final Message msg=mHandler.obtainMessage(INIT_COPY);
final OriginInfo origin=OriginInfo.fromExistingFile(codeFile);
msg.obj=new InstallParams(origin,installObserver,installFlags,installerPackageName,volumeUuid,null,user,packageAbiOverride);
mHandler.sendMessage(msg);
}
