{
  int pFlags=args.flags;
  String installerPackageName=args.installerPackageName;
  File tmpPackageFile=new File(args.getCodePath());
  boolean forwardLocked=((pFlags & PackageManager.INSTALL_FORWARD_LOCK) != 0);
  boolean onSd=((pFlags & PackageManager.INSTALL_EXTERNAL) != 0);
  boolean replace=false;
  int scanMode=(onSd ? 0 : SCAN_MONITOR) | SCAN_FORCE_DEX | SCAN_UPDATE_SIGNATURE| (newInstall ? SCAN_NEW_INSTALL : 0);
  res.returnCode=PackageManager.INSTALL_SUCCEEDED;
  if (DEBUG_INSTALL)   Slog.d(TAG,"installPackageLI: path=" + tmpPackageFile);
  int parseFlags=mDefParseFlags | PackageParser.PARSE_CHATTY | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0)| (onSd ? PackageParser.PARSE_ON_SDCARD : 0);
  PackageParser pp=new PackageParser(tmpPackageFile.getPath());
  pp.setSeparateProcesses(mSeparateProcesses);
  final PackageParser.Package pkg=pp.parsePackage(tmpPackageFile,null,mMetrics,parseFlags);
  if (pkg == null) {
    res.returnCode=pp.getParseError();
    return;
  }
  String pkgName=res.name=pkg.packageName;
  if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_TEST_ONLY) != 0) {
    if ((pFlags & PackageManager.INSTALL_ALLOW_TEST) == 0) {
      res.returnCode=PackageManager.INSTALL_FAILED_TEST_ONLY;
      return;
    }
  }
  if (!pp.collectCertificates(pkg,parseFlags)) {
    res.returnCode=pp.getParseError();
    return;
  }
  if (args.manifestDigest != null) {
    if (DEBUG_INSTALL) {
      final String parsedManifest=pkg.manifestDigest == null ? "null" : pkg.manifestDigest.toString();
      Slog.d(TAG,"Comparing manifests: " + args.manifestDigest.toString() + " vs. "+ parsedManifest);
    }
    if (!args.manifestDigest.equals(pkg.manifestDigest)) {
      res.returnCode=PackageManager.INSTALL_FAILED_PACKAGE_CHANGED;
      return;
    }
  }
 else   if (DEBUG_INSTALL) {
    final String parsedManifest=pkg.manifestDigest == null ? "null" : pkg.manifestDigest.toString();
    Slog.d(TAG,"manifestDigest was not present, but parser got: " + parsedManifest);
  }
  pp=null;
  String oldCodePath=null;
  boolean systemApp=false;
synchronized (mPackages) {
    int N=pkg.permissions.size();
    for (int i=0; i < N; i++) {
      PackageParser.Permission perm=pkg.permissions.get(i);
      BasePermission bp=mSettings.mPermissions.get(perm.info.name);
      if (bp != null) {
        if (compareSignatures(bp.packageSetting.signatures.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
          Slog.w(TAG,"Package " + pkg.packageName + " attempting to redeclare permission "+ perm.info.name+ " already owned by "+ bp.sourcePackage);
          res.returnCode=PackageManager.INSTALL_FAILED_DUPLICATE_PERMISSION;
          res.origPermission=perm.info.name;
          res.origPackage=bp.sourcePackage;
          return;
        }
      }
    }
    if ((pFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
      String oldName=mSettings.mRenamedPackages.get(pkgName);
      if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName) && mPackages.containsKey(oldName)) {
        pkg.setPackageName(oldName);
        pkgName=pkg.packageName;
        replace=true;
        if (DEBUG_INSTALL)         Slog.d(TAG,"Replacing existing renamed package: oldName=" + oldName + " pkgName="+ pkgName);
      }
 else       if (mPackages.containsKey(pkgName)) {
        replace=true;
        if (DEBUG_INSTALL)         Slog.d(TAG,"Replace existing pacakge: " + pkgName);
      }
    }
    PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (ps != null) {
      if (DEBUG_INSTALL)       Slog.d(TAG,"Existing package: " + ps);
      oldCodePath=mSettings.mPackages.get(pkgName).codePathString;
      if (ps.pkg != null && ps.pkg.applicationInfo != null) {
        systemApp=(ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
      }
      res.origUsers=ps.queryInstalledUsers(sUserManager.getUserIds(),true);
    }
  }
  if (systemApp && onSd) {
    Slog.w(TAG,"Cannot install updates to system apps on sdcard");
    res.returnCode=PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
    return;
  }
  if (!args.doRename(res.returnCode,pkgName,oldCodePath)) {
    res.returnCode=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
    return;
  }
  setApplicationInfoPaths(pkg,args.getCodePath(),args.getResourcePath());
  pkg.applicationInfo.nativeLibraryDir=args.getNativeLibraryPath();
  if (replace) {
    replacePackageLI(pkg,parseFlags,scanMode,args.user,installerPackageName,res);
  }
 else {
    installNewPackageLI(pkg,parseFlags,scanMode | SCAN_DELETE_DATA_ON_FAILURES,args.user,installerPackageName,res);
  }
synchronized (mPackages) {
    final PackageSetting ps=mSettings.mPackages.get(pkgName);
    if (ps != null) {
      res.newUsers=ps.queryInstalledUsers(sUserManager.getUserIds(),true);
    }
  }
}
