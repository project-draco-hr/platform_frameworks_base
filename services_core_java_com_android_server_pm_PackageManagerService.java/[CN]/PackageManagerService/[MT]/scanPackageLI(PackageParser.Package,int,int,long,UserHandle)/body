{
  final File scanFile=new File(pkg.codePath);
  if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
    throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,"Code and resource paths haven't been set correctly");
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if ((parseFlags & PackageParser.PARSE_IS_PRIVILEGED) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_PRIVILEGED;
  }
  if (mCustomResolverComponentName != null && mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {
    setUpCustomResolverActivity(pkg);
  }
  if (pkg.packageName.equals("android")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Slog.w(TAG,"*************************************************");
        Slog.w(TAG,"Core android package being redefined.  Skipping.");
        Slog.w(TAG," file=" + scanFile);
        Slog.w(TAG,"*************************************************");
        throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,"Core android package being redefined.  Skipping.");
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      if (!mResolverReplaced) {
        mResolveActivity.applicationInfo=mAndroidApplication;
        mResolveActivity.name=ResolverActivity.class.getName();
        mResolveActivity.packageName=mAndroidApplication.packageName;
        mResolveActivity.processName="system:ui";
        mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
        mResolveActivity.documentLaunchMode=ActivityInfo.DOCUMENT_LAUNCH_NEVER;
        mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
        mResolveActivity.theme=R.style.Theme_Holo_Dialog_Alert;
        mResolveActivity.exported=true;
        mResolveActivity.enabled=true;
        mResolveInfo.activityInfo=mResolveActivity;
        mResolveInfo.priority=0;
        mResolveInfo.preferredOrder=0;
        mResolveInfo.match=0;
        mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
      }
    }
  }
  if (DEBUG_PACKAGE_SCANNING) {
    if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)     Log.d(TAG,"Scanning package " + pkg.packageName);
  }
  if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
    throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,"Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
  }
  File destCodeFile=new File(pkg.applicationInfo.getCodePath());
  File destResourceFile=new File(pkg.applicationInfo.getResourcePath());
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  if (!isSystemApp(pkg)) {
    pkg.mOriginalPackages=null;
    pkg.mRealPackage=null;
    pkg.mAdoptPermissions=null;
  }
synchronized (mPackages) {
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLPw(pkg.mSharedUserId,0,true);
      if (suid == null) {
        throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,"Creating application package " + pkg.packageName + " for shared user failed");
      }
      if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)         Log.d(TAG,"Shared UserID " + pkg.mSharedUserId + " (uid="+ suid.userId+ "): packages="+ suid.packages);
      }
    }
    PackageSetting origPackage=null;
    String realName=null;
    if (pkg.mOriginalPackages != null) {
      final String renamed=mSettings.mRenamedPackages.get(pkg.mRealPackage);
      if (pkg.mOriginalPackages.contains(renamed)) {
        realName=pkg.mRealPackage;
        if (!pkg.packageName.equals(renamed)) {
          pkg.setPackageName(renamed);
        }
      }
 else {
        for (int i=pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
          if ((origPackage=mSettings.peekPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
            if (!verifyPackageUpdateLPr(origPackage,pkg)) {
              origPackage=null;
              continue;
            }
 else             if (origPackage.sharedUser != null) {
              if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                Slog.w(TAG,"Unable to migrate data from " + origPackage.name + " to "+ pkg.packageName+ ": old uid "+ origPackage.sharedUser.name+ " differs from "+ pkg.mSharedUserId);
                origPackage=null;
                continue;
              }
            }
 else {
              if (DEBUG_UPGRADE)               Log.v(TAG,"Renaming new package " + pkg.packageName + " to old name "+ origPackage.name);
            }
            break;
          }
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Slog.w(TAG,"Package " + pkg.packageName + " was transferred to another, but its .apk remains");
    }
    pkgSetting=mSettings.getPackageLPw(pkg,origPackage,realName,suid,destCodeFile,destResourceFile,pkg.applicationInfo.nativeLibraryRootDir,pkg.applicationInfo.primaryCpuAbi,pkg.applicationInfo.secondaryCpuAbi,pkg.applicationInfo.flags,user,false);
    if (pkgSetting == null) {
      throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,"Creating application package " + pkg.packageName + " failed");
    }
    if (pkgSetting.origPackage != null) {
      pkg.setPackageName(origPackage.name);
      String msg="New package " + pkgSetting.realName + " renamed to replace old package "+ pkgSetting.name;
      reportSettingsProblem(Log.WARN,msg);
      mTransferedPackages.add(origPackage.name);
      pkgSetting.origPackage=null;
    }
    if (realName != null) {
      mTransferedPackages.add(pkg.packageName);
    }
    if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
      updateSharedLibrariesLPw(pkg,null);
    }
    if (mFoundPolicyFile) {
      SELinuxMMAC.assignSeinfoValue(pkg);
    }
    pkg.applicationInfo.uid=pkgSetting.appId;
    pkg.mExtras=pkgSetting;
    if (!pkgSetting.keySetData.isUsingUpgradeKeySets() || pkgSetting.sharedUser != null) {
      try {
        verifySignaturesLP(pkgSetting,pkg);
      }
 catch (      PackageManagerException e) {
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
          throw e;
        }
        pkgSetting.signatures.mSignatures=pkg.mSignatures;
        if (pkgSetting.sharedUser != null) {
          if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures,pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,"Signature mismatch for shared user : " + pkgSetting.sharedUser);
          }
        }
        String msg="System package " + pkg.packageName + " signature changed; retaining data.";
        reportSettingsProblem(Log.WARN,msg);
      }
    }
 else {
      if (!checkUpgradeKeySetLP(pkgSetting,pkg)) {
        throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE,"Package " + pkg.packageName + " upgrade keys do not match the "+ "previously installed version");
      }
 else {
        pkgSetting.signatures.mSignatures=pkg.mSignatures;
      }
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      final int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        if (p.info.authority != null) {
          String names[]=p.info.authority.split(";");
          for (int j=0; j < names.length; j++) {
            if (mProvidersByAuthority.containsKey(names[j])) {
              PackageParser.Provider other=mProvidersByAuthority.get(names[j]);
              final String otherPackageName=((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?");
              throw new PackageManagerException(INSTALL_FAILED_CONFLICTING_PROVIDER,"Can't install because provider name " + names[j] + " (in package "+ pkg.applicationInfo.packageName+ ") is already used by "+ otherPackageName);
            }
          }
        }
      }
    }
    if (pkg.mAdoptPermissions != null) {
      for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
        final String origName=pkg.mAdoptPermissions.get(i);
        final PackageSetting orig=mSettings.peekPackageLPr(origName);
        if (orig != null) {
          if (verifyPackageUpdateLPr(orig,pkg)) {
            Slog.i(TAG,"Adopting permissions from " + origName + " to "+ pkg.packageName);
            mSettings.transferPermissionsLPw(origName,pkg.packageName);
          }
        }
      }
    }
  }
  final String pkgName=pkg.packageName;
  final long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),"system");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    dataPath=getDataPathForPackage(pkg.packageName,0);
    boolean uidError=false;
    if (dataPath.exists()) {
      int currentUid=0;
      try {
        StructStat stat=Os.stat(dataPath.getPath());
        currentUid=stat.st_uid;
      }
 catch (      ErrnoException e) {
        Slog.e(TAG,"Couldn't stat path " + dataPath.getPath(),e);
      }
      if (currentUid != pkg.applicationInfo.uid) {
        boolean recovered=false;
        if (currentUid == 0) {
          int ret=mInstaller.fixUid(pkgName,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
          if (ret >= 0) {
            recovered=true;
            String msg="Package " + pkg.packageName + " unexpectedly changed to uid 0; recovered to "+ +pkg.applicationInfo.uid;
            reportSettingsProblem(Log.WARN,msg);
          }
        }
        if (!recovered && ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 || (scanMode & SCAN_BOOTING) != 0)) {
          int ret=removeDataDirsLI(pkgName);
          if (ret >= 0) {
            String prefix=(parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 ? "System package " : "Third party package ";
            String msg=prefix + pkg.packageName + " has changed from uid: "+ currentUid+ " to "+ pkg.applicationInfo.uid+ "; old data erased";
            reportSettingsProblem(Log.WARN,msg);
            recovered=true;
            ret=createDataDirsLI(pkgName,pkg.applicationInfo.uid,pkg.applicationInfo.seinfo);
            if (ret == -1) {
              msg=prefix + pkg.packageName + " could not have data directory re-created after delete.";
              reportSettingsProblem(Log.WARN,msg);
              throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,msg);
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
 else         if (!recovered) {
          throw new PackageManagerException(INSTALL_FAILED_UID_CHANGED,"scanPackageLI");
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir="/mismatched_uid/settings_" + pkg.applicationInfo.uid + "/fs_"+ currentUid;
          pkg.applicationInfo.nativeLibraryDir=pkg.applicationInfo.dataDir;
          pkg.applicationInfo.nativeLibraryRootDir=pkg.applicationInfo.dataDir;
          String msg="Package " + pkg.packageName + " has mismatched uid: "+ currentUid+ " on disk, "+ pkg.applicationInfo.uid+ " in settings";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
      if (mShouldRestoreconData) {
        Slog.i(TAG,"SELinux relabeling of " + pkg.packageName + " issued.");
        mInstaller.restoreconData(pkg.packageName,pkg.applicationInfo.seinfo,pkg.applicationInfo.uid);
      }
    }
 else {
      if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)         Log.v(TAG,"Want this data dir: " + dataPath);
      }
      int ret=createDataDirsLI(pkgName,pkg.applicationInfo.uid,pkg.applicationInfo.seinfo);
      if (ret < 0) {
        throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,"Unable to create data dirs [errorCode=" + ret + "]");
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Slog.w(TAG,"Unable to create data directory: " + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  final String path=scanFile.getPath();
  final String codePath=pkg.applicationInfo.getCodePath();
  final String cpuAbiOverride=deriveAbiOverride(pkg.cpuAbiOverride,pkgSetting);
  if (isSystemApp(pkg) && !isUpdatedSystemApp(pkg)) {
    setBundledAppAbisAndRoots(pkg,pkgSetting);
    if (pkg.applicationInfo.primaryCpuAbi == null && pkg.applicationInfo.secondaryCpuAbi == null && Build.SUPPORTED_64_BIT_ABIS.length > 0) {
      NativeLibraryHelper.Handle handle=null;
      try {
        handle=NativeLibraryHelper.Handle.create(scanFile);
        if (NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
          pkg.applicationInfo.primaryCpuAbi=Build.SUPPORTED_32_BIT_ABIS[0];
        }
      }
 catch (      IOException ioe) {
        Slog.w(TAG,"Error scanning system app : " + ioe);
      }
 finally {
        IoUtils.closeQuietly(handle);
      }
    }
    setNativeLibraryPaths(pkg);
  }
 else {
    setNativeLibraryPaths(pkg);
    final boolean isAsec=isForwardLocked(pkg) || isExternal(pkg);
    final String nativeLibraryRootStr=pkg.applicationInfo.nativeLibraryRootDir;
    final boolean useIsaSpecificSubdirs=pkg.applicationInfo.nativeLibraryRootRequiresIsa;
    NativeLibraryHelper.Handle handle=null;
    try {
      handle=NativeLibraryHelper.Handle.create(scanFile);
      final File nativeLibraryRoot=new File(nativeLibraryRootStr);
      pkg.applicationInfo.primaryCpuAbi=null;
      pkg.applicationInfo.secondaryCpuAbi=null;
      if (isMultiArch(pkg.applicationInfo)) {
        if (pkg.cpuAbiOverride != null && !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) {
          Slog.w(TAG,"Ignoring abiOverride for multi arch application.");
        }
        int abi32=PackageManager.NO_NATIVE_LIBRARIES;
        int abi64=PackageManager.NO_NATIVE_LIBRARIES;
        if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
          if (isAsec) {
            abi32=NativeLibraryHelper.findSupportedAbi(handle,Build.SUPPORTED_32_BIT_ABIS);
          }
 else {
            abi32=NativeLibraryHelper.copyNativeBinariesIfNeededLI(handle,nativeLibraryRoot,Build.SUPPORTED_32_BIT_ABIS,useIsaSpecificSubdirs);
          }
        }
        maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.",abi32);
        if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
          if (isAsec) {
            abi64=NativeLibraryHelper.findSupportedAbi(handle,Build.SUPPORTED_64_BIT_ABIS);
          }
 else {
            abi64=NativeLibraryHelper.copyNativeBinariesIfNeededLI(handle,nativeLibraryRoot,Build.SUPPORTED_64_BIT_ABIS,useIsaSpecificSubdirs);
          }
        }
        maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.",abi64);
        if (abi64 >= 0) {
          pkg.applicationInfo.primaryCpuAbi=Build.SUPPORTED_64_BIT_ABIS[abi64];
        }
        if (abi32 >= 0) {
          final String abi=Build.SUPPORTED_32_BIT_ABIS[abi32];
          if (abi64 >= 0) {
            pkg.applicationInfo.secondaryCpuAbi=abi;
          }
 else {
            pkg.applicationInfo.primaryCpuAbi=abi;
          }
        }
      }
 else {
        String[] abiList=(cpuAbiOverride != null) ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
        boolean needsRenderScriptOverride=false;
        if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
          abiList=Build.SUPPORTED_32_BIT_ABIS;
          needsRenderScriptOverride=true;
        }
        final int copyRet;
        if (isAsec) {
          copyRet=NativeLibraryHelper.findSupportedAbi(handle,abiList);
        }
 else {
          copyRet=NativeLibraryHelper.copyNativeBinariesIfNeededLI(handle,nativeLibraryRoot,abiList,useIsaSpecificSubdirs);
        }
        if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
          throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR,"Error unpackaging native libs for app, errorCode=" + copyRet);
        }
        if (copyRet >= 0) {
          pkg.applicationInfo.primaryCpuAbi=abiList[copyRet];
        }
 else         if (copyRet == PackageManager.NO_NATIVE_LIBRARIES && cpuAbiOverride != null) {
          pkg.applicationInfo.primaryCpuAbi=cpuAbiOverride;
        }
 else         if (needsRenderScriptOverride) {
          pkg.applicationInfo.primaryCpuAbi=abiList[0];
        }
      }
    }
 catch (    IOException ioe) {
      Slog.e(TAG,"Unable to get canonical file " + ioe.toString());
    }
 finally {
      IoUtils.closeQuietly(handle);
    }
    setNativeLibraryPaths(pkg);
    if (DEBUG_INSTALL)     Slog.i(TAG,"Linking native library dir for " + path);
    final int[] userIds=sUserManager.getUserIds();
synchronized (mInstallLock) {
      if (pkg.applicationInfo.primaryCpuAbi != null && !VMRuntime.is64BitAbi(pkg.applicationInfo.primaryCpuAbi)) {
        final String nativeLibPath=pkg.applicationInfo.nativeLibraryDir;
        for (        int userId : userIds) {
          if (mInstaller.linkNativeLibraryDirectory(pkg.packageName,nativeLibPath,userId) < 0) {
            throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR,"Failed linking native library dir (user=" + userId + ")");
          }
        }
      }
    }
  }
  if (mPlatformPackage == pkg) {
    pkg.applicationInfo.primaryCpuAbi=VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
  }
  pkgSetting.primaryCpuAbiString=pkg.applicationInfo.primaryCpuAbi;
  pkgSetting.secondaryCpuAbiString=pkg.applicationInfo.secondaryCpuAbi;
  pkgSetting.cpuAbiOverrideString=cpuAbiOverride;
  pkg.cpuAbiOverride=cpuAbiOverride;
  Slog.d(TAG,"Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root="+ pkg.applicationInfo.nativeLibraryRootDir+ ", isa="+ pkg.applicationInfo.nativeLibraryRootRequiresIsa);
  pkgSetting.legacyNativeLibraryPathString=pkg.applicationInfo.nativeLibraryRootDir;
  if (DEBUG_ABI_SELECTION) {
    Log.d(TAG,"Abis for package[" + pkg.packageName + "] are"+ " primary="+ pkg.applicationInfo.primaryCpuAbi+ " secondary="+ pkg.applicationInfo.secondaryCpuAbi);
  }
  if ((scanMode & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
    adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages,pkg,forceDex,(scanMode & SCAN_DEFER_DEX) != 0);
  }
  if ((scanMode & SCAN_NO_DEX) == 0) {
    if (performDexOptLI(pkg,null,forceDex,(scanMode & SCAN_DEFER_DEX) != 0,false) == DEX_OPT_FAILED) {
      if ((scanMode & SCAN_DELETE_DATA_ON_FAILURES) != 0) {
        removeDataDirsLI(pkg.packageName);
      }
      throw new PackageManagerException(INSTALL_FAILED_DEXOPT,"scanPackageLI");
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  ArrayList<PackageParser.Package> clientLibPkgs=null;
synchronized (mPackages) {
    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
      if (pkg.libraryNames != null) {
        for (int i=0; i < pkg.libraryNames.size(); i++) {
          String name=pkg.libraryNames.get(i);
          boolean allowed=false;
          if (isUpdatedSystemApp(pkg)) {
            final PackageSetting sysPs=mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
              for (int j=0; j < sysPs.pkg.libraryNames.size(); j++) {
                if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                  allowed=true;
                  allowed=true;
                  break;
                }
              }
            }
          }
 else {
            allowed=true;
          }
          if (allowed) {
            if (!mSharedLibraries.containsKey(name)) {
              mSharedLibraries.put(name,new SharedLibraryEntry(null,pkg.packageName));
            }
 else             if (!name.equals(pkg.packageName)) {
              Slog.w(TAG,"Package " + pkg.packageName + " library "+ name+ " already exists; skipping");
            }
          }
 else {
            Slog.w(TAG,"Package " + pkg.packageName + " declares lib "+ name+ " that is not declared on system image; skipping");
          }
        }
        if ((scanMode & SCAN_BOOTING) == 0) {
          clientLibPkgs=updateAllSharedLibrariesLPw(pkg);
        }
      }
    }
  }
  if (clientLibPkgs != null) {
    if ((scanMode & SCAN_NO_DEX) == 0) {
      for (int i=0; i < clientLibPkgs.size(); i++) {
        PackageParser.Package clientPkg=clientLibPkgs.get(i);
        if (performDexOptLI(clientPkg,null,forceDex,(scanMode & SCAN_DEFER_DEX) != 0,false) == DEX_OPT_FAILED) {
          if ((scanMode & SCAN_DELETE_DATA_ON_FAILURES) != 0) {
            removeDataDirsLI(pkg.packageName);
          }
          throw new PackageManagerException(INSTALL_FAILED_DEXOPT,"scanPackageLI failed to dexopt clientLibPkgs");
        }
      }
    }
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    if (isForwardLocked(pkg) || isExternal(pkg)) {
      if (DEBUG_INSTALL) {
        Slog.i(TAG,"upgrading pkg " + pkg + " is ASEC-hosted -> UNAVAILABLE");
      }
      final int[] uidArray=new int[]{pkg.applicationInfo.uid};
      final ArrayList<String> pkgList=new ArrayList<String>(1);
      pkgList.add(pkg.applicationInfo.packageName);
      sendResourcesChangedBroadcast(false,true,pkgList,uidArray,null);
    }
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid,"update pkg");
  }
  if (clientLibPkgs != null) {
    for (int i=0; i < clientLibPkgs.size(); i++) {
      PackageParser.Package clientPkg=clientLibPkgs.get(i);
      killApplication(clientPkg.applicationInfo.packageName,clientPkg.applicationInfo.uid,"update lib");
    }
  }
synchronized (mPackages) {
    if ((scanMode & SCAN_MONITOR) != 0) {
      mAppDirs.put(pkg.codePath,pkg);
    }
    mSettings.insertPackageSettingLPw(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    final Iterator<PackageCleanItem> iter=mSettings.mPackagesToBeCleaned.iterator();
    while (iter.hasNext()) {
      PackageCleanItem item=iter.next();
      if (pkgName.equals(item.packageName)) {
        iter.remove();
      }
    }
    if (currentTime != 0) {
      if (pkgSetting.firstInstallTime == 0) {
        pkgSetting.firstInstallTime=pkgSetting.lastUpdateTime=currentTime;
      }
 else       if ((scanMode & SCAN_UPDATE_TIME) != 0) {
        pkgSetting.lastUpdateTime=currentTime;
      }
    }
 else     if (pkgSetting.firstInstallTime == 0) {
      pkgSetting.firstInstallTime=pkgSetting.lastUpdateTime=scanFileTime;
    }
 else     if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
      if (scanFileTime != pkgSetting.timeStamp) {
        pkgSetting.lastUpdateTime=scanFileTime;
      }
    }
    KeySetManagerService ksms=mSettings.mKeySetManagerService;
    try {
      ksms.removeAppKeySetDataLPw(pkg.packageName);
      ksms.addSigningKeySetToPackageLPw(pkg.packageName,pkg.mSigningKeys);
      if (pkg.mKeySetMapping != null) {
        for (        Map.Entry<String,ArraySet<PublicKey>> entry : pkg.mKeySetMapping.entrySet()) {
          if (entry.getValue() != null) {
            ksms.addDefinedKeySetToPackageLPw(pkg.packageName,entry.getValue(),entry.getKey());
          }
        }
        if (pkg.mUpgradeKeySets != null) {
          for (          String upgradeAlias : pkg.mUpgradeKeySets) {
            ksms.addUpgradeKeySetToPackageLPw(pkg.packageName,upgradeAlias);
          }
        }
      }
    }
 catch (    NullPointerException e) {
      Slog.e(TAG,"Could not add KeySet to " + pkg.packageName,e);
    }
catch (    IllegalArgumentException e) {
      Slog.e(TAG,"Could not add KeySet to malformed package" + pkg.packageName,e);
    }
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProviders.addProvider(p);
      p.syncable=p.info.isSyncable;
      if (p.info.authority != null) {
        String names[]=p.info.authority.split(";");
        p.info.authority=null;
        for (int j=0; j < names.length; j++) {
          if (j == 1 && p.syncable) {
            p=new PackageParser.Provider(p);
            p.syncable=false;
          }
          if (!mProvidersByAuthority.containsKey(names[j])) {
            mProvidersByAuthority.put(names[j],p);
            if (p.info.authority == null) {
              p.info.authority=names[j];
            }
 else {
              p.info.authority=p.info.authority + ";" + names[j];
            }
            if (DEBUG_PACKAGE_SCANNING) {
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)               Log.d(TAG,"Registered content provider: " + names[j] + ", className = "+ p.info.name+ ", isSyncable = "+ p.info.isSyncable);
            }
          }
 else {
            PackageParser.Provider other=mProvidersByAuthority.get(names[j]);
            Slog.w(TAG,"Skipping provider name " + names[j] + " (in package "+ pkg.applicationInfo.packageName+ "): name already used by "+ ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
          }
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Providers: " + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Services: " + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,"receiver");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Receivers: " + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,"activity");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Activities: " + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Slog.w(TAG,"Permission group " + pg.info.name + " from package "+ pg.info.packageName+ " ignored: original from "+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append("DUP:");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Permission Groups: " + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage != null && !bp.sourcePackage.equals(p.info.packageName)) {
            if (isSystemApp(p.owner)) {
              String msg="New decl " + p.owner + " of permission  "+ p.info.name+ " is system";
              reportSettingsProblem(Log.WARN,msg);
              bp.sourcePackage=null;
            }
          }
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.packageSetting=pkgSetting;
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Slog.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: base tree "+ tree.name+ " is from package "+ tree.sourcePackage);
            }
          }
 else {
            Slog.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: original from "+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append("DUP:");
          r.append(p.info.name);
        }
        if (bp.perm == p) {
          bp.protectionLevel=p.info.protectionLevel;
        }
      }
 else {
        Slog.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: no group "+ p.group);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Permissions: " + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.splitSourceDirs=pkg.applicationInfo.splitSourceDirs;
      a.info.splitPublicSourceDirs=pkg.applicationInfo.splitPublicSourceDirs;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      a.info.nativeLibraryDir=pkg.applicationInfo.nativeLibraryDir;
      mInstrumentation.put(a.getComponentName(),a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (DEBUG_PACKAGE_SCANNING)       Log.d(TAG,"  Instrumentation: " + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
    if (pkg.mOverlayTarget != null) {
      if (pkg.mOverlayTarget != null && !pkg.mOverlayTarget.equals("android")) {
        if (!mOverlays.containsKey(pkg.mOverlayTarget)) {
          mOverlays.put(pkg.mOverlayTarget,new HashMap<String,PackageParser.Package>());
        }
        HashMap<String,PackageParser.Package> map=mOverlays.get(pkg.mOverlayTarget);
        map.put(pkg.packageName,pkg);
        PackageParser.Package orig=mPackages.get(pkg.mOverlayTarget);
        if (orig != null && !createIdmapForPackagePairLI(orig,pkg)) {
          throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE,"scanPackageLI failed to createIdmap");
        }
      }
    }
 else     if (mOverlays.containsKey(pkg.packageName) && !pkg.packageName.equals("android")) {
      createIdmapsForPackageLI(pkg);
    }
  }
  return pkg;
}
