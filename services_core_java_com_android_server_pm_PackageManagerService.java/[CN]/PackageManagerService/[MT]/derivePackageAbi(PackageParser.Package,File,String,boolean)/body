{
  setNativeLibraryPaths(pkg);
  if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() || (isSystemApp(pkg) && !pkg.isUpdatedSystemApp())) {
    extractLibs=false;
  }
  final String nativeLibraryRootStr=pkg.applicationInfo.nativeLibraryRootDir;
  final boolean useIsaSpecificSubdirs=pkg.applicationInfo.nativeLibraryRootRequiresIsa;
  NativeLibraryHelper.Handle handle=null;
  try {
    handle=NativeLibraryHelper.Handle.create(pkg);
    final File nativeLibraryRoot=new File(nativeLibraryRootStr);
    pkg.applicationInfo.primaryCpuAbi=null;
    pkg.applicationInfo.secondaryCpuAbi=null;
    if (isMultiArch(pkg.applicationInfo)) {
      if (pkg.cpuAbiOverride != null && !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) {
        Slog.w(TAG,"Ignoring abiOverride for multi arch application.");
      }
      int abi32=PackageManager.NO_NATIVE_LIBRARIES;
      int abi64=PackageManager.NO_NATIVE_LIBRARIES;
      if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
        if (extractLibs) {
          abi32=NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,nativeLibraryRoot,Build.SUPPORTED_32_BIT_ABIS,useIsaSpecificSubdirs);
        }
 else {
          abi32=NativeLibraryHelper.findSupportedAbi(handle,Build.SUPPORTED_32_BIT_ABIS);
        }
      }
      maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.",abi32);
      if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
        if (extractLibs) {
          abi64=NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,nativeLibraryRoot,Build.SUPPORTED_64_BIT_ABIS,useIsaSpecificSubdirs);
        }
 else {
          abi64=NativeLibraryHelper.findSupportedAbi(handle,Build.SUPPORTED_64_BIT_ABIS);
        }
      }
      maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.",abi64);
      if (abi64 >= 0) {
        pkg.applicationInfo.primaryCpuAbi=Build.SUPPORTED_64_BIT_ABIS[abi64];
      }
      if (abi32 >= 0) {
        final String abi=Build.SUPPORTED_32_BIT_ABIS[abi32];
        if (abi64 >= 0) {
          if (cpuAbiOverride == null && pkg.use32bitAbi) {
            pkg.applicationInfo.secondaryCpuAbi=pkg.applicationInfo.primaryCpuAbi;
            pkg.applicationInfo.primaryCpuAbi=abi;
          }
 else {
            pkg.applicationInfo.secondaryCpuAbi=abi;
          }
        }
 else {
          pkg.applicationInfo.primaryCpuAbi=abi;
        }
      }
    }
 else {
      String[] abiList=(cpuAbiOverride != null) ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
      boolean needsRenderScriptOverride=false;
      if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
        abiList=Build.SUPPORTED_32_BIT_ABIS;
        needsRenderScriptOverride=true;
      }
      final int copyRet;
      if (extractLibs) {
        copyRet=NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,nativeLibraryRoot,abiList,useIsaSpecificSubdirs);
      }
 else {
        copyRet=NativeLibraryHelper.findSupportedAbi(handle,abiList);
      }
      if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
        throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR,"Error unpackaging native libs for app, errorCode=" + copyRet);
      }
      if (copyRet >= 0) {
        pkg.applicationInfo.primaryCpuAbi=abiList[copyRet];
      }
 else       if (copyRet == PackageManager.NO_NATIVE_LIBRARIES && cpuAbiOverride != null) {
        pkg.applicationInfo.primaryCpuAbi=cpuAbiOverride;
      }
 else       if (needsRenderScriptOverride) {
        pkg.applicationInfo.primaryCpuAbi=abiList[0];
      }
    }
  }
 catch (  IOException ioe) {
    Slog.e(TAG,"Unable to get canonical file " + ioe.toString());
  }
 finally {
    IoUtils.closeQuietly(handle);
  }
  setNativeLibraryPaths(pkg);
}
