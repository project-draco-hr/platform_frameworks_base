{
  final String volumeUuid=vol.fsUuid;
  if (TextUtils.isEmpty(volumeUuid)) {
    Slog.e(TAG,"Loading internal storage is probably a mistake; ignoring");
    return;
  }
  final ArrayList<ApplicationInfo> loaded=new ArrayList<>();
  final int parseFlags=mDefParseFlags | PackageParser.PARSE_EXTERNAL_STORAGE;
  final VersionInfo ver;
  final List<PackageSetting> packages;
synchronized (mPackages) {
    ver=mSettings.findOrCreateVersion(volumeUuid);
    packages=mSettings.getVolumePackagesLPr(volumeUuid);
  }
  for (  PackageSetting ps : packages) {
synchronized (mInstallLock) {
      final PackageParser.Package pkg;
      try {
        pkg=scanPackageTracedLI(ps.codePath,parseFlags,SCAN_INITIAL,0,null);
        loaded.add(pkg.applicationInfo);
      }
 catch (      PackageManagerException e) {
        Slog.w(TAG,"Failed to scan " + ps.codePath + ": "+ e.getMessage());
      }
      if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
        deleteCodeCacheDirsLI(ps.volumeUuid,ps.name);
      }
    }
  }
  final UserManager um=mContext.getSystemService(UserManager.class);
  for (  UserInfo user : um.getUsers()) {
    if (um.isUserUnlocked(user.id)) {
      reconcileAppsData(volumeUuid,user.id,Installer.FLAG_DE_STORAGE | Installer.FLAG_CE_STORAGE);
    }
 else     if (um.isUserRunning(user.id)) {
      reconcileAppsData(volumeUuid,user.id,Installer.FLAG_DE_STORAGE);
    }
 else {
      continue;
    }
  }
synchronized (mPackages) {
    int updateFlags=UPDATE_PERMISSIONS_ALL;
    if (ver.sdkVersion != mSdkVersion) {
      logCriticalInfo(Log.INFO,"Platform changed from " + ver.sdkVersion + " to "+ mSdkVersion+ "; regranting permissions for "+ volumeUuid);
      updateFlags|=UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
    }
    updatePermissionsLPw(null,null,volumeUuid,updateFlags);
    ver.forceCurrent();
    mSettings.writeLPr();
  }
  if (DEBUG_INSTALL)   Slog.d(TAG,"Loaded packages " + loaded);
  sendResourcesChangedBroadcast(true,false,loaded,null);
}
