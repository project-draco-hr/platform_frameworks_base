{
  int numberOfPackagesVisited=0;
  int numberOfPackagesOptimized=0;
  int numberOfPackagesSkipped=0;
  int numberOfPackagesFailed=0;
  final int numberOfPackagesToDexopt=pkgs.size();
  for (  PackageParser.Package pkg : pkgs) {
    numberOfPackagesVisited++;
    if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
      if (DEBUG_DEXOPT) {
        Log.i(TAG,"Skipping update of of non-optimizable app " + pkg.packageName);
      }
      numberOfPackagesSkipped++;
      continue;
    }
    if (DEBUG_DEXOPT) {
      Log.i(TAG,"Updating app " + numberOfPackagesVisited + " of "+ numberOfPackagesToDexopt+ ": "+ pkg.packageName);
    }
    if (showDialog) {
      try {
        ActivityManagerNative.getDefault().showBootMessage(mContext.getResources().getString(R.string.android_upgrading_apk,numberOfPackagesVisited,numberOfPackagesToDexopt),true);
      }
 catch (      RemoteException e) {
      }
    }
    int dexOptStatus=performDexOptTraced(pkg.packageName,false,compilerFilter,false);
switch (dexOptStatus) {
case PackageDexOptimizer.DEX_OPT_PERFORMED:
      numberOfPackagesOptimized++;
    break;
case PackageDexOptimizer.DEX_OPT_SKIPPED:
  numberOfPackagesSkipped++;
break;
case PackageDexOptimizer.DEX_OPT_FAILED:
numberOfPackagesFailed++;
break;
default :
Log.e(TAG,"Unexpected dexopt return code " + dexOptStatus);
break;
}
}
return new int[]{numberOfPackagesOptimized,numberOfPackagesSkipped,numberOfPackagesFailed};
}
