{
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,"**** ro.build.version.sdk not set!");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mOnlyCore=onlyCore;
  mLazyDexOpt="eng".equals(SystemProperties.get("ro.build.type"));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings(mPackages);
  mSettings.addSharedUserLPw("android.uid.system",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.phone",RADIO_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.log",LOG_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.nfc",NFC_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.bluetooth",BLUETOOTH_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  mSettings.addSharedUserLPw("android.uid.shell",SHELL_UID,ApplicationInfo.FLAG_SYSTEM,ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);
  long dexOptLRUThresholdInMinutes;
  if (mLazyDexOpt) {
    dexOptLRUThresholdInMinutes=30;
  }
 else {
    dexOptLRUThresholdInMinutes=7 * 24 * 60;
  }
  mDexOptLRUThresholdInMills=dexOptLRUThresholdInMinutes * 60 * 1000;
  String separateProcesses=SystemProperties.get("debug.separate_processes");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if ("*".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,"Running with debug.separate_processes: * (ALL)");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(",");
      Slog.w(TAG,"Running with debug.separate_processes: " + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  mInstaller=installer;
  mPackageDexOptimizer=new PackageDexOptimizer(this);
  mMoveCallbacks=new MoveCallbacks(FgThread.get().getLooper());
  mOnPermissionChangeListeners=new OnPermissionChangeListeners(FgThread.get().getLooper());
  getDefaultDisplayMetrics(context,mMetrics);
  SystemConfig systemConfig=SystemConfig.getInstance();
  mGlobalGids=systemConfig.getGlobalGids();
  mSystemPermissions=systemConfig.getSystemPermissions();
  mAvailableFeatures=systemConfig.getAvailableFeatures();
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread=new ServiceThread(TAG,Process.THREAD_PRIORITY_BACKGROUND,true);
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      Watchdog.getInstance().addThread(mHandler,WATCHDOG_TIMEOUT);
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,"data");
      mAppInstallDir=new File(dataDir,"app");
      mAppLib32InstallDir=new File(dataDir,"app-lib");
      mAsecInternalPath=new File(dataDir,"app-asec").getPath();
      mUserAppDataDir=new File(dataDir,"user");
      mDrmAppPrivateInstallDir=new File(dataDir,"app-private");
      sUserManager=new UserManagerService(context,this,mInstallLock,mPackages);
      ArrayMap<String,SystemConfig.PermissionEntry> permConfig=systemConfig.getPermissions();
      for (int i=0; i < permConfig.size(); i++) {
        SystemConfig.PermissionEntry perm=permConfig.valueAt(i);
        BasePermission bp=mSettings.mPermissions.get(perm.name);
        if (bp == null) {
          bp=new BasePermission(perm.name,"android",BasePermission.TYPE_BUILTIN);
          mSettings.mPermissions.put(perm.name,bp);
        }
        if (perm.gids != null) {
          bp.setGids(perm.gids,perm.perUser);
        }
      }
      ArrayMap<String,String> libConfig=systemConfig.getSharedLibraries();
      for (int i=0; i < libConfig.size(); i++) {
        mSharedLibraries.put(libConfig.keyAt(i),new SharedLibraryEntry(libConfig.valueAt(i),null));
      }
      mFoundPolicyFile=SELinuxMMAC.readInstallPolicy();
      mRestoredSettings=mSettings.readLPw(this,sUserManager.getUsers(false),mSdkVersion,mOnlyCore);
      String customResolverActivity=Resources.getSystem().getString(R.string.config_customResolverActivity);
      if (TextUtils.isEmpty(customResolverActivity)) {
        customResolverActivity=null;
      }
 else {
        mCustomResolverComponentName=ComponentName.unflattenFromString(customResolverActivity);
      }
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      final int scanFlags=SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING| SCAN_INITIAL;
      final ArraySet<String> alreadyDexOpted=new ArraySet<String>();
      final String bootClassPath=System.getenv("BOOTCLASSPATH");
      final String systemServerClassPath=System.getenv("SYSTEMSERVERCLASSPATH");
      if (bootClassPath != null) {
        String[] bootClassPathElements=splitString(bootClassPath,':');
        for (        String element : bootClassPathElements) {
          alreadyDexOpted.add(element);
        }
      }
 else {
        Slog.w(TAG,"No BOOTCLASSPATH found!");
      }
      if (systemServerClassPath != null) {
        String[] systemServerClassPathElements=splitString(systemServerClassPath,':');
        for (        String element : systemServerClassPathElements) {
          alreadyDexOpted.add(element);
        }
      }
 else {
        Slog.w(TAG,"No SYSTEMSERVERCLASSPATH found!");
      }
      final List<String> allInstructionSets=InstructionSets.getAllInstructionSets();
      final String[] dexCodeInstructionSets=getDexCodeInstructionSets(allInstructionSets.toArray(new String[allInstructionSets.size()]));
      if (mSharedLibraries.size() > 0) {
        for (        String dexCodeInstructionSet : dexCodeInstructionSets) {
          for (          SharedLibraryEntry libEntry : mSharedLibraries.values()) {
            final String lib=libEntry.path;
            if (lib == null) {
              continue;
            }
            try {
              int dexoptNeeded=DexFile.getDexOptNeeded(lib,null,dexCodeInstructionSet,false);
              if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                alreadyDexOpted.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true,dexCodeInstructionSet,dexoptNeeded);
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,"Library not found: " + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,"Cannot dexopt " + lib + "; is it an APK or JAR? "+ e.getMessage());
            }
          }
        }
      }
      File frameworkDir=new File(Environment.getRootDirectory(),"framework");
      alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");
      alreadyDexOpted.add(frameworkDir.getPath() + "/core-libart.jar");
      String[] frameworkFiles=frameworkDir.list();
      if (frameworkFiles != null) {
        for (        String dexCodeInstructionSet : dexCodeInstructionSets) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(frameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (alreadyDexOpted.contains(path)) {
              continue;
            }
            if (!path.endsWith(".apk") && !path.endsWith(".jar")) {
              continue;
            }
            try {
              int dexoptNeeded=DexFile.getDexOptNeeded(path,null,dexCodeInstructionSet,false);
              if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true,dexCodeInstructionSet,dexoptNeeded);
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,"Jar not found: " + path);
            }
catch (            IOException e) {
              Slog.w(TAG,"Exception reading jar: " + path,e);
            }
          }
        }
      }
      final VersionInfo ver=mSettings.getInternalVersion();
      mIsUpgrade=!Build.FINGERPRINT.equals(ver.fingerprint);
      mPromoteSystemApps=mIsUpgrade && ver.sdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1;
      if (mPromoteSystemApps) {
        Iterator<PackageSetting> pkgSettingIter=mSettings.mPackages.values().iterator();
        while (pkgSettingIter.hasNext()) {
          PackageSetting ps=pkgSettingIter.next();
          if (isSystemApp(ps)) {
            mExistingSystemPackages.add(ps.name);
          }
        }
      }
      File vendorOverlayDir=new File(VENDOR_OVERLAY_DIR);
      scanDirLI(vendorOverlayDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags | SCAN_TRUSTED_OVERLAY,0);
      scanDirLI(frameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED,scanFlags | SCAN_NO_DEX,0);
      final File privilegedAppDir=new File(Environment.getRootDirectory(),"priv-app");
      scanDirLI(privilegedAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED,scanFlags,0);
      final File systemAppDir=new File(Environment.getRootDirectory(),"app");
      scanDirLI(systemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      File vendorAppDir=new File("/vendor/app");
      try {
        vendorAppDir=vendorAppDir.getCanonicalFile();
      }
 catch (      IOException e) {
      }
      scanDirLI(vendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      final File oemAppDir=new File(Environment.getOemDirectory(),"app");
      scanDirLI(oemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanFlags,0);
      if (DEBUG_UPGRADE)       Log.v(TAG,"Running installd update commands");
      mInstaller.moveFiles();
      final List<String> possiblyDeletedUpdatedSystemApps=new ArrayList<String>();
      if (!mOnlyCore) {
        Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
        while (psit.hasNext()) {
          PackageSetting ps=psit.next();
          if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) == 0) {
            continue;
          }
          final PackageParser.Package scannedPkg=mPackages.get(ps.name);
          if (scannedPkg != null) {
            if (mSettings.isDisabledSystemPackageLPr(ps.name)) {
              logCriticalInfo(Log.WARN,"Expecting better updated system app for " + ps.name + "; removing system app.  Last known codePath="+ ps.codePathString+ ", installStatus="+ ps.installStatus+ ", versionCode="+ ps.versionCode+ "; scanned versionCode="+ scannedPkg.mVersionCode);
              removePackageLI(ps,true);
              mExpectingBetter.put(ps.name,ps.codePath);
            }
            continue;
          }
          if (!mSettings.isDisabledSystemPackageLPr(ps.name)) {
            psit.remove();
            logCriticalInfo(Log.WARN,"System package " + ps.name + " no longer exists; wiping its data");
            removeDataDirsLI(null,ps.name);
          }
 else {
            final PackageSetting disabledPs=mSettings.getDisabledSystemPkgLPr(ps.name);
            if (disabledPs.codePath == null || !disabledPs.codePath.exists()) {
              possiblyDeletedUpdatedSystemApps.add(ps.name);
            }
          }
        }
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackagesLPr();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      mSettings.pruneSharedUsersLPw();
      if (!mOnlyCore) {
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
        scanDirLI(mAppInstallDir,0,scanFlags | SCAN_REQUIRE_KNOWN,0);
        scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanFlags | SCAN_REQUIRE_KNOWN,0);
        for (        String deletedAppName : possiblyDeletedUpdatedSystemApps) {
          PackageParser.Package deletedPkg=mPackages.get(deletedAppName);
          mSettings.removeDisabledSystemPackageLPw(deletedAppName);
          String msg;
          if (deletedPkg == null) {
            msg="Updated system package " + deletedAppName + " no longer exists; wiping its data";
            removeDataDirsLI(null,deletedAppName);
          }
 else {
            msg="Updated system app + " + deletedAppName + " no longer present; removing system privileges for "+ deletedAppName;
            deletedPkg.applicationInfo.flags&=~ApplicationInfo.FLAG_SYSTEM;
            PackageSetting deletedPs=mSettings.mPackages.get(deletedAppName);
            deletedPs.pkgFlags&=~ApplicationInfo.FLAG_SYSTEM;
          }
          logCriticalInfo(Log.WARN,msg);
        }
        for (int i=0; i < mExpectingBetter.size(); i++) {
          final String packageName=mExpectingBetter.keyAt(i);
          if (!mPackages.containsKey(packageName)) {
            final File scanFile=mExpectingBetter.valueAt(i);
            logCriticalInfo(Log.WARN,"Expected better " + packageName + " but never showed up; reverting to system");
            final int reparseFlags;
            if (FileUtils.contains(privilegedAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED;
            }
 else             if (FileUtils.contains(systemAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else             if (FileUtils.contains(vendorAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else             if (FileUtils.contains(oemAppDir,scanFile)) {
              reparseFlags=PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR;
            }
 else {
              Slog.e(TAG,"Ignoring unexpected fallback path " + scanFile);
              continue;
            }
            mSettings.enableSystemPackageLPw(packageName);
            try {
              scanPackageLI(scanFile,reparseFlags,scanFlags,0,null);
            }
 catch (            PackageManagerException e) {
              Slog.e(TAG,"Failed to parse original system package: " + e.getMessage());
            }
          }
        }
      }
      mExpectingBetter.clear();
      updateAllSharedLibrariesLPw();
      for (      SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) {
        adjustCpuAbisForSharedUserLPw(setting.packages,null,false,false);
      }
      mPackageUsage.readLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,"Time to scan packages: " + ((SystemClock.uptimeMillis() - startTime) / 1000f) + " seconds");
      int updateFlags=UPDATE_PERMISSIONS_ALL;
      if (ver.sdkVersion != mSdkVersion) {
        Slog.i(TAG,"Platform changed from " + ver.sdkVersion + " to "+ mSdkVersion+ "; regranting permissions for internal storage");
        updateFlags|=UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;
      }
      updatePermissionsLPw(null,null,updateFlags);
      ver.sdkVersion=mSdkVersion;
      if (!onlyCore && (mPromoteSystemApps || !mRestoredSettings)) {
        for (        UserInfo user : sUserManager.getUsers(true)) {
          mSettings.applyDefaultPreferredAppsLPw(this,user.id);
          applyFactoryDefaultBrowserLPw(user.id);
          primeDomainVerificationsLPw(user.id);
        }
      }
      if (mIsUpgrade && !onlyCore) {
        Slog.i(TAG,"Build fingerprint changed; clearing code caches");
        for (int i=0; i < mSettings.mPackages.size(); i++) {
          final PackageSetting ps=mSettings.mPackages.valueAt(i);
          if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL,ps.volumeUuid)) {
            deleteCodeCacheDirsLI(ps.volumeUuid,ps.name);
          }
        }
        ver.fingerprint=Build.FINGERPRINT;
      }
      checkDefaultBrowser();
      mExistingSystemPackages.clear();
      mPromoteSystemApps=false;
      ver.databaseVersion=Settings.CURRENT_DATABASE_VERSION;
      mSettings.writeLPr();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      mRequiredVerifierPackage=getRequiredVerifierLPr();
      mRequiredInstallerPackage=getRequiredInstallerLPr();
      mInstallerService=new PackageInstallerService(context,this);
      mIntentFilterVerifierComponent=getIntentFilterVerifierComponentNameLPr();
      mIntentFilterVerifier=new IntentVerifierProxy(mContext,mIntentFilterVerifierComponent);
    }
  }
  Runtime.getRuntime().gc();
  LocalServices.addService(PackageManagerInternal.class,new PackageManagerInternalImpl());
}
