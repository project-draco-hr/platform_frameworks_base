{
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      int idx=mPendingInstalls.size();
      if (DEBUG_INSTALL)       Slog.i(TAG,"init_copy idx=" + idx + ": "+ params);
      if (!mBound) {
        Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER,"bindingMCS",System.identityHashCode(mHandler));
        if (!connectToService()) {
          Slog.e(TAG,"Failed to bind to media container service");
          params.serviceError();
          Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"bindingMCS",System.identityHashCode(mHandler));
          if (params.traceMethod != null) {
            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,params.traceMethod,params.traceCookie);
          }
          return;
        }
 else {
          mPendingInstalls.add(idx,params);
        }
      }
 else {
        mPendingInstalls.add(idx,params);
        if (idx == 0) {
          mHandler.sendEmptyMessage(MCS_BOUND);
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (DEBUG_INSTALL)     Slog.i(TAG,"mcs_bound");
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
      Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"bindingMCS",System.identityHashCode(mHandler));
    }
    if (mContainerService == null) {
      if (!mBound) {
        Slog.e(TAG,"Cannot bind to media container service");
        for (        HandlerParams params : mPendingInstalls) {
          params.serviceError();
          Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"queueInstall",System.identityHashCode(params));
          if (params.traceMethod != null) {
            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,params.traceMethod,params.traceCookie);
          }
          return;
        }
        mPendingInstalls.clear();
      }
 else {
        Slog.w(TAG,"Waiting to connect to media container service");
      }
    }
 else     if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.get(0);
      if (params != null) {
        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"queueInstall",System.identityHashCode(params));
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER,"startCopy");
        if (params.startCopy()) {
          if (DEBUG_SD_INSTALL)           Log.i(TAG,"Checking for more work or unbind...");
          if (mPendingInstalls.size() > 0) {
            mPendingInstalls.remove(0);
          }
          if (mPendingInstalls.size() == 0) {
            if (mBound) {
              if (DEBUG_SD_INSTALL)               Log.i(TAG,"Posting delayed MCS_UNBIND");
              removeMessages(MCS_UNBIND);
              Message ubmsg=obtainMessage(MCS_UNBIND);
              sendMessageDelayed(ubmsg,10000);
            }
          }
 else {
            if (DEBUG_SD_INSTALL)             Log.i(TAG,"Posting MCS_BOUND for next work");
            mHandler.sendEmptyMessage(MCS_BOUND);
          }
        }
        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
      }
    }
 else {
      Slog.w(TAG,"Empty queue");
    }
    break;
  }
case MCS_RECONNECT:
{
  if (DEBUG_INSTALL)   Slog.i(TAG,"mcs_reconnect");
  if (mPendingInstalls.size() > 0) {
    if (mBound) {
      disconnectService();
    }
    if (!connectToService()) {
      Slog.e(TAG,"Failed to bind to media container service");
      for (      HandlerParams params : mPendingInstalls) {
        params.serviceError();
        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"queueInstall",System.identityHashCode(params));
      }
      mPendingInstalls.clear();
    }
  }
  break;
}
case MCS_UNBIND:
{
if (DEBUG_INSTALL) Slog.i(TAG,"mcs_unbind");
if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
  if (mBound) {
    if (DEBUG_INSTALL)     Slog.i(TAG,"calling disconnectService()");
    disconnectService();
  }
}
 else if (mPendingInstalls.size() > 0) {
  mHandler.sendEmptyMessage(MCS_BOUND);
}
break;
}
case MCS_GIVE_UP:
{
if (DEBUG_INSTALL) Slog.i(TAG,"mcs_giveup too many retries");
HandlerParams params=mPendingInstalls.remove(0);
Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"queueInstall",System.identityHashCode(params));
break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList<String> components[];
int size=0;
int uids[];
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
if (mPendingBroadcasts == null) {
return;
}
size=mPendingBroadcasts.size();
if (size <= 0) {
return;
}
packages=new String[size];
components=new ArrayList[size];
uids=new int[size];
int i=0;
for (int n=0; n < mPendingBroadcasts.userIdCount(); n++) {
int packageUserId=mPendingBroadcasts.userIdAt(n);
Iterator<Map.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
while (it.hasNext() && i < size) {
  Map.Entry<String,ArrayList<String>> ent=it.next();
  packages[i]=ent.getKey();
  components[i]=ent.getValue();
  PackageSetting ps=mSettings.mPackages.get(ent.getKey());
  uids[i]=(ps != null) ? UserHandle.getUid(packageUserId,ps.appId) : -1;
  i++;
}
}
size=i;
mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
sendPackageChangedBroadcast(packages[i],true,components[i],uids[i]);
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
break;
}
case START_CLEANING_PACKAGE:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
final String packageName=(String)msg.obj;
final int userId=msg.arg1;
final boolean andCode=msg.arg2 != 0;
synchronized (mPackages) {
if (userId == UserHandle.USER_ALL) {
int[] users=sUserManager.getUserIds();
for (int user : users) {
mSettings.addPackageToCleanLPw(new PackageCleanItem(user,packageName,andCode));
}
}
 else {
mSettings.addPackageToCleanLPw(new PackageCleanItem(userId,packageName,andCode));
}
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,"Handling post-install for " + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
boolean deleteOld=false;
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
final String packageName=res.pkg.applicationInfo.packageName;
res.removedInfo.sendBroadcast(false,true,false);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
grantRequestedRuntimePermissions(res.pkg,args.user.getIdentifier(),args.installGrantPermissions);
}
int[] firstUsers;
int[] updateUsers=new int[0];
if (res.origUsers == null || res.origUsers.length == 0) {
firstUsers=res.newUsers;
}
 else {
firstUsers=new int[0];
for (int i=0; i < res.newUsers.length; i++) {
int user=res.newUsers[i];
boolean isNew=true;
for (int j=0; j < res.origUsers.length; j++) {
if (res.origUsers[j] == user) {
  isNew=false;
  break;
}
}
if (isNew) {
int[] newFirst=new int[firstUsers.length + 1];
System.arraycopy(firstUsers,0,newFirst,0,firstUsers.length);
newFirst[firstUsers.length]=user;
firstUsers=newFirst;
}
 else {
int[] newUpdate=new int[updateUsers.length + 1];
System.arraycopy(updateUsers,0,newUpdate,0,updateUsers.length);
newUpdate[updateUsers.length]=user;
updateUsers=newUpdate;
}
}
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,firstUsers);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null,updateUsers);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null,updateUsers);
sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null,updateUsers);
if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
if (DEBUG_INSTALL) {
Slog.i(TAG,"upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
}
int[] uidArray=new int[]{res.pkg.applicationInfo.uid};
ArrayList<String> pkgList=new ArrayList<String>(1);
pkgList.add(packageName);
sendResourcesChangedBroadcast(true,true,pkgList,uidArray,null);
}
}
if (res.removedInfo.args != null) {
deleteOld=true;
}
if (firstUsers.length > 0) {
if (packageIsBrowser(packageName,firstUsers[0])) {
synchronized (mPackages) {
for (int userId : firstUsers) {
  mSettings.setDefaultBrowserPackageNameLPw(null,userId);
}
}
}
}
EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED,getUnknownSourcesSettings());
}
Runtime.getRuntime().gc();
if (deleteOld) {
synchronized (mInstallLock) {
res.removedInfo.args.doPostDeleteLI(true);
}
}
if (args.observer != null) {
try {
Bundle extras=extrasForInstallResult(res);
args.observer.onPackageInstalled(res.name,res.returnCode,res.returnMsg,extras);
}
 catch (RemoteException e) {
Slog.i(TAG,"Observer no longer exists.");
}
}
if (args.traceMethod != null) {
Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,args.traceMethod,args.traceCookie);
}
return;
}
 else {
Slog.e(TAG,"Bogus post-install token " + msg.arg1);
}
Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"postInstall",msg.arg1);
}
break;
case UPDATED_MEDIA_STATUS:
{
if (DEBUG_SD_INSTALL) Log.i(TAG,"Got message UPDATED_MEDIA_STATUS");
boolean reportStatus=msg.arg1 == 1;
boolean doGc=msg.arg2 == 1;
if (DEBUG_SD_INSTALL) Log.i(TAG,"reportStatus=" + reportStatus + ", doGc = "+ doGc);
if (doGc) {
Runtime.getRuntime().gc();
}
if (msg.obj != null) {
@SuppressWarnings("unchecked") Set<AsecInstallArgs> args=(Set<AsecInstallArgs>)msg.obj;
if (DEBUG_SD_INSTALL) Log.i(TAG,"Unloading all containers");
unloadAllContainers(args);
}
if (reportStatus) {
try {
if (DEBUG_SD_INSTALL) Log.i(TAG,"Invoking MountService call back");
PackageHelper.getMountService().finishMediaUpdate();
}
 catch (RemoteException e) {
Log.e(TAG,"MountService not running?");
}
}
}
break;
case WRITE_SETTINGS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_SETTINGS);
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
mSettings.writeLPr();
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case WRITE_PACKAGE_RESTRICTIONS:
{
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
synchronized (mPackages) {
removeMessages(WRITE_PACKAGE_RESTRICTIONS);
for (int userId : mDirtyUsers) {
mSettings.writePackageRestrictionsLPr(userId);
}
mDirtyUsers.clear();
}
Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
}
break;
case CHECK_PENDING_VERIFICATION:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if ((state != null) && !state.timeoutExtended()) {
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
Slog.i(TAG,"Verification timed out for " + originUri);
mPendingVerification.remove(verificationId);
int ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
Slog.i(TAG,"Continuing with installation of " + originUri);
state.setVerifierResponse(Binder.getCallingUid(),PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_ALLOW,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,"Could not contact the ContainerService");
}
}
 else {
broadcastPackageVerified(verificationId,originUri,PackageManager.VERIFICATION_REJECT,state.getInstallArgs().getUser());
}
Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"verification",verificationId);
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case PACKAGE_VERIFIED:
{
final int verificationId=msg.arg1;
final PackageVerificationState state=mPendingVerification.get(verificationId);
if (state == null) {
Slog.w(TAG,"Invalid verification token " + verificationId + " received");
break;
}
final PackageVerificationResponse response=(PackageVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (state.isVerificationComplete()) {
mPendingVerification.remove(verificationId);
final InstallArgs args=state.getInstallArgs();
final Uri originUri=Uri.fromFile(args.origin.resolvedFile);
int ret;
if (state.isInstallAllowed()) {
ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
broadcastPackageVerified(verificationId,originUri,response.code,state.getInstallArgs().getUser());
try {
ret=args.copyApk(mContainerService,true);
}
 catch (RemoteException e) {
Slog.e(TAG,"Could not contact the ContainerService");
}
}
 else {
ret=PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
}
Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER,"verification",verificationId);
processPendingInstall(args,ret);
mHandler.sendEmptyMessage(MCS_UNBIND);
}
break;
}
case START_INTENT_FILTER_VERIFICATIONS:
{
IFVerificationParams params=(IFVerificationParams)msg.obj;
verifyIntentFiltersIfNeeded(params.userId,params.verifierUid,params.replacing,params.pkg);
break;
}
case INTENT_FILTER_VERIFIED:
{
final int verificationId=msg.arg1;
final IntentFilterVerificationState state=mIntentFilterVerificationStates.get(verificationId);
if (state == null) {
Slog.w(TAG,"Invalid IntentFilter verification token " + verificationId + " received");
break;
}
final int userId=state.getUserId();
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,"Processing IntentFilter verification with token:" + verificationId + " and userId:"+ userId);
final IntentFilterVerificationResponse response=(IntentFilterVerificationResponse)msg.obj;
state.setVerifierResponse(response.callerUid,response.code);
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,"IntentFilter verification with token:" + verificationId + " and userId:"+ userId+ " is settings verifier response with response code:"+ response.code);
if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,"Domains failing verification: " + response.getFailedDomainsString());
}
if (state.isVerificationComplete()) {
mIntentFilterVerifier.receiveVerificationResponse(verificationId);
}
 else {
if (DEBUG_DOMAIN_VERIFICATION) Slog.d(TAG,"IntentFilter verification with token:" + verificationId + " was not said to be complete");
}
break;
}
}
}
