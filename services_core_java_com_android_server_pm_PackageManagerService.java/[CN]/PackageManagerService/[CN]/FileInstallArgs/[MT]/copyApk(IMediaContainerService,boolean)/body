{
  int ret=PackageManager.INSTALL_SUCCEEDED;
  if (originStaged) {
    Slog.d(TAG,originFile + " already staged; skipping copy");
    codeFile=originFile;
    resourceFile=originFile;
  }
 else {
    try {
      final File tempDir=mInstallerService.allocateSessionDir();
      codeFile=tempDir;
      resourceFile=tempDir;
    }
 catch (    IOException e) {
      Slog.w(TAG,"Failed to create copy file: " + e);
      return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
    }
    final IParcelFileDescriptorFactory target=new IParcelFileDescriptorFactory.Stub(){
      @Override public ParcelFileDescriptor open(      String name,      int mode) throws RemoteException {
        if (!FileUtils.isValidExtFilename(name)) {
          throw new IllegalArgumentException("Invalid filename: " + name);
        }
        try {
          final File file=new File(codeFile,name);
          final FileDescriptor fd=Os.open(file.getAbsolutePath(),O_RDWR | O_CREAT,0644);
          Os.chmod(file.getAbsolutePath(),0644);
          return new ParcelFileDescriptor(fd);
        }
 catch (        ErrnoException e) {
          throw new RemoteException("Failed to open: " + e.getMessage());
        }
      }
    }
;
    ret=imcs.copyPackage(originFile.getAbsolutePath(),target);
    if (ret != PackageManager.INSTALL_SUCCEEDED) {
      Slog.e(TAG,"Failed to copy package");
      return ret;
    }
  }
  final File libraryRoot=new File(codeFile,LIB_DIR_NAME);
  NativeLibraryHelper.Handle handle=null;
  try {
    handle=NativeLibraryHelper.Handle.create(codeFile);
    if (multiArch) {
      if (abiOverride != null) {
        Slog.w(TAG,"Ignoring abiOverride for multi arch application.");
      }
      int copyRet=PackageManager.NO_NATIVE_LIBRARIES;
      if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
        copyRet=copyNativeLibrariesForInternalApp(handle,libraryRoot,Build.SUPPORTED_32_BIT_ABIS,true);
        if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
          Slog.w(TAG,"Failure copying 32 bit native libraries [errorCode=" + copyRet + "]");
          return copyRet;
        }
      }
      if (DEBUG_ABI_SELECTION && copyRet >= 0) {
        Log.d(TAG,"Installed 32 bit libraries under: " + codeFile + " abi="+ Build.SUPPORTED_32_BIT_ABIS[copyRet]);
      }
      if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
        copyRet=copyNativeLibrariesForInternalApp(handle,libraryRoot,Build.SUPPORTED_64_BIT_ABIS,true);
        if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
          Slog.w(TAG,"Failure copying 64 bit native libraries [errorCode=" + copyRet + "]");
          return copyRet;
        }
      }
      if (DEBUG_ABI_SELECTION && copyRet >= 0) {
        Log.d(TAG,"Installed 64 bit libraries under: " + codeFile + " abi="+ Build.SUPPORTED_64_BIT_ABIS[copyRet]);
      }
    }
 else {
      String[] abiList=(abiOverride != null) ? new String[]{abiOverride} : Build.SUPPORTED_ABIS;
      if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && abiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
        abiList=Build.SUPPORTED_32_BIT_ABIS;
      }
      int copyRet=copyNativeLibrariesForInternalApp(handle,libraryRoot,abiList,true);
      if (copyRet < 0 && copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
        Slog.w(TAG,"Failure copying native libraries [errorCode=" + copyRet + "]");
        return copyRet;
      }
      if (DEBUG_ABI_SELECTION && copyRet >= 0) {
        Log.d(TAG,"Installed libraries under: " + codeFile + " abi="+ abiList[copyRet]);
      }
    }
  }
 catch (  IOException e) {
    Slog.e(TAG,"Copying native libraries failed",e);
    ret=PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
  }
 finally {
    IoUtils.closeQuietly(handle);
  }
  return ret;
}
