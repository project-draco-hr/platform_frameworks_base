{
  if (DEBUG)   Slog.d(TAG,"stepIdleStateLocked: mState=" + mState);
  EventLogTags.writeDeviceIdleStep();
  final long now=SystemClock.elapsedRealtime();
  if ((now + DEFAULT_MIN_TIME_TO_ALARM) > mAlarmManager.getNextWakeFromIdleTime()) {
    if (mState != STATE_ACTIVE) {
      becomeActiveLocked("alarm");
    }
    return;
  }
switch (mState) {
case STATE_INACTIVE:
    startMonitoringSignificantMotion();
  scheduleAlarmLocked(DEFAULT_IDLE_AFTER_INACTIVE_TIMEOUT,false);
mNextIdlePendingDelay=DEFAULT_IDLE_PENDING_TIMEOUT;
mNextIdleDelay=DEFAULT_IDLE_TIMEOUT;
mState=STATE_IDLE_PENDING;
if (DEBUG) Slog.d(TAG,"Moved from STATE_INACTIVE to STATE_IDLE_PENDING.");
EventLogTags.writeDeviceIdle(mState,"step");
break;
case STATE_IDLE_PENDING:
mState=STATE_SENSING;
if (DEBUG) Slog.d(TAG,"Moved from STATE_IDLE_PENDING to STATE_SENSING.");
scheduleSensingAlarmLocked(DEFAULT_SENSING_TIMEOUT);
mAnyMotionDetector.checkForAnyMotion();
break;
case STATE_SENSING:
cancelSensingAlarmLocked();
case STATE_IDLE_MAINTENANCE:
scheduleAlarmLocked(mNextIdleDelay,true);
if (DEBUG) Slog.d(TAG,"Moved to STATE_IDLE. Next alarm in " + mNextIdleDelay + " ms.");
mNextIdleDelay=(long)(mNextIdleDelay * DEFAULT_IDLE_FACTOR);
if (DEBUG) Slog.d(TAG,"Setting mNextIdleDelay = " + mNextIdleDelay);
if (mNextIdleDelay > DEFAULT_MAX_IDLE_TIMEOUT) {
mNextIdleDelay=DEFAULT_MAX_IDLE_TIMEOUT;
}
mState=STATE_IDLE;
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON);
break;
case STATE_IDLE:
scheduleAlarmLocked(mNextIdlePendingDelay,false);
if (DEBUG) Slog.d(TAG,"Moved from STATE_IDLE to STATE_IDLE_MAINTENANCE. " + "Next alarm in " + mNextIdlePendingDelay + " ms.");
mNextIdlePendingDelay=(long)(mNextIdlePendingDelay * DEFAULT_IDLE_PENDING_FACTOR);
if (mNextIdlePendingDelay > DEFAULT_MAX_IDLE_PENDING_TIMEOUT) {
mNextIdlePendingDelay=DEFAULT_MAX_IDLE_PENDING_TIMEOUT;
}
mState=STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdle(mState,"step");
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}
