{
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println("Permission Denial: can't dump DeviceIdleController from from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid()+ " without permission "+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if ("-h".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if ("-u".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if ("-a".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println("Unknown option: " + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println("  Idling history:");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label="     normal";
        break;
case EVENT_LIGHT_IDLE:
      label=" light-idle";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label="light-maint";
break;
case EVENT_DEEP_IDLE:
label="  deep-idle";
break;
case EVENT_DEEP_MAINTENANCE:
label=" deep-maint";
break;
default :
label="         ??";
break;
}
pw.print("    ");
pw.print(label);
pw.print(": ");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println("  Whitelist (except idle) system apps:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println("  Whitelist system apps:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println("  Whitelist user apps:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println("  Whitelist (except idle) all app ids:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println("  Whitelist user app ids:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println("  Whitelist all app ids:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
dumpTempWhitelistSchedule(pw,true);
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println("  Temp whitelist app ids:");
for (int i=0; i < size; i++) {
pw.print("    ");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print("  mLightEnabled=");
pw.print(mLightEnabled);
pw.print("  mDeepEnabled=");
pw.println(mDeepEnabled);
pw.print("  mForceIdle=");
pw.println(mForceIdle);
pw.print("  mMotionSensor=");
pw.println(mMotionSensor);
pw.print("  mCurDisplay=");
pw.println(mCurDisplay);
pw.print("  mScreenOn=");
pw.println(mScreenOn);
pw.print("  mNetworkConnected=");
pw.println(mNetworkConnected);
pw.print("  mCharging=");
pw.println(mCharging);
pw.print("  mMotionActive=");
pw.println(mMotionListener.active);
pw.print("  mNotMoving=");
pw.println(mNotMoving);
pw.print("  mLocating=");
pw.print(mLocating);
pw.print(" mHasGps=");
pw.print(mHasGps);
pw.print(" mHasNetwork=");
pw.print(mHasNetworkLocation);
pw.print(" mLocated=");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print("  mLastGenericLocation=");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print("  mLastGpsLocation=");
pw.println(mLastGpsLocation);
}
pw.print("  mState=");
pw.print(stateToString(mState));
pw.print(" mLightState=");
pw.println(lightStateToString(mLightState));
pw.print("  mInactiveTimeout=");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print("  mActiveIdleOpCount=");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print("  mNextAlarmTime=");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print("  mNextIdlePendingDelay=");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print("  mNextIdleDelay=");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print("  mNextIdleDelay=");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print("  mNextLightAlarmTime=");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print("  mCurIdleBudget=");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print("  mMaintenanceStartTime=");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print("  mJobsActive=");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print("  mAlarmsActive=");
pw.println(mAlarmsActive);
}
}
}
