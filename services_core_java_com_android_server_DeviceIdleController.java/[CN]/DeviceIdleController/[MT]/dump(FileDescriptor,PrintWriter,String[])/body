{
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println("Permission Denial: can't dump DeviceIdleController from from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid()+ " without permission "+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_OWNER;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if ("-h".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if ("-u".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if ("-a".equals(arg)) {
      }
 else       if ("step".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            stepIdleStateLocked();
            pw.print("Stepped to: ");
            pw.println(stateToString(mState));
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if ("disable".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (mEnabled) {
              mEnabled=false;
              becomeActiveLocked("disabled",Process.myUid());
              pw.println("Idle mode disabled");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if ("enable".equals(arg)) {
synchronized (this) {
          long token=Binder.clearCallingIdentity();
          try {
            if (!mEnabled) {
              mEnabled=true;
              becomeInactiveIfAppropriateLocked();
              pw.println("Idle mode enabled");
            }
          }
  finally {
            Binder.restoreCallingIdentity(token);
          }
        }
        return;
      }
 else       if ("enabled".equals(arg)) {
synchronized (this) {
          pw.println(mEnabled ? "1" : " 0");
        }
        return;
      }
 else       if ("whitelist".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          while (i < args.length) {
            arg=args[i];
            i++;
            if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+')) {
              pw.println("Package must be prefixed with + or -: " + arg);
              return;
            }
            char op=arg.charAt(0);
            String pkg=arg.substring(1);
            if (op == '+') {
              if (addPowerSaveWhitelistAppInternal(pkg)) {
                pw.println("Added: " + pkg);
              }
 else {
                pw.println("Unknown package: " + pkg);
              }
            }
 else {
              if (removePowerSaveWhitelistAppInternal(pkg)) {
                pw.println("Removed: " + pkg);
              }
            }
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        return;
      }
 else       if ("tempwhitelist".equals(arg)) {
        long token=Binder.clearCallingIdentity();
        try {
          i++;
          if (i >= args.length) {
            pw.println("At least one package name must be specified");
            return;
          }
          while (i < args.length) {
            arg=args[i];
            i++;
            addPowerSaveTempWhitelistAppInternal(0,arg,10000L,userId);
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println("Unknown option: " + arg);
        return;
      }
 else {
        pw.println("Unknown command: " + arg);
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    int size=mPowerSaveWhitelistApps.size();
    if (size > 0) {
      pw.println("  Whitelist system apps:");
      for (int i=0; i < size; i++) {
        pw.print("    ");
        pw.println(mPowerSaveWhitelistApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistUserApps.size();
    if (size > 0) {
      pw.println("  Whitelist user apps:");
      for (int i=0; i < size; i++) {
        pw.print("    ");
        pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
      }
    }
    size=mPowerSaveWhitelistAllAppIds.size();
    if (size > 0) {
      pw.println("  Whitelist all app ids:");
      for (int i=0; i < size; i++) {
        pw.print("    ");
        pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
        pw.println();
      }
    }
    size=mTempWhitelistAppIdEndTimes.size();
    if (size > 0) {
      pw.println("  Temp whitelist schedule:");
      final long timeNow=SystemClock.elapsedRealtime();
      for (int i=0; i < size; i++) {
        pw.print("    UID=");
        pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
        pw.print(": ");
        TimeUtils.formatDuration(mTempWhitelistAppIdEndTimes.valueAt(i),timeNow,pw);
        pw.println();
      }
    }
    size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
    if (size > 0) {
      pw.println("  Temp whitelist app ids:");
      for (int i=0; i < size; i++) {
        pw.print("    ");
        pw.print(mTempWhitelistAppIdArray[i]);
        pw.println();
      }
    }
    pw.print("  mEnabled=");
    pw.println(mEnabled);
    pw.print("  mSigMotionSensor=");
    pw.println(mSigMotionSensor);
    pw.print("  mCurDisplay=");
    pw.println(mCurDisplay);
    pw.print("  mScreenOn=");
    pw.println(mScreenOn);
    pw.print("  mCharging=");
    pw.println(mCharging);
    pw.print("  mSigMotionActive=");
    pw.println(mSigMotionActive);
    pw.print("  mState=");
    pw.println(stateToString(mState));
    pw.print("  mInactiveTimeout=");
    TimeUtils.formatDuration(mInactiveTimeout,pw);
    pw.println();
    if (mNextAlarmTime != 0) {
      pw.print("  mNextAlarmTime=");
      TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
      pw.println();
    }
    if (mNextIdlePendingDelay != 0) {
      pw.print("  mNextIdlePendingDelay=");
      TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
      pw.println();
    }
    if (mNextIdleDelay != 0) {
      pw.print("  mNextIdleDelay=");
      TimeUtils.formatDuration(mNextIdleDelay,pw);
      pw.println();
    }
  }
}
