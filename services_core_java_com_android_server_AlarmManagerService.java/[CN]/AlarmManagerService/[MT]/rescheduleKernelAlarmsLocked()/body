{
  long nextNonWakeup=0;
  if (mAlarmBatches.size() > 0) {
    Batch firstWakeup=null, nextAfterWakeup=null;
    final int N=mAlarmBatches.size();
    for (int i=0; i < N; i++) {
      Batch b=mAlarmBatches.get(i);
      if (b.hasWakeups()) {
        firstWakeup=b;
        if (i < N - 1) {
          nextAfterWakeup=mAlarmBatches.get(i + 1);
        }
        break;
      }
    }
    final Batch firstBatch=mAlarmBatches.get(0);
    if (firstWakeup != null && mNextWakeupBatchStart != firstWakeup.start) {
      mNextWakeupBatchStart=mNextWakeup=firstWakeup.start;
      final long windowEnd=(nextAfterWakeup == null) ? firstWakeup.end : Math.min(firstWakeup.end,nextAfterWakeup.start);
      final long interval=windowEnd - firstWakeup.start;
      if (interval > 0 && interval < Integer.MAX_VALUE) {
        mNextWakeup+=mFuzzer.nextInt((int)interval);
      }
      setLocked(ELAPSED_REALTIME_WAKEUP,mNextWakeup);
    }
    if (firstBatch != firstWakeup) {
      nextNonWakeup=firstBatch.start;
    }
  }
  if (mPendingNonWakeupAlarms.size() > 0) {
    if (nextNonWakeup == 0 || mNextNonWakeupDeliveryTime < nextNonWakeup) {
      nextNonWakeup=mNextNonWakeupDeliveryTime;
    }
  }
  if (nextNonWakeup != 0 && mNextNonWakeup != nextNonWakeup) {
    mNextNonWakeup=nextNonWakeup;
    setLocked(ELAPSED_REALTIME,nextNonWakeup);
  }
}
