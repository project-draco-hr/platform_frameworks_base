{
  mLastAlarmDeliveryTime=nowELAPSED;
  for (int i=0; i < triggerList.size(); i++) {
    Alarm alarm=triggerList.get(i);
    final boolean allowWhileIdle=(alarm.flags & AlarmManager.FLAG_ALLOW_WHILE_IDLE) != 0;
    try {
      if (localLOGV) {
        Slog.v(TAG,"sending alarm " + alarm);
      }
      if (RECORD_ALARMS_IN_HISTORY) {
        if (alarm.workSource != null && alarm.workSource.size() > 0) {
          for (int wi=0; wi < alarm.workSource.size(); wi++) {
            ActivityManagerNative.noteAlarmStart(alarm.operation,alarm.workSource.get(wi),alarm.tag);
          }
        }
 else {
          ActivityManagerNative.noteAlarmStart(alarm.operation,-1,alarm.tag);
        }
      }
      alarm.operation.send(getContext(),0,mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT,alarm.count),mResultReceiver,mHandler,null,allowWhileIdle ? mIdleOptions : null);
      if (mBroadcastRefCount == 0) {
        setWakelockWorkSource(alarm.operation,alarm.workSource,alarm.type,alarm.tag,true);
        mWakeLock.acquire();
      }
      final InFlight inflight=new InFlight(AlarmManagerService.this,alarm.operation,alarm.workSource,alarm.type,alarm.tag,nowELAPSED);
      mInFlight.add(inflight);
      mBroadcastRefCount++;
      if (allowWhileIdle) {
        mLastAllowWhileIdleDispatch.put(alarm.uid,nowELAPSED);
        if (RECORD_DEVICE_IDLE_ALARMS) {
          IdleDispatchEntry ent=new IdleDispatchEntry();
          ent.uid=alarm.uid;
          ent.pkg=alarm.operation.getCreatorPackage();
          ent.tag=alarm.operation.getTag("");
          ent.op="DELIVER";
          ent.elapsedRealtime=nowELAPSED;
          mAllowWhileIdleDispatches.add(ent);
        }
      }
      final BroadcastStats bs=inflight.mBroadcastStats;
      bs.count++;
      if (bs.nesting == 0) {
        bs.nesting=1;
        bs.startTime=nowELAPSED;
      }
 else {
        bs.nesting++;
      }
      final FilterStats fs=inflight.mFilterStats;
      fs.count++;
      if (fs.nesting == 0) {
        fs.nesting=1;
        fs.startTime=nowELAPSED;
      }
 else {
        fs.nesting++;
      }
      if (alarm.type == ELAPSED_REALTIME_WAKEUP || alarm.type == RTC_WAKEUP) {
        bs.numWakeup++;
        fs.numWakeup++;
        if (alarm.workSource != null && alarm.workSource.size() > 0) {
          for (int wi=0; wi < alarm.workSource.size(); wi++) {
            ActivityManagerNative.noteWakeupAlarm(alarm.operation,alarm.workSource.get(wi),alarm.workSource.getName(wi),alarm.tag);
          }
        }
 else {
          ActivityManagerNative.noteWakeupAlarm(alarm.operation,-1,null,alarm.tag);
        }
      }
    }
 catch (    PendingIntent.CanceledException e) {
      if (alarm.repeatInterval > 0) {
        removeImpl(alarm.operation);
      }
    }
catch (    RuntimeException e) {
      Slog.w(TAG,"Failure sending alarm.",e);
    }
  }
}
