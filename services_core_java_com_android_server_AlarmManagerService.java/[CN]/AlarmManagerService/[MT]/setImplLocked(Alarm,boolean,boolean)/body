{
  if ((a.flags & AlarmManager.FLAG_IDLE_UNTIL) != 0) {
    if (mNextWakeFromIdle != null) {
      a.when=a.whenElapsed=a.maxWhenElapsed=mNextWakeFromIdle.whenElapsed;
    }
    final long nowElapsed=SystemClock.elapsedRealtime();
    final int fuzz=fuzzForDuration(a.whenElapsed - nowElapsed);
    if (fuzz > 0) {
      if (mRandom == null) {
        mRandom=new Random();
      }
      final int delta=mRandom.nextInt(fuzz);
      a.whenElapsed-=delta;
      if (false) {
        Slog.d(TAG,"Alarm when: " + a.whenElapsed);
        Slog.d(TAG,"Delta until alarm: " + (a.whenElapsed - nowElapsed));
        Slog.d(TAG,"Applied fuzz: " + fuzz);
        Slog.d(TAG,"Final delta: " + delta);
        Slog.d(TAG,"Final when: " + a.whenElapsed);
      }
      a.when=a.maxWhenElapsed=a.whenElapsed;
    }
  }
 else   if (mPendingIdleUntil != null) {
    if ((a.flags & (AlarmManager.FLAG_ALLOW_WHILE_IDLE | AlarmManager.FLAG_WAKE_FROM_IDLE)) == 0) {
      mPendingWhileIdleAlarms.add(a);
      return;
    }
  }
  int whichBatch=((a.flags & AlarmManager.FLAG_STANDALONE) != 0) ? -1 : attemptCoalesceLocked(a.whenElapsed,a.maxWhenElapsed);
  if (whichBatch < 0) {
    Batch batch=new Batch(a);
    addBatchLocked(mAlarmBatches,batch);
  }
 else {
    Batch batch=mAlarmBatches.get(whichBatch);
    if (batch.add(a)) {
      mAlarmBatches.remove(whichBatch);
      addBatchLocked(mAlarmBatches,batch);
    }
  }
  if (a.alarmClock != null) {
    mNextAlarmClockMayChange=true;
  }
  boolean needRebatch=false;
  if ((a.flags & AlarmManager.FLAG_IDLE_UNTIL) != 0) {
    mPendingIdleUntil=a;
    needRebatch=true;
  }
 else   if ((a.flags & AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) {
    if (mNextWakeFromIdle == null || mNextWakeFromIdle.whenElapsed > a.whenElapsed) {
      mNextWakeFromIdle=a;
      if (mPendingIdleUntil != null) {
        needRebatch=true;
      }
    }
  }
  if (!rebatching) {
    if (DEBUG_VALIDATE) {
      if (doValidate && !validateConsistencyLocked()) {
        Slog.v(TAG,"Tipping-point operation: type=" + a.type + " when="+ a.when+ " when(hex)="+ Long.toHexString(a.when)+ " whenElapsed="+ a.whenElapsed+ " maxWhenElapsed="+ a.maxWhenElapsed+ " interval="+ a.repeatInterval+ " op="+ a.operation+ " flags=0x"+ Integer.toHexString(a.flags));
        rebatchAllAlarmsLocked(false);
        needRebatch=false;
      }
    }
    if (needRebatch) {
      rebatchAllAlarmsLocked(false);
    }
    rescheduleKernelAlarmsLocked();
    updateNextAlarmClockLocked();
  }
}
