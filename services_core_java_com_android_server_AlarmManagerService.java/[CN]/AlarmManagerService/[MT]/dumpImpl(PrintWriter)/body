{
synchronized (mLock) {
    pw.println("Current Alarm Manager state:");
    final long nowRTC=System.currentTimeMillis();
    final long nowELAPSED=SystemClock.elapsedRealtime();
    SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    pw.print("nowRTC=");
    pw.print(nowRTC);
    pw.print("=");
    pw.print(sdf.format(new Date(nowRTC)));
    pw.print(" nowELAPSED=");
    pw.println(nowELAPSED);
    long nextWakeupRTC=mNextWakeup + (nowRTC - nowELAPSED);
    long nextNonWakeupRTC=mNextNonWakeup + (nowRTC - nowELAPSED);
    pw.print("Next alarm: ");
    pw.print(mNextNonWakeup);
    pw.print(" = ");
    pw.println(sdf.format(new Date(nextNonWakeupRTC)));
    pw.print("Next wakeup: ");
    pw.print(mNextWakeup);
    pw.print(" = ");
    pw.println(sdf.format(new Date(nextWakeupRTC)));
    if (mAlarmBatches.size() > 0) {
      pw.println();
      pw.print("Pending alarm batches: ");
      pw.println(mAlarmBatches.size());
      for (      Batch b : mAlarmBatches) {
        pw.print(b);
        pw.println(':');
        dumpAlarmList(pw,b.alarms,"  ",nowELAPSED,nowRTC);
      }
    }
    pw.println();
    pw.print("  Broadcast ref count: ");
    pw.println(mBroadcastRefCount);
    pw.println();
    if (mLog.dump(pw,"  Recent problems","    ")) {
      pw.println();
    }
    final FilterStats[] topFilters=new FilterStats[10];
    final Comparator<FilterStats> comparator=new Comparator<FilterStats>(){
      @Override public int compare(      FilterStats lhs,      FilterStats rhs){
        if (lhs.aggregateTime < rhs.aggregateTime) {
          return 1;
        }
 else         if (lhs.aggregateTime > rhs.aggregateTime) {
          return -1;
        }
        return 0;
      }
    }
;
    int len=0;
    for (int iu=0; iu < mBroadcastStats.size(); iu++) {
      ArrayMap<String,BroadcastStats> uidStats=mBroadcastStats.valueAt(iu);
      for (int ip=0; ip < uidStats.size(); ip++) {
        BroadcastStats bs=uidStats.valueAt(ip);
        for (int is=0; is < bs.filterStats.size(); is++) {
          FilterStats fs=bs.filterStats.valueAt(is);
          int pos=len > 0 ? Arrays.binarySearch(topFilters,0,len,fs,comparator) : 0;
          if (pos < 0) {
            pos=-pos - 1;
          }
          if (pos < topFilters.length) {
            int copylen=topFilters.length - pos - 1;
            if (copylen > 0) {
              System.arraycopy(topFilters,pos,topFilters,pos + 1,copylen);
            }
            topFilters[pos]=fs;
            if (len < topFilters.length) {
              len++;
            }
          }
        }
      }
    }
    if (len > 0) {
      pw.println("  Top Alarms:");
      for (int i=0; i < len; i++) {
        FilterStats fs=topFilters[i];
        pw.print("    ");
        if (fs.nesting > 0)         pw.print("*ACTIVE* ");
        TimeUtils.formatDuration(fs.aggregateTime,pw);
        pw.print(" running, ");
        pw.print(fs.numWakeup);
        pw.print(" wakeups, ");
        pw.print(fs.count);
        pw.print(" alarms: ");
        UserHandle.formatUid(pw,fs.mBroadcastStats.mUid);
        pw.print(":");
        pw.print(fs.mBroadcastStats.mPackageName);
        pw.println();
        pw.print("      ");
        if (fs.mTarget.first != null) {
          pw.print(" act=");
          pw.print(fs.mTarget.first);
        }
        if (fs.mTarget.second != null) {
          pw.print(" cmp=");
          pw.print(fs.mTarget.second.toShortString());
        }
        pw.println();
      }
    }
    pw.println(" ");
    pw.println("  Alarm Stats:");
    final ArrayList<FilterStats> tmpFilters=new ArrayList<FilterStats>();
    for (int iu=0; iu < mBroadcastStats.size(); iu++) {
      ArrayMap<String,BroadcastStats> uidStats=mBroadcastStats.valueAt(iu);
      for (int ip=0; ip < uidStats.size(); ip++) {
        BroadcastStats bs=uidStats.valueAt(ip);
        pw.print("  ");
        if (bs.nesting > 0)         pw.print("*ACTIVE* ");
        UserHandle.formatUid(pw,bs.mUid);
        pw.print(":");
        pw.print(bs.mPackageName);
        pw.print(" ");
        TimeUtils.formatDuration(bs.aggregateTime,pw);
        pw.print(" running, ");
        pw.print(bs.numWakeup);
        pw.println(" wakeups:");
        tmpFilters.clear();
        for (int is=0; is < bs.filterStats.size(); is++) {
          tmpFilters.add(bs.filterStats.valueAt(is));
        }
        Collections.sort(tmpFilters,comparator);
        for (int i=0; i < tmpFilters.size(); i++) {
          FilterStats fs=tmpFilters.get(i);
          pw.print("    ");
          if (fs.nesting > 0)           pw.print("*ACTIVE* ");
          TimeUtils.formatDuration(fs.aggregateTime,pw);
          pw.print(" ");
          pw.print(fs.numWakeup);
          pw.print(" wakes ");
          pw.print(fs.count);
          pw.print(" alarms:");
          if (fs.mTarget.first != null) {
            pw.print(" act=");
            pw.print(fs.mTarget.first);
          }
          if (fs.mTarget.second != null) {
            pw.print(" cmp=");
            pw.print(fs.mTarget.second.toShortString());
          }
          pw.println();
        }
      }
    }
    if (WAKEUP_STATS) {
      pw.println();
      pw.println("  Recent Wakeup History:");
      long last=-1;
      for (      WakeupEvent event : mRecentWakeups) {
        pw.print("    ");
        pw.print(sdf.format(new Date(event.when)));
        pw.print('|');
        if (last < 0) {
          pw.print('0');
        }
 else {
          pw.print(event.when - last);
        }
        last=event.when;
        pw.print('|');
        pw.print(event.uid);
        pw.print('|');
        pw.print(event.action);
        pw.println();
      }
      pw.println();
    }
  }
}
