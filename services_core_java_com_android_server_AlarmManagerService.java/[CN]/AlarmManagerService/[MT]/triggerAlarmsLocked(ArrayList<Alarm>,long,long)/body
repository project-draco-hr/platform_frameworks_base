{
  boolean hasWakeup=false;
  while (mAlarmBatches.size() > 0) {
    Batch batch=mAlarmBatches.get(0);
    if (batch.start > nowELAPSED) {
      break;
    }
    mAlarmBatches.remove(0);
    final int N=batch.size();
    for (int i=0; i < N; i++) {
      Alarm alarm=batch.get(i);
      alarm.count=1;
      triggerList.add(alarm);
      if (alarm.repeatInterval > 0) {
        alarm.count+=(nowELAPSED - alarm.whenElapsed) / alarm.repeatInterval;
        final long delta=alarm.count * alarm.repeatInterval;
        final long nextElapsed=alarm.whenElapsed + delta;
        setImplLocked(alarm.type,alarm.when + delta,nextElapsed,alarm.windowLength,maxTriggerTime(nowELAPSED,nextElapsed,alarm.repeatInterval),alarm.repeatInterval,alarm.operation,batch.standalone,true,alarm.workSource,alarm.alarmClock,alarm.userId);
      }
      if (alarm.wakeup) {
        hasWakeup=true;
      }
      if (alarm.alarmClock != null) {
        mNextAlarmClockMayChange=true;
      }
    }
  }
  mCurrentSeq++;
  calculateDeliveryPriorities(triggerList);
  Collections.sort(triggerList,mAlarmDispatchComparator);
  if (localLOGV) {
    for (int i=0; i < triggerList.size(); i++) {
      Slog.v(TAG,"Triggering alarm #" + i + ": "+ triggerList.get(i));
    }
  }
  return hasWakeup;
}
