{
  ArrayList<Alarm> triggerList=new ArrayList<Alarm>();
  while (true) {
    int result=waitForAlarm(mNativeData);
    triggerList.clear();
    if ((result & TIME_CHANGED_MASK) != 0) {
      if (DEBUG_BATCH) {
        Slog.v(TAG,"Time changed notification from kernel; rebatching");
      }
      removeImpl(mTimeTickSender);
      rebatchAllAlarms();
      mClockReceiver.scheduleTimeTickEvent();
synchronized (mLock) {
        mNumTimeChanged++;
      }
      Intent intent=new Intent(Intent.ACTION_TIME_CHANGED);
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      getContext().sendBroadcastAsUser(intent,UserHandle.ALL);
    }
synchronized (mLock) {
      final long nowRTC=System.currentTimeMillis();
      final long nowELAPSED=SystemClock.elapsedRealtime();
      if (localLOGV)       Slog.v(TAG,"Checking for alarms... rtc=" + nowRTC + ", elapsed="+ nowELAPSED);
      if (WAKEUP_STATS) {
        if ((result & IS_WAKEUP_MASK) != 0) {
          long newEarliest=nowRTC - RECENT_WAKEUP_PERIOD;
          int n=0;
          for (          WakeupEvent event : mRecentWakeups) {
            if (event.when > newEarliest)             break;
            n++;
          }
          for (int i=0; i < n; i++) {
            mRecentWakeups.remove();
          }
          recordWakeupAlarms(mAlarmBatches,nowELAPSED,nowRTC);
        }
      }
      boolean hasWakeup=triggerAlarmsLocked(triggerList,nowELAPSED,nowRTC);
      if (!hasWakeup && checkAllowNonWakeupDelayLocked(nowELAPSED)) {
        if (mPendingNonWakeupAlarms.size() == 0) {
          mStartCurrentDelayTime=nowELAPSED;
          mNextNonWakeupDeliveryTime=nowELAPSED + ((currentNonWakeupFuzzLocked(nowELAPSED) * 3) / 2);
        }
        mPendingNonWakeupAlarms.addAll(triggerList);
        mNumDelayedAlarms+=triggerList.size();
        rescheduleKernelAlarmsLocked();
        updateNextAlarmClockLocked();
      }
 else {
        rescheduleKernelAlarmsLocked();
        updateNextAlarmClockLocked();
        if (mPendingNonWakeupAlarms.size() > 0) {
          calculateDeliveryPriorities(mPendingNonWakeupAlarms);
          triggerList.addAll(mPendingNonWakeupAlarms);
          Collections.sort(triggerList,mAlarmDispatchComparator);
          final long thisDelayTime=nowELAPSED - mStartCurrentDelayTime;
          mTotalDelayTime+=thisDelayTime;
          if (mMaxDelayTime < thisDelayTime) {
            mMaxDelayTime=thisDelayTime;
          }
          mPendingNonWakeupAlarms.clear();
        }
        deliverAlarmsLocked(triggerList,nowELAPSED);
      }
    }
  }
}
