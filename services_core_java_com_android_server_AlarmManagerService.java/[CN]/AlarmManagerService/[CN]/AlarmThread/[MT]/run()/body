{
  ArrayList<Alarm> triggerList=new ArrayList<Alarm>();
  while (true) {
    int result=waitForAlarm(mNativeData);
    mLastWakeup=SystemClock.elapsedRealtime();
    triggerList.clear();
    final long nowRTC=System.currentTimeMillis();
    final long nowELAPSED=SystemClock.elapsedRealtime();
    if ((result & TIME_CHANGED_MASK) != 0) {
      final long lastTimeChangeClockTime;
      final long expectedClockTime;
synchronized (mLock) {
        lastTimeChangeClockTime=mLastTimeChangeClockTime;
        expectedClockTime=lastTimeChangeClockTime + (nowELAPSED - mLastTimeChangeRealtime);
      }
      if (lastTimeChangeClockTime == 0 || nowRTC < (expectedClockTime - 500) || nowRTC > (expectedClockTime + 500)) {
        if (DEBUG_BATCH) {
          Slog.v(TAG,"Time changed notification from kernel; rebatching");
        }
        removeImpl(mTimeTickSender);
        rebatchAllAlarms();
        mClockReceiver.scheduleTimeTickEvent();
synchronized (mLock) {
          mNumTimeChanged++;
          mLastTimeChangeClockTime=nowRTC;
          mLastTimeChangeRealtime=nowELAPSED;
        }
        Intent intent=new Intent(Intent.ACTION_TIME_CHANGED);
        intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        getContext().sendBroadcastAsUser(intent,UserHandle.ALL);
        result|=IS_WAKEUP_MASK;
      }
    }
    if (result != TIME_CHANGED_MASK) {
synchronized (mLock) {
        if (localLOGV)         Slog.v(TAG,"Checking for alarms... rtc=" + nowRTC + ", elapsed="+ nowELAPSED);
        if (WAKEUP_STATS) {
          if ((result & IS_WAKEUP_MASK) != 0) {
            long newEarliest=nowRTC - RECENT_WAKEUP_PERIOD;
            int n=0;
            for (            WakeupEvent event : mRecentWakeups) {
              if (event.when > newEarliest)               break;
              n++;
            }
            for (int i=0; i < n; i++) {
              mRecentWakeups.remove();
            }
            recordWakeupAlarms(mAlarmBatches,nowELAPSED,nowRTC);
          }
        }
        boolean hasWakeup=triggerAlarmsLocked(triggerList,nowELAPSED,nowRTC);
        if (!hasWakeup && checkAllowNonWakeupDelayLocked(nowELAPSED)) {
          if (mPendingNonWakeupAlarms.size() == 0) {
            mStartCurrentDelayTime=nowELAPSED;
            mNextNonWakeupDeliveryTime=nowELAPSED + ((currentNonWakeupFuzzLocked(nowELAPSED) * 3) / 2);
          }
          mPendingNonWakeupAlarms.addAll(triggerList);
          mNumDelayedAlarms+=triggerList.size();
          rescheduleKernelAlarmsLocked();
          updateNextAlarmClockLocked();
        }
 else {
          rescheduleKernelAlarmsLocked();
          updateNextAlarmClockLocked();
          if (mPendingNonWakeupAlarms.size() > 0) {
            calculateDeliveryPriorities(mPendingNonWakeupAlarms);
            triggerList.addAll(mPendingNonWakeupAlarms);
            Collections.sort(triggerList,mAlarmDispatchComparator);
            final long thisDelayTime=nowELAPSED - mStartCurrentDelayTime;
            mTotalDelayTime+=thisDelayTime;
            if (mMaxDelayTime < thisDelayTime) {
              mMaxDelayTime=thisDelayTime;
            }
            mPendingNonWakeupAlarms.clear();
          }
          deliverAlarmsLocked(triggerList,nowELAPSED);
        }
      }
    }
 else {
      rescheduleKernelAlarmsLocked();
    }
  }
}
