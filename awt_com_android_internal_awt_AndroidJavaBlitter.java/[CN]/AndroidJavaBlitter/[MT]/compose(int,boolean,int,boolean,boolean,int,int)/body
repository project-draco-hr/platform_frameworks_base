{
  int sa, sr, sg, sb, da, dr, dg, db;
  sa=(srcRGB >> 24) & 0xff;
  sr=(srcRGB >> 16) & 0xff;
  sg=(srcRGB >> 8) & 0xff;
  sb=srcRGB & 0xff;
  if (isSrcAlphaPre) {
    sa=mulLUT[srcConstAlpha][sa] & 0xff;
    sr=mulLUT[srcConstAlpha][sr] & 0xff;
    sg=mulLUT[srcConstAlpha][sg] & 0xff;
    sb=mulLUT[srcConstAlpha][sb] & 0xff;
  }
 else {
    sa=mulLUT[srcConstAlpha][sa] & 0xff;
    sr=mulLUT[sa][sr] & 0xff;
    sg=mulLUT[sa][sg] & 0xff;
    sb=mulLUT[sa][sb] & 0xff;
  }
  da=(dstRGB >> 24) & 0xff;
  dr=(dstRGB >> 16) & 0xff;
  dg=(dstRGB >> 8) & 0xff;
  db=dstRGB & 0xff;
  if (!isDstAlphaPre) {
    dr=mulLUT[da][dr] & 0xff;
    dg=mulLUT[da][dg] & 0xff;
    db=mulLUT[da][db] & 0xff;
  }
  int Fs=0;
  int Fd=0;
switch (rule) {
case AlphaComposite.CLEAR:
    break;
case AlphaComposite.DST:
  Fd=255;
break;
case AlphaComposite.DST_ATOP:
Fs=255 - da;
Fd=sa;
break;
case AlphaComposite.DST_IN:
Fd=sa;
break;
case AlphaComposite.DST_OUT:
Fd=255 - sa;
break;
case AlphaComposite.DST_OVER:
Fs=255 - da;
Fd=255;
break;
case AlphaComposite.SRC:
Fs=255;
break;
case AlphaComposite.SRC_ATOP:
Fs=da;
Fd=255 - sa;
break;
case AlphaComposite.SRC_IN:
Fs=da;
break;
case AlphaComposite.SRC_OUT:
Fs=255 - da;
break;
case AlphaComposite.SRC_OVER:
Fs=255;
Fd=255 - sa;
break;
case AlphaComposite.XOR:
Fs=255 - da;
Fd=255 - sa;
break;
}
dr=(mulLUT[sr][Fs] & 0xff) + (mulLUT[dr][Fd] & 0xff);
dg=(mulLUT[sg][Fs] & 0xff) + (mulLUT[dg][Fd] & 0xff);
db=(mulLUT[sb][Fs] & 0xff) + (mulLUT[db][Fd] & 0xff);
da=(mulLUT[sa][Fs] & 0xff) + (mulLUT[da][Fd] & 0xff);
if (!isDstAlphaPre) {
if (da != 255) {
dr=divLUT[da][dr] & 0xff;
dg=divLUT[da][dg] & 0xff;
db=divLUT[da][db] & 0xff;
}
}
if (!dstHasAlpha) {
da=0xff;
}
dstRGB=(da << 24) | (dr << 16) | (dg << 8)| db;
return dstRGB;
}
