{
  if (Config.LOGD) {
    Log.d(TAG,"_requestLocationUpdates: listener = " + listener.asBinder());
  }
  LocationProviderImpl impl=LocationProviderImpl.getProvider(provider);
  if (impl == null) {
    throw new IllegalArgumentException("provider=" + provider);
  }
  checkPermissions(provider);
  String[] packages=getPackageNames();
  long identity=Binder.clearCallingIdentity();
  try {
    Listener myListener=new Listener(listener);
    UpdateRecord r=new UpdateRecord(provider,minTime,minDistance,myListener,packages);
synchronized (mLocationListeners) {
      IBinder binder=listener.asBinder();
      if (mListeners.get(binder) == null) {
        try {
          binder.linkToDeath(myListener,0);
          mListeners.put(binder,myListener);
        }
 catch (        RemoteException e) {
          return;
        }
      }
      HashMap<String,UpdateRecord> records=mLocationListeners.get(binder);
      if (records == null) {
        records=new HashMap<String,UpdateRecord>();
        mLocationListeners.put(binder,records);
      }
      UpdateRecord oldRecord=records.put(provider,r);
      if (oldRecord != null) {
        oldRecord.dispose();
      }
      if (impl instanceof NetworkLocationProvider) {
        ((NetworkLocationProvider)impl).addListener(packages);
      }
      boolean isProviderEnabled=isAllowedBySettings(provider);
      if (isProviderEnabled) {
        long minTimeForProvider=getMinTime(provider);
        impl.setMinTime(minTimeForProvider);
        impl.enableLocationTracking(true);
        updateWakelockStatus(mScreenOn);
        mLocationHandler.removeMessages(MESSAGE_HEARTBEAT,provider);
        Message m=Message.obtain(mLocationHandler,MESSAGE_HEARTBEAT,provider);
        mLocationHandler.sendMessageAtTime(m,SystemClock.uptimeMillis() + 1000);
      }
 else {
        try {
          listener.onProviderDisabled(provider);
        }
 catch (        RemoteException e) {
          Log.w(TAG,"RemoteException calling onProviderDisabled on " + listener);
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}
