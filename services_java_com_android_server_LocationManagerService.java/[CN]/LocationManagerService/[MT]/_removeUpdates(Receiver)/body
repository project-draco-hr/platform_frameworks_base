{
  Object key=receiver.getKey();
  if (Config.LOGD) {
    Log.d(TAG,"_removeUpdates: listener = " + key);
  }
  mCallingUid=getCallingUid();
  long identity=Binder.clearCallingIdentity();
  try {
synchronized (mLocationListeners) {
      Receiver myReceiver=mListeners.remove(key);
      if ((myReceiver != null) && (myReceiver.isListener())) {
        myReceiver.getListener().asBinder().unlinkToDeath(myReceiver,0);
      }
      HashSet<String> providers=new HashSet<String>();
      HashMap<String,UpdateRecord> oldRecords=mLocationListeners.get(key);
      if (oldRecords != null) {
        for (        UpdateRecord record : oldRecords.values()) {
          if (record.mProvider.equals(LocationManager.NETWORK_PROVIDER)) {
            if (mNetworkLocationInterface != null) {
              mNetworkLocationInterface.removeListener(record.mPackages);
            }
          }
          record.dispose();
        }
        providers.addAll(oldRecords.keySet());
      }
      if (providers.contains("gps")) {
        try {
          mBatteryStats.noteRequestGpsOff(mCallingUid);
        }
 catch (        RemoteException e) {
          Log.w(TAG,"Got RemoteException calling noteRequestGpsOff",e);
        }
      }
      mLocationListeners.remove(key);
      mLastFixBroadcast.remove(key);
      mLastStatusBroadcast.remove(key);
      for (      String provider : providers) {
        if (!isAllowedBySettings(provider)) {
          continue;
        }
        boolean hasOtherListener=false;
synchronized (mRecordsByProvider) {
          HashSet<UpdateRecord> recordsForProvider=mRecordsByProvider.get(provider);
          if (recordsForProvider != null && recordsForProvider.size() > 0) {
            hasOtherListener=true;
          }
        }
        LocationProviderImpl p=LocationProviderImpl.getProvider(provider);
        if (p != null) {
          if (hasOtherListener) {
            p.setMinTime(getMinTime(provider));
          }
 else {
            mLocationHandler.removeMessages(MESSAGE_HEARTBEAT,provider);
            p.enableLocationTracking(false);
          }
        }
      }
      updateWakelockStatus(mScreenOn);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
    mCallingUid=-1;
  }
}
