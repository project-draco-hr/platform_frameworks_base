{
  if (LOCAL_LOGV) {
    Log.v(TAG,"_requestLocationUpdates: listener = " + receiver);
  }
  LocationProviderImpl impl=LocationProviderImpl.getProvider(provider);
  if (impl == null) {
    throw new IllegalArgumentException("provider=" + provider);
  }
  checkPermissionsSafe(provider);
  final int callingUid=Binder.getCallingUid();
  boolean newUid=!providerHasListener(provider,callingUid,null);
  long identity=Binder.clearCallingIdentity();
  try {
    UpdateRecord r=new UpdateRecord(provider,minTime,minDistance,receiver,callingUid);
    UpdateRecord oldRecord=receiver.mUpdateRecords.put(provider,r);
    if (oldRecord != null) {
      oldRecord.disposeLocked();
    }
    if (newUid) {
      impl.addListener(callingUid);
    }
    boolean isProviderEnabled=isAllowedBySettingsLocked(provider);
    if (isProviderEnabled) {
      long minTimeForProvider=getMinTimeLocked(provider);
      impl.setMinTime(minTimeForProvider);
      impl.enableLocationTracking(true);
      updateWakelockStatusLocked();
    }
 else {
      try {
        if (receiver.isListener()) {
          receiver.getListener().onProviderDisabled(provider);
        }
      }
 catch (      RemoteException e) {
        Log.w(TAG,"RemoteException calling onProviderDisabled on " + receiver.getListener());
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}
