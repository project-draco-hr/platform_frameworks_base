{
  HashSet<UpdateRecord> records=mRecordsByProvider.get(provider);
  if (records == null || records.size() == 0) {
    return;
  }
  LocationProviderImpl p=LocationProviderImpl.getProvider(provider);
  if (p == null) {
    return;
  }
  Location loc=mLocationsByProvider.get(provider);
  if (loc == null) {
    loc=new Location(provider);
    mLocationsByProvider.put(provider,loc);
  }
 else {
    loc.reset();
  }
  Location mockLoc=mMockProviderLocation.get(provider);
  boolean locationValid;
  if (mockLoc != null) {
    locationValid=true;
    loc.set(mockLoc);
  }
 else {
    locationValid=p.getLocation(loc);
  }
  if (locationValid) {
    Location location=mLastKnownLocation.get(provider);
    if (location == null) {
      mLastKnownLocation.put(provider,new Location(loc));
    }
 else {
      location.set(loc);
    }
    writeLastKnownLocation(provider,loc);
    if (p instanceof NetworkLocationProvider) {
      mWakeLockNetworkReceived=true;
    }
 else     if (p instanceof GpsLocationProvider) {
    }
  }
  long newStatusUpdateTime=p.getStatusUpdateTime();
  Long mockStatusUpdateTime=mMockProviderStatusUpdateTime.get(provider);
  if (mockStatusUpdateTime != null) {
    newStatusUpdateTime=mockStatusUpdateTime.longValue();
  }
  Bundle extras=new Bundle();
  int status=p.getStatus(extras);
  Integer mockStatus=mMockProviderStatus.get(provider);
  if (mockStatus != null) {
    status=mockStatus.intValue();
  }
  Bundle mockExtras=mMockProviderStatusExtras.get(provider);
  if (mockExtras != null) {
    extras.clear();
    extras.putAll(mockExtras);
  }
  for (  UpdateRecord r : records) {
    ILocationListener listener=r.mListener.mListener;
    IBinder binder=listener.asBinder();
    if (locationValid) {
      HashMap<String,Location> map=mLastFixBroadcast.get(binder);
      if (map == null) {
        map=new HashMap<String,Location>();
        mLastFixBroadcast.put(binder,map);
      }
      Location lastLoc=map.get(provider);
      if ((lastLoc == null) || shouldBroadcast(loc,lastLoc,r)) {
        if (lastLoc == null) {
          lastLoc=new Location(loc);
          map.put(provider,lastLoc);
        }
 else {
          lastLoc.set(loc);
        }
        try {
          listener.onLocationChanged(loc);
        }
 catch (        RemoteException doe) {
          Log.w(TAG,"RemoteException calling onLocationChanged on " + listener);
          _removeUpdates(listener);
        }
      }
    }
    HashMap<String,Long> statusMap=mLastStatusBroadcast.get(binder);
    if (statusMap == null) {
      statusMap=new HashMap<String,Long>();
      mLastStatusBroadcast.put(binder,statusMap);
    }
    long prevStatusUpdateTime=(statusMap.get(provider) != null) ? statusMap.get(provider) : 0;
    if ((newStatusUpdateTime > prevStatusUpdateTime) && (prevStatusUpdateTime != 0 || status != LocationProvider.AVAILABLE)) {
      statusMap.put(provider,newStatusUpdateTime);
      try {
        listener.onStatusChanged(provider,status,extras);
      }
 catch (      RemoteException doe) {
        Log.w(TAG,"RemoteException calling onStatusChanged on " + listener);
        _removeUpdates(listener);
      }
    }
  }
}
