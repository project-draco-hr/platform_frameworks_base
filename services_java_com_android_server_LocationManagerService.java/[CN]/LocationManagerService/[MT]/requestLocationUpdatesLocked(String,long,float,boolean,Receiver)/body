{
  LocationProviderInterface p=mProvidersByName.get(provider);
  if (p == null) {
    throw new IllegalArgumentException("requested provider " + provider + " doesn't exisit");
  }
  receiver.mRequiredPermissions=checkPermissionsSafe(provider,receiver.mRequiredPermissions);
  final int callingPid=Binder.getCallingPid();
  final int callingUid=Binder.getCallingUid();
  boolean newUid=!providerHasListener(provider,callingUid,null);
  long identity=Binder.clearCallingIdentity();
  try {
    UpdateRecord r=new UpdateRecord(provider,minTime,minDistance,singleShot,receiver,callingUid);
    UpdateRecord oldRecord=receiver.mUpdateRecords.put(provider,r);
    if (oldRecord != null) {
      oldRecord.disposeLocked();
    }
    if (newUid) {
      p.addListener(callingUid);
    }
    boolean isProviderEnabled=isAllowedBySettingsLocked(provider);
    if (isProviderEnabled) {
      long minTimeForProvider=getMinTimeLocked(provider);
      Slog.i(TAG,"request " + provider + " (pid "+ callingPid+ ") "+ minTime+ " "+ minTimeForProvider+ (singleShot ? " (singleshot)" : ""));
      p.setMinTime(minTimeForProvider,mTmpWorkSource);
      if (!singleShot || !p.requestSingleShotFix()) {
        p.enableLocationTracking(true);
      }
    }
 else {
      receiver.callProviderEnabledLocked(provider,false);
    }
    if (LOCAL_LOGV) {
      Slog.v(TAG,"_requestLocationUpdates: provider = " + provider + " listener = "+ receiver);
    }
  }
  finally {
    Binder.restoreCallingIdentity(identity);
  }
}
