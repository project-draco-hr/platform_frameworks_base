{
  if (mEnterAnimation != null) {
    mEnterAnimation.removeAllListeners();
    mEnterAnimation.cancel();
  }
  Rect targetTaskRect=ctx.targetTaskTransform.rect;
  float scale=(float)targetTaskRect.width() / getMeasuredWidth();
  float scaleYOffset=((1f - scale) * getMeasuredHeight()) / 2;
  float scaledTopInset=(int)(scale * mConfig.systemInsets.top);
  int translationY=(int)-scaleYOffset + (int)(mConfig.systemInsets.top - scaledTopInset) + targetTaskRect.top;
  int clipBottom=mConfig.systemInsets.top + (int)(targetTaskRect.height() / scale);
  float minScale=TaskStackViewLayoutAlgorithm.StackPeekMinScale;
  float scaleRange=1f - minScale;
  float dim=(1f - ctx.targetTaskTransform.scale) / scaleRange;
  dim=mDimInterpolator.getInterpolation(Math.min(dim,1f));
  int toDim=Math.max(0,Math.min(mMaxDim,(int)(dim * 255)));
  mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE,mLayerPaint);
  mEnterAnimation=new AnimatorSet();
  mEnterAnimation.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      post(new Runnable(){
        @Override public void run(){
          mIsAnimating=false;
          setLayerType(View.LAYER_TYPE_NONE,mLayerPaint);
          mCb.onEnterAnimationComplete();
          postAnimRunnable.run();
        }
      }
);
    }
  }
);
  mEnterAnimation.setStartDelay(0);
  mEnterAnimation.setDuration(475);
  mEnterAnimation.setInterpolator(mConfig.fastOutSlowInInterpolator);
  mEnterAnimation.playTogether(ObjectAnimator.ofInt(this,"clipBottom",clipBottom),ObjectAnimator.ofInt(this,"dim",toDim),ObjectAnimator.ofFloat(this,"translationY",translationY),ObjectAnimator.ofFloat(this,"scaleX",scale),ObjectAnimator.ofFloat(this,"scaleY",scale));
  setClipTop(mConfig.systemInsets.top);
  mEnterAnimation.start();
  mIsAnimating=true;
}
