{
  final List<Key> keys=mKeyboard.getKeys();
  final boolean shifted=mKeyboard.isShifted();
  int primaryIndex=NOT_A_KEY;
  int closestKey=NOT_A_KEY;
  int closestKeyDist=mProximityThreshold + 1;
  java.util.Arrays.fill(mDistances,Integer.MAX_VALUE);
  final int keyCount=keys.size();
  for (int i=0; i < keyCount; i++) {
    final Key key=keys.get(i);
    int dist=0;
    boolean isInside=key.isInside(x,y);
    if (((mProximityCorrectOn && (dist=key.squaredDistanceFrom(x,y)) < mProximityThreshold) || isInside) && key.codes[0] > 32) {
      final int nCodes=key.codes.length;
      if (dist < closestKeyDist) {
        closestKeyDist=dist;
        closestKey=i;
      }
      if (allKeys == null)       continue;
      for (int j=0; j < mDistances.length; j++) {
        if (mDistances[j] > dist) {
          System.arraycopy(mDistances,j,mDistances,j + nCodes,mDistances.length - j - nCodes);
          System.arraycopy(allKeys,j,allKeys,j + nCodes,allKeys.length - j - nCodes);
          for (int c=0; c < nCodes; c++) {
            allKeys[j + c]=key.codes[c];
            if (shifted) {
            }
            mDistances[j + c]=dist;
          }
          break;
        }
      }
    }
    if (isInside) {
      primaryIndex=i;
    }
  }
  if (primaryIndex == NOT_A_KEY) {
    primaryIndex=closestKey;
  }
  return primaryIndex;
}
