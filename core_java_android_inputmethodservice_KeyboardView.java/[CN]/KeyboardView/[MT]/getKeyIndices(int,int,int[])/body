{
  final Key[] keys=mKeys;
  int primaryIndex=NOT_A_KEY;
  int closestKey=NOT_A_KEY;
  int closestKeyDist=mProximityThreshold + 1;
  java.util.Arrays.fill(mDistances,Integer.MAX_VALUE);
  int[] nearestKeyIndices=mKeyboard.getNearestKeys(x,y);
  final int keyCount=nearestKeyIndices.length;
  for (int i=0; i < keyCount; i++) {
    final Key key=keys[nearestKeyIndices[i]];
    int dist=0;
    boolean isInside=key.isInside(x,y);
    if (((mProximityCorrectOn && (dist=key.squaredDistanceFrom(x,y)) < mProximityThreshold) || isInside) && key.codes[0] > 32) {
      final int nCodes=key.codes.length;
      if (dist < closestKeyDist) {
        closestKeyDist=dist;
        closestKey=nearestKeyIndices[i];
      }
      if (allKeys == null)       continue;
      for (int j=0; j < mDistances.length; j++) {
        if (mDistances[j] > dist) {
          System.arraycopy(mDistances,j,mDistances,j + nCodes,mDistances.length - j - nCodes);
          System.arraycopy(allKeys,j,allKeys,j + nCodes,allKeys.length - j - nCodes);
          for (int c=0; c < nCodes; c++) {
            allKeys[j + c]=key.codes[c];
            mDistances[j + c]=dist;
          }
          break;
        }
      }
    }
    if (isInside) {
      primaryIndex=nearestKeyIndices[i];
    }
  }
  if (primaryIndex == NOT_A_KEY) {
    primaryIndex=closestKey;
  }
  return primaryIndex;
}
