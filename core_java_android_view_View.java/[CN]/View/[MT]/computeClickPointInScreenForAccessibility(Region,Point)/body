{
  if (mAttachInfo == null) {
    return false;
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    return false;
  }
  RectF bounds=mAttachInfo.mTmpTransformRect;
  bounds.set(0,0,getWidth(),getHeight());
  List<RectF> intersections=mAttachInfo.mTmpRectList;
  intersections.clear();
  if (mParent instanceof ViewGroup) {
    ViewGroup parentGroup=(ViewGroup)mParent;
    if (!parentGroup.translateBoundsAndIntersectionsInWindowCoordinates(this,bounds,intersections)) {
      intersections.clear();
      return false;
    }
  }
  final int dx=mAttachInfo.mWindowLeft;
  final int dy=mAttachInfo.mWindowTop;
  bounds.offset(dx,dy);
  offsetRects(intersections,dx,dy);
  if (intersections.isEmpty() && interactiveRegion == null) {
    outPoint.set((int)bounds.centerX(),(int)bounds.centerY());
  }
 else {
    Region region=new Region();
    region.set((int)bounds.left,(int)bounds.top,(int)bounds.right,(int)bounds.bottom);
    final int intersectionCount=intersections.size();
    for (int i=intersectionCount - 1; i >= 0; i--) {
      RectF intersection=intersections.remove(i);
      region.op((int)intersection.left,(int)intersection.top,(int)intersection.right,(int)intersection.bottom,Region.Op.DIFFERENCE);
    }
    if (region.isEmpty()) {
      return false;
    }
    if (interactiveRegion != null) {
      region.op(interactiveRegion,Region.Op.INTERSECT);
    }
    if (region.isEmpty()) {
      return false;
    }
    if (region.isRect()) {
      Rect regionBounds=mAttachInfo.mTmpInvalRect;
      region.getBounds(regionBounds);
      outPoint.set(regionBounds.centerX(),regionBounds.centerY());
      return true;
    }
    Path path=region.getBoundaryPath();
    PathMeasure pathMeasure=new PathMeasure(path,false);
    final float[] coordinates=mAttachInfo.mTmpTransformLocation;
    final float point=pathMeasure.getLength() * 0.01f;
    if (!pathMeasure.getPosTan(point,coordinates,null)) {
      return false;
    }
    outPoint.set(Math.round(coordinates[0]),Math.round(coordinates[1]));
  }
  return true;
}
