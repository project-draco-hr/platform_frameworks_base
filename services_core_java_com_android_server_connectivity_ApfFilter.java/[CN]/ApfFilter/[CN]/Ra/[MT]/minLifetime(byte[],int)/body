{
  long minLifetime=Long.MAX_VALUE;
  ByteBuffer byteBuffer=ByteBuffer.wrap(packet);
  for (int i=0; (i + 1) < mNonLifetimes.size(); i++) {
    int offset=mNonLifetimes.get(i).first + mNonLifetimes.get(i).second;
    if (offset == ICMP6_RA_CHECKSUM_OFFSET) {
      continue;
    }
    int lifetimeLength=mNonLifetimes.get(i + 1).first - offset;
    long val;
switch (lifetimeLength) {
case 2:
      val=byteBuffer.getShort(offset);
    break;
case 4:
  val=byteBuffer.getInt(offset);
break;
default :
throw new IllegalStateException("bogus lifetime size " + length);
}
val&=(1L << (lifetimeLength * 8)) - 1;
minLifetime=Math.min(minLifetime,val);
}
return minLifetime;
}
