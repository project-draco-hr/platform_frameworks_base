{
  String nextFilterLabel="Ra" + getUniqueNumber();
  gen.addLoadFromMemory(Register.R0,gen.PACKET_SIZE_MEMORY_SLOT);
  gen.addJumpIfR0NotEquals(mPacket.limit(),nextFilterLabel);
  int filterLifetime=(int)(currentLifetime() / FRACTION_OF_LIFETIME_TO_FILTER);
  gen.addLoadFromMemory(Register.R0,gen.FILTER_AGE_MEMORY_SLOT);
  gen.addJumpIfR0GreaterThan(filterLifetime,nextFilterLabel);
  for (int i=0; i < mNonLifetimes.size(); i++) {
    Pair<Integer,Integer> nonLifetime=mNonLifetimes.get(i);
    gen.addLoadImmediate(Register.R0,nonLifetime.first);
    gen.addJumpIfBytesNotEqual(Register.R0,Arrays.copyOfRange(mPacket.array(),nonLifetime.first,nonLifetime.first + nonLifetime.second),nextFilterLabel);
    if ((i + 1) < mNonLifetimes.size()) {
      Pair<Integer,Integer> nextNonLifetime=mNonLifetimes.get(i + 1);
      int offset=nonLifetime.first + nonLifetime.second;
      if (offset == ICMP6_RA_CHECKSUM_OFFSET) {
        continue;
      }
      int length=nextNonLifetime.first - offset;
switch (length) {
case 4:
        gen.addLoad32(Register.R0,offset);
      break;
case 2:
    gen.addLoad16(Register.R0,offset);
  break;
default :
throw new IllegalStateException("bogus lifetime size " + length);
}
gen.addJumpIfR0LessThan(filterLifetime,nextFilterLabel);
}
}
gen.addJump(gen.DROP_LABEL);
gen.defineLabel(nextFilterLabel);
return filterLifetime;
}
