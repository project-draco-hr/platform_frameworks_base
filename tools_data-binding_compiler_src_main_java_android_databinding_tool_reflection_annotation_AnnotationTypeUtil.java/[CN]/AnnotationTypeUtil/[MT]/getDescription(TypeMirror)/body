{
  if (typeMirror == null) {
    throw new UnsupportedOperationException();
  }
switch (typeMirror.getKind()) {
case BOOLEAN:
    return BOOLEAN;
case BYTE:
  return BYTE;
case SHORT:
return SHORT;
case INT:
return INT;
case LONG:
return LONG;
case CHAR:
return CHAR;
case FLOAT:
return FLOAT;
case DOUBLE:
return DOUBLE;
case DECLARED:
return CLASS_PREFIX + mTypes.erasure(typeMirror).toString().replace('.','/') + CLASS_SUFFIX;
case VOID:
return VOID;
case ARRAY:
final ArrayType arrayType=(ArrayType)typeMirror;
final String componentType=getDescription(arrayType.getComponentType());
return ARRAY + componentType;
case TYPEVAR:
final TypeVariable typeVariable=(TypeVariable)typeMirror;
final String name=typeVariable.toString();
return CLASS_PREFIX + name.replace('.','/') + CLASS_SUFFIX;
case EXECUTABLE:
final ExecutableType executableType=(ExecutableType)typeMirror;
final int argStart=mTypes.erasure(executableType).toString().indexOf('(');
final String methodName=executableType.toString().substring(0,argStart);
final String args=joinArgs(executableType.getParameterTypes());
return methodName + "(" + args+ ")"+ getDescription(executableType.getReturnType());
default :
throw new UnsupportedOperationException("cannot understand type " + typeMirror.toString() + ", kind:"+ typeMirror.getKind().name());
}
}
