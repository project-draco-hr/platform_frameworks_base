{
  int padL=0;
  int padT=0;
  int padR=0;
  int padB=0;
  final Rect outRect=mTmpOutRect;
  final int layoutDirection=getLayoutDirection();
  final boolean nest=mLayerState.mPaddingMode == PADDING_MODE_NEST;
  final ChildDrawable[] array=mLayerState.mChildren;
  final int N=mLayerState.mNum;
  for (int i=0; i < N; i++) {
    final ChildDrawable r=array[i];
    final Drawable d=r.mDrawable;
    if (d == null) {
      continue;
    }
    final Rect container=mTmpContainer;
    container.set(d.getBounds());
    final int insetL, insetR;
    if (layoutDirection == LayoutDirection.RTL) {
      insetL=r.mInsetE == UNDEFINED_INSET ? r.mInsetL : r.mInsetE;
      insetR=r.mInsetS == UNDEFINED_INSET ? r.mInsetR : r.mInsetS;
    }
 else {
      insetL=r.mInsetS == UNDEFINED_INSET ? r.mInsetL : r.mInsetS;
      insetR=r.mInsetE == UNDEFINED_INSET ? r.mInsetR : r.mInsetE;
    }
    container.set(bounds.left + insetL + padL,bounds.top + r.mInsetT + padT,bounds.right - insetR - padR,bounds.bottom - r.mInsetB - padB);
    final int gravity=resolveGravity(r.mGravity,r.mWidth,r.mHeight);
    final int w=r.mWidth < 0 ? d.getIntrinsicWidth() : r.mWidth;
    final int h=r.mHeight < 0 ? d.getIntrinsicHeight() : r.mHeight;
    Gravity.apply(gravity,w,h,container,outRect,layoutDirection);
    d.setBounds(outRect);
    if (nest) {
      padL+=mPaddingL[i];
      padR+=mPaddingR[i];
      padT+=mPaddingT[i];
      padB+=mPaddingB[i];
    }
  }
}
