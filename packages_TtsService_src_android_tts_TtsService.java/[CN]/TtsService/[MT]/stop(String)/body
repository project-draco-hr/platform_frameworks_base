{
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      Log.i(SERVICE_TAG,"Stopping");
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mCallingApp.equals(callingApp)) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && mCurrentSpeechItem.mCallingApp.equals(callingApp)) {
        try {
          result=sNativeSynth.stop();
        }
 catch (        NullPointerException e1) {
          result=TextToSpeech.ERROR;
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(SERVICE_TAG,"Stopped");
    }
 else {
      Log.e(SERVICE_TAG,"TTS stop(): queue locked longer than expected");
      result=TextToSpeech.ERROR;
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,"TTS stop: tryLock interrupted");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}
