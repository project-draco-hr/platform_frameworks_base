{
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.setPriority(Thread.MIN_PRIORITY);
          synth.start();
          return;
        }
        if (params != null) {
          String language="";
          String country="";
          String variant="";
          for (int i=0; i < params.size() - 1; i=i + 2) {
            String param=params.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_RATE)) {
                setSpeechRate("",Integer.parseInt(params.get(i + 1)));
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_LANGUAGE)) {
                language=params.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_COUNTRY)) {
                country=params.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.TTS_KEY_PARAM_VARIANT)) {
                variant=params.get(i + 1);
              }
            }
          }
          if (language.length() > 0) {
            setLanguage("",language,country,variant);
          }
        }
        nativeSynth.speak(text);
      }
 catch (      InterruptedException e) {
        Log.e("TTS speakInternalOnly","tryLock interrupted");
        e.printStackTrace();
      }
 finally {
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MIN_PRIORITY);
  synth.start();
}
