{
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock();
    if (!speechQueueAvailable) {
      return;
    }
    if (mSpeechQueue.size() < 1) {
      mIsSpeaking=false;
      broadcastTtsQueueProcessingCompleted();
      return;
    }
    SpeechItem currentSpeechItem=mSpeechQueue.get(0);
    mIsSpeaking=true;
    SoundResource sr=getSoundResource(currentSpeechItem);
    Log.i("TTS processing: ",currentSpeechItem.mText);
    if (sr == null) {
      if (currentSpeechItem.mType == SpeechItem.TEXT) {
        currentSpeechItem=splitCurrentTextIfNeeded(currentSpeechItem);
        speakInternalOnly(currentSpeechItem.mText,currentSpeechItem.mParams);
      }
 else       if (currentSpeechItem.mType == SpeechItem.TEXT_TO_FILE) {
        synthToFileInternalOnly(currentSpeechItem.mText,currentSpeechItem.mParams,currentSpeechItem.mFilename);
      }
 else {
        silence(currentSpeechItem.mDuration);
      }
    }
 else {
      cleanUpPlayer();
      if (sr.mSourcePackageName == PKGNAME) {
        mPlayer=MediaPlayer.create(this,sr.mResId);
      }
 else       if (sr.mSourcePackageName != null) {
        Context ctx;
        try {
          ctx=this.createPackageContext(sr.mSourcePackageName,0);
        }
 catch (        NameNotFoundException e) {
          e.printStackTrace();
          mSpeechQueue.remove(0);
          mIsSpeaking=false;
          return;
        }
        mPlayer=MediaPlayer.create(ctx,sr.mResId);
      }
 else {
        mPlayer=MediaPlayer.create(this,Uri.parse(sr.mFilename));
      }
      if (mPlayer == null) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        return;
      }
      mPlayer.setOnCompletionListener(this);
      try {
        mPlayer.setAudioStreamType(getStreamTypeFromParams(currentSpeechItem.mParams));
        mPlayer.start();
      }
 catch (      IllegalStateException e) {
        mSpeechQueue.clear();
        mIsSpeaking=false;
        cleanUpPlayer();
        return;
      }
    }
    if (mSpeechQueue.size() > 0) {
      mSpeechQueue.remove(0);
    }
  }
  finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
  }
}
