{
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      mSpeechQueue.clear();
      if (mCurrentSpeechItem != null) {
        result=sNativeSynth.stopSync();
        mKillList.put(mCurrentSpeechItem,true);
        mIsSpeaking=false;
        if (mCurrentSpeechItem.mType == SpeechItem.TEXT_TO_FILE) {
          if (mCurrentSpeechItem.mFilename != null) {
            File tempFile=new File(mCurrentSpeechItem.mFilename);
            Log.v(SERVICE_TAG,"Leaving behind " + mCurrentSpeechItem.mFilename);
            if (tempFile.exists()) {
              Log.v(SERVICE_TAG,"About to delete " + mCurrentSpeechItem.mFilename);
              if (tempFile.delete()) {
                Log.v(SERVICE_TAG,"file successfully deleted");
              }
            }
          }
        }
        mCurrentSpeechItem=null;
      }
    }
 else {
      Log.e(SERVICE_TAG,"TTS killAllUtterances(): queue locked longer than expected");
      result=TextToSpeech.ERROR;
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,"TTS killAllUtterances(): tryLock interrupted");
    result=TextToSpeech.ERROR;
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}
