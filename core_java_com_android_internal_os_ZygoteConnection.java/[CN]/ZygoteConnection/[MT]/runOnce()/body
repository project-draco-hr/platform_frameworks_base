{
  String args[];
  Arguments parsedArgs=null;
  FileDescriptor[] descriptors;
  long startTime=SystemClock.elapsedRealtime();
  try {
    args=readArgumentList();
    descriptors=mSocket.getAncillaryFileDescriptors();
  }
 catch (  IOException ex) {
    Log.w(TAG,"IOException on command socket " + ex.getMessage());
    closeSocket();
    return true;
  }
  checkTime(startTime,"zygoteConnection.runOnce: readArgumentList");
  if (args == null) {
    closeSocket();
    return true;
  }
  PrintStream newStderr=null;
  if (descriptors != null && descriptors.length >= 3) {
    newStderr=new PrintStream(new FileOutputStream(descriptors[2]));
  }
  int pid=-1;
  FileDescriptor childPipeFd=null;
  FileDescriptor serverPipeFd=null;
  try {
    parsedArgs=new Arguments(args);
    if (parsedArgs.abiListQuery) {
      return handleAbiListQuery();
    }
    if (parsedArgs.permittedCapabilities != 0 || parsedArgs.effectiveCapabilities != 0) {
      throw new ZygoteSecurityException("Client may not specify capabilities: " + "permitted=0x" + Long.toHexString(parsedArgs.permittedCapabilities) + ", effective=0x"+ Long.toHexString(parsedArgs.effectiveCapabilities));
    }
    applyUidSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyRlimitSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyInvokeWithSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    applyseInfoSecurityPolicy(parsedArgs,peer,peerSecurityContext);
    checkTime(startTime,"zygoteConnection.runOnce: apply security policies");
    applyDebuggerSystemProperty(parsedArgs);
    applyInvokeWithSystemProperty(parsedArgs);
    checkTime(startTime,"zygoteConnection.runOnce: apply security policies");
    int[][] rlimits=null;
    if (parsedArgs.rlimits != null) {
      rlimits=parsedArgs.rlimits.toArray(intArray2d);
    }
    if (parsedArgs.runtimeInit && parsedArgs.invokeWith != null) {
      FileDescriptor[] pipeFds=Os.pipe();
      childPipeFd=pipeFds[1];
      serverPipeFd=pipeFds[0];
      ZygoteInit.setCloseOnExec(serverPipeFd,true);
    }
    int[] fdsToClose={-1,-1};
    FileDescriptor fd=mSocket.getFileDescriptor();
    if (fd != null) {
      fdsToClose[0]=fd.getInt$();
    }
    fd=ZygoteInit.getServerSocketFileDescriptor();
    if (fd != null) {
      fdsToClose[1]=fd.getInt$();
    }
    fd=null;
    checkTime(startTime,"zygoteConnection.runOnce: preForkAndSpecialize");
    pid=Zygote.forkAndSpecialize(parsedArgs.uid,parsedArgs.gid,parsedArgs.gids,parsedArgs.debugFlags,rlimits,parsedArgs.mountExternal,parsedArgs.seInfo,parsedArgs.niceName,fdsToClose,parsedArgs.instructionSet,parsedArgs.appDataDir);
    checkTime(startTime,"zygoteConnection.runOnce: postForkAndSpecialize");
  }
 catch (  IOException ex) {
    logAndPrintError(newStderr,"Exception creating pipe",ex);
  }
catch (  ErrnoException ex) {
    logAndPrintError(newStderr,"Exception creating pipe",ex);
  }
catch (  IllegalArgumentException ex) {
    logAndPrintError(newStderr,"Invalid zygote arguments",ex);
  }
catch (  ZygoteSecurityException ex) {
    logAndPrintError(newStderr,"Zygote security policy prevents request: ",ex);
  }
  try {
    if (pid == 0) {
      IoUtils.closeQuietly(serverPipeFd);
      serverPipeFd=null;
      handleChildProc(parsedArgs,descriptors,childPipeFd,newStderr);
      return true;
    }
 else {
      IoUtils.closeQuietly(childPipeFd);
      childPipeFd=null;
      return handleParentProc(pid,descriptors,serverPipeFd,parsedArgs);
    }
  }
  finally {
    IoUtils.closeQuietly(childPipeFd);
    IoUtils.closeQuietly(serverPipeFd);
  }
}
