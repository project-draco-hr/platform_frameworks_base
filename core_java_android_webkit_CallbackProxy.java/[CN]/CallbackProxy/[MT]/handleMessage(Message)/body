{
switch (msg.what) {
case PAGE_STARTED:
    if (mWebViewClient != null) {
      mWebViewClient.onPageStarted(mWebView,msg.getData().getString("url"),(Bitmap)msg.obj);
    }
  break;
case PAGE_FINISHED:
if (mWebViewClient != null) {
  mWebViewClient.onPageFinished(mWebView,(String)msg.obj);
}
break;
case RECEIVED_ICON:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedIcon(mWebView,(Bitmap)msg.obj);
}
break;
case RECEIVED_TITLE:
if (mWebChromeClient != null) {
mWebChromeClient.onReceivedTitle(mWebView,(String)msg.obj);
}
break;
case TOO_MANY_REDIRECTS:
Message cancelMsg=(Message)msg.getData().getParcelable("cancelMsg");
Message continueMsg=(Message)msg.getData().getParcelable("continueMsg");
if (mWebViewClient != null) {
mWebViewClient.onTooManyRedirects(mWebView,cancelMsg,continueMsg);
}
 else {
cancelMsg.sendToTarget();
}
break;
case REPORT_ERROR:
if (mWebViewClient != null) {
int reasonCode=msg.arg1;
final String description=msg.getData().getString("description");
final String failUrl=msg.getData().getString("failingUrl");
mWebViewClient.onReceivedError(mWebView,reasonCode,description,failUrl);
}
break;
case RESEND_POST_DATA:
Message resend=(Message)msg.getData().getParcelable("resend");
Message dontResend=(Message)msg.getData().getParcelable("dontResend");
if (mWebViewClient != null) {
mWebViewClient.onFormResubmission(mWebView,dontResend,resend);
}
 else {
dontResend.sendToTarget();
}
break;
case OVERRIDE_URL:
String overrideUrl=msg.getData().getString("url");
boolean override=uiOverrideUrlLoading(overrideUrl);
ResultTransport<Boolean> result=(ResultTransport<Boolean>)msg.obj;
synchronized (this) {
result.setResult(override);
notify();
}
break;
case AUTH_REQUEST:
if (mWebViewClient != null) {
HttpAuthHandler handler=(HttpAuthHandler)msg.obj;
String host=msg.getData().getString("host");
String realm=msg.getData().getString("realm");
mWebViewClient.onReceivedHttpAuthRequest(mWebView,handler,host,realm);
}
break;
case SSL_ERROR:
if (mWebViewClient != null) {
HashMap<String,Object> map=(HashMap<String,Object>)msg.obj;
mWebViewClient.onReceivedSslError(mWebView,(SslErrorHandler)map.get("handler"),(SslError)map.get("error"));
}
break;
case PROGRESS:
synchronized (this) {
if (mWebChromeClient != null) {
mWebChromeClient.onProgressChanged(mWebView,mLatestProgress);
}
mProgressUpdatePending=false;
}
break;
case UPDATE_VISITED:
if (mWebViewClient != null) {
mWebViewClient.doUpdateVisitedHistory(mWebView,(String)msg.obj,msg.arg1 != 0);
}
break;
case LOAD_RESOURCE:
if (mWebViewClient != null) {
mWebViewClient.onLoadResource(mWebView,(String)msg.obj);
}
break;
case DOWNLOAD_FILE:
if (mDownloadListener != null) {
String url=msg.getData().getString("url");
String userAgent=msg.getData().getString("userAgent");
String contentDisposition=msg.getData().getString("contentDisposition");
String mimetype=msg.getData().getString("mimetype");
Long contentLength=msg.getData().getLong("contentLength");
mDownloadListener.onDownloadStart(url,userAgent,contentDisposition,mimetype,contentLength);
}
break;
case CREATE_WINDOW:
if (mWebChromeClient != null) {
if (!mWebChromeClient.onCreateWindow(mWebView,msg.arg1 == 1,msg.arg2 == 1,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
}
break;
case REQUEST_FOCUS:
if (mWebChromeClient != null) {
mWebChromeClient.onRequestFocus(mWebView);
}
break;
case CLOSE_WINDOW:
if (mWebChromeClient != null) {
mWebChromeClient.onCloseWindow((WebView)msg.obj);
}
break;
case SAVE_PASSWORD:
Bundle bundle=msg.getData();
String host=bundle.getString("host");
String username=bundle.getString("username");
String password=bundle.getString("password");
if (!mWebView.onSavePassword(host,username,password,(Message)msg.obj)) {
synchronized (this) {
notify();
}
}
break;
case ASYNC_KEYEVENTS:
if (mWebViewClient != null) {
mWebViewClient.onUnhandledKeyEvent(mWebView,(KeyEvent)msg.obj);
}
break;
case JS_ALERT:
if (mWebChromeClient != null) {
JsResult res=(JsResult)msg.obj;
String message=msg.getData().getString("message");
String url=msg.getData().getString("url");
if (!mWebChromeClient.onJsAlert(mWebView,url,message,res)) {
res.handleDefault();
}
res.setReady();
}
break;
case JS_CONFIRM:
if (mWebChromeClient != null) {
JsResult res=(JsResult)msg.obj;
String message=msg.getData().getString("message");
String url=msg.getData().getString("url");
if (!mWebChromeClient.onJsConfirm(mWebView,url,message,res)) {
res.handleDefault();
}
res.setReady();
}
break;
case JS_PROMPT:
if (mWebChromeClient != null) {
JsPromptResult res=(JsPromptResult)msg.obj;
String message=msg.getData().getString("message");
String defaultVal=msg.getData().getString("default");
String url=msg.getData().getString("url");
if (!mWebChromeClient.onJsPrompt(mWebView,url,message,defaultVal,res)) {
res.handleDefault();
}
res.setReady();
}
break;
case JS_UNLOAD:
if (mWebChromeClient != null) {
JsResult res=(JsResult)msg.obj;
String message=msg.getData().getString("message");
String url=msg.getData().getString("url");
if (!mWebChromeClient.onJsBeforeUnload(mWebView,url,message,res)) {
res.handleDefault();
}
res.setReady();
}
break;
case RECEIVED_CERTIFICATE:
mWebView.setCertificate((SslCertificate)msg.obj);
break;
case NOTIFY:
synchronized (this) {
notify();
}
break;
case SCALE_CHANGED:
if (mWebViewClient != null) {
mWebViewClient.onScaleChanged(mWebView,msg.getData().getFloat("old"),msg.getData().getFloat("new"));
}
break;
case SWITCH_OUT_HISTORY:
mWebView.switchOutDrawHistory();
break;
}
}
