{
synchronized (mLock) {
    pw.println();
    pw.println("Display Controller Locked State:");
    pw.println("  mDisplayReadyLocked=" + mDisplayReadyLocked);
    pw.println("  mPendingRequestLocked=" + mPendingRequestLocked);
    pw.println("  mPendingRequestChangedLocked=" + mPendingRequestChangedLocked);
    pw.println("  mPendingWaitForNegativeProximityLocked=" + mPendingWaitForNegativeProximityLocked);
    pw.println("  mPendingUpdatePowerStateLocked=" + mPendingUpdatePowerStateLocked);
  }
  pw.println();
  pw.println("Display Controller Configuration:");
  pw.println("  mScreenBrightnessDimConfig=" + mScreenBrightnessDimConfig);
  pw.println("  mUseSoftwareAutoBrightnessConfig=" + mUseSoftwareAutoBrightnessConfig);
  pw.println("  mAutoBrightnessLevelsConfig=" + Arrays.toString(mAutoBrightnessLevelsConfig));
  pw.println("  mAutoBrightnessLcdBacklightValuesConfig=" + Arrays.toString(mAutoBrightnessLcdBacklightValuesConfig));
  pw.println("  mLightSensorWarmUpTimeConfig=" + mLightSensorWarmUpTimeConfig);
  if (Looper.myLooper() == mHandler.getLooper()) {
    dumpLocal(pw);
  }
 else {
    final StringWriter out=new StringWriter();
    final CountDownLatch latch=new CountDownLatch(1);
    Message msg=Message.obtain(mHandler,new Runnable(){
      @Override public void run(){
        PrintWriter localpw=new PrintWriter(out);
        try {
          dumpLocal(localpw);
        }
  finally {
          localpw.flush();
          latch.countDown();
        }
      }
    }
);
    msg.setAsynchronous(true);
    mHandler.sendMessage(msg);
    try {
      latch.await();
      pw.print(out.toString());
    }
 catch (    InterruptedException ex) {
      pw.println();
      pw.println("Failed to dump thread state due to interrupted exception!");
    }
  }
}
