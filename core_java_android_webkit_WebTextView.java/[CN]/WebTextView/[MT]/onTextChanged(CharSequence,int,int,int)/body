{
  super.onTextChanged(s,start,before,count);
  String postChange=s.toString();
  if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0,mMaxLength).equals(postChange))) {
    return;
  }
  mPreChange=postChange;
  if (0 == count) {
    if (before > 0) {
      updateCachedTextfield();
      if (mGotDelete) {
        mGotDelete=false;
        int oldEnd=start + before;
        if (mDelSelEnd == oldEnd && (mDelSelStart == start || (mDelSelStart == oldEnd && before == 1))) {
          sendDomEvent(new KeyEvent(KeyEvent.ACTION_DOWN,KeyEvent.KEYCODE_DEL));
          sendDomEvent(new KeyEvent(KeyEvent.ACTION_UP,KeyEvent.KEYCODE_DEL));
          return;
        }
      }
      mWebView.deleteSelection(start,start + before);
    }
    mGotDelete=false;
    return;
  }
  mGotDelete=false;
  TextUtils.getChars(s,start + count - 1,start + count,mCharacter,0);
  KeyCharacterMap kmap=KeyCharacterMap.load(KeyCharacterMap.VIRTUAL_KEYBOARD);
  KeyEvent[] events=kmap.getEvents(mCharacter);
  boolean cannotUseKeyEvents=null == events;
  int charactersFromKeyEvents=cannotUseKeyEvents ? 0 : 1;
  if (count > 1 || cannotUseKeyEvents) {
    String replace=s.subSequence(start,start + count - charactersFromKeyEvents).toString();
    mWebView.replaceTextfieldText(start,start + before,replace,start + count - charactersFromKeyEvents,start + count - charactersFromKeyEvents);
  }
 else {
    if (DebugFlags.WEB_TEXT_VIEW) {
      Log.v(LOGTAG,"onTextChanged start=" + start + " start + before="+ (start + before));
    }
    if (!mInSetTextAndKeepSelection) {
      mWebView.setSelection(start,start + before);
    }
  }
  if (!cannotUseKeyEvents) {
    int length=events.length;
    for (int i=0; i < length; i++) {
      if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
        sendDomEvent(events[i]);
      }
    }
  }
  updateCachedTextfield();
}
