{
  super.onTextChanged(s,start,before,count);
  String postChange=s.toString();
  if (mPreChange == null || mPreChange.equals(postChange) || (mMaxLength > -1 && mPreChange.length() > mMaxLength && mPreChange.substring(0,mMaxLength).equals(postChange))) {
    return;
  }
  mPreChange=postChange;
  if (before > 0 && 0 == count) {
    mWebView.deleteSelection(start,start + before);
    updateCachedTextfield();
    return;
  }
  TextUtils.getChars(s,start + count - 1,start + count,mCharacter,0);
  KeyCharacterMap kmap=KeyCharacterMap.load(KeyCharacterMap.BUILT_IN_KEYBOARD);
  KeyEvent[] events=kmap.getEvents(mCharacter);
  boolean cannotUseKeyEvents=null == events;
  int charactersFromKeyEvents=cannotUseKeyEvents ? 0 : 1;
  if (count > 1 || cannotUseKeyEvents) {
    String replace=s.subSequence(start,start + count - charactersFromKeyEvents).toString();
    mWebView.replaceTextfieldText(start,start + before,replace,start + count - charactersFromKeyEvents,start + count - charactersFromKeyEvents);
  }
 else {
    if (DebugFlags.WEB_TEXT_VIEW) {
      Log.v(LOGTAG,"onTextChanged start=" + start + " start + before="+ (start + before));
    }
    if (!mInSetTextAndKeepSelection) {
      mWebView.setSelection(start,start + before);
    }
  }
  if (!cannotUseKeyEvents) {
    int length=events.length;
    for (int i=0; i < length; i++) {
      if (!KeyEvent.isModifierKey(events[i].getKeyCode())) {
        sendDomEvent(events[i]);
      }
    }
  }
  updateCachedTextfield();
}
