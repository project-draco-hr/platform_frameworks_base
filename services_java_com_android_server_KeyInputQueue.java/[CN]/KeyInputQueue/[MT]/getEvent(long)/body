{
  long begin=SystemClock.uptimeMillis();
  final long end=begin + timeoutMS;
  long now=begin;
synchronized (mFirst) {
    while (mFirst.next == mLast && end > now) {
      try {
        mWakeLock.release();
        mFirst.wait(end - now);
      }
 catch (      InterruptedException e) {
      }
      now=SystemClock.uptimeMillis();
      if (begin > now) {
        begin=now;
      }
    }
    if (mFirst.next == mLast) {
      return null;
    }
    QueuedEvent p=mFirst.next;
    mFirst.next=p.next;
    mFirst.next.prev=mFirst;
    p.inQueue=false;
    return p;
  }
}
