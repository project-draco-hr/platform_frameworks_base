{
  final boolean mustNotify;
  boolean mustInitialize=false;
  boolean autoBrightnessAdjustmentChanged=false;
synchronized (mLock) {
    mPendingUpdatePowerStateLocked=false;
    if (mPendingRequestLocked == null) {
      return;
    }
    if (mPowerRequest == null) {
      mPowerRequest=new DisplayPowerRequest(mPendingRequestLocked);
      mWaitingForNegativeProximity=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mustInitialize=true;
    }
 else     if (mPendingRequestChangedLocked) {
      autoBrightnessAdjustmentChanged=(mPowerRequest.screenAutoBrightnessAdjustment != mPendingRequestLocked.screenAutoBrightnessAdjustment);
      mPowerRequest.copyFrom(mPendingRequestLocked);
      mWaitingForNegativeProximity|=mPendingWaitForNegativeProximityLocked;
      mPendingWaitForNegativeProximityLocked=false;
      mPendingRequestChangedLocked=false;
      mDisplayReadyLocked=false;
    }
    mustNotify=!mDisplayReadyLocked;
  }
  if (mustInitialize) {
    initialize();
  }
  int state;
  int brightness=PowerManager.BRIGHTNESS_DEFAULT;
  boolean performScreenOffTransition=false;
switch (mPowerRequest.policy) {
case DisplayPowerRequest.POLICY_OFF:
    state=Display.STATE_OFF;
  performScreenOffTransition=true;
break;
case DisplayPowerRequest.POLICY_DOZE:
if (mPowerRequest.dozeScreenState != Display.STATE_UNKNOWN) {
state=mPowerRequest.dozeScreenState;
}
 else {
state=Display.STATE_DOZE;
}
if (!mAllowAutoBrightnessWhileDozingConfig) {
brightness=mPowerRequest.dozeScreenBrightness;
}
break;
case DisplayPowerRequest.POLICY_DIM:
case DisplayPowerRequest.POLICY_BRIGHT:
default :
state=Display.STATE_ON;
break;
}
assert(state != Display.STATE_UNKNOWN);
if (mProximitySensor != null) {
if (mPowerRequest.useProximitySensor && state != Display.STATE_OFF) {
setProximitySensorEnabled(true);
if (!mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE) {
mScreenOffBecauseOfProximity=true;
sendOnProximityPositiveWithWakelock();
}
}
 else if (mWaitingForNegativeProximity && mScreenOffBecauseOfProximity && mProximity == PROXIMITY_POSITIVE && state != Display.STATE_OFF) {
setProximitySensorEnabled(true);
}
 else {
setProximitySensorEnabled(false);
mWaitingForNegativeProximity=false;
}
if (mScreenOffBecauseOfProximity && mProximity != PROXIMITY_POSITIVE) {
mScreenOffBecauseOfProximity=false;
sendOnProximityNegativeWithWakelock();
}
}
 else {
mWaitingForNegativeProximity=false;
}
if (mScreenOffBecauseOfProximity) {
state=Display.STATE_OFF;
}
animateScreenStateChange(state,performScreenOffTransition);
state=mPowerState.getScreenState();
if (state == Display.STATE_OFF) {
brightness=PowerManager.BRIGHTNESS_OFF;
}
boolean autoBrightnessEnabled=false;
if (mAutomaticBrightnessController != null) {
final boolean autoBrightnessEnabledInDoze=mAllowAutoBrightnessWhileDozingConfig && (state == Display.STATE_DOZE || state == Display.STATE_DOZE_SUSPEND);
autoBrightnessEnabled=mPowerRequest.useAutoBrightness && (state == Display.STATE_ON || autoBrightnessEnabledInDoze) && brightness < 0;
final boolean userInitiatedChange=autoBrightnessAdjustmentChanged && mPowerRequest.brightnessSetByUser;
mAutomaticBrightnessController.configure(autoBrightnessEnabled,mPowerRequest.screenAutoBrightnessAdjustment,state != Display.STATE_ON,userInitiatedChange,mPowerRequest.useTwilight);
}
if (mPowerRequest.boostScreenBrightness && brightness != PowerManager.BRIGHTNESS_OFF) {
brightness=PowerManager.BRIGHTNESS_ON;
}
boolean slowChange=false;
if (brightness < 0) {
if (autoBrightnessEnabled) {
brightness=mAutomaticBrightnessController.getAutomaticScreenBrightness();
}
if (brightness >= 0) {
brightness=clampScreenBrightness(brightness);
if (mAppliedAutoBrightness && !autoBrightnessAdjustmentChanged) {
slowChange=true;
}
mAppliedAutoBrightness=true;
}
 else {
mAppliedAutoBrightness=false;
}
}
 else {
mAppliedAutoBrightness=false;
}
if (brightness < 0 && (state == Display.STATE_DOZE || state == Display.STATE_DOZE_SUSPEND)) {
brightness=mScreenBrightnessDozeConfig;
}
if (brightness < 0) {
brightness=clampScreenBrightness(mPowerRequest.screenBrightness);
}
if (mPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
if (brightness > mScreenBrightnessRangeMinimum) {
brightness=Math.max(Math.min(brightness - SCREEN_DIM_MINIMUM_REDUCTION,mScreenBrightnessDimConfig),mScreenBrightnessRangeMinimum);
}
if (!mAppliedDimming) {
slowChange=false;
}
mAppliedDimming=true;
}
 else if (mAppliedDimming) {
slowChange=false;
mAppliedDimming=false;
}
if (mPowerRequest.lowPowerMode) {
if (brightness > mScreenBrightnessRangeMinimum) {
brightness=Math.max(brightness / 2,mScreenBrightnessRangeMinimum);
}
if (!mAppliedLowPower) {
slowChange=false;
}
mAppliedLowPower=true;
}
 else if (mAppliedLowPower) {
slowChange=false;
mAppliedLowPower=false;
}
if (!mPendingScreenOff) {
if (state == Display.STATE_ON || state == Display.STATE_DOZE) {
animateScreenBrightness(brightness,slowChange ? BRIGHTNESS_RAMP_RATE_SLOW : mBrightnessRampRateFast);
}
 else {
animateScreenBrightness(brightness,0);
}
}
final boolean ready=mPendingScreenOnUnblocker == null && !mColorFadeOnAnimator.isStarted() && !mColorFadeOffAnimator.isStarted() && mPowerState.waitUntilClean(mCleanListener);
final boolean finished=ready && !mScreenBrightnessRampAnimator.isAnimating();
if (ready && state != Display.STATE_OFF && mReportedScreenStateToPolicy == REPORTED_TO_POLICY_SCREEN_TURNING_ON) {
mReportedScreenStateToPolicy=REPORTED_TO_POLICY_SCREEN_ON;
mWindowManagerPolicy.screenTurnedOn();
}
if (!finished && !mUnfinishedBusiness) {
if (DEBUG) {
Slog.d(TAG,"Unfinished business...");
}
mCallbacks.acquireSuspendBlocker();
mUnfinishedBusiness=true;
}
if (ready && mustNotify) {
synchronized (mLock) {
if (!mPendingRequestChangedLocked) {
mDisplayReadyLocked=true;
if (DEBUG) {
Slog.d(TAG,"Display ready!");
}
}
}
sendOnStateChangedWithWakelock();
}
if (finished && mUnfinishedBusiness) {
if (DEBUG) {
Slog.d(TAG,"Finished business...");
}
mUnfinishedBusiness=false;
mCallbacks.releaseSuspendBlocker();
}
}
