{
  mPacket=ByteBuffer.allocate(length).put(ByteBuffer.wrap(packet,0,length));
  mPacket.clear();
  mLastSeen=curTime();
  int lastNonLifetimeStart=addNonLifetime(0,ICMP6_RA_CHECKSUM_OFFSET,ICMP6_RA_CHECKSUM_LEN);
  lastNonLifetimeStart=addNonLifetime(lastNonLifetimeStart,ICMP6_RA_ROUTER_LIFETIME_OFFSET,ICMP6_RA_ROUTER_LIFETIME_LEN);
  mPacket.position(ICMP6_RA_OPTION_OFFSET);
  while (mPacket.hasRemaining()) {
    int optionType=((int)mPacket.get(mPacket.position())) & 0xff;
    int optionLength=(((int)mPacket.get(mPacket.position() + 1)) & 0xff) * 8;
switch (optionType) {
case ICMP6_PREFIX_OPTION_TYPE:
      lastNonLifetimeStart=addNonLifetime(lastNonLifetimeStart,ICMP6_PREFIX_OPTION_VALID_LIFETIME_OFFSET,ICMP6_PREFIX_OPTION_VALID_LIFETIME_LEN);
    lastNonLifetimeStart=addNonLifetime(lastNonLifetimeStart,ICMP6_PREFIX_OPTION_PREFERRED_LIFETIME_OFFSET,ICMP6_PREFIX_OPTION_PREFERRED_LIFETIME_LEN);
  mPrefixOptionOffsets.add(mPacket.position());
break;
case ICMP6_RDNSS_OPTION_TYPE:
mRdnssOptionOffsets.add(mPacket.position());
case ICMP6_ROUTE_INFO_OPTION_TYPE:
case ICMP6_DNSSL_OPTION_TYPE:
lastNonLifetimeStart=addNonLifetime(lastNonLifetimeStart,ICMP6_4_BYTE_LIFETIME_OFFSET,ICMP6_4_BYTE_LIFETIME_LEN);
break;
default :
break;
}
if (optionLength <= 0) {
throw new IllegalArgumentException(String.format("Invalid option length opt=%d len=%d",optionType,optionLength));
}
mPacket.position(mPacket.position() + optionLength);
}
addNonLifetime(lastNonLifetimeStart,0,0);
mMinLifetime=minLifetime(packet,length);
}
