{
  int action=event.getActionMasked();
  final boolean pointerUp=action == MotionEvent.ACTION_POINTER_UP;
  final int skipIndex=pointerUp ? event.getActionIndex() : -1;
  float sumX=0, sumY=0;
  final int count=event.getPointerCount();
  for (int i=0; i < count; i++) {
    if (skipIndex == i)     continue;
    sumX+=event.getX(i);
    sumY+=event.getY(i);
  }
  final int div=pointerUp ? count - 1 : count;
  float x=sumX / div;
  float y=sumY / div;
  if (action == MotionEvent.ACTION_DOWN) {
    mFirstX=x;
    mFirstY=y;
    mTouchDownTime=System.currentTimeMillis();
    if (mTouchCallback != null) {
      mTouchCallback.onTouchDown();
    }
  }
 else   if (action == MotionEvent.ACTION_UP) {
    ViewConfiguration config=ViewConfiguration.get(getContext());
    float squaredDist=(mFirstX - x) * (mFirstX - x) + (mFirstY - y) * (mFirstY - y);
    float slop=config.getScaledTouchSlop() * config.getScaledTouchSlop();
    long now=System.currentTimeMillis();
    if (mTouchCallback != null) {
      if (squaredDist < slop && now < mTouchDownTime + ViewConfiguration.getTapTimeout()) {
        mTouchCallback.onTap();
      }
      mTouchCallback.onTouchUp();
    }
  }
  if (!mTouchEnabled) {
    return true;
  }
synchronized (mLock) {
    mScaleGestureDetector.onTouchEvent(event);
switch (action) {
case MotionEvent.ACTION_MOVE:
      mRenderer.centerX+=(mLastX - x) / mRenderer.scale;
    mRenderer.centerY+=(mLastY - y) / mRenderer.scale;
  invalidate();
break;
}
if (mRenderer.source != null) {
final RectF edges=mTempEdges;
getEdgesHelper(edges);
final float scale=mRenderer.scale;
if (edges.left > 0) {
mRenderer.centerX+=Math.ceil(edges.left / scale);
}
if (edges.right < getWidth()) {
mRenderer.centerX+=(edges.right - getWidth()) / scale;
}
if (edges.top > 0) {
mRenderer.centerY+=Math.ceil(edges.top / scale);
}
if (edges.bottom < getHeight()) {
mRenderer.centerY+=(edges.bottom - getHeight()) / scale;
}
}
}
mLastX=x;
mLastY=y;
return true;
}
