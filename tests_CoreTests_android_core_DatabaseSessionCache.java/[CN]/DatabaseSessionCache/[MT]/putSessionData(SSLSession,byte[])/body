{
  if (mDatabaseHelper == null) {
    return;
  }
  if (mExternalCache.size() > MAX_CACHE_SIZE) {
    Cursor byTime=mDatabaseHelper.getWritableDatabase().query(SSL_CACHE_TABLE,PROJECTION,null,null,null,null,SSL_CACHE_TIME_SEC);
    byTime.moveToFirst();
    String hostPort=byTime.getString(SSL_CACHE_HOSTPORT_COL);
    mDatabaseHelper.getWritableDatabase().delete(SSL_CACHE_TABLE,SSL_CACHE_HOSTPORT + "= ?",new String[]{hostPort});
  }
  long t0=System.currentTimeMillis();
  String b64=new String(Base64.encodeBase64(der));
  String key=session.getPeerHost() + ":" + session.getPeerPort();
  ContentValues values=new ContentValues();
  values.put(SSL_CACHE_HOSTPORT,key);
  values.put(SSL_CACHE_SESSION,b64);
  values.put(SSL_CACHE_TIME_SEC,System.currentTimeMillis() / 1000);
synchronized (this.getClass()) {
    mExternalCache.put(key,der);
    try {
      mDatabaseHelper.getWritableDatabase().insert(SSL_CACHE_TABLE,null,values);
    }
 catch (    SQLException ex) {
      Log.w(TAG,"Ignoring SQL exception when caching session",ex);
    }
  }
  if (Log.isLoggable(TAG,Log.DEBUG)) {
    long t1=System.currentTimeMillis();
    Log.d(TAG,"New SSL session " + session.getPeerHost() + " DER len: "+ der.length+ " "+ (t1 - t0));
  }
}
