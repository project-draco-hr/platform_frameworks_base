{
  if (inputLength == 0) {
    input=EMPTY_BYTE_ARRAY;
    inputOffset=0;
  }
  byte[] updateOutput=null;
  if ((mBufferedLength + inputLength) > mMaxChunkSize) {
    updateOutput=update(input,inputOffset,inputLength);
    inputOffset+=inputLength;
    inputLength=0;
  }
  byte[] finalChunk;
  if ((mBufferedLength == 0) && (inputOffset == 0) && (inputLength == input.length)) {
    finalChunk=input;
  }
 else {
    finalChunk=new byte[mBufferedLength + inputLength];
    System.arraycopy(mBuffered,mBufferedOffset,finalChunk,0,mBufferedLength);
    System.arraycopy(input,inputOffset,finalChunk,mBufferedLength,inputLength);
  }
  mBuffered=EMPTY_BYTE_ARRAY;
  mBufferedLength=0;
  mBufferedOffset=0;
  OperationResult opResult=mKeyStoreOperation.finish(finalChunk);
  if (opResult == null) {
    throw new KeyStoreConnectException();
  }
 else   if (opResult.resultCode != KeyStore.NO_ERROR) {
    throw KeymasterUtils.getExceptionForKeymasterError(opResult.resultCode);
  }
  if (opResult.inputConsumed != finalChunk.length) {
    throw new CryptoOperationException("Unexpected number of bytes consumed by finish: " + opResult.inputConsumed + " instead of "+ finalChunk.length);
  }
  byte[] result;
  byte[] finishOutput=opResult.output;
  if ((updateOutput == null) || (updateOutput.length == 0)) {
    result=finishOutput;
  }
 else   if ((finishOutput == null) || (finishOutput.length == 0)) {
    result=updateOutput;
  }
 else {
    result=new byte[updateOutput.length + finishOutput.length];
    System.arraycopy(updateOutput,0,result,0,updateOutput.length);
    System.arraycopy(finishOutput,0,result,updateOutput.length,finishOutput.length);
  }
  return (result != null) ? result : EMPTY_BYTE_ARRAY;
}
