{
  if (LOGV)   Slog.v(TAG,"updateIfacesLocked()");
  final NetworkState[] states;
  try {
    states=mConnManager.getAllNetworkState();
  }
 catch (  RemoteException e) {
    Slog.w(TAG,"problem reading network state");
    return;
  }
  final HashMap<NetworkIdentity,String> networks=Maps.newHashMap();
  for (  NetworkState state : states) {
    if (state.networkInfo.isConnected()) {
      final String iface=state.linkProperties.getInterfaceName();
      final NetworkIdentity ident=NetworkIdentity.buildNetworkIdentity(mContext,state);
      networks.put(ident,iface);
    }
  }
  mNetworkRules.clear();
  final ArrayList<String> ifaceList=Lists.newArrayList();
  for (  NetworkPolicy policy : mNetworkPolicy.values()) {
    ifaceList.clear();
    for (    NetworkIdentity ident : networks.keySet()) {
      if (policy.template.matches(ident)) {
        final String iface=networks.get(ident);
        ifaceList.add(iface);
      }
    }
    if (ifaceList.size() > 0) {
      final String[] ifaces=ifaceList.toArray(new String[ifaceList.size()]);
      mNetworkRules.put(policy,ifaces);
    }
  }
  final HashSet<String> newMeteredIfaces=Sets.newHashSet();
  final long currentTime=currentTimeMillis(true);
  for (  NetworkPolicy policy : mNetworkRules.keySet()) {
    final String[] ifaces=mNetworkRules.get(policy);
    final long start=computeLastCycleBoundary(currentTime,policy);
    final long end=currentTime;
    final long totalBytes=getTotalBytes(policy.template,start,end);
    if (totalBytes == UNKNOWN_BYTES)     continue;
    if (LOGD) {
      Slog.d(TAG,"applying policy " + policy.toString() + " to ifaces "+ Arrays.toString(ifaces));
    }
    final boolean hasLimit=policy.limitBytes != LIMIT_DISABLED;
    if (hasLimit) {
      final long quotaBytes;
      if (policy.lastSnooze >= start) {
        quotaBytes=Long.MAX_VALUE;
      }
 else {
        quotaBytes=Math.max(1,policy.limitBytes - totalBytes);
      }
      if (ifaces.length > 1) {
        Slog.w(TAG,"shared quota unsupported; generating rule for each iface");
      }
      for (      String iface : ifaces) {
        removeInterfaceQuota(iface);
        setInterfaceQuota(iface,quotaBytes);
        newMeteredIfaces.add(iface);
      }
    }
  }
  for (  String iface : mMeteredIfaces) {
    if (!newMeteredIfaces.contains(iface)) {
      removeInterfaceQuota(iface);
    }
  }
  mMeteredIfaces=newMeteredIfaces;
  final String[] meteredIfaces=mMeteredIfaces.toArray(new String[mMeteredIfaces.size()]);
  mHandler.obtainMessage(MSG_METERED_IFACES_CHANGED,meteredIfaces).sendToTarget();
}
