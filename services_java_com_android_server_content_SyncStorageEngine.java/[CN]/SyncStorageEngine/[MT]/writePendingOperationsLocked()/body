{
  final int N=mPendingOperations.size();
  FileOutputStream fos=null;
  try {
    if (N == 0) {
      if (Log.isLoggable(TAG_FILE,Log.VERBOSE)) {
        Log.v(TAG,"Truncating " + mPendingFile.getBaseFile());
      }
      mPendingFile.truncate();
      return;
    }
    if (Log.isLoggable(TAG_FILE,Log.VERBOSE)) {
      Log.v(TAG,"Writing new " + mPendingFile.getBaseFile());
    }
    fos=mPendingFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,"utf-8");
    out.startDocument(null,true);
    out.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output",true);
    out.startTag(null,"pending");
    out.attribute(null,"version",Integer.toString(PENDING_OPERATION_VERSION));
    for (int i=0; i < N; i++) {
      PendingOperation pop=mPendingOperations.get(i);
      out.startTag(null,"op");
      out.attribute(null,XML_ATTR_AUTHORITYID,Integer.toString(pop.authorityId));
      out.attribute(null,XML_ATTR_SOURCE,Integer.toString(pop.syncSource));
      out.attribute(null,XML_ATTR_EXPEDITED,Boolean.toString(pop.expedited));
      out.attribute(null,XML_ATTR_REASON,Integer.toString(pop.reason));
      extrasToXml(out,pop.extras);
      out.endTag(null,"op");
    }
    out.endTag(null,"pending");
    out.endDocument();
    mPendingFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,"Error writing pending operations",e1);
    if (fos != null) {
      mPendingFile.failWrite(fos);
    }
  }
}
