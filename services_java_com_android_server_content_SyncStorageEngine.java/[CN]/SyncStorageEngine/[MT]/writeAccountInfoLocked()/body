{
  if (DEBUG_FILE)   Log.v(TAG,"Writing new " + mAccountInfoFile.getBaseFile());
  FileOutputStream fos=null;
  try {
    fos=mAccountInfoFile.startWrite();
    XmlSerializer out=new FastXmlSerializer();
    out.setOutput(fos,"utf-8");
    out.startDocument(null,true);
    out.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output",true);
    out.startTag(null,"accounts");
    out.attribute(null,"version",Integer.toString(ACCOUNTS_VERSION));
    out.attribute(null,XML_ATTR_NEXT_AUTHORITY_ID,Integer.toString(mNextAuthorityId));
    out.attribute(null,XML_ATTR_SYNC_RANDOM_OFFSET,Integer.toString(mSyncRandomOffset));
    final int M=mMasterSyncAutomatically.size();
    for (int m=0; m < M; m++) {
      int userId=mMasterSyncAutomatically.keyAt(m);
      Boolean listen=mMasterSyncAutomatically.valueAt(m);
      out.startTag(null,XML_TAG_LISTEN_FOR_TICKLES);
      out.attribute(null,XML_ATTR_USER,Integer.toString(userId));
      out.attribute(null,XML_ATTR_ENABLED,Boolean.toString(listen));
      out.endTag(null,XML_TAG_LISTEN_FOR_TICKLES);
    }
    final int N=mAuthorities.size();
    for (int i=0; i < N; i++) {
      AuthorityInfo authority=mAuthorities.valueAt(i);
      out.startTag(null,"authority");
      out.attribute(null,"id",Integer.toString(authority.ident));
      out.attribute(null,"account",authority.account.name);
      out.attribute(null,XML_ATTR_USER,Integer.toString(authority.userId));
      out.attribute(null,"type",authority.account.type);
      out.attribute(null,"authority",authority.authority);
      out.attribute(null,XML_ATTR_ENABLED,Boolean.toString(authority.enabled));
      if (authority.syncable < 0) {
        out.attribute(null,"syncable","unknown");
      }
 else {
        out.attribute(null,"syncable",Boolean.toString(authority.syncable != 0));
      }
      for (      Pair<Bundle,Long> periodicSync : authority.periodicSyncs) {
        out.startTag(null,"periodicSync");
        out.attribute(null,"period",Long.toString(periodicSync.second));
        final Bundle extras=periodicSync.first;
        for (        String key : extras.keySet()) {
          out.startTag(null,"extra");
          out.attribute(null,"name",key);
          final Object value=extras.get(key);
          if (value instanceof Long) {
            out.attribute(null,"type","long");
            out.attribute(null,"value1",value.toString());
          }
 else           if (value instanceof Integer) {
            out.attribute(null,"type","integer");
            out.attribute(null,"value1",value.toString());
          }
 else           if (value instanceof Boolean) {
            out.attribute(null,"type","boolean");
            out.attribute(null,"value1",value.toString());
          }
 else           if (value instanceof Float) {
            out.attribute(null,"type","float");
            out.attribute(null,"value1",value.toString());
          }
 else           if (value instanceof Double) {
            out.attribute(null,"type","double");
            out.attribute(null,"value1",value.toString());
          }
 else           if (value instanceof String) {
            out.attribute(null,"type","string");
            out.attribute(null,"value1",value.toString());
          }
 else           if (value instanceof Account) {
            out.attribute(null,"type","account");
            out.attribute(null,"value1",((Account)value).name);
            out.attribute(null,"value2",((Account)value).type);
          }
          out.endTag(null,"extra");
        }
        out.endTag(null,"periodicSync");
      }
      out.endTag(null,"authority");
    }
    out.endTag(null,"accounts");
    out.endDocument();
    mAccountInfoFile.finishWrite(fos);
  }
 catch (  java.io.IOException e1) {
    Log.w(TAG,"Error writing accounts",e1);
    if (fos != null) {
      mAccountInfoFile.failWrite(fos);
    }
  }
}
