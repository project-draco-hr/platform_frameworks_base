{
  if (outputs == null || outputs.length <= 0) {
    throw new IllegalArgumentException("outputs must have at least 1 surface");
  }
 else   if (inputResults != null && inputResults.length != outputs.length) {
    throw new IllegalArgumentException("The lengths of outputs and inputResults " + "don't match");
  }
  int numReprocessCaptures=0;
  SimpleCaptureCallback captureCallback=new SimpleCaptureCallback();
  ArrayList<CaptureRequest> captureRequests=new ArrayList<>(outputs.length);
  for (int i=0; i < outputs.length; i++) {
    CaptureRequest.Builder builder;
    boolean isReprocess=(inputResults != null && inputResults[i] != null);
    if (isReprocess) {
      builder=mCamera.createReprocessCaptureRequest(inputResults[i]);
      numReprocessCaptures++;
    }
 else {
      builder=mCamera.createCaptureRequest(CAPTURE_TEMPLATE);
    }
    builder.addTarget(outputs[i]);
    CaptureRequest request=builder.build();
    assertTrue("Capture request reprocess type " + request.isReprocess() + " is wrong.",request.isReprocess() == isReprocess);
    captureRequests.add(request);
  }
  if (captureRequests.size() == 1) {
    mSession.capture(captureRequests.get(0),captureCallback,mHandler);
  }
 else {
    mSession.captureBurst(captureRequests,captureCallback,mHandler);
  }
  TotalCaptureResult[] results;
  if (numReprocessCaptures == 0 || numReprocessCaptures == outputs.length) {
    results=new TotalCaptureResult[outputs.length];
    for (int i=0; i < results.length; i++) {
      results[i]=captureCallback.getTotalCaptureResultForRequest(captureRequests.get(i),CAPTURE_TIMEOUT_FRAMES);
    }
  }
 else {
    results=captureCallback.getTotalCaptureResultsForRequests(captureRequests,CAPTURE_TIMEOUT_FRAMES * captureRequests.size());
  }
  for (int i=0; i < numReprocessCaptures; i++) {
    mImageWriterListener.waitForImageReleased(CAPTURE_TIMEOUT_MS);
  }
  return results;
}
