{
  SensorManager sensorManager=(SensorManager)mContext.getSystemService(Context.SENSOR_SERVICE);
  final int which=mStatsType;
  final int speedSteps=mPowerProfile.getNumSpeedSteps();
  final double[] powerCpuNormal=new double[speedSteps];
  final long[] cpuSpeedStepTimes=new long[speedSteps];
  for (int p=0; p < speedSteps; p++) {
    powerCpuNormal[p]=mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE,p);
  }
  final double mobilePowerPerPacket=getMobilePowerPerPacket();
  final double wifiPowerPerPacket=getWifiPowerPerPacket();
  long appWakelockTime=0;
  BatterySipper osApp=null;
  mStatsPeriod=mTypeBatteryRealtime;
  SparseArray<? extends Uid> uidStats=mStats.getUidStats();
  final int NU=uidStats.size();
  for (int iu=0; iu < NU; iu++) {
    Uid u=uidStats.valueAt(iu);
    double p;
    double power=0;
    double highestDrain=0;
    String packageWithHighestDrain=null;
    Map<String,? extends BatteryStats.Uid.Proc> processStats=u.getProcessStats();
    long cpuTime=0;
    long cpuFgTime=0;
    long wakelockTime=0;
    long gpsTime=0;
    if (processStats.size() > 0) {
      for (      Map.Entry<String,? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
        Uid.Proc ps=ent.getValue();
        final long userTime=ps.getUserTime(which);
        final long systemTime=ps.getSystemTime(which);
        final long foregroundTime=ps.getForegroundTime(which);
        cpuFgTime+=foregroundTime * 10;
        final long tmpCpuTime=(userTime + systemTime) * 10;
        int totalTimeAtSpeeds=0;
        for (int step=0; step < speedSteps; step++) {
          cpuSpeedStepTimes[step]=ps.getTimeAtCpuSpeedStep(step,which);
          totalTimeAtSpeeds+=cpuSpeedStepTimes[step];
        }
        if (totalTimeAtSpeeds == 0)         totalTimeAtSpeeds=1;
        double processPower=0;
        for (int step=0; step < speedSteps; step++) {
          double ratio=(double)cpuSpeedStepTimes[step] / totalTimeAtSpeeds;
          if (DEBUG && ratio != 0)           Log.d(TAG,"UID " + u.getUid() + ": CPU step #"+ step+ " ratio="+ makemAh(ratio)+ " power="+ makemAh(ratio * tmpCpuTime * powerCpuNormal[step] / (60 * 60 * 1000)));
          processPower+=ratio * tmpCpuTime * powerCpuNormal[step];
        }
        cpuTime+=tmpCpuTime;
        if (DEBUG && processPower != 0) {
          Log.d(TAG,String.format("process %s, cpu power=%s",ent.getKey(),makemAh(processPower / (60 * 60 * 1000))));
        }
        power+=processPower;
        if (packageWithHighestDrain == null || packageWithHighestDrain.startsWith("*")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
 else         if (highestDrain < processPower && !ent.getKey().startsWith("*")) {
          highestDrain=processPower;
          packageWithHighestDrain=ent.getKey();
        }
      }
    }
    if (cpuFgTime > cpuTime) {
      if (DEBUG && cpuFgTime > cpuTime + 10000) {
        Log.d(TAG,"WARNING! Cputime is more than 10 seconds behind Foreground time");
      }
      cpuTime=cpuFgTime;
    }
    power/=(60 * 60 * 1000);
    Map<String,? extends BatteryStats.Uid.Wakelock> wakelockStats=u.getWakelockStats();
    for (    Map.Entry<String,? extends BatteryStats.Uid.Wakelock> wakelockEntry : wakelockStats.entrySet()) {
      Uid.Wakelock wakelock=wakelockEntry.getValue();
      BatteryStats.Timer timer=wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);
      if (timer != null) {
        wakelockTime+=timer.getTotalTimeLocked(mBatteryRealtime,which);
      }
    }
    wakelockTime/=1000;
    appWakelockTime+=wakelockTime;
    p=(wakelockTime * mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_AWAKE)) / (60 * 60 * 1000);
    if (DEBUG && p != 0)     Log.d(TAG,"UID " + u.getUid() + ": wake "+ wakelockTime+ " power="+ makemAh(p));
    power+=p;
    final long mobileRx=u.getNetworkActivityPackets(NETWORK_MOBILE_RX_DATA,mStatsType);
    final long mobileTx=u.getNetworkActivityPackets(NETWORK_MOBILE_TX_DATA,mStatsType);
    final long mobileRxB=u.getNetworkActivityBytes(NETWORK_MOBILE_RX_DATA,mStatsType);
    final long mobileTxB=u.getNetworkActivityBytes(NETWORK_MOBILE_TX_DATA,mStatsType);
    p=(mobileRx + mobileTx) * mobilePowerPerPacket;
    if (DEBUG && p != 0)     Log.d(TAG,"UID " + u.getUid() + ": mobile packets "+ (mobileRx + mobileTx)+ " power="+ makemAh(p));
    power+=p;
    final long wifiRx=u.getNetworkActivityPackets(NETWORK_WIFI_RX_DATA,mStatsType);
    final long wifiTx=u.getNetworkActivityPackets(NETWORK_WIFI_TX_DATA,mStatsType);
    final long wifiRxB=u.getNetworkActivityBytes(NETWORK_WIFI_RX_DATA,mStatsType);
    final long wifiTxB=u.getNetworkActivityBytes(NETWORK_WIFI_TX_DATA,mStatsType);
    p=(wifiRx + wifiTx) * wifiPowerPerPacket;
    if (DEBUG && p != 0)     Log.d(TAG,"UID " + u.getUid() + ": wifi packets "+ (mobileRx + mobileTx)+ " power="+ makemAh(p));
    power+=p;
    long wifiRunningTimeMs=u.getWifiRunningTime(mBatteryRealtime,which) / 1000;
    mAppWifiRunning+=wifiRunningTimeMs;
    p=(wifiRunningTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_ON)) / (60 * 60 * 1000);
    if (DEBUG && p != 0)     Log.d(TAG,"UID " + u.getUid() + ": wifi running "+ wifiRunningTimeMs+ " power="+ makemAh(p));
    power+=p;
    long wifiScanTimeMs=u.getWifiScanTime(mBatteryRealtime,which) / 1000;
    p=(wifiScanTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_SCAN)) / (60 * 60 * 1000);
    if (DEBUG)     Log.d(TAG,"UID " + u.getUid() + ": wifi scan "+ wifiScanTimeMs+ " power="+ makemAh(p));
    power+=p;
    for (int bin=0; bin < BatteryStats.Uid.NUM_WIFI_BATCHED_SCAN_BINS; bin++) {
      long batchScanTimeMs=u.getWifiBatchedScanTime(bin,mBatteryRealtime,which) / 1000;
      p=((batchScanTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_BATCHED_SCAN,bin))) / (60 * 60 * 1000);
      if (DEBUG && p != 0)       Log.d(TAG,"UID " + u.getUid() + ": wifi batched scan # "+ bin+ " time="+ batchScanTimeMs+ " power="+ makemAh(p));
      power+=p;
    }
    Map<Integer,? extends BatteryStats.Uid.Sensor> sensorStats=u.getSensorStats();
    for (    Map.Entry<Integer,? extends BatteryStats.Uid.Sensor> sensorEntry : sensorStats.entrySet()) {
      Uid.Sensor sensor=sensorEntry.getValue();
      int sensorHandle=sensor.getHandle();
      BatteryStats.Timer timer=sensor.getSensorTime();
      long sensorTime=timer.getTotalTimeLocked(mBatteryRealtime,which) / 1000;
      double multiplier=0;
switch (sensorHandle) {
case Uid.Sensor.GPS:
        multiplier=mPowerProfile.getAveragePower(PowerProfile.POWER_GPS_ON);
      gpsTime=sensorTime;
    break;
default :
  List<Sensor> sensorList=sensorManager.getSensorList(android.hardware.Sensor.TYPE_ALL);
for (android.hardware.Sensor s : sensorList) {
  if (s.getHandle() == sensorHandle) {
    multiplier=s.getPower();
    break;
  }
}
}
p=(multiplier * sensorTime) / (60 * 60 * 1000);
if (DEBUG && p != 0) Log.d(TAG,"UID " + u.getUid() + ": sensor #"+ sensorHandle+ " time="+ sensorTime+ " power="+ makemAh(p));
power+=p;
}
if (DEBUG && power != 0) Log.d(TAG,String.format("UID %d: total power=%s",u.getUid(),makemAh(power)));
final int userId=UserHandle.getUserId(u.getUid());
if (power != 0 || u.getUid() == 0) {
BatterySipper app=new BatterySipper(BatterySipper.DrainType.APP,u,new double[]{power});
app.cpuTime=cpuTime;
app.gpsTime=gpsTime;
app.wifiRunningTime=wifiRunningTimeMs;
app.cpuFgTime=cpuFgTime;
app.wakeLockTime=wakelockTime;
app.mobileRxPackets=mobileRx;
app.mobileTxPackets=mobileTx;
app.wifiRxPackets=wifiRx;
app.wifiTxPackets=wifiTx;
app.mobileRxBytes=mobileRxB;
app.mobileTxBytes=mobileTxB;
app.wifiRxBytes=wifiRxB;
app.wifiTxBytes=wifiTxB;
app.packageWithHighestDrain=packageWithHighestDrain;
if (u.getUid() == Process.WIFI_UID) {
mWifiSippers.add(app);
mWifiPower+=power;
}
 else if (u.getUid() == Process.BLUETOOTH_UID) {
mBluetoothSippers.add(app);
mBluetoothPower+=power;
}
 else if (mAsUser != UserHandle.USER_ALL && userId != mAsUser && UserHandle.getAppId(u.getUid()) >= Process.FIRST_APPLICATION_UID) {
List<BatterySipper> list=mUserSippers.get(userId);
if (list == null) {
list=new ArrayList<BatterySipper>();
mUserSippers.put(userId,list);
}
list.add(app);
if (power != 0) {
Double userPower=mUserPower.get(userId);
if (userPower == null) {
  userPower=power;
}
 else {
  userPower+=power;
}
mUserPower.put(userId,userPower);
}
}
 else {
mUsageList.add(app);
if (power > mMaxPower) mMaxPower=power;
mComputedPower+=power;
}
if (u.getUid() == 0) {
osApp=app;
}
}
}
if (osApp != null) {
long wakeTimeMillis=mBatteryUptime / 1000;
wakeTimeMillis-=appWakelockTime + (mStats.getScreenOnTime(mBatteryRealtime,which) / 1000);
if (wakeTimeMillis > 0) {
double power=(wakeTimeMillis * mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_AWAKE)) / (60 * 60 * 1000);
if (DEBUG) Log.d(TAG,"OS wakeLockTime " + wakeTimeMillis + " power "+ makemAh(power));
osApp.wakeLockTime+=wakeTimeMillis;
osApp.value+=power;
osApp.values[0]+=power;
if (osApp.value > mMaxPower) mMaxPower=osApp.value;
mComputedPower+=power;
}
}
}
