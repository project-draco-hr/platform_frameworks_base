{
  if (event == null || (event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
    throw new IllegalArgumentException("event must be a pointer event");
  }
  if (DEBUG) {
    Log.d(TAG,"postPointerEvent: " + event);
  }
  final int action=event.getActionMasked();
  final int eventType;
switch (action) {
case MotionEvent.ACTION_DOWN:
case MotionEvent.ACTION_MOVE:
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_CANCEL:
    eventType=EVENT_TYPE_TOUCH;
  break;
case MotionEvent.ACTION_SCROLL:
eventType=EVENT_TYPE_SCROLL;
break;
case MotionEvent.ACTION_HOVER_ENTER:
case MotionEvent.ACTION_HOVER_MOVE:
case MotionEvent.ACTION_HOVER_EXIT:
eventType=EVENT_TYPE_HOVER;
break;
default :
return false;
}
synchronized (mLock) {
MotionEvent eventToEnqueue=event;
if (eventType == EVENT_TYPE_TOUCH) {
eventToEnqueue=mPostTouchStream.update(event);
if (eventToEnqueue == null) {
if (DEBUG) {
Log.d(TAG,"postPointerEvent: dropped event " + event);
}
unscheduleLongPressLocked();
unscheduleClickLocked();
return false;
}
if (mPostSendTouchEventsToWebKit && mPostDoNotSendTouchEventsToWebKitUntilNextGesture && action == MotionEvent.ACTION_DOWN) {
mPostDoNotSendTouchEventsToWebKitUntilNextGesture=false;
}
}
if (eventToEnqueue == event) {
eventToEnqueue=event.copy();
}
DispatchEvent d=obtainDispatchEventLocked(eventToEnqueue,eventType,0,webKitXOffset,webKitYOffset,webKitScale);
enqueueEventLocked(d);
}
return true;
}
