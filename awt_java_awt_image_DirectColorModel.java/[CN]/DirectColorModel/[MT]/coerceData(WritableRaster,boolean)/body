{
  if (!hasAlpha || this.isAlphaPremultiplied == isAlphaPremultiplied) {
    return this;
  }
  int minX=raster.getMinX();
  int minY=raster.getMinY();
  int w=raster.getWidth();
  int h=raster.getHeight();
  int components[]=null;
  int transparentComponents[]=new int[numComponents];
  float alphaFactor=maxValues[numColorComponents];
  if (isAlphaPremultiplied) {
switch (transferType) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_INT:
      for (int i=0; i < h; i++, minY++) {
        for (int j=0, x=minX; j < w; j++, x++) {
          components=raster.getPixel(x,minY,components);
          if (components[numColorComponents] == 0) {
            raster.setPixel(x,minY,transparentComponents);
          }
 else {
            float alpha=components[numColorComponents] / alphaFactor;
            for (int n=0; n < numColorComponents; n++) {
              components[n]=(int)(alpha * components[n] + 0.5f);
            }
            raster.setPixel(x,minY,components);
          }
        }
      }
    break;
default :
  throw new UnsupportedOperationException(Messages.getString("awt.214"));
}
}
 else {
switch (transferType) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_INT:
for (int i=0; i < h; i++, minY++) {
  for (int j=0, x=minX; j < w; j++, x++) {
    components=raster.getPixel(x,minY,components);
    if (components[numColorComponents] != 0) {
      float alpha=alphaFactor / components[numColorComponents];
      for (int n=0; n < numColorComponents; n++) {
        components[n]=(int)(alpha * components[n] + 0.5f);
      }
      raster.setPixel(x,minY,components);
    }
  }
}
break;
default :
throw new UnsupportedOperationException(Messages.getString("awt.214"));
}
}
return new DirectColorModel(cs,pixel_bits,componentMasks[0],componentMasks[1],componentMasks[2],componentMasks[3],isAlphaPremultiplied,transferType);
}
