{
  if (equals(ColorModel.getRGBdefault())) {
    int ia[];
    if (pixel == null) {
      ia=new int[1];
    }
 else {
      ia=(int[])pixel;
    }
    ia[0]=rgb;
    return ia;
  }
  int alpha=(rgb >> 24) & 0xff;
  int red=(rgb >> 16) & 0xff;
  int green=(rgb >> 8) & 0xff;
  int blue=rgb & 0xff;
  float comp[]=new float[numColorComponents];
  float normComp[]=null;
  if (is_sRGB || is_LINEAR_RGB) {
    if (is_LINEAR_RGB) {
      if (LINEAR_RGB_Length == 8) {
        red=to_LINEAR_8RGB_LUT[red] & 0xff;
        green=to_LINEAR_8RGB_LUT[green] & 0xff;
        blue=to_LINEAR_8RGB_LUT[blue] & 0xff;
      }
 else {
        red=to_LINEAR_16RGB_LUT[red] & 0xffff;
        green=to_LINEAR_16RGB_LUT[green] & 0xffff;
        blue=to_LINEAR_16RGB_LUT[blue] & 0xffff;
      }
    }
    comp[0]=red / fFactor;
    comp[1]=green / fFactor;
    comp[2]=blue / fFactor;
    if (!hasAlpha) {
      normComp=comp;
    }
 else {
      float normAlpha=alpha / 255.0f;
      normComp=new float[numComponents];
      for (int i=0; i < numColorComponents; i++) {
        normComp[i]=comp[i];
      }
      normComp[numColorComponents]=normAlpha;
    }
  }
 else {
    comp[0]=red / fFactor;
    comp[1]=green / fFactor;
    comp[2]=blue / fFactor;
    float rgbComp[]=cs.fromRGB(comp);
    if (!hasAlpha) {
      normComp=rgbComp;
    }
 else {
      float normAlpha=alpha / 255.0f;
      normComp=new float[numComponents];
      for (int i=0; i < numColorComponents; i++) {
        normComp[i]=rgbComp[i];
      }
      normComp[numColorComponents]=normAlpha;
    }
  }
  int pxl=0;
  if (hasAlpha) {
    float normAlpha=normComp[numColorComponents];
    alpha=(int)(normAlpha * maxValues[numColorComponents] + 0.5f);
    if (isAlphaPremultiplied) {
      red=(int)(normComp[0] * normAlpha * maxValues[0] + 0.5f);
      green=(int)(normComp[1] * normAlpha * maxValues[1] + 0.5f);
      blue=(int)(normComp[2] * normAlpha * maxValues[2] + 0.5f);
    }
 else {
      red=(int)(normComp[0] * maxValues[0] + 0.5f);
      green=(int)(normComp[1] * maxValues[1] + 0.5f);
      blue=(int)(normComp[2] * maxValues[2] + 0.5f);
    }
    pxl=(alpha << offsets[3]) & componentMasks[3];
  }
 else {
    red=(int)(normComp[0] * maxValues[0] + 0.5f);
    green=(int)(normComp[1] * maxValues[1] + 0.5f);
    blue=(int)(normComp[2] * maxValues[2] + 0.5f);
  }
  pxl|=((red << offsets[0]) & componentMasks[0]) | ((green << offsets[1]) & componentMasks[1]) | ((blue << offsets[2]) & componentMasks[2]);
switch (transferType) {
case DataBuffer.TYPE_BYTE:
    byte ba[];
  if (pixel == null) {
    ba=new byte[1];
  }
 else {
    ba=(byte[])pixel;
  }
ba[0]=(byte)pxl;
return ba;
case DataBuffer.TYPE_USHORT:
short sa[];
if (pixel == null) {
sa=new short[1];
}
 else {
sa=(short[])pixel;
}
sa[0]=(short)pxl;
return sa;
case DataBuffer.TYPE_INT:
int ia[];
if (pixel == null) {
ia=new int[1];
}
 else {
ia=(int[])pixel;
}
ia[0]=pxl;
return ia;
default :
throw new UnsupportedOperationException(Messages.getString("awt.214"));
}
}
