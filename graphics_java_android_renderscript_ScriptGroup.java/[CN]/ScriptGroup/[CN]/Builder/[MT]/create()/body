{
  if (mNodes.size() == 0) {
    throw new RSInvalidStateException("Empty script groups are not allowed");
  }
  for (int ct=0; ct < mNodes.size(); ct++) {
    mNodes.get(ct).dagNumber=0;
  }
  validateDAG();
  ArrayList<IO> inputs=new ArrayList<IO>();
  ArrayList<IO> outputs=new ArrayList<IO>();
  int[] kernels=new int[mKernelCount];
  int idx=0;
  for (int ct=0; ct < mNodes.size(); ct++) {
    Node n=mNodes.get(ct);
    for (int ct2=0; ct2 < n.mKernels.size(); ct2++) {
      final Script.KernelID kid=n.mKernels.get(ct2);
      kernels[idx++]=kid.getID(mRS);
      boolean hasInput=false;
      boolean hasOutput=false;
      for (int ct3=0; ct3 < n.mInputs.size(); ct3++) {
        if (n.mInputs.get(ct3).mToK == kid) {
          hasInput=true;
        }
      }
      for (int ct3=0; ct3 < n.mOutputs.size(); ct3++) {
        if (n.mOutputs.get(ct3).mFrom == kid) {
          hasOutput=true;
        }
      }
      if (!hasInput) {
        inputs.add(new IO(kid));
      }
      if (!hasOutput) {
        outputs.add(new IO(kid));
      }
    }
  }
  if (idx != mKernelCount) {
    throw new RSRuntimeException("Count mismatch, should not happen.");
  }
  int[] src=new int[mLines.size()];
  int[] dstk=new int[mLines.size()];
  int[] dstf=new int[mLines.size()];
  int[] types=new int[mLines.size()];
  for (int ct=0; ct < mLines.size(); ct++) {
    ConnectLine cl=mLines.get(ct);
    src[ct]=cl.mFrom.getID(mRS);
    if (cl.mToK != null) {
      dstk[ct]=cl.mToK.getID(mRS);
    }
    if (cl.mToF != null) {
      dstf[ct]=cl.mToF.getID(mRS);
    }
    types[ct]=cl.mAllocationType.getID(mRS);
  }
  int id=mRS.nScriptGroupCreate(kernels,src,dstk,dstf,types);
  if (id == 0) {
    throw new RSRuntimeException("Object creation error, should not happen.");
  }
  ScriptGroup sg=new ScriptGroup(id,mRS);
  sg.mOutputs=new IO[outputs.size()];
  for (int ct=0; ct < outputs.size(); ct++) {
    sg.mOutputs[ct]=outputs.get(ct);
  }
  sg.mInputs=new IO[inputs.size()];
  for (int ct=0; ct < inputs.size(); ct++) {
    sg.mInputs[ct]=inputs.get(ct);
  }
  return sg;
}
