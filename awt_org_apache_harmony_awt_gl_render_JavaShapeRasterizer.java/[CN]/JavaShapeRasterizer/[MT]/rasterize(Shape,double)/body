{
  PathIterator path=shape.getPathIterator(null,flatness);
  if (path.isDone()) {
    return new MultiRectArea();
  }
  makeBuffer(path,flatness);
  init();
  int y=edgesYS[0];
  int nextY=y;
  int crossCount;
  MultiRectArea.LineCash rect=new MultiRectArea.LineCash(edgesCount);
  rect.setLine(y);
  while (y <= nextY) {
    crossCount=0;
    if (y == nextY) {
      int i=activeCount;
      while (i > 0) {
        i--;
        if (activeYEnd[i] == y) {
          activeCount--;
          int length=activeCount - i;
          if (length != 0) {
            int pos=i + 1;
            System.arraycopy(activeX,pos,activeX,i,length);
            System.arraycopy(activeYEnd,pos,activeYEnd,i,length);
            System.arraycopy(activeXStep,pos,activeXStep,i,length);
            System.arraycopy(activeDY,pos,activeDY,i,length);
            System.arraycopy(activeExt,pos,activeExt,i,length);
          }
        }
      }
      nextY=findActiveEdges(y);
    }
    for (int i=0; i < activeCount; i++) {
      crossX[crossCount]=(int)Math.ceil(activeX[i]);
      crossDY[crossCount]=activeDY[i];
      crossCount++;
    }
    if (crossCount == 0) {
      rect.skipLine();
    }
 else {
      sort(crossX,crossDY,crossCount);
      filler.add(rect,crossX,crossDY,crossCount,y);
    }
    for (int i=0; i < activeCount; i++) {
      activeX[i]+=activeXStep[i];
    }
    y++;
  }
  return rect;
}
