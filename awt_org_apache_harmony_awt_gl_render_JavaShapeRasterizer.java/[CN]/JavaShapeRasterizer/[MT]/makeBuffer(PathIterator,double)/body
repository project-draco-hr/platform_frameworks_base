{
  edgesX=new int[POINT_CAPACITY];
  edgesY=new int[POINT_CAPACITY];
  edgesN=new int[POINT_CAPACITY];
  bounds=new int[POINT_CAPACITY];
  boundCount=0;
  edgesCount=0;
  if (path.getWindingRule() == PathIterator.WIND_EVEN_ODD) {
    filler=new Filler.EvenOdd();
  }
 else {
    filler=new Filler.NonZero();
  }
  float[] coords=new float[2];
  boolean closed=true;
  while (!path.isDone()) {
switch (path.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
      if (!closed) {
        boundCount++;
        bounds=checkBufSize(bounds,boundCount);
        bounds[boundCount]=edgesCount;
      }
    addEdge((int)coords[0],(int)coords[1],boundCount);
  closed=false;
break;
case PathIterator.SEG_LINETO:
addEdge((int)coords[0],(int)coords[1],boundCount);
break;
case PathIterator.SEG_CLOSE:
boundCount++;
bounds=checkBufSize(bounds,boundCount);
bounds[boundCount]=edgesCount;
closed=true;
break;
default :
throw new RuntimeException(Messages.getString("awt.36"));
}
path.next();
}
if (!closed) {
boundCount++;
bounds=checkBufSize(bounds,boundCount);
bounds[boundCount]=edgesCount;
}
}
