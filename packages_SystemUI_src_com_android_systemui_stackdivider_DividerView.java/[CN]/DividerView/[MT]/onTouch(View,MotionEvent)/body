{
  convertToScreenCoordinates(event);
  final int action=event.getAction() & MotionEvent.ACTION_MASK;
switch (action) {
case MotionEvent.ACTION_DOWN:
    mVelocityTracker=VelocityTracker.obtain();
  mVelocityTracker.addMovement(event);
mStartX=(int)event.getX();
mStartY=(int)event.getY();
boolean result=startDragging(true,true);
if (!result) {
stopDragging();
}
mStartPosition=getCurrentPosition();
mMoving=false;
return result;
case MotionEvent.ACTION_MOVE:
mVelocityTracker.addMovement(event);
int x=(int)event.getX();
int y=(int)event.getY();
boolean exceededTouchSlop=isHorizontalDivision() && Math.abs(y - mStartY) > mTouchSlop || (!isHorizontalDivision() && Math.abs(x - mStartX) > mTouchSlop);
if (!mMoving && exceededTouchSlop) {
mStartX=x;
mStartY=y;
mMoving=true;
}
if (mMoving && mDockSide != WindowManager.DOCKED_INVALID) {
int position=calculatePosition(x,y);
SnapTarget snapTarget=mSnapAlgorithm.calculateSnapTarget(position,0,false);
resizeStack(calculatePosition(x,y),snapTarget.position,snapTarget);
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mVelocityTracker.addMovement(event);
x=(int)event.getRawX();
y=(int)event.getRawY();
mVelocityTracker.computeCurrentVelocity(1000);
int position=calculatePosition(x,y);
stopDragging(position,isHorizontalDivision() ? mVelocityTracker.getYVelocity() : mVelocityTracker.getXVelocity(),false);
mMoving=false;
break;
}
return true;
}
