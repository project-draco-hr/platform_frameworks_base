{
  int installFlags=PackageManager.INSTALL_ALL_USERS;
  String installerPackageName=null;
  String opt;
  String algo=null;
  byte[] iv=null;
  byte[] key=null;
  String macAlgo=null;
  byte[] macKey=null;
  byte[] tag=null;
  String originatingUriString=null;
  String referrer=null;
  String abi=null;
  while ((opt=nextOption()) != null) {
    if (opt.equals("-l")) {
      installFlags|=PackageManager.INSTALL_FORWARD_LOCK;
    }
 else     if (opt.equals("-r")) {
      installFlags|=PackageManager.INSTALL_REPLACE_EXISTING;
    }
 else     if (opt.equals("-i")) {
      installerPackageName=nextOptionData();
      if (installerPackageName == null) {
        System.err.println("Error: no value specified for -i");
        return;
      }
    }
 else     if (opt.equals("-t")) {
      installFlags|=PackageManager.INSTALL_ALLOW_TEST;
    }
 else     if (opt.equals("-s")) {
      installFlags|=PackageManager.INSTALL_EXTERNAL;
    }
 else     if (opt.equals("-f")) {
      installFlags|=PackageManager.INSTALL_INTERNAL;
    }
 else     if (opt.equals("-d")) {
      installFlags|=PackageManager.INSTALL_ALLOW_DOWNGRADE;
    }
 else     if (opt.equals("--algo")) {
      algo=nextOptionData();
      if (algo == null) {
        System.err.println("Error: must supply argument for --algo");
        return;
      }
    }
 else     if (opt.equals("--iv")) {
      iv=hexToBytes(nextOptionData());
      if (iv == null) {
        System.err.println("Error: must supply argument for --iv");
        return;
      }
    }
 else     if (opt.equals("--key")) {
      key=hexToBytes(nextOptionData());
      if (key == null) {
        System.err.println("Error: must supply argument for --key");
        return;
      }
    }
 else     if (opt.equals("--macalgo")) {
      macAlgo=nextOptionData();
      if (macAlgo == null) {
        System.err.println("Error: must supply argument for --macalgo");
        return;
      }
    }
 else     if (opt.equals("--mackey")) {
      macKey=hexToBytes(nextOptionData());
      if (macKey == null) {
        System.err.println("Error: must supply argument for --mackey");
        return;
      }
    }
 else     if (opt.equals("--tag")) {
      tag=hexToBytes(nextOptionData());
      if (tag == null) {
        System.err.println("Error: must supply argument for --tag");
        return;
      }
    }
 else     if (opt.equals("--originating-uri")) {
      originatingUriString=nextOptionData();
      if (originatingUriString == null) {
        System.err.println("Error: must supply argument for --originating-uri");
        return;
      }
    }
 else     if (opt.equals("--referrer")) {
      referrer=nextOptionData();
      if (referrer == null) {
        System.err.println("Error: must supply argument for --referrer");
        return;
      }
    }
 else     if (opt.equals("--abi")) {
      abi=nextOptionData();
      if (abi == null) {
        System.err.println("Error: must supply argument for --abi");
        return;
      }
    }
 else {
      System.err.println("Error: Unknown option: " + opt);
      return;
    }
  }
  if (abi != null) {
    final String[] supportedAbis=Build.SUPPORTED_ABIS;
    boolean matched=false;
    for (    String supportedAbi : supportedAbis) {
      if (supportedAbi.equals(abi)) {
        matched=true;
        break;
      }
    }
    if (!matched) {
      System.err.println("Error: abi " + abi + " not supported on this device.");
      return;
    }
  }
  final ContainerEncryptionParams encryptionParams;
  if (algo != null || iv != null || key != null || macAlgo != null || macKey != null || tag != null) {
    if (algo == null || iv == null || key == null) {
      System.err.println("Error: all of --algo, --iv, and --key must be specified");
      return;
    }
    if (macAlgo != null || macKey != null || tag != null) {
      if (macAlgo == null || macKey == null || tag == null) {
        System.err.println("Error: all of --macalgo, --mackey, and --tag must " + "be specified");
        return;
      }
    }
    try {
      final SecretKey encKey=new SecretKeySpec(key,"RAW");
      final SecretKey macSecretKey;
      if (macKey == null || macKey.length == 0) {
        macSecretKey=null;
      }
 else {
        macSecretKey=new SecretKeySpec(macKey,"RAW");
      }
      encryptionParams=new ContainerEncryptionParams(algo,new IvParameterSpec(iv),encKey,macAlgo,null,macSecretKey,tag,-1,-1,-1);
    }
 catch (    InvalidAlgorithmParameterException e) {
      e.printStackTrace();
      return;
    }
  }
 else {
    encryptionParams=null;
  }
  final Uri apkURI;
  final Uri verificationURI;
  final Uri originatingURI;
  final Uri referrerURI;
  if (originatingUriString != null) {
    originatingURI=Uri.parse(originatingUriString);
  }
 else {
    originatingURI=null;
  }
  if (referrer != null) {
    referrerURI=Uri.parse(referrer);
  }
 else {
    referrerURI=null;
  }
  final String apkFilePath=nextArg();
  System.err.println("\tpkg: " + apkFilePath);
  if (apkFilePath != null) {
    apkURI=Uri.fromFile(new File(apkFilePath));
  }
 else {
    System.err.println("Error: no package specified");
    return;
  }
  final String verificationFilePath=nextArg();
  if (verificationFilePath != null) {
    System.err.println("\tver: " + verificationFilePath);
    verificationURI=Uri.fromFile(new File(verificationFilePath));
  }
 else {
    verificationURI=null;
  }
  PackageInstallObserver obs=new PackageInstallObserver();
  try {
    VerificationParams verificationParams=new VerificationParams(verificationURI,originatingURI,referrerURI,VerificationParams.NO_UID,null);
    mPm.installPackageWithVerificationEncryptionAndAbiOverrideEtc(apkURI,null,obs,installFlags,installerPackageName,verificationParams,encryptionParams,abi);
synchronized (obs) {
      while (!obs.finished) {
        try {
          obs.wait();
        }
 catch (        InterruptedException e) {
        }
      }
      if (obs.result == PackageManager.INSTALL_SUCCEEDED) {
        System.out.println("Success");
      }
 else {
        System.err.println("Failure [" + installFailureToString(obs) + "]");
      }
    }
  }
 catch (  RemoteException e) {
    System.err.println(e.toString());
    System.err.println(PM_NOT_RUNNING_ERR);
  }
}
