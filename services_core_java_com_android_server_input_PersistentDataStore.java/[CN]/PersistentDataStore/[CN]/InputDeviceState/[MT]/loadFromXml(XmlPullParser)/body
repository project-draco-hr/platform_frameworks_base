{
  final int outerDepth=parser.getDepth();
  while (XmlUtils.nextElementWithin(parser,outerDepth)) {
    if (parser.getName().equals("keyboard-layout")) {
      String descriptor=parser.getAttributeValue(null,"descriptor");
      if (descriptor == null) {
        throw new XmlPullParserException("Missing descriptor attribute on keyboard-layout.");
      }
      String current=parser.getAttributeValue(null,"current");
      if (current != null && current.equals("true")) {
        if (mCurrentKeyboardLayout != null) {
          throw new XmlPullParserException("Found multiple current keyboard layouts.");
        }
        mCurrentKeyboardLayout=descriptor;
      }
      String inputMethodId=parser.getAttributeValue(null,"input-method-id");
      String inputMethodSubtypeId=parser.getAttributeValue(null,"input-method-subtype-id");
      if (inputMethodId == null && inputMethodSubtypeId != null || inputMethodId != null && inputMethodSubtypeId == null) {
        throw new XmlPullParserException("Found an incomplete input method description");
      }
      if (inputMethodSubtypeId != null) {
        InputMethodSubtypeHandle handle=new InputMethodSubtypeHandle(inputMethodId,Integer.parseInt(inputMethodSubtypeId));
        if (mKeyboardLayouts.containsKey(handle)) {
          throw new XmlPullParserException("Found duplicate subtype to keyboard layout mapping: " + handle);
        }
        mKeyboardLayouts.put(handle,descriptor);
      }
 else {
        if (mUnassociatedKeyboardLayouts.contains(descriptor)) {
          throw new XmlPullParserException("Found duplicate unassociated keyboard layout: " + descriptor);
        }
        mUnassociatedKeyboardLayouts.add(descriptor);
      }
    }
 else     if (parser.getName().equals("calibration")) {
      String format=parser.getAttributeValue(null,"format");
      String rotation=parser.getAttributeValue(null,"rotation");
      int r=-1;
      if (format == null) {
        throw new XmlPullParserException("Missing format attribute on calibration.");
      }
      if (!format.equals("affine")) {
        throw new XmlPullParserException("Unsupported format for calibration.");
      }
      if (rotation != null) {
        try {
          r=stringToSurfaceRotation(rotation);
        }
 catch (        IllegalArgumentException e) {
          throw new XmlPullParserException("Unsupported rotation for calibration.");
        }
      }
      float[] matrix=TouchCalibration.IDENTITY.getAffineTransform();
      int depth=parser.getDepth();
      while (XmlUtils.nextElementWithin(parser,depth)) {
        String tag=parser.getName().toLowerCase();
        String value=parser.nextText();
        for (int i=0; i < matrix.length && i < CALIBRATION_NAME.length; i++) {
          if (tag.equals(CALIBRATION_NAME[i])) {
            matrix[i]=Float.parseFloat(value);
            break;
          }
        }
      }
      if (r == -1) {
        for (r=0; r < mTouchCalibration.length; r++) {
          mTouchCalibration[r]=new TouchCalibration(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);
        }
      }
 else {
        mTouchCalibration[r]=new TouchCalibration(matrix[0],matrix[1],matrix[2],matrix[3],matrix[4],matrix[5]);
      }
    }
  }
  Collections.sort(mUnassociatedKeyboardLayouts);
  if (mCurrentKeyboardLayout == null && !mUnassociatedKeyboardLayouts.isEmpty()) {
    mCurrentKeyboardLayout=mUnassociatedKeyboardLayouts.get(0);
  }
}
