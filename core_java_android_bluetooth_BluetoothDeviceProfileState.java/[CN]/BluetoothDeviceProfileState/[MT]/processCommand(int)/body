{
  Log.i(TAG,"Processing command:" + command);
switch (command) {
case CONNECT_HFP_OUTGOING:
    if (mHeadsetService != null) {
      return mHeadsetService.connectHeadsetInternal(mDevice);
    }
  break;
case CONNECT_HFP_INCOMING:
if (!mHeadsetServiceConnected) {
  deferProfileServiceMessage(command);
}
 else if (mHeadsetState == BluetoothHeadset.STATE_CONNECTING) {
  return mHeadsetService.acceptIncomingConnect(mDevice);
}
 else if (mHeadsetState == BluetoothHeadset.STATE_DISCONNECTED) {
  return mHeadsetService.createIncomingConnect(mDevice);
}
break;
case CONNECT_A2DP_OUTGOING:
if (mA2dpService != null) {
return mA2dpService.connectSinkInternal(mDevice);
}
break;
case CONNECT_A2DP_INCOMING:
return true;
case DISCONNECT_HFP_OUTGOING:
if (!mHeadsetServiceConnected) {
deferProfileServiceMessage(command);
}
 else {
Message m=new Message();
m.what=DISCONNECT_PBAP_OUTGOING;
deferMessage(m);
if (mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT) {
mHeadsetService.setPriority(mDevice,BluetoothHeadset.PRIORITY_ON);
}
return mHeadsetService.disconnectHeadsetInternal(mDevice);
}
break;
case DISCONNECT_HFP_INCOMING:
return true;
case DISCONNECT_A2DP_INCOMING:
return true;
case DISCONNECT_A2DP_OUTGOING:
if (mA2dpService != null) {
if (mA2dpService.getSinkPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT) {
mA2dpService.setSinkPriority(mDevice,BluetoothHeadset.PRIORITY_ON);
}
return mA2dpService.disconnectSinkInternal(mDevice);
}
break;
case DISCONNECT_PBAP_OUTGOING:
if (!mPbapServiceConnected) {
deferProfileServiceMessage(command);
}
 else {
return mPbapService.disconnect();
}
break;
case UNPAIR:
return mService.removeBondInternal(mDevice.getAddress());
default :
Log.e(TAG,"Error: Unknown Command");
}
return false;
}
