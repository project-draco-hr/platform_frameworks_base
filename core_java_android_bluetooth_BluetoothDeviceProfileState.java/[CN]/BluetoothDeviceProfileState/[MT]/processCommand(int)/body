{
  Log.e(TAG,"Processing command:" + command);
  Message msg;
switch (command) {
case CONNECT_HFP_OUTGOING:
    if (mHeadsetService != null) {
      return mHeadsetService.connectHeadsetInternal(mDevice);
    }
  break;
case CONNECT_HFP_INCOMING:
if (!mHeadsetServiceConnected) {
  deferProfileServiceMessage(command);
}
 else {
  int access=getTrust();
  if (access == BluetoothDevice.CONNECTION_ACCESS_YES) {
    handleIncomingConnection(command,true);
  }
 else   if (access == BluetoothDevice.CONNECTION_ACCESS_NO && !readIncomingAllowedValue()) {
    handleIncomingConnection(command,false);
  }
 else {
    sendConnectionAccessIntent();
    msg=obtainMessage(CONNECTION_ACCESS_REQUEST_EXPIRY);
    sendMessageDelayed(msg,CONNECTION_ACCESS_REQUEST_EXPIRY_TIMEOUT);
  }
  return true;
}
break;
case CONNECT_A2DP_OUTGOING:
if (mA2dpService != null) {
return mA2dpService.connectSinkInternal(mDevice);
}
break;
case CONNECT_A2DP_INCOMING:
int access=getTrust();
if (access == BluetoothDevice.CONNECTION_ACCESS_YES) {
handleIncomingConnection(command,true);
}
 else if (access == BluetoothDevice.CONNECTION_ACCESS_NO && !readIncomingAllowedValue()) {
handleIncomingConnection(command,false);
}
 else {
sendConnectionAccessIntent();
msg=obtainMessage(CONNECTION_ACCESS_REQUEST_EXPIRY);
sendMessageDelayed(msg,CONNECTION_ACCESS_REQUEST_EXPIRY_TIMEOUT);
}
return true;
case DISCONNECT_HFP_OUTGOING:
if (!mHeadsetServiceConnected) {
deferProfileServiceMessage(command);
}
 else {
Message m=new Message();
m.what=DISCONNECT_PBAP_OUTGOING;
deferMessage(m);
if (mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT) {
mHeadsetService.setPriority(mDevice,BluetoothHeadset.PRIORITY_ON);
}
return mHeadsetService.disconnectHeadsetInternal(mDevice);
}
break;
case DISCONNECT_HFP_INCOMING:
return true;
case DISCONNECT_A2DP_INCOMING:
return true;
case DISCONNECT_A2DP_OUTGOING:
if (mA2dpService != null) {
if (mA2dpService.getSinkPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT) {
mA2dpService.setSinkPriority(mDevice,BluetoothHeadset.PRIORITY_ON);
}
return mA2dpService.disconnectSinkInternal(mDevice);
}
break;
case DISCONNECT_PBAP_OUTGOING:
if (!mPbapServiceConnected) {
deferProfileServiceMessage(command);
}
 else {
return mPbapService.disconnect();
}
break;
case UNPAIR:
writeTimerValue(INIT_INCOMING_REJECT_TIMER);
setTrust(CONNECTION_ACCESS_UNDEFINED);
return mService.removeBondInternal(mDevice.getAddress());
default :
Log.e(TAG,"Error: Unknown Command");
}
return false;
}
