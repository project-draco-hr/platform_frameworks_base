{
  log("ACL Connected State -> Processing Message: " + message.what);
switch (message.what) {
case CONNECT_HFP_OUTGOING:
case DISCONNECT_HFP_OUTGOING:
    transitionTo(mOutgoingHandsfree);
  break;
case CONNECT_HFP_INCOMING:
transitionTo(mIncomingHandsfree);
break;
case DISCONNECT_HFP_INCOMING:
transitionTo(mIncomingHandsfree);
break;
case CONNECT_A2DP_OUTGOING:
case DISCONNECT_A2DP_OUTGOING:
transitionTo(mOutgoingA2dp);
break;
case CONNECT_A2DP_INCOMING:
case DISCONNECT_A2DP_INCOMING:
transitionTo(mIncomingA2dp);
break;
case CONNECT_HID_OUTGOING:
case DISCONNECT_HID_OUTGOING:
transitionTo(mOutgoingHid);
break;
case CONNECT_HID_INCOMING:
case DISCONNECT_HID_INCOMING:
transitionTo(mIncomingHid);
break;
case DISCONNECT_PBAP_OUTGOING:
processCommand(DISCONNECT_PBAP_OUTGOING);
break;
case UNPAIR:
if (mHeadsetState != BluetoothHeadset.STATE_DISCONNECTED) {
sendMessage(DISCONNECT_HFP_OUTGOING);
deferMessage(message);
break;
}
 else if (mA2dpState != BluetoothA2dp.STATE_DISCONNECTED) {
sendMessage(DISCONNECT_A2DP_OUTGOING);
deferMessage(message);
break;
}
 else if (mService.getInputDeviceConnectionState(mDevice) != BluetoothInputDevice.STATE_DISCONNECTED) {
sendMessage(DISCONNECT_HID_OUTGOING);
deferMessage(message);
break;
}
processCommand(UNPAIR);
break;
case AUTO_CONNECT_PROFILES:
if (isPhoneDocked(mDevice)) {
break;
}
 else {
if (mHeadsetService == null) {
mAutoConnectionPending=true;
}
 else if (mHeadsetService.getPriority(mDevice) == BluetoothHeadset.PRIORITY_AUTO_CONNECT && mHeadsetService.getDevicesMatchingConnectionStates(new int[]{BluetoothProfile.STATE_CONNECTED,BluetoothProfile.STATE_CONNECTING,BluetoothProfile.STATE_DISCONNECTING}).size() == 0) {
mHeadsetService.connect(mDevice);
}
if (mA2dpService != null && mA2dpService.getPriority(mDevice) == BluetoothA2dp.PRIORITY_AUTO_CONNECT && mA2dpService.getDevicesMatchingConnectionStates(new int[]{BluetoothA2dp.STATE_CONNECTED,BluetoothProfile.STATE_CONNECTING,BluetoothProfile.STATE_DISCONNECTING}).size() == 0) {
mA2dpService.connect(mDevice);
}
if (mService.getInputDevicePriority(mDevice) == BluetoothInputDevice.PRIORITY_AUTO_CONNECT) {
mService.connectInputDevice(mDevice);
}
}
break;
case CONNECT_OTHER_PROFILES:
if (isPhoneDocked(mDevice)) {
break;
}
if (message.arg1 == CONNECT_A2DP_OUTGOING) {
if (mA2dpService != null && mA2dpService.getConnectedDevices().size() == 0) {
Log.i(TAG,"A2dp:Connect Other Profiles");
mA2dpService.connect(mDevice);
}
}
 else if (message.arg1 == CONNECT_HFP_OUTGOING) {
if (mHeadsetService == null) {
deferMessage(message);
}
 else {
if (mHeadsetService.getConnectedDevices().size() == 0) {
Log.i(TAG,"Headset:Connect Other Profiles");
mHeadsetService.connect(mDevice);
}
}
}
break;
case TRANSITION_TO_STABLE:
break;
case SM_QUIT_CMD:
mContext.unregisterReceiver(mBroadcastReceiver);
mBroadcastReceiver=null;
mAdapter.closeProfileProxy(BluetoothProfile.HEADSET,mHeadsetService);
mBluetoothProfileServiceListener=null;
mOutgoingHandsfree=null;
mPbap=null;
mPbapService.close();
mPbapService=null;
mIncomingHid=null;
mOutgoingHid=null;
mIncomingHandsfree=null;
mOutgoingHandsfree=null;
mIncomingA2dp=null;
mOutgoingA2dp=null;
mBondedDevice=null;
return NOT_HANDLED;
default :
return NOT_HANDLED;
}
return HANDLED;
}
