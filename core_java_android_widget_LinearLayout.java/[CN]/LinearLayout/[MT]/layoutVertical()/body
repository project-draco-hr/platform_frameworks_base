{
  final int paddingLeft=mPaddingLeft;
  int childTop=mPaddingTop;
  int childLeft;
  final int width=mRight - mLeft;
  int childRight=width - mPaddingRight;
  int childSpace=width - paddingLeft - mPaddingRight;
  final int count=getVirtualChildCount();
  final int majorGravity=mGravity & Gravity.VERTICAL_GRAVITY_MASK;
  final int minorGravity=mGravity & Gravity.HORIZONTAL_GRAVITY_MASK;
  if (majorGravity != Gravity.TOP) {
switch (majorGravity) {
case Gravity.BOTTOM:
      childTop=mBottom - mTop + mPaddingTop - mTotalLength;
    break;
case Gravity.CENTER_VERTICAL:
  childTop+=((mBottom - mTop) - mTotalLength) / 2;
break;
}
}
final boolean showDividerMiddle=(mShowDividers & SHOW_DIVIDER_MIDDLE) == SHOW_DIVIDER_MIDDLE;
if ((mShowDividers & SHOW_DIVIDER_BEGINNING) == SHOW_DIVIDER_BEGINNING) {
childTop+=mDividerHeight;
}
for (int i=0; i < count; i++) {
final View child=getVirtualChildAt(i);
if (child == null) {
childTop+=measureNullChild(i);
}
 else if (child.getVisibility() != GONE) {
final int childWidth=child.getMeasuredWidth();
final int childHeight=child.getMeasuredHeight();
final LinearLayout.LayoutParams lp=(LinearLayout.LayoutParams)child.getLayoutParams();
int gravity=lp.gravity;
if (gravity < 0) {
gravity=minorGravity;
}
switch (gravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
case Gravity.LEFT:
childLeft=paddingLeft + lp.leftMargin;
break;
case Gravity.CENTER_HORIZONTAL:
childLeft=paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin;
break;
case Gravity.RIGHT:
childLeft=childRight - childWidth - lp.rightMargin;
break;
default :
childLeft=paddingLeft;
break;
}
childTop+=lp.topMargin;
setChildFrame(child,childLeft,childTop + getLocationOffset(child),childWidth,childHeight);
childTop+=childHeight + lp.bottomMargin + getNextLocationOffset(child);
if (showDividerMiddle) {
childTop+=mDividerHeight;
}
i+=getChildrenSkipCount(child,i);
}
}
}
