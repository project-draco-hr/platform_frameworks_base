{
synchronized (mCacheLock) {
switch (what) {
case PLAYBACKINFO_PLAYBACK_TYPE:
      if ((value >= PLAYBACK_TYPE_MIN) && (value <= PLAYBACK_TYPE_MAX)) {
        if (mPlaybackType != value) {
          mPlaybackType=value;
          sendAudioServiceNewPlaybackInfo_syncCacheLock(what,value);
        }
      }
 else {
        Log.w(TAG,"using invalid value for PLAYBACKINFO_PLAYBACK_TYPE");
      }
    break;
case PLAYBACKINFO_VOLUME:
  if ((value > -1) && (value <= mPlaybackVolumeMax)) {
    if (mPlaybackVolume != value) {
      mPlaybackVolume=value;
      sendAudioServiceNewPlaybackInfo_syncCacheLock(what,value);
    }
  }
 else {
    Log.w(TAG,"using invalid value for PLAYBACKINFO_VOLUME");
  }
break;
case PLAYBACKINFO_VOLUME_MAX:
if (value > 0) {
if (mPlaybackVolumeMax != value) {
  mPlaybackVolumeMax=value;
  sendAudioServiceNewPlaybackInfo_syncCacheLock(what,value);
}
}
 else {
Log.w(TAG,"using invalid value for PLAYBACKINFO_VOLUME_MAX");
}
break;
case PLAYBACKINFO_USES_STREAM:
if ((value >= 0) && (value < AudioSystem.getNumStreamTypes())) {
mPlaybackStream=value;
}
 else {
Log.w(TAG,"using invalid value for PLAYBACKINFO_USES_STREAM");
}
break;
case PLAYBACKINFO_VOLUME_HANDLING:
if ((value >= PLAYBACK_VOLUME_FIXED) && (value <= PLAYBACK_VOLUME_VARIABLE)) {
if (mPlaybackVolumeHandling != value) {
mPlaybackVolumeHandling=value;
sendAudioServiceNewPlaybackInfo_syncCacheLock(what,value);
}
}
 else {
Log.w(TAG,"using invalid value for PLAYBACKINFO_VOLUME_HANDLING");
}
break;
default :
Log.w(TAG,"setPlaybackInformation() ignoring unknown key " + what);
break;
}
}
}
