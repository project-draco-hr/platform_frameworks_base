{
  if (LOGV)   Slog.v(TAG,"writeUidStatsLocked()");
  if (!mUidStatsLoaded) {
    Slog.w(TAG,"asked to write UID stats when not loaded; skipping");
    return;
  }
  if (mTime.hasCache()) {
    final long currentTime=mTime.currentTimeMillis();
    final long maxUidHistory=mSettings.getUidMaxHistory();
    final long maxTagHistory=mSettings.getTagMaxHistory();
    for (    UidStatsKey key : mUidStats.keySet()) {
      final NetworkStatsHistory history=mUidStats.get(key);
      if (key.tag == TAG_NONE) {
        history.removeBucketsBefore(currentTime - maxUidHistory);
      }
 else {
        history.removeBucketsBefore(currentTime - maxTagHistory);
      }
    }
  }
  final HashMap<NetworkIdentitySet,ArrayList<UidStatsKey>> keysByIdent=Maps.newHashMap();
  for (  UidStatsKey key : mUidStats.keySet()) {
    ArrayList<UidStatsKey> keys=keysByIdent.get(key.ident);
    if (keys == null) {
      keys=Lists.newArrayList();
      keysByIdent.put(key.ident,keys);
    }
    keys.add(key);
  }
  FileOutputStream fos=null;
  try {
    fos=mUidFile.startWrite();
    final DataOutputStream out=new DataOutputStream(new BufferedOutputStream(fos));
    out.writeInt(FILE_MAGIC);
    out.writeInt(VERSION_UID_WITH_SET);
    out.writeInt(keysByIdent.size());
    for (    NetworkIdentitySet ident : keysByIdent.keySet()) {
      final ArrayList<UidStatsKey> keys=keysByIdent.get(ident);
      ident.writeToStream(out);
      out.writeInt(keys.size());
      for (      UidStatsKey key : keys) {
        final NetworkStatsHistory history=mUidStats.get(key);
        out.writeInt(key.uid);
        out.writeInt(key.set);
        out.writeInt(key.tag);
        history.writeToStream(out);
      }
    }
    out.flush();
    mUidFile.finishWrite(fos);
  }
 catch (  IOException e) {
    Log.wtf(TAG,"problem writing stats",e);
    if (fos != null) {
      mUidFile.failWrite(fos);
    }
  }
}
