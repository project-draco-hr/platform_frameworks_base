{
  final List<RootInfo> matching=new ArrayList<>();
  for (  RootInfo root : roots) {
    if (state.action == State.ACTION_CREATE && !root.supportsCreate())     continue;
    if (state.action == State.ACTION_PICK_COPY_DESTINATION && !root.supportsCreate())     continue;
    if (state.action == State.ACTION_OPEN_TREE && !root.supportsChildren())     continue;
    if (!state.showAdvanced && root.isAdvanced())     continue;
    if (state.localOnly && !root.isLocalOnly())     continue;
    if (state.directoryCopy && !root.supportsChildren())     continue;
    if (root.isEmpty() && (state.action == State.ACTION_OPEN || state.action == State.ACTION_GET_CONTENT)) {
      if (DEBUG)       Log.i(TAG,"Skipping empty root: " + root);
      continue;
    }
    final boolean overlap=MimePredicate.mimeMatches(root.derivedMimeTypes,state.acceptMimes) || MimePredicate.mimeMatches(state.acceptMimes,root.derivedMimeTypes);
    if (!overlap) {
      continue;
    }
    if (state.excludedAuthorities.contains(root.authority)) {
      if (DEBUG)       Log.d(TAG,"Excluding root " + root.authority + " from calling package.");
      continue;
    }
    if (DEBUG)     Log.d(TAG,"Including root " + root + " in roots list.");
    matching.add(root);
  }
  return matching;
}
