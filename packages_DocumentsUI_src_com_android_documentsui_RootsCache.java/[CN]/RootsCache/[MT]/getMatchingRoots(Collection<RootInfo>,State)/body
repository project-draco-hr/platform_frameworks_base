{
  final List<RootInfo> matching=Lists.newArrayList();
  for (  RootInfo root : roots) {
    final boolean supportsCreate=(root.flags & Root.FLAG_SUPPORTS_CREATE) != 0;
    final boolean supportsIsChild=(root.flags & Root.FLAG_SUPPORTS_IS_CHILD) != 0;
    final boolean advanced=(root.flags & Root.FLAG_ADVANCED) != 0;
    final boolean localOnly=(root.flags & Root.FLAG_LOCAL_ONLY) != 0;
    final boolean empty=(root.flags & Root.FLAG_EMPTY) != 0;
    if (state.action == State.ACTION_CREATE && !supportsCreate)     continue;
    if (state.action == State.ACTION_OPEN_COPY_DESTINATION && !supportsCreate)     continue;
    if (state.action == State.ACTION_OPEN_TREE && !supportsIsChild)     continue;
    if (!state.showAdvanced && advanced)     continue;
    if (state.localOnly && !localOnly)     continue;
    if ((state.action != State.ACTION_CREATE || state.action != State.ACTION_OPEN_TREE || state.action != State.ACTION_OPEN_COPY_DESTINATION) && empty)     continue;
    final boolean overlap=MimePredicate.mimeMatches(root.derivedMimeTypes,state.acceptMimes) || MimePredicate.mimeMatches(state.acceptMimes,root.derivedMimeTypes);
    if (!overlap) {
      continue;
    }
    matching.add(root);
  }
  return matching;
}
