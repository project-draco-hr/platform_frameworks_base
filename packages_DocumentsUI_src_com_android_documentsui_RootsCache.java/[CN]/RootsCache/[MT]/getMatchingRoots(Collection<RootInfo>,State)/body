{
  final List<RootInfo> matching=new ArrayList<>();
  for (  RootInfo root : roots) {
    final boolean supportsCreate=(root.flags & Root.FLAG_SUPPORTS_CREATE) != 0;
    final boolean supportsIsChild=(root.flags & Root.FLAG_SUPPORTS_IS_CHILD) != 0;
    final boolean advanced=(root.flags & Root.FLAG_ADVANCED) != 0;
    final boolean localOnly=(root.flags & Root.FLAG_LOCAL_ONLY) != 0;
    final boolean empty=(root.flags & Root.FLAG_EMPTY) != 0;
    if (state.action == State.ACTION_CREATE && !supportsCreate)     continue;
    if (state.action == State.ACTION_OPEN_COPY_DESTINATION && !supportsCreate)     continue;
    if (state.action == State.ACTION_OPEN_TREE && !supportsIsChild)     continue;
    if (!state.showAdvanced && advanced)     continue;
    if (state.localOnly && !localOnly)     continue;
    if (state.directoryCopy && root.isDownloads())     continue;
    if (empty && (state.action == State.ACTION_OPEN || state.action == State.ACTION_GET_CONTENT)) {
      if (DEBUG)       Log.i(TAG,"Skipping empty root: " + root);
      continue;
    }
    final boolean overlap=MimePredicate.mimeMatches(root.derivedMimeTypes,state.acceptMimes) || MimePredicate.mimeMatches(state.acceptMimes,root.derivedMimeTypes);
    if (!overlap) {
      continue;
    }
    if (state.excludedAuthorities.contains(root.authority)) {
      if (DEBUG)       Log.d(TAG,"Excluding root " + root.authority + " from calling package.");
      continue;
    }
    matching.add(root);
  }
  return matching;
}
