{
  if (mExecutingActions) {
    throw new IllegalStateException("Recursive entry to executePendingTransactions");
  }
  if (Looper.myLooper() != mHost.getHandler().getLooper()) {
    throw new IllegalStateException("Must be called from main thread of process");
  }
  boolean didSomething=false;
  while (true) {
    int numActions;
synchronized (this) {
      if (mPendingActions == null || mPendingActions.size() == 0) {
        break;
      }
      numActions=mPendingActions.size();
      if (mTmpActions == null || mTmpActions.length < numActions) {
        mTmpActions=new Runnable[numActions];
      }
      mPendingActions.toArray(mTmpActions);
      mPendingActions.clear();
      mHost.getHandler().removeCallbacks(mExecCommit);
    }
    mExecutingActions=true;
    for (int i=0; i < numActions; i++) {
      mTmpActions[i].run();
      mTmpActions[i]=null;
    }
    mExecutingActions=false;
    didSomething=true;
  }
  if (mHavePendingDeferredStart) {
    boolean loadersRunning=false;
    for (int i=0; i < mActive.size(); i++) {
      Fragment f=mActive.get(i);
      if (f != null && f.mLoaderManager != null) {
        loadersRunning|=f.mLoaderManager.hasRunningLoaders();
      }
    }
    if (!loadersRunning) {
      mHavePendingDeferredStart=false;
      startPendingDeferredFragments();
    }
  }
  return didSomething;
}
