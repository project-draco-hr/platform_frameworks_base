{
  if (mExecutingActions) {
    throw new IllegalStateException("Recursive entry to executePendingTransactions");
  }
  if (Looper.myLooper() != mHost.getHandler().getLooper()) {
    throw new IllegalStateException("Must be called from main thread of process");
  }
  boolean didSomething=false;
  while (true) {
    int numActions;
synchronized (this) {
      if (mPendingActions == null || mPendingActions.size() == 0) {
        break;
      }
      numActions=mPendingActions.size();
      if (mTmpActions == null || mTmpActions.length < numActions) {
        mTmpActions=new Runnable[numActions];
      }
      mPendingActions.toArray(mTmpActions);
      mPendingActions.clear();
      mHost.getHandler().removeCallbacks(mExecCommit);
    }
    mExecutingActions=true;
    for (int i=0; i < numActions; i++) {
      mTmpActions[i].run();
      mTmpActions[i]=null;
    }
    mExecutingActions=false;
    didSomething=true;
  }
  doPendingDeferredStart();
  return didSomething;
}
