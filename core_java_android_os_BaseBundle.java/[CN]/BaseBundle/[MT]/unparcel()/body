{
  if (mParcelledData == null) {
    if (DEBUG)     Log.d(TAG,"unparcel " + Integer.toHexString(System.identityHashCode(this)) + ": no parcelled data");
    return;
  }
  if (sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
    Slog.wtf(TAG,"Attempting to unparcel a Bundle while in transit; this may " + "clobber all data inside!",new Throwable());
  }
  if (mParcelledData == EMPTY_PARCEL) {
    if (DEBUG)     Log.d(TAG,"unparcel " + Integer.toHexString(System.identityHashCode(this)) + ": empty");
    if (mMap == null) {
      mMap=new ArrayMap<String,Object>(1);
    }
 else {
      mMap.erase();
    }
    mParcelledData=null;
    return;
  }
  int N=mParcelledData.readInt();
  if (DEBUG)   Log.d(TAG,"unparcel " + Integer.toHexString(System.identityHashCode(this)) + ": reading "+ N+ " maps");
  if (N < 0) {
    return;
  }
  if (mMap == null) {
    mMap=new ArrayMap<String,Object>(N);
  }
 else {
    mMap.erase();
    mMap.ensureCapacity(N);
  }
  try {
    mParcelledData.readArrayMapInternal(mMap,N,mClassLoader);
  }
 catch (  BadParcelableException e) {
    if (sShouldDefuse) {
      Log.w(TAG,"Failed to parse Bundle, but defusing quietly",e);
      mMap.erase();
    }
 else {
      throw e;
    }
  }
 finally {
    mParcelledData.recycle();
    mParcelledData=null;
  }
  if (DEBUG)   Log.d(TAG,"unparcel " + Integer.toHexString(System.identityHashCode(this)) + " final map: "+ mMap);
}
