{
  final ArrayList<WindowState> windows=mWindows;
  final boolean inDrag=(mDragState != null);
  if (inDrag) {
    if (DEBUG_DRAG) {
      Log.d(TAG,"Inserting drag window");
    }
    addDragInputWindow(mTempInputWindows);
  }
  final int N=windows.size();
  for (int i=N - 1; i >= 0; i--) {
    final WindowState child=windows.get(i);
    if (child.mInputChannel == null || child.mRemoved) {
      continue;
    }
    final int flags=child.mAttrs.flags;
    final int type=child.mAttrs.type;
    final boolean hasFocus=(child == mInputFocus);
    final boolean isVisible=child.isVisibleLw();
    final boolean hasWallpaper=(child == mWallpaperTarget) && (type != WindowManager.LayoutParams.TYPE_KEYGUARD);
    if (inDrag && isVisible) {
      mDragState.sendDragStartedIfNeededLw(child);
    }
    final InputWindow inputWindow=mTempInputWindows.add();
    inputWindow.inputChannel=child.mInputChannel;
    inputWindow.name=child.toString();
    inputWindow.layoutParamsFlags=flags;
    inputWindow.layoutParamsType=type;
    inputWindow.dispatchingTimeoutNanos=child.getInputDispatchingTimeoutNanos();
    inputWindow.visible=isVisible;
    inputWindow.canReceiveKeys=child.canReceiveKeys();
    inputWindow.hasFocus=hasFocus;
    inputWindow.hasWallpaper=hasWallpaper;
    inputWindow.paused=child.mAppToken != null ? child.mAppToken.paused : false;
    inputWindow.layer=child.mLayer;
    inputWindow.ownerPid=child.mSession.mPid;
    inputWindow.ownerUid=child.mSession.mUid;
    final Rect frame=child.mFrame;
    inputWindow.frameLeft=frame.left;
    inputWindow.frameTop=frame.top;
    inputWindow.frameRight=frame.right;
    inputWindow.frameBottom=frame.bottom;
    final Rect visibleFrame=child.mVisibleFrame;
    inputWindow.visibleFrameLeft=visibleFrame.left;
    inputWindow.visibleFrameTop=visibleFrame.top;
    inputWindow.visibleFrameRight=visibleFrame.right;
    inputWindow.visibleFrameBottom=visibleFrame.bottom;
switch (child.mTouchableInsets) {
default :
case ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_FRAME:
      inputWindow.touchableAreaLeft=frame.left;
    inputWindow.touchableAreaTop=frame.top;
  inputWindow.touchableAreaRight=frame.right;
inputWindow.touchableAreaBottom=frame.bottom;
break;
case ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT:
{
Rect inset=child.mGivenContentInsets;
inputWindow.touchableAreaLeft=frame.left + inset.left;
inputWindow.touchableAreaTop=frame.top + inset.top;
inputWindow.touchableAreaRight=frame.right - inset.right;
inputWindow.touchableAreaBottom=frame.bottom - inset.bottom;
break;
}
case ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE:
{
Rect inset=child.mGivenVisibleInsets;
inputWindow.touchableAreaLeft=frame.left + inset.left;
inputWindow.touchableAreaTop=frame.top + inset.top;
inputWindow.touchableAreaRight=frame.right - inset.right;
inputWindow.touchableAreaBottom=frame.bottom - inset.bottom;
break;
}
}
}
mInputManager.setInputWindows(mTempInputWindows.toNullTerminatedArray());
mTempInputWindows.clear();
}
