{
  mOutsideTouchTargets=null;
  if (nextKey != null) {
    final int keycode=nextKey.getKeyCode();
    final int repeatCount=nextKey.getRepeatCount();
    final boolean down=nextKey.getAction() != KeyEvent.ACTION_UP;
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(keycode);
    if (!dispatch) {
      if (callingUid == 0 || mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,callingPid,callingUid) == PackageManager.PERMISSION_GRANTED) {
        mPolicy.interceptKeyTi(null,keycode,nextKey.getMetaState(),down,repeatCount,nextKey.getFlags());
      }
      Slog.w(TAG,"Event timeout during app switch: dropping " + nextKey);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    if (callingUid == 0 || (focus != null && callingUid == focus.mSession.mUid) || mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,callingPid,callingUid) == PackageManager.PERMISSION_GRANTED) {
      if (mPolicy.interceptKeyTi(focus,keycode,nextKey.getMetaState(),down,repeatCount,nextKey.getFlags())) {
        return CONSUMED_EVENT_TOKEN;
      }
    }
    return focus;
  }
 else   if (!isPointerEvent) {
    boolean dispatch=mKeyWaiter.checkShouldDispatchKey(-1);
    if (!dispatch) {
      Slog.w(TAG,"Event timeout during app switch: dropping trackball " + nextMotion);
      return SKIP_TARGET_TOKEN;
    }
    WindowState focus=null;
synchronized (mWindowMap) {
      focus=getFocusedWindowLocked();
    }
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    return focus;
  }
  if (nextMotion == null) {
    return SKIP_TARGET_TOKEN;
  }
  boolean dispatch=mKeyWaiter.checkShouldDispatchKey(KeyEvent.KEYCODE_UNKNOWN);
  if (!dispatch) {
    Slog.w(TAG,"Event timeout during app switch: dropping pointer " + nextMotion);
    return SKIP_TARGET_TOKEN;
  }
  int action=nextMotion.getAction();
  final float xf=nextMotion.getX();
  final float yf=nextMotion.getY();
  final long eventTime=nextMotion.getEventTime();
  final boolean screenWasOff=qev != null && (qev.flags & WindowManagerPolicy.FLAG_BRIGHT_HERE) != 0;
  WindowState target=null;
synchronized (mWindowMap) {
synchronized (this) {
      if (action == MotionEvent.ACTION_DOWN) {
        if (mMotionTarget != null) {
          Slog.w(TAG,"Pointer down received while already down in: " + mMotionTarget);
          mMotionTarget=null;
        }
        final int x=(int)xf;
        final int y=(int)yf;
        final ArrayList windows=mWindows;
        final int N=windows.size();
        WindowState topErrWindow=null;
        final Rect tmpRect=mTempRect;
        for (int i=N - 1; i >= 0; i--) {
          WindowState child=(WindowState)windows.get(i);
          final int flags=child.mAttrs.flags;
          if ((flags & WindowManager.LayoutParams.FLAG_SYSTEM_ERROR) != 0) {
            if (topErrWindow == null) {
              topErrWindow=child;
            }
          }
          if (!child.isVisibleLw()) {
            continue;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
            if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
              child.mNextOutsideTouch=mOutsideTouchTargets;
              mOutsideTouchTargets=child;
            }
            continue;
          }
          tmpRect.set(child.mFrame);
          if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT) {
            tmpRect.left+=child.mGivenContentInsets.left;
            tmpRect.top+=child.mGivenContentInsets.top;
            tmpRect.right-=child.mGivenContentInsets.right;
            tmpRect.bottom-=child.mGivenContentInsets.bottom;
          }
 else           if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE) {
            tmpRect.left+=child.mGivenVisibleInsets.left;
            tmpRect.top+=child.mGivenVisibleInsets.top;
            tmpRect.right-=child.mGivenVisibleInsets.right;
            tmpRect.bottom-=child.mGivenVisibleInsets.bottom;
          }
          final int touchFlags=flags & (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
          if (tmpRect.contains(x,y) || touchFlags == 0) {
            if (!screenWasOff || (flags & WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING) != 0) {
              mMotionTarget=child;
            }
 else {
              mMotionTarget=null;
            }
            break;
          }
          if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
            child.mNextOutsideTouch=mOutsideTouchTargets;
            mOutsideTouchTargets=child;
          }
        }
        if (topErrWindow != null && mMotionTarget != topErrWindow) {
          mMotionTarget=null;
        }
      }
      target=mMotionTarget;
    }
  }
  wakeupIfNeeded(target,eventType(nextMotion));
  return target != null ? target : SKIP_TARGET_TOKEN;
}
