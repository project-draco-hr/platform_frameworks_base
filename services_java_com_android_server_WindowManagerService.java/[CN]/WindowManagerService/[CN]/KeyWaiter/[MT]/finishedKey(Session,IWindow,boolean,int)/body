{
  if (DEBUG_INPUT)   Log.v(TAG,"finishedKey: client=" + client + ", force="+ force);
  if (client == null) {
    return null;
  }
synchronized (this) {
    if (DEBUG_INPUT)     Log.v(TAG,"finishedKey: client=" + client.asBinder() + ", force="+ force+ ", last="+ mLastBinder+ " (token="+ (mLastWin != null ? mLastWin.mToken : null)+ ")");
    QueuedEvent qev=null;
    WindowState win=null;
    if (returnWhat == RETURN_PENDING_POINTER) {
      qev=session.mPendingPointerMove;
      win=session.mPendingPointerWindow;
      session.mPendingPointerMove=null;
      session.mPendingPointerWindow=null;
    }
 else     if (returnWhat == RETURN_PENDING_TRACKBALL) {
      qev=session.mPendingTrackballMove;
      win=session.mPendingTrackballWindow;
      session.mPendingTrackballMove=null;
      session.mPendingTrackballWindow=null;
    }
    if (mLastBinder == client.asBinder()) {
      if (DEBUG_INPUT)       Log.v(TAG,"finishedKey: last paused=" + ((mLastWin != null) ? mLastWin.mToken.paused : "null"));
      if (mLastWin != null && (!mLastWin.mToken.paused || force || !mEventDispatching)) {
        doFinishedKeyLocked(false);
      }
 else {
        mFinished=true;
        notifyAll();
      }
    }
 else {
      if (DEBUG_INPUT || true)       Log.v(TAG,"finishedKey: " + client + " tried to finish but mLastBinder="+ mLastBinder);
    }
    if (qev != null) {
      MotionEvent res=(MotionEvent)qev.event;
      if (DEBUG_INPUT)       Log.v(TAG,"Returning pending motion: " + res);
      mQueue.recycleEvent(qev);
      if (win != null && returnWhat == RETURN_PENDING_POINTER) {
        res.offsetLocation(-win.mFrame.left,-win.mFrame.top);
      }
      return res;
    }
    return null;
  }
}
