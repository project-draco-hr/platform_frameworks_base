{
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  KeyEvent lastKey=null;
  long lastKeyTime=SystemClock.uptimeMillis();
  long nextKeyTime=lastKeyTime + LONG_WAIT;
  long downTime=0;
  int keyRepeatCount=0;
  boolean configChanged=false;
  while (true) {
    long curTime=SystemClock.uptimeMillis();
    if (DEBUG_INPUT)     Slog.v(TAG,"Waiting for next key: now=" + curTime + ", repeat @ "+ nextKeyTime);
    QueuedEvent ev=mQueue.getEvent((int)((!configChanged && curTime < nextKeyTime) ? (nextKeyTime - curTime) : 0));
    if (DEBUG_INPUT && ev != null)     Slog.v(TAG,"Event: type=" + ev.classType + " data="+ ev.event);
    if (MEASURE_LATENCY) {
      lt.sample("2 got event              ",System.nanoTime() - ev.whenNano);
    }
    if (lastKey != null && !mPolicy.allowKeyRepeat()) {
      lastKey=null;
      downTime=0;
      lastKeyTime=curTime;
      nextKeyTime=curTime + LONG_WAIT;
    }
    try {
      if (ev != null) {
        curTime=SystemClock.uptimeMillis();
        int eventType;
        if (ev.classType == RawInputEvent.CLASS_TOUCHSCREEN) {
          eventType=eventType((MotionEvent)ev.event);
        }
 else         if (ev.classType == RawInputEvent.CLASS_KEYBOARD || ev.classType == RawInputEvent.CLASS_TRACKBALL) {
          eventType=LocalPowerManager.BUTTON_EVENT;
        }
 else {
          eventType=LocalPowerManager.OTHER_EVENT;
        }
        try {
          if ((curTime - mLastBatteryStatsCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
            mLastBatteryStatsCallTime=curTime;
            mBatteryStats.noteInputEvent();
          }
        }
 catch (        RemoteException e) {
        }
        if (ev.classType == RawInputEvent.CLASS_CONFIGURATION_CHANGED) {
        }
 else         if (eventType != TOUCH_EVENT && eventType != LONG_TOUCH_EVENT && eventType != CHEEK_EVENT) {
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
 else         if (mLastTouchEventType != eventType || (curTime - mLastUserActivityCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
          mLastUserActivityCallTime=curTime;
          mLastTouchEventType=eventType;
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
switch (ev.classType) {
case RawInputEvent.CLASS_KEYBOARD:
          KeyEvent ke=(KeyEvent)ev.event;
        if (ke.isDown()) {
          lastKey=ke;
          downTime=curTime;
          keyRepeatCount=0;
          lastKeyTime=curTime;
          nextKeyTime=lastKeyTime + ViewConfiguration.getLongPressTimeout();
          if (DEBUG_INPUT)           Slog.v(TAG,"Received key down: first repeat @ " + nextKeyTime);
        }
 else {
          lastKey=null;
          downTime=0;
          lastKeyTime=curTime;
          nextKeyTime=curTime + LONG_WAIT;
          if (DEBUG_INPUT)           Slog.v(TAG,"Received key up: ignore repeat @ " + nextKeyTime);
        }
      dispatchKey((KeyEvent)ev.event,0,0);
    mQueue.recycleEvent(ev);
  break;
case RawInputEvent.CLASS_TOUCHSCREEN:
dispatchPointer(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_TRACKBALL:
dispatchTrackball(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_CONFIGURATION_CHANGED:
configChanged=true;
break;
default :
mQueue.recycleEvent(ev);
break;
}
}
 else if (configChanged) {
configChanged=false;
sendNewConfiguration();
}
 else if (lastKey != null) {
curTime=SystemClock.uptimeMillis();
if (DEBUG_INPUT) Slog.v(TAG,"Key timeout: repeat=" + nextKeyTime + ", now="+ curTime);
if (curTime < nextKeyTime) {
continue;
}
lastKeyTime=nextKeyTime;
nextKeyTime=nextKeyTime + KEY_REPEAT_DELAY;
keyRepeatCount++;
if (DEBUG_INPUT) Slog.v(TAG,"Key repeat: count=" + keyRepeatCount + ", next @ "+ nextKeyTime);
KeyEvent newEvent;
if (downTime != 0 && (downTime + ViewConfiguration.getLongPressTimeout()) <= curTime) {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount,lastKey.getFlags() | KeyEvent.FLAG_LONG_PRESS);
downTime=0;
}
 else {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount);
}
dispatchKey(newEvent,0,0);
}
 else {
curTime=SystemClock.uptimeMillis();
lastKeyTime=curTime;
nextKeyTime=curTime + LONG_WAIT;
}
}
 catch (Exception e) {
Slog.e(TAG,"Input thread received uncaught exception: " + e,e);
}
}
}
