{
  if (DEBUG_INPUT || WindowManagerPolicy.WATCH_POINTER)   Log.v(TAG,"dispatchPointer " + ev);
  if (MEASURE_LATENCY) {
    lt.sample("3 Wait for last dispatch ",System.nanoTime() - qev.whenNano);
  }
  Object targetObj=mKeyWaiter.waitForNextEventTarget(null,qev,ev,true,false);
  if (MEASURE_LATENCY) {
    lt.sample("3 Last dispatch finished ",System.nanoTime() - qev.whenNano);
  }
  int action=ev.getAction();
  if (action == MotionEvent.ACTION_UP) {
    mKeyWaiter.mMotionTarget=null;
    mPowerManager.logPointerUpEvent();
  }
 else   if (action == MotionEvent.ACTION_DOWN) {
    mPowerManager.logPointerDownEvent();
  }
  if (targetObj == null) {
    if (action != MotionEvent.ACTION_MOVE) {
      Log.w(TAG,"No window to dispatch pointer action " + ev.getAction());
    }
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return false;
  }
  if (targetObj == mKeyWaiter.CONSUMED_EVENT_TOKEN) {
    if (qev != null) {
      mQueue.recycleEvent(qev);
    }
    ev.recycle();
    return true;
  }
  WindowState target=(WindowState)targetObj;
  final long eventTime=ev.getEventTime();
  final long eventTimeNano=ev.getEventTimeNano();
  if (uid != 0 && uid != target.mSession.mUid) {
    if (mContext.checkPermission(android.Manifest.permission.INJECT_EVENTS,pid,uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,"Permission denied: injecting pointer event from pid " + pid + " uid "+ uid+ " to window "+ target+ " owned by uid "+ target.mSession.mUid);
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return false;
    }
  }
  if (MEASURE_LATENCY) {
    lt.sample("4 in dispatchPointer     ",System.nanoTime() - eventTimeNano);
  }
  if ((target.mAttrs.flags & WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES) != 0) {
    boolean cheekPress=mPolicy.isCheekPressedAgainstScreen(ev);
    boolean returnFlag=false;
    if ((action == MotionEvent.ACTION_DOWN)) {
      mFatTouch=false;
      if (cheekPress) {
        mFatTouch=true;
        returnFlag=true;
      }
    }
 else {
      if (action == MotionEvent.ACTION_UP) {
        if (mFatTouch) {
          mFatTouch=false;
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
        }
      }
 else       if (action == MotionEvent.ACTION_MOVE) {
        if (mFatTouch) {
          returnFlag=true;
        }
 else         if (cheekPress) {
          ev.setAction(MotionEvent.ACTION_CANCEL);
          action=MotionEvent.ACTION_CANCEL;
          if (DEBUG_INPUT)           Log.v(TAG,"Sending cancel for invalid ACTION_MOVE");
          mFatTouch=true;
        }
      }
    }
    if (returnFlag) {
      if (qev != null) {
        mQueue.recycleEvent(qev);
      }
      ev.recycle();
      return false;
    }
  }
  if (action == MotionEvent.ACTION_DOWN) {
    int max_events_per_sec=35;
    try {
      max_events_per_sec=Integer.parseInt(SystemProperties.get("windowsmgr.max_events_per_sec"));
      if (max_events_per_sec < 1) {
        max_events_per_sec=35;
      }
    }
 catch (    NumberFormatException e) {
    }
    mMinWaitTimeBetweenTouchEvents=1000 / max_events_per_sec;
  }
  if (action == MotionEvent.ACTION_MOVE) {
    long nextEventTime=mLastTouchEventTime + mMinWaitTimeBetweenTouchEvents;
    long now=SystemClock.uptimeMillis();
    if (now < nextEventTime) {
      try {
        Thread.sleep(nextEventTime - now);
      }
 catch (      InterruptedException e) {
      }
      mLastTouchEventTime=nextEventTime;
    }
 else {
      mLastTouchEventTime=now;
    }
  }
  if (MEASURE_LATENCY) {
    lt.sample("5 in dispatchPointer     ",System.nanoTime() - eventTimeNano);
  }
synchronized (mWindowMap) {
    if (qev != null && action == MotionEvent.ACTION_MOVE) {
      mKeyWaiter.bindTargetWindowLocked(target,KeyWaiter.RETURN_PENDING_POINTER,qev);
      ev=null;
    }
 else {
      if (action == MotionEvent.ACTION_DOWN) {
        WindowState out=mKeyWaiter.mOutsideTouchTargets;
        if (out != null) {
          MotionEvent oev=MotionEvent.obtain(ev);
          oev.setAction(MotionEvent.ACTION_OUTSIDE);
          do {
            final Rect frame=out.mFrame;
            oev.offsetLocation(-(float)frame.left,-(float)frame.top);
            try {
              out.mClient.dispatchPointer(oev,eventTime);
            }
 catch (            android.os.RemoteException e) {
              Log.i(TAG,"WINDOW DIED during outside motion dispatch: " + out);
            }
            oev.offsetLocation((float)frame.left,(float)frame.top);
            out=out.mNextOutsideTouch;
          }
 while (out != null);
          mKeyWaiter.mOutsideTouchTargets=null;
        }
      }
      final Rect frame=target.mFrame;
      ev.offsetLocation(-(float)frame.left,-(float)frame.top);
      mKeyWaiter.bindTargetWindowLocked(target);
    }
  }
  try {
    if (DEBUG_INPUT || DEBUG_FOCUS || WindowManagerPolicy.WATCH_POINTER) {
      Log.v(TAG,"Delivering pointer " + qev + " to "+ target);
    }
    if (MEASURE_LATENCY) {
      lt.sample("6 before svr->client ipc ",System.nanoTime() - eventTimeNano);
    }
    target.mClient.dispatchPointer(ev,eventTime);
    if (MEASURE_LATENCY) {
      lt.sample("7 after  svr->client ipc ",System.nanoTime() - eventTimeNano);
    }
    return true;
  }
 catch (  android.os.RemoteException e) {
    Log.i(TAG,"WINDOW DIED during motion dispatch: " + target);
    mKeyWaiter.mMotionTarget=null;
    try {
      removeWindow(target.mSession,target.mClient);
    }
 catch (    java.util.NoSuchElementException ex) {
    }
  }
  return false;
}
