{
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
    mLastRotationFlags=animFlags;
  }
  if (DEBUG_ORIENTATION)   Slog.v(TAG,"Overwriting rotation value from " + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Slog.v(TAG,"new rotation is set to " + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Slog.v(TAG,"Rotation changed to " + rotation + " from "+ mRotation+ " (forceApp="+ mForcedAppOrientation+ ", req="+ mRequestedRotation+ ")");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    mWaitingForConfig=true;
    mLayoutNeeded=true;
    startFreezingDisplayLocked();
    Slog.i(TAG,"Setting rotation to " + rotation + ", animFlags="+ animFlags);
    if (ENABLE_NATIVE_INPUT_DISPATCH) {
      mInputManager.setDisplayOrientation(0,rotation);
    }
 else {
      mQueue.setOrientation(rotation);
    }
    if (mDisplayEnabled) {
      Surface.setOrientation(0,rotation,animFlags);
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}
