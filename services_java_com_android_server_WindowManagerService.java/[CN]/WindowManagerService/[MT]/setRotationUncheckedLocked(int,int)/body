{
  boolean changed;
  if (rotation == WindowManagerPolicy.USE_LAST_ROTATION) {
    rotation=mRequestedRotation;
  }
 else {
    mRequestedRotation=rotation;
    mLastRotationFlags=animFlags;
  }
  if (DEBUG_ORIENTATION)   Slog.v(TAG,"Overwriting rotation value from " + rotation);
  rotation=mPolicy.rotationForOrientationLw(mForcedAppOrientation,mRotation,mDisplayEnabled);
  if (DEBUG_ORIENTATION)   Slog.v(TAG,"new rotation is set to " + rotation);
  changed=mDisplayEnabled && mRotation != rotation;
  if (changed) {
    if (DEBUG_ORIENTATION)     Slog.v(TAG,"Rotation changed to " + rotation + " from "+ mRotation+ " (forceApp="+ mForcedAppOrientation+ ", req="+ mRequestedRotation+ ")");
    mRotation=rotation;
    mWindowsFreezingScreen=true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
    mWaitingForConfig=true;
    mLayoutNeeded=true;
    startFreezingDisplayLocked();
    Slog.i(TAG,"Setting rotation to " + rotation + ", animFlags="+ animFlags);
    mInputManager.setDisplayOrientation(0,rotation);
    if (mDisplayEnabled) {
      if (CUSTOM_SCREEN_ROTATION) {
        Surface.freezeDisplay(0);
        Surface.openTransaction();
        if (mScreenRotationAnimation != null) {
          mScreenRotationAnimation.setRotation(rotation);
        }
        Surface.closeTransaction();
        Surface.setOrientation(0,rotation,animFlags);
        Surface.unfreezeDisplay(0);
      }
 else {
        Surface.setOrientation(0,rotation,animFlags);
      }
    }
    for (int i=mWindows.size() - 1; i >= 0; i--) {
      WindowState w=mWindows.get(i);
      if (w.mSurface != null) {
        w.mOrientationChanging=true;
      }
    }
    for (int i=mRotationWatchers.size() - 1; i >= 0; i--) {
      try {
        mRotationWatchers.get(i).onRotationChanged(rotation);
      }
 catch (      RemoteException e) {
      }
    }
  }
  return changed;
}
