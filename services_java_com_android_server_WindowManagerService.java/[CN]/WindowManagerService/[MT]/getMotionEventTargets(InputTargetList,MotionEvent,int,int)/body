{
  if (nature == InputQueue.INPUT_EVENT_NATURE_TRACKBALL) {
    WindowState focus=getFocusedWindow();
    wakeupIfNeeded(focus,LocalPowerManager.BUTTON_EVENT);
    addInputTarget(inputTargets,focus,InputTarget.FLAG_SYNC);
    return;
  }
  int action=event.getAction();
  final boolean screenWasOff=(policyFlags & WindowManagerPolicy.FLAG_BRIGHT_HERE) != 0;
  WindowState target=mTouchFocus;
  if (action == MotionEvent.ACTION_UP) {
    mPowerManager.logPointerUpEvent();
    clearTouchFocus();
  }
 else   if (action == MotionEvent.ACTION_DOWN) {
    mPowerManager.logPointerDownEvent();
synchronized (mWindowMap) {
      if (mTouchFocus != null) {
        Slog.w(TAG,"Pointer down received while already down in: " + mTouchFocus);
        clearTouchFocus();
      }
      final int x=(int)event.getX();
      final int y=(int)event.getY();
      final ArrayList windows=mWindows;
      final int N=windows.size();
      WindowState topErrWindow=null;
      final Rect tmpRect=mTempRect;
      for (int i=N - 1; i >= 0; i--) {
        WindowState child=(WindowState)windows.get(i);
        final int flags=child.mAttrs.flags;
        if ((flags & WindowManager.LayoutParams.FLAG_SYSTEM_ERROR) != 0) {
          if (topErrWindow == null) {
            topErrWindow=child;
          }
        }
        if (!child.isVisibleLw()) {
          continue;
        }
        if ((flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
          if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
            child.mNextOutsideTouch=mOutsideTouchTargets;
            mOutsideTouchTargets=child;
          }
          continue;
        }
        tmpRect.set(child.mFrame);
        if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_CONTENT) {
          tmpRect.left+=child.mGivenContentInsets.left;
          tmpRect.top+=child.mGivenContentInsets.top;
          tmpRect.right-=child.mGivenContentInsets.right;
          tmpRect.bottom-=child.mGivenContentInsets.bottom;
        }
 else         if (child.mTouchableInsets == ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_VISIBLE) {
          tmpRect.left+=child.mGivenVisibleInsets.left;
          tmpRect.top+=child.mGivenVisibleInsets.top;
          tmpRect.right-=child.mGivenVisibleInsets.right;
          tmpRect.bottom-=child.mGivenVisibleInsets.bottom;
        }
        final int touchFlags=flags & (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
        if (tmpRect.contains(x,y) || touchFlags == 0) {
          if (!screenWasOff || (flags & WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING) != 0) {
            mTouchFocus=child;
          }
 else {
            mTouchFocus=null;
          }
          break;
        }
        if ((flags & WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH) != 0) {
          child.mNextOutsideTouch=mOutsideTouchTargets;
          mOutsideTouchTargets=child;
        }
      }
      if (topErrWindow != null && mTouchFocus != topErrWindow) {
        mTouchFocus=null;
      }
    }
    target=mTouchFocus;
  }
  if (target != null) {
    wakeupIfNeeded(target,eventType(event));
  }
  int targetFlags=0;
  if (target == null) {
    if (action != MotionEvent.ACTION_MOVE) {
      Slog.w(TAG,"No window to dispatch pointer action " + action);
    }
  }
 else {
    if ((target.mAttrs.flags & WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES) != 0) {
      boolean cheekPress=mPolicy.isCheekPressedAgainstScreen(event);
      boolean returnFlag=false;
      if ((action == MotionEvent.ACTION_DOWN)) {
        mFatTouch=false;
        if (cheekPress) {
          mFatTouch=true;
          returnFlag=true;
        }
      }
 else {
        if (action == MotionEvent.ACTION_UP) {
          if (mFatTouch) {
            mFatTouch=false;
            returnFlag=true;
          }
 else           if (cheekPress) {
            targetFlags|=InputTarget.FLAG_CANCEL;
            action=MotionEvent.ACTION_CANCEL;
          }
        }
 else         if (action == MotionEvent.ACTION_MOVE) {
          if (mFatTouch) {
            returnFlag=true;
          }
 else           if (cheekPress) {
            targetFlags|=InputTarget.FLAG_CANCEL;
            action=MotionEvent.ACTION_CANCEL;
            if (DEBUG_INPUT)             Slog.v(TAG,"Sending cancel for invalid ACTION_MOVE");
            mFatTouch=true;
          }
        }
      }
      if (returnFlag) {
        return;
      }
    }
  }
synchronized (mWindowMap) {
    if (target != null && !target.isVisibleLw()) {
      target=null;
    }
    if (action == MotionEvent.ACTION_DOWN) {
      while (mOutsideTouchTargets != null) {
        addInputTarget(inputTargets,mOutsideTouchTargets,InputTarget.FLAG_OUTSIDE | targetFlags);
        mOutsideTouchTargets=mOutsideTouchTargets.mNextOutsideTouch;
      }
    }
    if (mSendingPointersToWallpaper || (target != null && action == MotionEvent.ACTION_DOWN && mWallpaperTarget == target && target.mAttrs.type != WindowManager.LayoutParams.TYPE_KEYGUARD)) {
      int curTokenIndex=mWallpaperTokens.size();
      while (curTokenIndex > 0) {
        curTokenIndex--;
        WindowToken token=mWallpaperTokens.get(curTokenIndex);
        int curWallpaperIndex=token.windows.size();
        while (curWallpaperIndex > 0) {
          curWallpaperIndex--;
          WindowState wallpaper=token.windows.get(curWallpaperIndex);
          if ((wallpaper.mAttrs.flags & WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE) != 0) {
            continue;
          }
switch (action) {
case MotionEvent.ACTION_DOWN:
            mSendingPointersToWallpaper=true;
          break;
case MotionEvent.ACTION_UP:
        mSendingPointersToWallpaper=false;
      break;
  }
  addInputTarget(inputTargets,wallpaper,targetFlags);
}
}
}
if (target != null) {
addInputTarget(inputTargets,target,InputTarget.FLAG_SYNC | targetFlags);
}
}
}
