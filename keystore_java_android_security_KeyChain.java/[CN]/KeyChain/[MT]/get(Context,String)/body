{
  if (context == null) {
    throw new NullPointerException("context == null");
  }
  if (alias == null) {
    throw new NullPointerException("alias == null");
  }
  ensureNotOnMainThread(context);
  final BlockingQueue<IKeyChainService> q=new LinkedBlockingQueue<IKeyChainService>(1);
  ServiceConnection keyChainServiceConnection=new ServiceConnection(){
    @Override public void onServiceConnected(    ComponentName name,    IBinder service){
      try {
        q.put(IKeyChainService.Stub.asInterface(service));
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
    @Override public void onServiceDisconnected(    ComponentName name){
    }
  }
;
  boolean isBound=context.bindService(new Intent(IKeyChainService.class.getName()),keyChainServiceConnection,Context.BIND_AUTO_CREATE);
  if (!isBound) {
    throw new AssertionError("could not bind to KeyChainService");
  }
  IKeyChainService keyChainService;
  try {
    keyChainService=q.take();
    AccountManager accountManager=AccountManager.get(context);
    Account account=accountManager.getAccountsByType(ACCOUNT_TYPE)[0];
    AccountManagerFuture<Bundle> future=accountManager.getAuthToken(account,alias,false,null,null);
    Bundle bundle;
    try {
      bundle=future.getResult();
    }
 catch (    OperationCanceledException e) {
      throw new AssertionError(e);
    }
catch (    IOException e) {
      throw new AssertionError(e);
    }
catch (    AuthenticatorException e) {
      throw new AssertionError(e);
    }
    Intent intent=bundle.getParcelable(AccountManager.KEY_INTENT);
    if (intent != null) {
      Bundle result=new Bundle();
      intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_NEW_TASK);
      return new KeyChainResult(intent);
    }
    String authToken=bundle.getString(AccountManager.KEY_AUTHTOKEN);
    if (authToken == null) {
      throw new AssertionError("Invalid authtoken");
    }
    byte[] privateKeyBytes=keyChainService.getPrivateKey(alias,authToken);
    byte[] certificateBytes=keyChainService.getCertificate(alias,authToken);
    return new KeyChainResult(toPrivateKey(privateKeyBytes),toCertificate(certificateBytes));
  }
  finally {
    context.unbindService(keyChainServiceConnection);
  }
}
