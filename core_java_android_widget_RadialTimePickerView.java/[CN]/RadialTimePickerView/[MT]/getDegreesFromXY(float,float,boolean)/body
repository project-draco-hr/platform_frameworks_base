{
  final double hypotenuse=Math.sqrt((y - mYCenter) * (y - mYCenter) + (x - mXCenter) * (x - mXCenter));
  if (constrainOutside && hypotenuse > mCircleRadius) {
    return -1;
  }
  if (mIs24HourMode && mShowHours) {
    if (hypotenuse >= mMinHypotenuseForInnerNumber && hypotenuse <= mHalfwayHypotenusePoint) {
      mIsOnInnerCircle=true;
    }
 else     if ((hypotenuse <= mMaxHypotenuseForOuterNumber || !constrainOutside) && hypotenuse >= mHalfwayHypotenusePoint) {
      mIsOnInnerCircle=false;
    }
 else {
      return -1;
    }
  }
 else {
    final int index=(mShowHours) ? HOURS : MINUTES;
    final float length=(mCircleRadius * mNumbersRadiusMultiplier[index]);
    final int distanceToNumber=(int)(hypotenuse - length);
    final int maxAllowedDistance=(int)(mCircleRadius * (1 - mNumbersRadiusMultiplier[index]));
    if (distanceToNumber < -maxAllowedDistance || (constrainOutside && distanceToNumber > maxAllowedDistance)) {
      return -1;
    }
  }
  final float opposite=Math.abs(y - mYCenter);
  int degrees=(int)(Math.toDegrees(Math.asin(opposite / hypotenuse)) + 0.5);
  final boolean rightSide=(x > mXCenter);
  final boolean topSide=(y < mYCenter);
  if (rightSide) {
    if (topSide) {
      degrees=90 - degrees;
    }
 else {
      degrees=90 + degrees;
    }
  }
 else {
    if (topSide) {
      degrees=270 + degrees;
    }
 else {
      degrees=270 - degrees;
    }
  }
  return degrees;
}
