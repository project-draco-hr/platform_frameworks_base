{
  final double hypotenuse=Math.sqrt((y - mYCenter) * (y - mYCenter) + (x - mXCenter) * (x - mXCenter));
  if (hypotenuse > mCircleRadius[HOURS]) {
    return -1;
  }
  if (mIs24HourMode && mShowHours) {
    if (hypotenuse >= mMinHypotenuseForInnerNumber && hypotenuse <= mHalfwayHypotenusePoint) {
      mIsOnInnerCircle=true;
    }
 else     if (hypotenuse <= mMaxHypotenuseForOuterNumber && hypotenuse >= mHalfwayHypotenusePoint) {
      mIsOnInnerCircle=false;
    }
 else {
      return -1;
    }
  }
 else {
    final int index=(mShowHours) ? HOURS : MINUTES;
    final float length=(mCircleRadius[index] * mNumbersRadiusMultiplier[index]);
    final int distanceToNumber=(int)Math.abs(hypotenuse - length);
    final int maxAllowedDistance=(int)(mCircleRadius[index] * (1 - mNumbersRadiusMultiplier[index]));
    if (distanceToNumber > maxAllowedDistance) {
      return -1;
    }
  }
  final float opposite=Math.abs(y - mYCenter);
  int degrees=(int)(Math.toDegrees(Math.asin(opposite / hypotenuse)) + 0.5);
  final boolean rightSide=(x > mXCenter);
  final boolean topSide=(y < mYCenter);
  if (rightSide) {
    if (topSide) {
      degrees=90 - degrees;
    }
 else {
      degrees=90 + degrees;
    }
  }
 else {
    if (topSide) {
      degrees=270 + degrees;
    }
 else {
      degrees=270 - degrees;
    }
  }
  return degrees;
}
