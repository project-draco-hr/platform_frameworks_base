{
  final double hypotenuse=Math.sqrt((y - mYCenter) * (y - mYCenter) + (x - mXCenter) * (x - mXCenter));
  if (hypotenuse > mCircleRadius[HOURS]) {
    return -1;
  }
  if (mIs24HourMode && mShowHours) {
    if (hypotenuse >= mMinHypotenuseForInnerNumber && hypotenuse <= mHalfwayHypotenusePoint) {
      mIsOnInnerCircle=true;
    }
 else     if (hypotenuse <= mMaxHypotenuseForOuterNumber && hypotenuse >= mHalfwayHypotenusePoint) {
      mIsOnInnerCircle=false;
    }
 else {
      return -1;
    }
  }
 else {
    final int index=(mShowHours) ? HOURS : MINUTES;
    final float length=(mCircleRadius[index] * mNumbersRadiusMultiplier[index]);
    final int distanceToNumber=(int)Math.abs(hypotenuse - length);
    final int maxAllowedDistance=(int)(mCircleRadius[index] * (1 - mNumbersRadiusMultiplier[index]));
    if (distanceToNumber > maxAllowedDistance) {
      return -1;
    }
  }
  final float opposite=Math.abs(y - mYCenter);
  double degrees=Math.toDegrees(Math.asin(opposite / hypotenuse));
  boolean rightSide=(x > mXCenter);
  boolean topSide=(y < mYCenter);
  if (rightSide && topSide) {
    degrees=90 - degrees;
  }
 else   if (rightSide && !topSide) {
    degrees=90 + degrees;
  }
 else   if (!rightSide && !topSide) {
    degrees=270 - degrees;
  }
 else   if (!rightSide && topSide) {
    degrees=270 + degrees;
  }
  return (int)degrees;
}
