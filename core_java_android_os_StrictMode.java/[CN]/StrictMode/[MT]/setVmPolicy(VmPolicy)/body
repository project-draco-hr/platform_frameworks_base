{
synchronized (StrictMode.class) {
    sVmPolicy=policy;
    sVmPolicyMask=policy.mask;
    setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
    Looper looper=Looper.getMainLooper();
    if (looper != null) {
      MessageQueue mq=looper.mQueue;
      if (policy.classInstanceLimit.size() == 0 || (sVmPolicyMask & VM_PENALTY_MASK) == 0) {
        mq.removeIdleHandler(sProcessIdleHandler);
        sIsIdlerRegistered=false;
      }
 else       if (!sIsIdlerRegistered) {
        mq.addIdleHandler(sProcessIdleHandler);
        sIsIdlerRegistered=true;
      }
    }
    int networkPolicy=NETWORK_POLICY_ACCEPT;
    if ((sVmPolicyMask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
      if ((sVmPolicyMask & PENALTY_DEATH) != 0 || (sVmPolicyMask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
        networkPolicy=NETWORK_POLICY_REJECT;
      }
 else {
        networkPolicy=NETWORK_POLICY_LOG;
      }
    }
    final INetworkManagementService netd=INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
    if (netd != null) {
      try {
        netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(),networkPolicy);
      }
 catch (      RemoteException ignored) {
      }
    }
 else     if (networkPolicy != NETWORK_POLICY_ACCEPT) {
      Log.w(TAG,"Dropping requested network policy due to missing service!");
    }
  }
}
