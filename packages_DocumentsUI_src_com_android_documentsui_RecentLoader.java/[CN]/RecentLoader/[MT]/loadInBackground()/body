{
  if (mFirstPassLatch == null) {
    for (    RootInfo root : mRoots) {
      if ((root.flags & Root.FLAG_SUPPORTS_RECENTS) != 0) {
        final RecentTask task=new RecentTask(root.authority,root.rootId);
        mTasks.put(root,task);
      }
    }
    mFirstPassLatch=new CountDownLatch(mTasks.size());
    for (    RecentTask task : mTasks.values()) {
      sExecutor.execute(task);
    }
    try {
      mFirstPassLatch.await(MAX_FIRST_PASS_WAIT_MILLIS,TimeUnit.MILLISECONDS);
      mFirstPassDone=true;
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
  List<Cursor> cursors=Lists.newArrayList();
  for (  RecentTask task : mTasks.values()) {
    if (task.isDone()) {
      try {
        final Cursor cursor=task.get();
        final FilteringCursorWrapper filtered=new FilteringCursorWrapper(cursor,mAcceptMimes,new String[]{Document.MIME_TYPE_DIR}){
          @Override public void close(){
          }
        }
;
        cursors.add(filtered);
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
catch (      ExecutionException e) {
        Log.w(TAG,"Failed to load " + task.authority + ", "+ task.rootId,e);
      }
    }
  }
  final DirectoryResult result=new DirectoryResult();
  result.sortOrder=SORT_ORDER_LAST_MODIFIED;
  if (cursors.size() > 0) {
    final MergeCursor merged=new MergeCursor(cursors.toArray(new Cursor[cursors.size()]));
    final SortingCursorWrapper sorted=new SortingCursorWrapper(merged,result.sortOrder);
    result.cursor=sorted;
  }
  return result;
}
