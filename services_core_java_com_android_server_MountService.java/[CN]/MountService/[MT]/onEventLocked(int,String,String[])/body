{
switch (code) {
case VoldResponseCode.DISK_CREATED:
{
      if (cooked.length != 3)       break;
      final String id=cooked[1];
      final int flags=Integer.parseInt(cooked[2]);
      mDisks.put(id,new DiskInfo(id,flags));
      break;
    }
case VoldResponseCode.DISK_SIZE_CHANGED:
{
    if (cooked.length != 3)     break;
    final DiskInfo disk=mDisks.get(cooked[1]);
    if (disk != null) {
      disk.size=Long.parseLong(cooked[2]);
    }
    break;
  }
case VoldResponseCode.DISK_LABEL_CHANGED:
{
  if (cooked.length != 3)   break;
  final DiskInfo disk=mDisks.get(cooked[1]);
  if (disk != null) {
    disk.label=cooked[2];
  }
  break;
}
case VoldResponseCode.DISK_VOLUME_CREATED:
{
if (cooked.length != 3) break;
final String diskId=cooked[1];
final String volId=cooked[2];
final DiskInfo disk=mDisks.get(diskId);
if (disk != null) {
  disk.volumeIds=ArrayUtils.appendElement(String.class,disk.volumeIds,volId);
}
final VolumeInfo vol=mVolumes.get(volId);
if (vol != null) {
  vol.diskId=diskId;
}
break;
}
case VoldResponseCode.DISK_VOLUME_DESTROYED:
{
if (cooked.length != 3) break;
final String diskId=cooked[1];
final String volId=cooked[2];
final DiskInfo disk=mDisks.get(diskId);
if (disk != null) {
disk.volumeIds=ArrayUtils.removeElement(String.class,disk.volumeIds,volId);
}
final VolumeInfo vol=mVolumes.get(volId);
if (vol != null) {
vol.diskId=null;
}
break;
}
case VoldResponseCode.DISK_DESTROYED:
{
if (cooked.length != 2) break;
mDisks.remove(cooked[1]);
break;
}
case VoldResponseCode.VOLUME_CREATED:
{
if (cooked.length != 3) break;
final String id=cooked[1];
final int type=Integer.parseInt(cooked[2]);
final int mtpIndex=allocateMtpIndex(id);
final VolumeInfo vol=new VolumeInfo(id,type,mtpIndex);
mVolumes.put(id,vol);
onVolumeCreatedLocked(vol);
break;
}
case VoldResponseCode.VOLUME_STATE_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
final int oldState=vol.state;
final int newState=Integer.parseInt(cooked[2]);
vol.state=newState;
onVolumeStateChangedLocked(vol,oldState,newState);
}
break;
}
case VoldResponseCode.VOLUME_FS_TYPE_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsType=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_FS_UUID_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsUuid=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_FS_LABEL_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsLabel=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_PATH_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.path=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_DESTROYED:
{
if (cooked.length != 2) break;
mVolumes.remove(cooked[1]);
break;
}
case VoldResponseCode.FstrimCompleted:
{
EventLogTags.writeFstrimFinish(SystemClock.elapsedRealtime());
break;
}
default :
{
Slog.d(TAG,"Unhandled vold event " + code);
}
}
return true;
}
