{
switch (code) {
case VoldResponseCode.DISK_CREATED:
{
      if (cooked.length != 3)       break;
      final String id=cooked[1];
      final int flags=Integer.parseInt(cooked[2]);
      mDisks.put(id,new DiskInfo(id,flags));
      break;
    }
case VoldResponseCode.DISK_SIZE_CHANGED:
{
    if (cooked.length != 3)     break;
    final DiskInfo disk=mDisks.get(cooked[1]);
    if (disk != null) {
      disk.size=Long.parseLong(cooked[2]);
    }
    break;
  }
case VoldResponseCode.DISK_LABEL_CHANGED:
{
  final DiskInfo disk=mDisks.get(cooked[1]);
  if (disk != null) {
    final StringBuilder builder=new StringBuilder();
    for (int i=2; i < cooked.length; i++) {
      builder.append(cooked[i]).append(' ');
    }
    disk.label=builder.toString().trim();
  }
  break;
}
case VoldResponseCode.DISK_SCANNED:
{
if (cooked.length != 2) break;
final DiskInfo disk=mDisks.get(cooked[1]);
if (disk != null) {
  onDiskScannedLocked(disk);
}
break;
}
case VoldResponseCode.DISK_DESTROYED:
{
if (cooked.length != 2) break;
mDisks.remove(cooked[1]);
break;
}
case VoldResponseCode.VOLUME_CREATED:
{
final String id=cooked[1];
final int type=Integer.parseInt(cooked[2]);
final String diskId=(cooked.length == 4) ? cooked[3] : null;
final DiskInfo disk=mDisks.get(diskId);
final int mtpIndex=allocateMtpIndex(id);
final VolumeInfo vol=new VolumeInfo(id,type,disk,mtpIndex);
mVolumes.put(id,vol);
onVolumeCreatedLocked(vol);
break;
}
case VoldResponseCode.VOLUME_STATE_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
final int oldState=vol.state;
final int newState=Integer.parseInt(cooked[2]);
vol.state=newState;
onVolumeStateChangedLocked(vol.clone(),oldState,newState);
}
break;
}
case VoldResponseCode.VOLUME_FS_TYPE_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsType=cooked[2];
}
mCallbacks.notifyVolumeMetadataChanged(vol.clone());
break;
}
case VoldResponseCode.VOLUME_FS_UUID_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsUuid=cooked[2];
}
refreshMetadataLocked();
mCallbacks.notifyVolumeMetadataChanged(vol.clone());
break;
}
case VoldResponseCode.VOLUME_FS_LABEL_CHANGED:
{
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
final StringBuilder builder=new StringBuilder();
for (int i=2; i < cooked.length; i++) {
builder.append(cooked[i]).append(' ');
}
vol.fsLabel=builder.toString().trim();
}
mCallbacks.notifyVolumeMetadataChanged(vol.clone());
break;
}
case VoldResponseCode.VOLUME_PATH_CHANGED:
{
if (cooked.length != 3) break;
final VolumeInfo vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.path=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_DESTROYED:
{
if (cooked.length != 2) break;
mVolumes.remove(cooked[1]);
break;
}
case VoldResponseCode.FstrimCompleted:
{
EventLogTags.writeFstrimFinish(SystemClock.elapsedRealtime());
break;
}
default :
{
Slog.d(TAG,"Unhandled vold event " + code);
}
}
return true;
}
