{
switch (code) {
case VoldResponseCode.DISK_CREATED:
{
      if (cooked.length != 3)       break;
      final String id=cooked[1];
      final int flags=Integer.parseInt(cooked[2]);
      mDisks.put(id,new Disk(id,flags));
      break;
    }
case VoldResponseCode.DISK_SIZE_CHANGED:
{
    if (cooked.length != 3)     break;
    final Disk disk=mDisks.get(cooked[1]);
    if (disk != null) {
      disk.size=Long.parseLong(cooked[2]);
    }
    break;
  }
case VoldResponseCode.DISK_LABEL_CHANGED:
{
  if (cooked.length != 3)   break;
  final Disk disk=mDisks.get(cooked[1]);
  if (disk != null) {
    disk.label=cooked[2];
  }
  break;
}
case VoldResponseCode.DISK_VOLUME_CREATED:
{
if (cooked.length != 3) break;
final Disk disk=mDisks.get(cooked[1]);
final Volume vol=mVolumes.get(cooked[2]);
if (disk != null && vol != null) {
  disk.volumes.add(vol);
}
break;
}
case VoldResponseCode.DISK_DESTROYED:
{
if (cooked.length != 2) break;
mDisks.remove(cooked[1]);
break;
}
case VoldResponseCode.VOLUME_CREATED:
{
if (cooked.length != 3) break;
final String id=cooked[1];
final int type=Integer.parseInt(cooked[2]);
final Volume vol=new Volume(id,type);
mVolumes.put(id,vol);
onVolumeCreatedLocked(vol);
break;
}
case VoldResponseCode.VOLUME_STATE_CHANGED:
{
if (cooked.length != 3) break;
final Volume vol=mVolumes.get(cooked[1]);
if (vol != null) {
final int oldState=vol.state;
final int newState=Integer.parseInt(cooked[2]);
vol.state=newState;
onVolumeStateChangedLocked(vol,oldState,newState);
}
break;
}
case VoldResponseCode.VOLUME_FS_TYPE_CHANGED:
{
if (cooked.length != 3) break;
final Volume vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsType=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_FS_UUID_CHANGED:
{
if (cooked.length != 3) break;
final Volume vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsUuid=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_FS_LABEL_CHANGED:
{
if (cooked.length != 3) break;
final Volume vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.fsLabel=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_PATH_CHANGED:
{
if (cooked.length != 3) break;
final Volume vol=mVolumes.get(cooked[1]);
if (vol != null) {
vol.path=cooked[2];
}
break;
}
case VoldResponseCode.VOLUME_DESTROYED:
{
if (cooked.length != 2) break;
mVolumes.remove(cooked[1]);
break;
}
case VoldResponseCode.FstrimCompleted:
{
EventLogTags.writeFstrimFinish(SystemClock.elapsedRealtime());
break;
}
default :
{
Slog.d(TAG,"Unhandled vold event " + code);
}
}
return true;
}
