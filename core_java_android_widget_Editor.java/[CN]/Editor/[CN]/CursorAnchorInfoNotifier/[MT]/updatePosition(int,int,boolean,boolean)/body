{
  final InputMethodState ims=mInputMethodState;
  if (ims == null || ims.mBatchEditNesting > 0) {
    return;
  }
  final InputMethodManager imm=InputMethodManager.peekInstance();
  if (null == imm) {
    return;
  }
  if (!imm.isWatchingCursor(mTextView)) {
    return;
  }
  Layout layout=mTextView.getLayout();
  if (layout == null) {
    return;
  }
  final CursorAnchorInfo.Builder builder=mSelectionInfoBuilder;
  builder.reset();
  final int selectionStart=mTextView.getSelectionStart();
  builder.setSelectionRange(selectionStart,mTextView.getSelectionEnd());
  mViewToScreenMatrix.set(mTextView.getMatrix());
  mTextView.getLocationOnScreen(mTmpIntOffset);
  mViewToScreenMatrix.postTranslate(mTmpIntOffset[0],mTmpIntOffset[1]);
  builder.setMatrix(mViewToScreenMatrix);
  final float viewportToContentHorizontalOffset=mTextView.viewportToContentHorizontalOffset();
  final float viewportToContentVerticalOffset=mTextView.viewportToContentVerticalOffset();
  final CharSequence text=mTextView.getText();
  if (text instanceof Spannable) {
    final Spannable sp=(Spannable)text;
    int composingTextStart=EditableInputConnection.getComposingSpanStart(sp);
    int composingTextEnd=EditableInputConnection.getComposingSpanEnd(sp);
    if (composingTextEnd < composingTextStart) {
      final int temp=composingTextEnd;
      composingTextEnd=composingTextStart;
      composingTextStart=temp;
    }
    final boolean hasComposingText=(0 <= composingTextStart) && (composingTextStart < composingTextEnd);
    if (hasComposingText) {
      final CharSequence composingText=text.subSequence(composingTextStart,composingTextEnd);
      builder.setComposingText(composingTextStart,composingText);
    }
    for (int offset=composingTextStart; offset < composingTextEnd; offset++) {
      if (offset < 0) {
        continue;
      }
      final int line=layout.getLineForOffset(offset);
      final float left=layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
      final float top=layout.getLineTop(line) + viewportToContentVerticalOffset;
      final float right=layout.getPrimaryHorizontal(offset + 1) + viewportToContentHorizontalOffset;
      final float bottom=layout.getLineBottom(line) + viewportToContentVerticalOffset;
      final boolean leftTopVisible=isPositionVisible(left,top);
      final boolean rightBottomVisible=isPositionVisible(right,bottom);
      final int characterRectFlags;
      if (leftTopVisible && rightBottomVisible) {
        characterRectFlags=CursorAnchorInfo.CHARACTER_RECT_TYPE_FULLY_VISIBLE;
      }
 else       if (leftTopVisible || rightBottomVisible) {
        characterRectFlags=CursorAnchorInfo.CHARACTER_RECT_TYPE_PARTIALLY_VISIBLE;
      }
 else {
        characterRectFlags=CursorAnchorInfo.CHARACTER_RECT_TYPE_INVISIBLE;
      }
      builder.addCharacterRect(offset,left,top,right,bottom,characterRectFlags);
    }
  }
  if (0 <= selectionStart) {
    final int offset=selectionStart;
    final int line=layout.getLineForOffset(offset);
    final float insertionMarkerX=layout.getPrimaryHorizontal(offset) + viewportToContentHorizontalOffset;
    final float insertionMarkerTop=layout.getLineTop(line) + viewportToContentVerticalOffset;
    final float insertionMarkerBaseline=layout.getLineBaseline(line) + viewportToContentVerticalOffset;
    final float insertionMarkerBottom=layout.getLineBottom(line) + viewportToContentVerticalOffset;
    final boolean isClipped=!isPositionVisible(insertionMarkerX,insertionMarkerTop) || !isPositionVisible(insertionMarkerX,insertionMarkerBottom);
    builder.setInsertionMarkerLocation(insertionMarkerX,insertionMarkerTop,insertionMarkerBaseline,insertionMarkerBottom,isClipped);
  }
  imm.updateCursorAnchorInfo(mTextView,builder.build());
}
