{
  final float eventX=event.getX();
  final float eventY=event.getY();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    if (extractedTextModeWillBeStarted()) {
      hide();
    }
 else {
      mMinTouchOffset=mMaxTouchOffset=mTextView.getOffsetForPosition(eventX,eventY);
      if (mGestureStayedInTapRegion) {
        if (mDoubleTap) {
          final float deltaX=eventX - mDownPositionX;
          final float deltaY=eventY - mDownPositionY;
          final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
          ViewConfiguration viewConfiguration=ViewConfiguration.get(mTextView.getContext());
          int doubleTapSlop=viewConfiguration.getScaledDoubleTapSlop();
          boolean stayedInArea=distanceSquared < doubleTapSlop * doubleTapSlop;
          if (stayedInArea && isPositionOnText(eventX,eventY)) {
            selectCurrentWordAndStartDrag();
            mDiscardNextActionUp=true;
          }
        }
      }
      mDownPositionX=eventX;
      mDownPositionY=eventY;
      mGestureStayedInTapRegion=true;
      mHaventMovedEnoughToStartDrag=true;
    }
  break;
case MotionEvent.ACTION_POINTER_DOWN:
case MotionEvent.ACTION_POINTER_UP:
if (mTextView.getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH_DISTINCT)) {
  updateMinAndMaxOffsets(event);
}
break;
case MotionEvent.ACTION_MOVE:
final ViewConfiguration viewConfig=ViewConfiguration.get(mTextView.getContext());
final int touchSlop=viewConfig.getScaledTouchSlop();
if (mGestureStayedInTapRegion || mHaventMovedEnoughToStartDrag) {
final float deltaX=eventX - mDownPositionX;
final float deltaY=eventY - mDownPositionY;
final float distanceSquared=deltaX * deltaX + deltaY * deltaY;
if (mGestureStayedInTapRegion) {
int doubleTapTouchSlop=viewConfig.getScaledDoubleTapTouchSlop();
mGestureStayedInTapRegion=distanceSquared <= doubleTapTouchSlop * doubleTapTouchSlop;
}
if (mHaventMovedEnoughToStartDrag) {
mHaventMovedEnoughToStartDrag=distanceSquared <= touchSlop * touchSlop;
}
}
if (mStartHandle != null && mStartHandle.isShowing()) {
break;
}
if (mStartOffset != -1 && mTextView.getLayout() != null) {
if (!mHaventMovedEnoughToStartDrag) {
float y=eventY;
if (mSwitchedLines) {
final float fingerOffset=(mStartHandle != null) ? mStartHandle.getIdealVerticalOffset() : touchSlop;
y=eventY - fingerOffset;
}
final int currLine=getCurrentLineAdjustedForSlop(mTextView.getLayout(),mLineSelectionIsOn,y);
if (!mSwitchedLines && currLine != mLineSelectionIsOn) {
mSwitchedLines=true;
break;
}
int startOffset;
int offset=mTextView.getOffsetAtCoordinate(currLine,eventX);
if (mStartOffset < offset) {
offset=getWordEnd(offset);
startOffset=getWordStart(mStartOffset);
}
 else {
offset=getWordStart(offset);
startOffset=getWordEnd(mStartOffset);
}
mLineSelectionIsOn=currLine;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,offset);
}
}
break;
case MotionEvent.ACTION_UP:
if (mDragAcceleratorActive) {
mTextView.getParent().requestDisallowInterceptTouchEvent(false);
show();
int startOffset=mTextView.getSelectionStart();
int endOffset=mTextView.getSelectionEnd();
if (endOffset < startOffset) {
int tmp=endOffset;
endOffset=startOffset;
startOffset=tmp;
Selection.setSelection((Spannable)mTextView.getText(),startOffset,endOffset);
}
mStartHandle.showAtLocation(startOffset);
mEndHandle.showAtLocation(endOffset);
startSelectionActionMode();
mDragAcceleratorActive=false;
mStartOffset=-1;
mSwitchedLines=false;
}
break;
}
}
