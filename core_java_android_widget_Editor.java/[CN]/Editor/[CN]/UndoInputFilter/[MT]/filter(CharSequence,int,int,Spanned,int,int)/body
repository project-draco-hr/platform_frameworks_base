{
  if (DEBUG_UNDO) {
    Log.d(TAG,"filter: source=" + source + " ("+ start+ "-"+ end+ ") "+ "dest="+ dest+ " ("+ dstart+ "-"+ dend+ ")");
  }
  if (!mEditor.mAllowUndo) {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: undo is disabled");
    return null;
  }
  final UndoManager um=mEditor.mUndoManager;
  if (um.isInUndo()) {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: skipping, currently performing undo/redo");
    return null;
  }
  if (!isValidRange(source,start,end) || !isValidRange(dest,dstart,dend)) {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: invalid op");
    return null;
  }
  if (start == end && dstart == dend) {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: skipping no-op");
    return null;
  }
  EditOperation edit=new EditOperation(mEditor,source,start,end,dest,dstart,dend);
  um.beginUpdate("Edit text");
  EditOperation lastEdit=um.getLastOperation(EditOperation.class,mEditor.mUndoOwner,UndoManager.MERGE_MODE_UNIQUE);
  if (lastEdit == null) {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: adding first op " + edit);
    um.addOperation(edit,UndoManager.MERGE_MODE_NONE);
  }
 else   if (lastEdit.mergeWith(edit)) {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: merge succeeded, created " + lastEdit);
  }
 else {
    if (DEBUG_UNDO)     Log.d(TAG,"filter: merge failed, adding " + edit);
    um.commitState(mEditor.mUndoOwner);
    um.addOperation(edit,UndoManager.MERGE_MODE_NONE);
  }
  um.endUpdate();
  return null;
}
