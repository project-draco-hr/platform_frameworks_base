{
  if (!force && !mUpdateInputWindowsNeeded) {
    return;
  }
  mUpdateInputWindowsNeeded=false;
  if (false)   Slog.d(WindowManagerService.TAG,">>>>>> ENTERED updateInputWindowsLw");
  final ArrayList<WindowState> windows=mService.mWindows;
  final boolean inDrag=(mService.mDragState != null);
  if (inDrag) {
    if (WindowManagerService.DEBUG_DRAG) {
      Log.d(WindowManagerService.TAG,"Inserting drag window");
    }
    final InputWindowHandle dragWindowHandle=mService.mDragState.mDragWindowHandle;
    if (dragWindowHandle != null) {
      addInputWindowHandleLw(dragWindowHandle);
    }
 else {
      Slog.w(WindowManagerService.TAG,"Drag is in progress but there is no " + "drag window handle.");
    }
  }
  final int NFW=mService.mFakeWindows.size();
  for (int i=0; i < NFW; i++) {
    addInputWindowHandleLw(mService.mFakeWindows.get(i).mWindowHandle);
  }
  final int N=windows.size();
  for (int i=N - 1; i >= 0; i--) {
    final WindowState child=windows.get(i);
    final InputChannel inputChannel=child.mInputChannel;
    final InputWindowHandle inputWindowHandle=child.mInputWindowHandle;
    if (inputChannel == null || inputWindowHandle == null || child.mRemoved) {
      continue;
    }
    final int flags=child.mAttrs.flags;
    final int type=child.mAttrs.type;
    final boolean hasFocus=(child == mInputFocus);
    final boolean isVisible=child.isVisibleLw();
    final boolean hasWallpaper=(child == mService.mWallpaperTarget) && (type != WindowManager.LayoutParams.TYPE_KEYGUARD);
    if (inDrag && isVisible) {
      mService.mDragState.sendDragStartedIfNeededLw(child);
    }
    inputWindowHandle.name=child.toString();
    inputWindowHandle.layoutParamsFlags=flags;
    inputWindowHandle.layoutParamsType=type;
    inputWindowHandle.dispatchingTimeoutNanos=child.getInputDispatchingTimeoutNanos();
    inputWindowHandle.visible=isVisible;
    inputWindowHandle.canReceiveKeys=child.canReceiveKeys();
    inputWindowHandle.hasFocus=hasFocus;
    inputWindowHandle.hasWallpaper=hasWallpaper;
    inputWindowHandle.paused=child.mAppToken != null ? child.mAppToken.paused : false;
    inputWindowHandle.layer=child.mLayer;
    inputWindowHandle.ownerPid=child.mSession.mPid;
    inputWindowHandle.ownerUid=child.mSession.mUid;
    inputWindowHandle.inputFeatures=child.mAttrs.inputFeatures;
    final Rect frame=child.mFrame;
    inputWindowHandle.frameLeft=frame.left;
    inputWindowHandle.frameTop=frame.top;
    inputWindowHandle.frameRight=frame.right;
    inputWindowHandle.frameBottom=frame.bottom;
    if (child.mGlobalScale != 1) {
      inputWindowHandle.scaleFactor=1.0f / child.mGlobalScale;
    }
 else {
      inputWindowHandle.scaleFactor=1;
    }
    child.getTouchableRegion(inputWindowHandle.touchableRegion);
    addInputWindowHandleLw(inputWindowHandle);
  }
  mService.mInputManager.setInputWindows(mInputWindowHandles);
  clearInputWindowHandlesLw();
  if (false)   Slog.d(WindowManagerService.TAG,"<<<<<<< EXITED updateInputWindowsLw");
}
