{
  final NetworkInfo egressInfo=mConnService.getActiveNetworkInfoUnfiltered();
  final LinkProperties egressProp=mConnService.getActiveLinkProperties();
  final NetworkInfo vpnInfo=mVpn.getNetworkInfo();
  final VpnConfig vpnConfig=mVpn.getLegacyVpnConfig();
  final boolean egressDisconnected=egressInfo == null || State.DISCONNECTED.equals(egressInfo.getState());
  final boolean egressChanged=egressProp == null || !TextUtils.equals(mAcceptedEgressIface,egressProp.getInterfaceName());
  final String egressTypeName=(egressInfo == null) ? null : ConnectivityManager.getNetworkTypeName(egressInfo.getType());
  final String egressIface=(egressProp == null) ? null : egressProp.getInterfaceName();
  Slog.d(TAG,"handleStateChanged: egress=" + egressTypeName + " "+ mAcceptedEgressIface+ "->"+ egressIface);
  if (egressDisconnected || egressChanged) {
    clearSourceRulesLocked();
    mAcceptedEgressIface=null;
    mVpn.stopLegacyVpn();
  }
  if (egressDisconnected) {
    hideNotification();
    return;
  }
  final int egressType=egressInfo.getType();
  if (vpnInfo.getDetailedState() == DetailedState.FAILED) {
    EventLogTags.writeLockdownVpnError(egressType);
  }
  if (mErrorCount > MAX_ERROR_COUNT) {
    showNotification(R.string.vpn_lockdown_error,R.drawable.vpn_disconnected);
  }
 else   if (egressInfo.isConnected() && !vpnInfo.isConnectedOrConnecting()) {
    if (mProfile.isValidLockdownProfile()) {
      Slog.d(TAG,"Active network connected; starting VPN");
      EventLogTags.writeLockdownVpnConnecting(egressType);
      showNotification(R.string.vpn_lockdown_connecting,R.drawable.vpn_disconnected);
      mAcceptedEgressIface=egressProp.getInterfaceName();
      try {
        mVpn.startLegacyVpn(mProfile,KeyStore.getInstance(),egressProp);
      }
 catch (      IllegalStateException e) {
        mAcceptedEgressIface=null;
        Slog.e(TAG,"Failed to start VPN",e);
        showNotification(R.string.vpn_lockdown_error,R.drawable.vpn_disconnected);
      }
    }
 else {
      Slog.e(TAG,"Invalid VPN profile; requires IP-based server and DNS");
      showNotification(R.string.vpn_lockdown_error,R.drawable.vpn_disconnected);
    }
  }
 else   if (vpnInfo.isConnected() && vpnConfig != null) {
    final String iface=vpnConfig.interfaze;
    final List<LinkAddress> sourceAddrs=vpnConfig.addresses;
    if (TextUtils.equals(iface,mAcceptedIface) && sourceAddrs.equals(mAcceptedSourceAddr)) {
      return;
    }
    Slog.d(TAG,"VPN connected using iface=" + iface + ", sourceAddr="+ sourceAddrs.toString());
    EventLogTags.writeLockdownVpnConnected(egressType);
    showNotification(R.string.vpn_lockdown_connected,R.drawable.vpn_connected);
    try {
      clearSourceRulesLocked();
      mNetService.setFirewallInterfaceRule(iface,true);
      for (      LinkAddress addr : sourceAddrs) {
        setFirewallEgressSourceRule(addr,true);
      }
      mNetService.setFirewallUidRule(ROOT_UID,true);
      mNetService.setFirewallUidRule(Os.getuid(),true);
      mErrorCount=0;
      mAcceptedIface=iface;
      mAcceptedSourceAddr=sourceAddrs;
    }
 catch (    RemoteException e) {
      throw new RuntimeException("Problem setting firewall rules",e);
    }
    mConnService.sendConnectedBroadcast(augmentNetworkInfo(egressInfo));
  }
}
