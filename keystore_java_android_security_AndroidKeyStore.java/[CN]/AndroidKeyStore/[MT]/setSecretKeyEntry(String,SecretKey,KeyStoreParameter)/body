{
  if (key instanceof KeyStoreSecretKey) {
    String keyAliasInKeystore=((KeyStoreSecretKey)key).getAlias();
    if (keyAliasInKeystore == null) {
      throw new KeyStoreException("KeyStore-backed secret key does not have an alias");
    }
    if (!keyAliasInKeystore.startsWith(Credentials.USER_SECRET_KEY)) {
      throw new KeyStoreException("KeyStore-backed secret key has invalid alias: " + keyAliasInKeystore);
    }
    String keyEntryAlias=keyAliasInKeystore.substring(Credentials.USER_SECRET_KEY.length());
    if (!entryAlias.equals(keyEntryAlias)) {
      throw new KeyStoreException("Can only replace KeyStore-backed keys with same" + " alias: " + entryAlias + " != "+ keyEntryAlias);
    }
    if (params != null) {
      throw new KeyStoreException("Modifying KeyStore-backed key using protection" + " parameters not supported");
    }
    return;
  }
  if (params == null) {
    throw new KeyStoreException("Protection parameters must be specified when importing a symmetric key");
  }
  String keyExportFormat=key.getFormat();
  if (keyExportFormat == null) {
    throw new KeyStoreException("Only secret keys that export their key material are supported");
  }
 else   if (!"RAW".equals(keyExportFormat)) {
    throw new KeyStoreException("Unsupported secret key material export format: " + keyExportFormat);
  }
  byte[] keyMaterial=key.getEncoded();
  if (keyMaterial == null) {
    throw new KeyStoreException("Key did not export its key material despite supporting" + " RAW format export");
  }
  String keyAlgorithmString=key.getAlgorithm();
  int keymasterAlgorithm;
  int keymasterDigest;
  try {
    keymasterAlgorithm=KeymasterUtils.getKeymasterAlgorithmFromJcaSecretKeyAlgorithm(keyAlgorithmString);
    keymasterDigest=KeymasterUtils.getKeymasterDigestfromJcaSecretKeyAlgorithm(keyAlgorithmString);
  }
 catch (  IllegalArgumentException e) {
    throw new KeyStoreException("Unsupported secret key algorithm: " + keyAlgorithmString);
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addInt(KeymasterDefs.KM_TAG_ALGORITHM,keymasterAlgorithm);
  int[] keymasterDigests;
  if (params.isDigestsSpecified()) {
    keymasterDigests=KeymasterUtils.getKeymasterDigestsFromJcaDigestAlgorithms(params.getDigests());
    if (keymasterDigest != -1) {
      if (!com.android.internal.util.ArrayUtils.contains(keymasterDigests,keymasterDigest)) {
        throw new KeyStoreException("Key digest mismatch" + ". Key: " + keyAlgorithmString + ", parameter spec: "+ Arrays.asList(params.getDigests()));
      }
    }
  }
 else {
    if (keymasterDigest != -1) {
      keymasterDigests=new int[]{keymasterDigest};
    }
 else {
      keymasterDigests=EmptyArray.INT;
    }
  }
  args.addInts(KeymasterDefs.KM_TAG_DIGEST,keymasterDigests);
  if (keymasterDigests.length > 0) {
    int digestOutputSizeBytes=KeymasterUtils.getDigestOutputSizeBytes(keymasterDigests[0]);
    if (digestOutputSizeBytes != -1) {
      args.addInt(KeymasterDefs.KM_TAG_MAC_LENGTH,digestOutputSizeBytes);
    }
  }
  if (keymasterAlgorithm == KeymasterDefs.KM_ALGORITHM_HMAC) {
    if (keymasterDigests.length == 0) {
      throw new KeyStoreException("At least one digest algorithm must be specified" + " for key algorithm " + keyAlgorithmString);
    }
  }
  @KeyStoreKeyProperties.PurposeEnum int purposes=params.getPurposes();
  int[] keymasterBlockModes=KeymasterUtils.getKeymasterBlockModesFromJcaBlockModes(params.getBlockModes());
  if (((purposes & KeyStoreKeyProperties.Purpose.ENCRYPT) != 0) && (params.isRandomizedEncryptionRequired())) {
    for (    int keymasterBlockMode : keymasterBlockModes) {
      if (!KeymasterUtils.isKeymasterBlockModeIndCpaCompatible(keymasterBlockMode)) {
        throw new KeyStoreException("Randomized encryption (IND-CPA) required but may be violated by block" + " mode: " + KeymasterUtils.getJcaBlockModeFromKeymasterBlockMode(keymasterBlockMode) + ". See KeyStoreParameter documentation.");
      }
    }
  }
  for (  int keymasterPurpose : KeyStoreKeyProperties.Purpose.allToKeymaster(purposes)) {
    args.addInt(KeymasterDefs.KM_TAG_PURPOSE,keymasterPurpose);
  }
  args.addInts(KeymasterDefs.KM_TAG_BLOCK_MODE,keymasterBlockModes);
  int[] keymasterPaddings=ArrayUtils.concat(KeymasterUtils.getKeymasterPaddingsFromJcaEncryptionPaddings(params.getEncryptionPaddings()),KeymasterUtils.getKeymasterPaddingsFromJcaSignaturePaddings(params.getSignaturePaddings()));
  args.addInts(KeymasterDefs.KM_TAG_PADDING,keymasterPaddings);
  if (params.getUserAuthenticators() == 0) {
    args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
  }
 else {
    args.addInt(KeymasterDefs.KM_TAG_USER_AUTH_TYPE,KeyStoreKeyProperties.UserAuthenticator.allToKeymaster(params.getUserAuthenticators()));
  }
  if (params.isInvalidatedOnNewFingerprintEnrolled()) {
  }
  if (params.getUserAuthenticationValidityDurationSeconds() != -1) {
    args.addInt(KeymasterDefs.KM_TAG_AUTH_TIMEOUT,params.getUserAuthenticationValidityDurationSeconds());
  }
  args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,(params.getKeyValidityStart() != null) ? params.getKeyValidityStart() : new Date(0));
  args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,(params.getKeyValidityForOriginationEnd() != null) ? params.getKeyValidityForOriginationEnd() : new Date(Long.MAX_VALUE));
  args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,(params.getKeyValidityForConsumptionEnd() != null) ? params.getKeyValidityForConsumptionEnd() : new Date(Long.MAX_VALUE));
  args.addInt(KeymasterDefs.KM_TAG_KEY_SIZE,keyMaterial.length * 8);
  if (((purposes & KeyStoreKeyProperties.Purpose.ENCRYPT) != 0) && (!params.isRandomizedEncryptionRequired())) {
    args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
  }
  Credentials.deleteAllTypesForAlias(mKeyStore,entryAlias);
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + entryAlias;
  int errorCode=mKeyStore.importKey(keyAliasInKeystore,args,KeymasterDefs.KM_KEY_FORMAT_RAW,keyMaterial,params.getFlags(),new KeyCharacteristics());
  if (errorCode != android.security.KeyStore.NO_ERROR) {
    throw new KeyStoreException("Failed to import secret key. Keystore error code: " + errorCode);
  }
}
