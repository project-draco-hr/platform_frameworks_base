{
  if (key instanceof KeyStoreSecretKey) {
    String keyAliasInKeystore=((KeyStoreSecretKey)key).getAlias();
    if (keyAliasInKeystore == null) {
      throw new KeyStoreException("KeyStore-backed secret key does not have an alias");
    }
    if (!keyAliasInKeystore.startsWith(Credentials.USER_SECRET_KEY)) {
      throw new KeyStoreException("KeyStore-backed secret key has invalid alias: " + keyAliasInKeystore);
    }
    String keyEntryAlias=keyAliasInKeystore.substring(Credentials.USER_SECRET_KEY.length());
    if (!entryAlias.equals(keyEntryAlias)) {
      throw new KeyStoreException("Can only replace KeyStore-backed keys with same" + " alias: " + entryAlias + " != "+ keyEntryAlias);
    }
    if (params != null) {
      throw new KeyStoreException("Modifying KeyStore-backed key using protection" + " parameters not supported");
    }
    return;
  }
  if (params == null) {
    throw new KeyStoreException("Protection parameters must be specified when importing a symmetric key");
  }
  String keyExportFormat=key.getFormat();
  if (keyExportFormat == null) {
    throw new KeyStoreException("Only secret keys that export their key material are supported");
  }
 else   if (!"RAW".equals(keyExportFormat)) {
    throw new KeyStoreException("Unsupported secret key material export format: " + keyExportFormat);
  }
  byte[] keyMaterial=key.getEncoded();
  if (keyMaterial == null) {
    throw new KeyStoreException("Key did not export its key material despite supporting" + " RAW format export");
  }
  String keyAlgorithmString=key.getAlgorithm();
  @KeyStoreKeyConstraints.AlgorithmEnum int keyAlgorithm;
  @KeyStoreKeyConstraints.AlgorithmEnum Integer digest;
  try {
    keyAlgorithm=KeyStoreKeyConstraints.Algorithm.fromJCASecretKeyAlgorithm(keyAlgorithmString);
    digest=KeyStoreKeyConstraints.Digest.fromJCASecretKeyAlgorithm(keyAlgorithmString);
  }
 catch (  IllegalArgumentException e) {
    throw new KeyStoreException("Unsupported secret key algorithm: " + keyAlgorithmString);
  }
  if ((params.getAlgorithm() != null) && (params.getAlgorithm() != keyAlgorithm)) {
    throw new KeyStoreException("Key algorithm mismatch. Key: " + keyAlgorithmString + ", parameter spec: "+ KeyStoreKeyConstraints.Algorithm.toString(params.getAlgorithm()));
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addInt(KeymasterDefs.KM_TAG_ALGORITHM,KeyStoreKeyConstraints.Algorithm.toKeymaster(keyAlgorithm));
  if (digest != null) {
    if (params.getDigest() != null) {
      if (digest != params.getDigest()) {
        throw new KeyStoreException("Key digest mismatch. Key: " + keyAlgorithmString + ", parameter spec: "+ KeyStoreKeyConstraints.Digest.toString(params.getDigest()));
      }
    }
  }
 else {
    digest=params.getDigest();
  }
  if (digest != null) {
    args.addInt(KeymasterDefs.KM_TAG_DIGEST,KeyStoreKeyConstraints.Digest.toKeymaster(digest));
  }
  @KeyStoreKeyConstraints.PurposeEnum int purposes=(params.getPurposes() != null) ? params.getPurposes() : (KeyStoreKeyConstraints.Purpose.ENCRYPT | KeyStoreKeyConstraints.Purpose.DECRYPT | KeyStoreKeyConstraints.Purpose.SIGN| KeyStoreKeyConstraints.Purpose.VERIFY);
  for (  int keymasterPurpose : KeyStoreKeyConstraints.Purpose.allToKeymaster(purposes)) {
    args.addInt(KeymasterDefs.KM_TAG_PURPOSE,keymasterPurpose);
  }
  if (params.getBlockMode() != null) {
    args.addInt(KeymasterDefs.KM_TAG_BLOCK_MODE,KeyStoreKeyConstraints.BlockMode.toKeymaster(params.getBlockMode()));
  }
  if (params.getPadding() != null) {
    args.addInt(KeymasterDefs.KM_TAG_PADDING,KeyStoreKeyConstraints.Padding.toKeymaster(params.getPadding()));
  }
  if (params.getMaxUsesPerBoot() != null) {
    args.addInt(KeymasterDefs.KM_TAG_MAX_USES_PER_BOOT,params.getMaxUsesPerBoot());
  }
  if (params.getMinSecondsBetweenOperations() != null) {
    args.addInt(KeymasterDefs.KM_TAG_MIN_SECONDS_BETWEEN_OPS,params.getMinSecondsBetweenOperations());
  }
  if (params.getUserAuthenticators().isEmpty()) {
    args.addBoolean(KeymasterDefs.KM_TAG_NO_AUTH_REQUIRED);
  }
 else {
  }
  if (params.getUserAuthenticationValidityDurationSeconds() != null) {
    args.addInt(KeymasterDefs.KM_TAG_AUTH_TIMEOUT,params.getUserAuthenticationValidityDurationSeconds());
  }
  if (params.getKeyValidityStart() != null) {
    args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,params.getKeyValidityStart());
  }
  if (params.getKeyValidityForOriginationEnd() != null) {
    args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,params.getKeyValidityForOriginationEnd());
  }
  if (params.getKeyValidityForConsumptionEnd() != null) {
    args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,params.getKeyValidityForConsumptionEnd());
  }
  args.addInt(KeymasterDefs.KM_TAG_KEY_SIZE,keyMaterial.length * 8);
  Credentials.deleteAllTypesForAlias(mKeyStore,entryAlias);
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + entryAlias;
  int errorCode=mKeyStore.importKey(keyAliasInKeystore,args,KeymasterDefs.KM_KEY_FORMAT_RAW,keyMaterial,params.getFlags(),new KeyCharacteristics());
  if (errorCode != android.security.KeyStore.NO_ERROR) {
    throw new KeyStoreException("Failed to import secret key. Keystore error code: " + errorCode);
  }
}
