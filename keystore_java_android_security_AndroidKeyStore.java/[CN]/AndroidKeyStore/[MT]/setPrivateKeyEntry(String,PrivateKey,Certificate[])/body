{
  byte[] keyBytes=null;
  final String pkeyAlias;
  if (key instanceof OpenSSLKeyHolder) {
    pkeyAlias=((OpenSSLKeyHolder)key).getOpenSSLKey().getAlias();
  }
 else {
    pkeyAlias=null;
  }
  final boolean shouldReplacePrivateKey;
  if (pkeyAlias != null && pkeyAlias.startsWith(Credentials.USER_PRIVATE_KEY)) {
    final String keySubalias=pkeyAlias.substring(Credentials.USER_PRIVATE_KEY.length());
    if (!alias.equals(keySubalias)) {
      throw new KeyStoreException("Can only replace keys with same alias: " + alias + " != "+ keySubalias);
    }
    shouldReplacePrivateKey=false;
  }
 else {
    final String keyFormat=key.getFormat();
    if ((keyFormat == null) || (!"PKCS#8".equals(keyFormat))) {
      throw new KeyStoreException("Only PrivateKeys that can be encoded into PKCS#8 are supported");
    }
    keyBytes=key.getEncoded();
    if (keyBytes == null) {
      throw new KeyStoreException("PrivateKey has no encoding");
    }
    shouldReplacePrivateKey=true;
  }
  if ((chain == null) || (chain.length == 0)) {
    throw new KeyStoreException("Must supply at least one Certificate with PrivateKey");
  }
  X509Certificate[] x509chain=new X509Certificate[chain.length];
  for (int i=0; i < chain.length; i++) {
    if (!"X.509".equals(chain[i].getType())) {
      throw new KeyStoreException("Certificates must be in X.509 format: invalid cert #" + i);
    }
    if (!(chain[i] instanceof X509Certificate)) {
      throw new KeyStoreException("Certificates must be in X.509 format: invalid cert #" + i);
    }
    x509chain[i]=(X509Certificate)chain[i];
  }
  final byte[] userCertBytes;
  try {
    userCertBytes=x509chain[0].getEncoded();
  }
 catch (  CertificateEncodingException e) {
    throw new KeyStoreException("Couldn't encode certificate #1",e);
  }
  final byte[] chainBytes;
  if (chain.length > 1) {
    final byte[][] certsBytes=new byte[x509chain.length - 1][];
    int totalCertLength=0;
    for (int i=0; i < certsBytes.length; i++) {
      try {
        certsBytes[i]=x509chain[i + 1].getEncoded();
        totalCertLength+=certsBytes[i].length;
      }
 catch (      CertificateEncodingException e) {
        throw new KeyStoreException("Can't encode Certificate #" + i,e);
      }
    }
    chainBytes=new byte[totalCertLength];
    int outputOffset=0;
    for (int i=0; i < certsBytes.length; i++) {
      final int certLength=certsBytes[i].length;
      System.arraycopy(certsBytes[i],0,chainBytes,outputOffset,certLength);
      outputOffset+=certLength;
      certsBytes[i]=null;
    }
  }
 else {
    chainBytes=null;
  }
  if (shouldReplacePrivateKey) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
  }
 else {
    Credentials.deleteCertificateTypesForAlias(mKeyStore,alias);
  }
  if (shouldReplacePrivateKey && !mKeyStore.importKey(Credentials.USER_PRIVATE_KEY + alias,keyBytes)) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    throw new KeyStoreException("Couldn't put private key in keystore");
  }
 else   if (!mKeyStore.put(Credentials.USER_CERTIFICATE + alias,userCertBytes)) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    throw new KeyStoreException("Couldn't put certificate #1 in keystore");
  }
 else   if (chainBytes != null && !mKeyStore.put(Credentials.CA_CERTIFICATE + alias,chainBytes)) {
    Credentials.deleteAllTypesForAlias(mKeyStore,alias);
    throw new KeyStoreException("Couldn't put certificate chain in keystore");
  }
}
