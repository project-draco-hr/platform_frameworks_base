{
  new Thread(){
    public void run(){
      String path=Environment.getExternalStorageDirectory().getPath();
      String state=Environment.MEDIA_REMOVED;
      try {
        String[] vols=mConnector.doListCommand("volume list",VoldResponseCode.VolumeListResult);
        for (        String volstr : vols) {
          String[] tok=volstr.split(" ");
          if (!tok[1].equals(path)) {
            Slog.w(TAG,String.format("Skipping unknown volume '%s'",tok[1]));
            continue;
          }
          int st=Integer.parseInt(tok[2]);
          if (st == VolumeState.NoMedia) {
            state=Environment.MEDIA_REMOVED;
          }
 else           if (st == VolumeState.Idle) {
            state=Environment.MEDIA_UNMOUNTED;
          }
 else           if (st == VolumeState.Mounted) {
            state=Environment.MEDIA_MOUNTED;
            Slog.i(TAG,"Media already mounted on daemon connection");
          }
 else           if (st == VolumeState.Shared) {
            state=Environment.MEDIA_SHARED;
            Slog.i(TAG,"Media shared on daemon connection");
          }
 else {
            throw new Exception(String.format("Unexpected state %d",st));
          }
        }
        if (state != null) {
          if (DEBUG_EVENTS)           Slog.i(TAG,"Updating valid state " + state);
          updatePublicVolumeState(path,state);
        }
      }
 catch (      Exception e) {
        Slog.e(TAG,"Error processing initial volume state",e);
        updatePublicVolumeState(path,Environment.MEDIA_REMOVED);
      }
      try {
        boolean avail=doGetShareMethodAvailable("ums");
        notifyShareAvailabilityChange("ums",avail);
      }
 catch (      Exception ex) {
        Slog.w(TAG,"Failed to get share availability");
      }
      mReady=true;
    }
  }
.start();
}
