{
  if (Constants.DebugFlags.App.EnableSimulatedTaskGroups) {
    HashMap<Task.TaskKey,Task> taskMap=new HashMap<Task.TaskKey,Task>();
    ArrayList<Task> tasks=mTaskList.getTasks();
    Collections.sort(tasks,new Comparator<Task>(){
      @Override public int compare(      Task task,      Task task2){
        return (int)(task.key.firstActiveTime - task2.key.firstActiveTime);
      }
    }
);
    NamedCounter counter=new NamedCounter("task-group","");
    int taskCount=tasks.size();
    String prevPackage="";
    int prevAffiliation=-1;
    Random r=new Random();
    int groupCountDown=Constants.DebugFlags.App.TaskAffiliationsGroupCount;
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      String packageName=t.key.baseIntent.getComponent().getPackageName();
      packageName="pkg";
      TaskGrouping group;
      if (packageName.equals(prevPackage) && groupCountDown > 0) {
        group=getGroupWithAffiliation(prevAffiliation);
        groupCountDown--;
      }
 else {
        int affiliation=IndividualTaskIdOffset + t.key.id;
        group=new TaskGrouping(affiliation);
        addGroup(group);
        prevAffiliation=affiliation;
        prevPackage=packageName;
        groupCountDown=Constants.DebugFlags.App.TaskAffiliationsGroupCount;
      }
      group.addTask(t);
      taskMap.put(t.key,t);
    }
    Collections.sort(mGroups,new Comparator<TaskGrouping>(){
      @Override public int compare(      TaskGrouping taskGrouping,      TaskGrouping taskGrouping2){
        return (int)(taskGrouping.latestActiveTimeInGroup - taskGrouping2.latestActiveTimeInGroup);
      }
    }
);
    int taskIndex=0;
    int groupCount=mGroups.size();
    for (int i=0; i < groupCount; i++) {
      TaskGrouping group=mGroups.get(i);
      Collections.sort(group.mTaskKeys,new Comparator<Task.TaskKey>(){
        @Override public int compare(        Task.TaskKey taskKey,        Task.TaskKey taskKey2){
          return (int)(taskKey.firstActiveTime - taskKey2.firstActiveTime);
        }
      }
);
      ArrayList<Task.TaskKey> groupTasks=group.mTaskKeys;
      int groupTaskCount=groupTasks.size();
      for (int j=0; j < groupTaskCount; j++) {
        tasks.set(taskIndex,taskMap.get(groupTasks.get(j)));
        taskIndex++;
      }
    }
    mTaskList.set(tasks);
  }
 else {
    HashMap<Task.TaskKey,Task> tasksMap=new HashMap<Task.TaskKey,Task>();
    ArrayList<Task> tasks=mTaskList.getTasks();
    int taskCount=tasks.size();
    for (int i=0; i < taskCount; i++) {
      Task t=tasks.get(i);
      TaskGrouping group;
      int affiliation=t.taskAffiliation > 0 ? t.taskAffiliation : IndividualTaskIdOffset + t.key.id;
      if (mAffinitiesGroups.containsKey(affiliation)) {
        group=getGroupWithAffiliation(affiliation);
      }
 else {
        group=new TaskGrouping(affiliation);
        addGroup(group);
      }
      group.addTask(t);
      tasksMap.put(t.key,t);
    }
    float minAlpha=context.getResources().getFloat(R.dimen.recents_task_affiliation_color_min_alpha_percentage);
    int taskGroupCount=mGroups.size();
    for (int i=0; i < taskGroupCount; i++) {
      TaskGrouping group=mGroups.get(i);
      taskCount=group.getTaskCount();
      if (taskCount <= 1)       continue;
      int affiliationColor=tasksMap.get(group.mTaskKeys.get(0)).taskAffiliationColor;
      float alphaStep=(1f - minAlpha) / taskCount;
      float alpha=1f;
      for (int j=0; j < taskCount; j++) {
        Task t=tasksMap.get(group.mTaskKeys.get(j));
        t.colorPrimary=Utilities.getColorWithOverlay(affiliationColor,Color.WHITE,alpha);
        alpha-=alphaStep;
      }
    }
  }
}
