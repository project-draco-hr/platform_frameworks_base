{
synchronized (mMutex) {
    if (DEBUG)     Slog.d(TAG,"notifyConditions pkg=" + pkg + " info="+ info+ " conditions="+ (conditions == null ? null : Arrays.asList(conditions)));
    if (conditions == null || conditions.length == 0)     return;
    final int N=conditions.length;
    boolean valid=true;
    for (int i=0; i < N; i++) {
      final Uri id=conditions[i].id;
      if (!Condition.isValidId(id,pkg)) {
        Slog.w(TAG,"Ignoring conditions from " + pkg + " for invalid id: "+ id);
        valid=false;
      }
    }
    if (!valid)     return;
    for (int i=0; i < N; i++) {
      mConditions.put(conditions[i].id,info);
    }
    for (    IConditionListener listener : mListeners.values()) {
      try {
        listener.onConditionsReceived(conditions);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,"Error sending conditions to listener " + listener,e);
      }
    }
    if (mCurrentConditionId != null) {
      for (int i=0; i < N; i++) {
        final Condition c=conditions[i];
        if (!c.id.equals(mCurrentConditionId))         continue;
        if (c.state == Condition.STATE_TRUE || c.state == Condition.STATE_ERROR) {
          triggerExitLocked(c.state == Condition.STATE_ERROR);
          return;
        }
      }
    }
  }
}
