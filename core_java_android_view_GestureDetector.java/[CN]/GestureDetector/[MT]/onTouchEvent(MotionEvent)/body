{
  if (mInputEventConsistencyVerifier != null) {
    mInputEventConsistencyVerifier.onTouchEvent(ev,0);
  }
  final int action=ev.getAction();
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final boolean pointerUp=(action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
  final int skipIndex=pointerUp ? ev.getActionIndex() : -1;
  float sumX=0, sumY=0;
  final int count=ev.getPointerCount();
  for (int i=0; i < count; i++) {
    if (skipIndex == i)     continue;
    sumX+=ev.getX(i);
    sumY+=ev.getY(i);
  }
  final int div=pointerUp ? count - 1 : count;
  final float focusX=sumX / div;
  final float focusY=sumY / div;
  boolean handled=false;
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_POINTER_DOWN:
    mDownFocusX=mLastFocusX=focusX;
  mDownFocusY=mLastFocusY=focusY;
cancelTaps();
break;
case MotionEvent.ACTION_POINTER_UP:
mDownFocusX=mLastFocusX=focusX;
mDownFocusY=mLastFocusY=focusY;
mVelocityTracker.computeCurrentVelocity(1000,mMaximumFlingVelocity);
final int upIndex=ev.getActionIndex();
final int id1=ev.getPointerId(upIndex);
final float x1=mVelocityTracker.getXVelocity(id1);
final float y1=mVelocityTracker.getYVelocity(id1);
for (int i=0; i < count; i++) {
if (i == upIndex) continue;
final int id2=ev.getPointerId(i);
final float x=x1 * mVelocityTracker.getXVelocity(id2);
final float y=y1 * mVelocityTracker.getYVelocity(id2);
final float dot=x + y;
if (dot < 0) {
mVelocityTracker.clear();
break;
}
}
break;
case MotionEvent.ACTION_DOWN:
if (mDoubleTapListener != null) {
boolean hadTapMessage=mHandler.hasMessages(TAP);
if (hadTapMessage) mHandler.removeMessages(TAP);
if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage&& isConsideredDoubleTap(mCurrentDownEvent,mPreviousUpEvent,ev)) {
mIsDoubleTapping=true;
handled|=mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
handled|=mDoubleTapListener.onDoubleTapEvent(ev);
}
 else {
mHandler.sendEmptyMessageDelayed(TAP,DOUBLE_TAP_TIMEOUT);
}
}
mDownFocusX=mLastFocusX=focusX;
mDownFocusY=mLastFocusY=focusY;
if (mCurrentDownEvent != null) {
mCurrentDownEvent.recycle();
}
mCurrentDownEvent=MotionEvent.obtain(ev);
mAlwaysInTapRegion=true;
mAlwaysInBiggerTapRegion=true;
mStillDown=true;
mInLongPress=false;
if (mIsLongpressEnabled) {
mHandler.removeMessages(LONG_PRESS);
mHandler.sendEmptyMessageAtTime(LONG_PRESS,mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
}
mHandler.sendEmptyMessageAtTime(SHOW_PRESS,mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
handled|=mListener.onDown(ev);
break;
case MotionEvent.ACTION_MOVE:
if (mInLongPress) {
break;
}
final float scrollX=mLastFocusX - focusX;
final float scrollY=mLastFocusY - focusY;
if (mIsDoubleTapping) {
handled|=mDoubleTapListener.onDoubleTapEvent(ev);
}
 else if (mAlwaysInTapRegion) {
final int deltaX=(int)(focusX - mDownFocusX);
final int deltaY=(int)(focusY - mDownFocusY);
int distance=(deltaX * deltaX) + (deltaY * deltaY);
if (distance > mTouchSlopSquare) {
handled=mListener.onScroll(mCurrentDownEvent,ev,scrollX,scrollY);
mLastFocusX=focusX;
mLastFocusY=focusY;
mAlwaysInTapRegion=false;
mHandler.removeMessages(TAP);
mHandler.removeMessages(SHOW_PRESS);
mHandler.removeMessages(LONG_PRESS);
}
if (distance > mDoubleTapTouchSlopSquare) {
mAlwaysInBiggerTapRegion=false;
}
}
 else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
handled=mListener.onScroll(mCurrentDownEvent,ev,scrollX,scrollY);
mLastFocusX=focusX;
mLastFocusY=focusY;
}
break;
case MotionEvent.ACTION_UP:
mStillDown=false;
MotionEvent currentUpEvent=MotionEvent.obtain(ev);
if (mIsDoubleTapping) {
handled|=mDoubleTapListener.onDoubleTapEvent(ev);
}
 else if (mInLongPress) {
mHandler.removeMessages(TAP);
mInLongPress=false;
}
 else if (mAlwaysInTapRegion) {
handled=mListener.onSingleTapUp(ev);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
final int pointerId=ev.getPointerId(0);
velocityTracker.computeCurrentVelocity(1000,mMaximumFlingVelocity);
final float velocityY=velocityTracker.getYVelocity(pointerId);
final float velocityX=velocityTracker.getXVelocity(pointerId);
if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
handled=mListener.onFling(mCurrentDownEvent,ev,velocityX,velocityY);
}
}
if (mPreviousUpEvent != null) {
mPreviousUpEvent.recycle();
}
mPreviousUpEvent=currentUpEvent;
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mIsDoubleTapping=false;
mHandler.removeMessages(SHOW_PRESS);
mHandler.removeMessages(LONG_PRESS);
break;
case MotionEvent.ACTION_CANCEL:
cancel();
break;
}
if (!handled && mInputEventConsistencyVerifier != null) {
mInputEventConsistencyVerifier.onUnhandledEvent(ev,0);
}
return handled;
}
