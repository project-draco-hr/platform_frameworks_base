{
  final Surface surface=win.mSurface;
  boolean leakedSurface=false;
  boolean killedApps=false;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,win.toString(),win.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    int N=mWindows.size();
    Slog.i(TAG,"Out of memory for surface!  Looking for leaks...");
    for (int i=0; i < N; i++) {
      WindowState ws=mWindows.get(i);
      if (ws.mSurface != null) {
        if (!mSessions.contains(ws.mSession)) {
          Slog.w(TAG,"LEAKED SURFACE (session doesn't exist): " + ws + " surface="+ ws.mSurface+ " token="+ win.mToken+ " pid="+ ws.mSession.mPid+ " uid="+ ws.mSession.mUid);
          if (SHOW_TRANSACTIONS)           logSurface(ws,"LEAK DESTROY",null);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          mForceRemoves.add(ws);
          i--;
          N--;
          leakedSurface=true;
        }
 else         if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
          Slog.w(TAG,"LEAKED SURFACE (app token hidden): " + ws + " surface="+ ws.mSurface+ " token="+ win.mAppToken);
          if (SHOW_TRANSACTIONS)           logSurface(ws,"LEAK DESTROY",null);
          ws.mSurface.destroy();
          ws.mSurfaceShown=false;
          ws.mSurface=null;
          leakedSurface=true;
        }
      }
    }
    if (!leakedSurface) {
      Slog.w(TAG,"No leaked surfaces; killing applicatons!");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int i=0; i < N; i++) {
        WindowState ws=mWindows.get(i);
        if (ws.mSurface != null) {
          pidCandidates.append(ws.mSession.mPid,ws.mSession.mPid);
        }
      }
      if (pidCandidates.size() > 0) {
        int[] pids=new int[pidCandidates.size()];
        for (int i=0; i < pids.length; i++) {
          pids[i]=pidCandidates.keyAt(i);
        }
        try {
          if (mActivityManager.killPids(pids,"Free memory",secure)) {
            killedApps=true;
          }
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,"Looks like we have reclaimed some memory, clearing surface for retry.");
      if (surface != null) {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC)         logSurface(win,"RECOVER DESTROY",null);
        surface.destroy();
        win.mSurfaceShown=false;
        win.mSurface=null;
      }
      try {
        win.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
  return leakedSurface || killedApps;
}
