{
  if (mDisplay == null) {
    return false;
  }
  mInputManager.getInputConfiguration(config);
  final boolean rotated=(mRotation == Surface.ROTATION_90 || mRotation == Surface.ROTATION_270);
  final int realdw=rotated ? mBaseDisplayHeight : mBaseDisplayWidth;
  final int realdh=rotated ? mBaseDisplayWidth : mBaseDisplayHeight;
  if (mAltOrientation) {
    mCurDisplayWidth=realdw;
    mCurDisplayHeight=realdh;
    if (realdw > realdh) {
      int maxw=(int)(realdh / 1.3f);
      if (maxw < realdw) {
        mCurDisplayWidth=maxw;
      }
    }
 else {
      int maxh=(int)(realdw / 1.3f);
      if (maxh < realdh) {
        mCurDisplayHeight=maxh;
      }
    }
  }
 else {
    mCurDisplayWidth=realdw;
    mCurDisplayHeight=realdh;
  }
  final int dw=mCurDisplayWidth;
  final int dh=mCurDisplayHeight;
  int orientation=Configuration.ORIENTATION_SQUARE;
  if (dw < dh) {
    orientation=Configuration.ORIENTATION_PORTRAIT;
  }
 else   if (dw > dh) {
    orientation=Configuration.ORIENTATION_LANDSCAPE;
  }
  config.orientation=orientation;
  DisplayMetrics dm=new DisplayMetrics();
  mDisplay.getRealMetrics(dm);
  dm.widthPixels=dm.unscaledWidthPixels=mAppDisplayWidth=mPolicy.getNonDecorDisplayWidth(mRotation,dw);
  dm.heightPixels=dm.unscaledHeightPixels=mAppDisplayHeight=mPolicy.getNonDecorDisplayHeight(mRotation,dh);
  mCompatibleScreenScale=CompatibilityInfo.computeCompatibleScaling(dm,null);
  config.screenWidthDp=(int)(mPolicy.getConfigDisplayWidth(mRotation,dw) / dm.density);
  config.screenHeightDp=(int)(mPolicy.getConfigDisplayHeight(mRotation,dh) / dm.density);
  int unrotDw, unrotDh;
  if (rotated) {
    unrotDw=dh;
    unrotDh=dw;
  }
 else {
    unrotDw=dw;
    unrotDh=dh;
  }
  config.smallestScreenWidthDp=reduceConfigWidthSize(unrotDw,Surface.ROTATION_0,dm.density,unrotDw);
  config.smallestScreenWidthDp=reduceConfigWidthSize(config.smallestScreenWidthDp,Surface.ROTATION_90,dm.density,unrotDh);
  config.smallestScreenWidthDp=reduceConfigWidthSize(config.smallestScreenWidthDp,Surface.ROTATION_180,dm.density,unrotDw);
  config.smallestScreenWidthDp=reduceConfigWidthSize(config.smallestScreenWidthDp,Surface.ROTATION_270,dm.density,unrotDh);
  int screenLayout;
  int longSize=dw;
  int shortSize=dh;
  if (longSize < shortSize) {
    int tmp=longSize;
    longSize=shortSize;
    shortSize=tmp;
  }
  longSize=(int)(longSize / dm.density);
  shortSize=(int)(shortSize / dm.density);
  if (longSize < 470) {
    screenLayout=Configuration.SCREENLAYOUT_SIZE_SMALL | Configuration.SCREENLAYOUT_LONG_NO;
  }
 else {
    if (longSize >= 960 && shortSize >= 720) {
      screenLayout=Configuration.SCREENLAYOUT_SIZE_XLARGE;
    }
 else     if (longSize >= 640 && shortSize >= 480) {
      screenLayout=Configuration.SCREENLAYOUT_SIZE_LARGE;
    }
 else {
      screenLayout=Configuration.SCREENLAYOUT_SIZE_NORMAL;
    }
    if (shortSize > 321 || longSize > 570) {
      screenLayout|=Configuration.SCREENLAYOUT_COMPAT_NEEDED;
    }
    if (((longSize * 3) / 5) >= (shortSize - 1)) {
      screenLayout|=Configuration.SCREENLAYOUT_LONG_YES;
    }
 else {
      screenLayout|=Configuration.SCREENLAYOUT_LONG_NO;
    }
  }
  config.screenLayout=screenLayout;
  boolean hardKeyboardAvailable=config.keyboard != Configuration.KEYBOARD_NOKEYS;
  if (hardKeyboardAvailable != mHardKeyboardAvailable) {
    mHardKeyboardAvailable=hardKeyboardAvailable;
    mHardKeyboardEnabled=hardKeyboardAvailable;
    mH.removeMessages(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);
    mH.sendEmptyMessage(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);
  }
  if (!mHardKeyboardEnabled) {
    config.keyboard=Configuration.KEYBOARD_NOKEYS;
  }
  config.keyboardHidden=Configuration.KEYBOARDHIDDEN_NO;
  config.hardKeyboardHidden=Configuration.HARDKEYBOARDHIDDEN_NO;
  config.navigationHidden=Configuration.NAVIGATIONHIDDEN_NO;
  mPolicy.adjustConfigurationLw(config);
  return true;
}
