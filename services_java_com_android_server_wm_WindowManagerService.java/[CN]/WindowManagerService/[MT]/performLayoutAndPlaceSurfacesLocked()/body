{
  if (mInLayout) {
    if (DEBUG) {
      throw new RuntimeException("Recursive call!");
    }
    Slog.w(TAG,"performLayoutAndPlaceSurfacesLocked called while in layout");
    return;
  }
  if (mWaitingForConfig) {
    return;
  }
  if (mDisplay == null) {
    return;
  }
  mInLayout=true;
  boolean recoveringMemory=false;
  try {
    if (mForceRemoves != null) {
      recoveringMemory=true;
      for (int i=0; i < mForceRemoves.size(); i++) {
        WindowState ws=mForceRemoves.get(i);
        Slog.i(TAG,"Force removing: " + ws);
        removeWindowInnerLocked(ws.mSession,ws);
      }
      mForceRemoves=null;
      Slog.w(TAG,"Due to memory failure, waiting a bit for next layout");
      Object tmp=new Object();
synchronized (tmp) {
        try {
          tmp.wait(250);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
 catch (  RuntimeException e) {
    Log.wtf(TAG,"Unhandled exception while force removing for memory",e);
  }
  try {
    performLayoutAndPlaceSurfacesLockedInner(recoveringMemory);
    int N=mPendingRemove.size();
    if (N > 0) {
      if (mPendingRemoveTmp.length < N) {
        mPendingRemoveTmp=new WindowState[N + 10];
      }
      mPendingRemove.toArray(mPendingRemoveTmp);
      mPendingRemove.clear();
      for (int i=0; i < N; i++) {
        WindowState w=mPendingRemoveTmp[i];
        removeWindowInnerLocked(w.mSession,w);
      }
      mInLayout=false;
      assignLayersLocked();
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
 else {
      mInLayout=false;
      if (mLayoutNeeded) {
        requestTraversalLocked();
      }
    }
    if (mWindowsChanged && !mWindowChangeListeners.isEmpty()) {
      mH.removeMessages(H.REPORT_WINDOWS_CHANGE);
      mH.sendMessage(mH.obtainMessage(H.REPORT_WINDOWS_CHANGE));
    }
  }
 catch (  RuntimeException e) {
    mInLayout=false;
    Log.wtf(TAG,"Unhandled exception while laying out windows",e);
  }
}
