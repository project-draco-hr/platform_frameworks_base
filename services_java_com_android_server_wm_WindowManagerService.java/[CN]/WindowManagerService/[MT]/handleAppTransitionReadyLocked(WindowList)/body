{
  int changes=0;
  int i;
  int NN=mOpeningApps.size();
  boolean goodToGo=true;
  if (DEBUG_APP_TRANSITIONS)   Slog.v(TAG,"Checking " + NN + " opening apps (frozen="+ mDisplayFrozen+ " timeout="+ mAppTransition.isTimeout()+ ")...");
  if (!mDisplayFrozen && !mAppTransition.isTimeout()) {
    for (i=0; i < NN && goodToGo; i++) {
      AppWindowToken wtoken=mOpeningApps.get(i);
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,"Check opening app=" + wtoken + ": allDrawn="+ wtoken.allDrawn+ " startingDisplayed="+ wtoken.startingDisplayed+ " startingMoved="+ wtoken.startingMoved);
      if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
        goodToGo=false;
      }
    }
  }
  if (goodToGo) {
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,"**** GOOD TO GO");
    int transit=mAppTransition.getAppTransition();
    if (mSkipAppTransitionAnimation) {
      transit=AppTransition.TRANSIT_UNSET;
    }
    mAppTransition.goodToGo();
    mStartingIconInTransition=false;
    mSkipAppTransitionAnimation=false;
    mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
    rebuildAppWindowListLocked();
    WindowState oldWallpaper=mWallpaperTarget != null && mWallpaperTarget.mWinAnimator.isAnimating() && !mWallpaperTarget.mWinAnimator.isDummyAnimation() ? null : mWallpaperTarget;
    final AppWindowToken wallpaperTargetAppToken=mWallpaperTarget != null ? mWallpaperTarget.mAppToken : null;
    if (wallpaperTargetAppToken != null && !mClosingApps.contains(wallpaperTargetAppToken) && !mOpeningApps.contains(wallpaperTargetAppToken) && (transit & AppTransition.TRANSIT_EXIT_MASK) != 0) {
      mOpeningApps.add(wallpaperTargetAppToken);
      NN++;
    }
    mInnerFields.mWallpaperMayChange=false;
    LayoutParams animLp=null;
    int bestAnimLayer=-1;
    boolean fullscreenAnim=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,"New wallpaper target=" + mWallpaperTarget + ", oldWallpaper="+ oldWallpaper+ ", lower target="+ mLowerWallpaperTarget+ ", upper target="+ mUpperWallpaperTarget);
    boolean openingAppHasWallpaper=false;
    boolean closingAppHasWallpaper=false;
    final AppWindowToken lowerWallpaperAppToken;
    final AppWindowToken upperWallpaperAppToken;
    if (mLowerWallpaperTarget == null) {
      lowerWallpaperAppToken=upperWallpaperAppToken=null;
    }
 else {
      lowerWallpaperAppToken=mLowerWallpaperTarget.mAppToken;
      upperWallpaperAppToken=mUpperWallpaperTarget.mAppToken;
    }
    final int NC=mClosingApps.size();
    NN=NC + mOpeningApps.size();
    for (i=0; i < NN; i++) {
      final AppWindowToken wtoken;
      if (i < NC) {
        wtoken=mClosingApps.get(i);
        if (wtoken == lowerWallpaperAppToken || wtoken == upperWallpaperAppToken) {
          closingAppHasWallpaper=true;
        }
      }
 else {
        wtoken=mOpeningApps.get(i - NC);
        if (wtoken == lowerWallpaperAppToken || wtoken == upperWallpaperAppToken) {
          openingAppHasWallpaper=true;
        }
      }
      if (wtoken.appFullscreen) {
        WindowState ws=wtoken.findMainWindow();
        if (ws != null) {
          animLp=ws.mAttrs;
          bestAnimLayer=ws.mLayer;
          fullscreenAnim=true;
        }
      }
 else       if (!fullscreenAnim) {
        WindowState ws=wtoken.findMainWindow();
        if (ws != null) {
          if (ws.mLayer > bestAnimLayer) {
            animLp=ws.mAttrs;
            bestAnimLayer=ws.mLayer;
          }
        }
      }
    }
    if (closingAppHasWallpaper && openingAppHasWallpaper) {
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,"Wallpaper animation!");
switch (transit) {
case AppTransition.TRANSIT_ACTIVITY_OPEN:
case AppTransition.TRANSIT_TASK_OPEN:
case AppTransition.TRANSIT_TASK_TO_FRONT:
        transit=AppTransition.TRANSIT_WALLPAPER_INTRA_OPEN;
      break;
case AppTransition.TRANSIT_ACTIVITY_CLOSE:
case AppTransition.TRANSIT_TASK_CLOSE:
case AppTransition.TRANSIT_TASK_TO_BACK:
    transit=AppTransition.TRANSIT_WALLPAPER_INTRA_CLOSE;
  break;
}
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"New transit: " + transit);
}
 else if ((oldWallpaper != null) && !mOpeningApps.contains(oldWallpaper.mAppToken)) {
transit=AppTransition.TRANSIT_WALLPAPER_CLOSE;
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"New transit away from wallpaper: " + transit);
}
 else if (mWallpaperTarget != null && mWallpaperTarget.isVisibleLw()) {
transit=AppTransition.TRANSIT_WALLPAPER_OPEN;
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"New transit into wallpaper: " + transit);
}
if (!mPolicy.allowAppAnimationsLw()) {
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"Animations disallowed by keyguard or dream.");
animLp=null;
}
AppWindowToken topOpeningApp=null;
int topOpeningLayer=0;
NN=mOpeningApps.size();
for (i=0; i < NN; i++) {
AppWindowToken wtoken=mOpeningApps.get(i);
final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"Now opening app" + wtoken);
appAnimator.clearThumbnail();
wtoken.inPendingTransaction=false;
appAnimator.animation=null;
setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
wtoken.updateReportedVisibilityLocked();
wtoken.waitingToShow=false;
appAnimator.mAllAppWinAnimators.clear();
final int N=wtoken.allAppWindows.size();
for (int j=0; j < N; j++) {
appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
}
mAnimator.mAnimating|=appAnimator.showAllWindowsLocked();
if (animLp != null) {
int layer=-1;
for (int j=0; j < wtoken.windows.size(); j++) {
  WindowState win=wtoken.windows.get(j);
  if (win.mWinAnimator.mAnimLayer > layer) {
    layer=win.mWinAnimator.mAnimLayer;
  }
}
if (topOpeningApp == null || layer > topOpeningLayer) {
  topOpeningApp=wtoken;
  topOpeningLayer=layer;
}
}
}
NN=mClosingApps.size();
for (i=0; i < NN; i++) {
AppWindowToken wtoken=mClosingApps.get(i);
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"Now closing app " + wtoken);
wtoken.mAppAnimator.clearThumbnail();
wtoken.inPendingTransaction=false;
wtoken.mAppAnimator.animation=null;
setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
wtoken.updateReportedVisibilityLocked();
wtoken.waitingToHide=false;
wtoken.allDrawn=true;
wtoken.deferClearAllDrawn=false;
}
AppWindowAnimator appAnimator=topOpeningApp == null ? null : topOpeningApp.mAppAnimator;
Bitmap nextAppTransitionThumbnail=mAppTransition.getNextAppTransitionThumbnail();
if (nextAppTransitionThumbnail != null && appAnimator != null && appAnimator.animation != null) {
Rect dirty=new Rect(0,0,nextAppTransitionThumbnail.getWidth(),nextAppTransitionThumbnail.getHeight());
try {
final DisplayContent displayContent=getDefaultDisplayContentLocked();
final Display display=displayContent.getDisplay();
SurfaceControl surfaceControl=new SurfaceControl(mFxSession,"thumbnail anim",dirty.width(),dirty.height(),PixelFormat.TRANSLUCENT,SurfaceControl.HIDDEN);
surfaceControl.setLayerStack(display.getLayerStack());
appAnimator.thumbnail=surfaceControl;
if (SHOW_TRANSACTIONS) Slog.i(TAG,"  THUMBNAIL " + surfaceControl + ": CREATE");
Surface drawSurface=new Surface();
drawSurface.copyFrom(surfaceControl);
Canvas c=drawSurface.lockCanvas(dirty);
c.drawBitmap(nextAppTransitionThumbnail,0,0,null);
drawSurface.unlockCanvasAndPost(c);
drawSurface.release();
appAnimator.thumbnailLayer=topOpeningLayer;
DisplayInfo displayInfo=getDefaultDisplayInfoLocked();
Animation anim=mAppTransition.createThumbnailAnimationLocked(transit,true,true,displayInfo.appWidth,displayInfo.appHeight);
appAnimator.thumbnailAnimation=anim;
anim.restrictDuration(MAX_ANIMATION_DURATION);
anim.scaleCurrentDuration(mTransitionAnimationScale);
Point p=new Point();
mAppTransition.getStartingPoint(p);
appAnimator.thumbnailX=p.x;
appAnimator.thumbnailY=p.y;
}
 catch (OutOfResourcesException e) {
Slog.e(TAG,"Can't allocate thumbnail/Canvas surface w=" + dirty.width() + " h="+ dirty.height(),e);
appAnimator.clearThumbnail();
}
}
mAppTransition.postAnimationCallback();
mAppTransition.clear();
mOpeningApps.clear();
mClosingApps.clear();
changes|=WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG;
getDefaultDisplayContentLocked().layoutNeeded=true;
if (windows == getDefaultWindowListLocked() && !moveInputMethodWindowsIfNeededLocked(true)) {
assignLayersLocked(windows);
}
updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,false);
mFocusMayChange=false;
}
return changes;
}
