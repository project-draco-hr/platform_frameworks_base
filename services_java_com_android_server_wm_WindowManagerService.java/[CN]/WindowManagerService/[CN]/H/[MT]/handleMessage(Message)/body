{
switch (msg.what) {
case REPORT_FOCUS_CHANGE:
{
      WindowState lastFocus;
      WindowState newFocus;
synchronized (mWindowMap) {
        lastFocus=mLastFocus;
        newFocus=mCurrentFocus;
        if (lastFocus == newFocus) {
          return;
        }
        mLastFocus=newFocus;
        if (newFocus != null && lastFocus != null && !newFocus.isDisplayedLw()) {
          mLosingFocus.add(lastFocus);
          lastFocus=null;
        }
      }
      if (lastFocus != newFocus) {
        if (newFocus != null) {
          try {
            newFocus.mClient.windowFocusChanged(true,mInTouchMode);
          }
 catch (          RemoteException e) {
          }
          notifyFocusChanged();
        }
        if (lastFocus != null) {
          try {
            lastFocus.mClient.windowFocusChanged(false,mInTouchMode);
          }
 catch (          RemoteException e) {
          }
        }
        mPolicy.focusChanged(lastFocus,newFocus);
      }
    }
  break;
case REPORT_LOSING_FOCUS:
{
  ArrayList<WindowState> losers;
synchronized (mWindowMap) {
    losers=mLosingFocus;
    mLosingFocus=new ArrayList<WindowState>();
  }
  final int N=losers.size();
  for (int i=0; i < N; i++) {
    try {
      losers.get(i).mClient.windowFocusChanged(false,mInTouchMode);
    }
 catch (    RemoteException e) {
    }
  }
}
break;
case ANIMATE:
{
synchronized (mWindowMap) {
mAnimationPending=false;
performLayoutAndPlaceSurfacesLocked();
}
}
break;
case ADD_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
final StartingData sd=wtoken.startingData;
if (sd == null) {
return;
}
if (DEBUG_STARTING_WINDOW) Slog.v(TAG,"Add starting " + wtoken + ": pkg="+ sd.pkg);
View view=null;
try {
view=mPolicy.addStartingWindow(wtoken.token,sd.pkg,sd.theme,sd.compatInfo,sd.nonLocalizedLabel,sd.labelRes,sd.icon,sd.windowFlags);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when adding starting window",e);
}
if (view != null) {
boolean abort=false;
synchronized (mWindowMap) {
if (wtoken.removed || wtoken.startingData == null) {
if (wtoken.startingWindow != null) {
  if (DEBUG_STARTING_WINDOW)   Slog.v(TAG,"Aborted starting " + wtoken + ": removed="+ wtoken.removed+ " startingData="+ wtoken.startingData);
  wtoken.startingWindow=null;
  wtoken.startingData=null;
  abort=true;
}
}
 else {
wtoken.startingView=view;
}
if (DEBUG_STARTING_WINDOW && !abort) Slog.v(TAG,"Added starting " + wtoken + ": startingWindow="+ wtoken.startingWindow+ " startingView="+ wtoken.startingView);
}
if (abort) {
try {
mPolicy.removeStartingWindow(wtoken.token,view);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when removing starting window",e);
}
}
}
}
break;
case REMOVE_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
IBinder token=null;
View view=null;
synchronized (mWindowMap) {
if (DEBUG_STARTING_WINDOW) Slog.v(TAG,"Remove starting " + wtoken + ": startingWindow="+ wtoken.startingWindow+ " startingView="+ wtoken.startingView);
if (wtoken.startingWindow != null) {
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
}
}
if (view != null) {
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when removing starting window",e);
}
}
}
break;
case FINISHED_STARTING:
{
IBinder token=null;
View view=null;
while (true) {
synchronized (mWindowMap) {
final int N=mFinishedStarting.size();
if (N <= 0) {
break;
}
AppWindowToken wtoken=mFinishedStarting.remove(N - 1);
if (DEBUG_STARTING_WINDOW) Slog.v(TAG,"Finished starting " + wtoken + ": startingWindow="+ wtoken.startingWindow+ " startingView="+ wtoken.startingView);
if (wtoken.startingWindow == null) {
continue;
}
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
}
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when removing starting window",e);
}
}
}
break;
case REPORT_APPLICATION_TOKEN_WINDOWS:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
boolean nowVisible=msg.arg1 != 0;
boolean nowGone=msg.arg2 != 0;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG,"Reporting visible in " + wtoken + " visible="+ nowVisible+ " gone="+ nowGone);
if (nowVisible) {
wtoken.appToken.windowsVisible();
}
 else {
wtoken.appToken.windowsGone();
}
}
 catch (RemoteException ex) {
}
}
break;
case WINDOW_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG,"Window freeze timeout expired.");
int i=mWindows.size();
while (i > 0) {
i--;
WindowState w=mWindows.get(i);
if (w.mOrientationChanging) {
w.mOrientationChanging=false;
Slog.w(TAG,"Force clearing orientation change: " + w);
}
}
performLayoutAndPlaceSurfacesLocked();
}
break;
}
case HOLD_SCREEN_CHANGED:
{
Session oldHold;
Session newHold;
synchronized (mWindowMap) {
oldHold=mLastReportedHold;
newHold=(Session)msg.obj;
mLastReportedHold=newHold;
}
if (oldHold != newHold) {
try {
if (oldHold != null) {
mBatteryStats.noteStopWakelock(oldHold.mUid,-1,"window",BatteryStats.WAKE_TYPE_WINDOW);
}
if (newHold != null) {
mBatteryStats.noteStartWakelock(newHold.mUid,-1,"window",BatteryStats.WAKE_TYPE_WINDOW);
}
}
 catch (RemoteException e) {
}
}
break;
}
case APP_TRANSITION_TIMEOUT:
{
synchronized (mWindowMap) {
if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"*** APP TRANSITION TIMEOUT");
mAppTransitionReady=true;
mAppTransitionTimeout=true;
performLayoutAndPlaceSurfacesLocked();
}
}
break;
}
case PERSIST_ANIMATION_SCALE:
{
Settings.System.putFloat(mContext.getContentResolver(),Settings.System.WINDOW_ANIMATION_SCALE,mWindowAnimationScale);
Settings.System.putFloat(mContext.getContentResolver(),Settings.System.TRANSITION_ANIMATION_SCALE,mTransitionAnimationScale);
break;
}
case FORCE_GC:
{
synchronized (mWindowMap) {
if (mAnimationPending) {
mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),2000);
return;
}
if (mDisplayFrozen) {
return;
}
}
Runtime.getRuntime().gc();
break;
}
case ENABLE_SCREEN:
{
performEnableScreen();
break;
}
case APP_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG,"App freeze timeout expired.");
int i=mAppTokens.size();
while (i > 0) {
i--;
AppWindowToken tok=mAppTokens.get(i);
if (tok.freezingScreen) {
Slog.w(TAG,"Force clearing freeze: " + tok);
unsetAppFreezingScreenLocked(tok,true,true);
}
}
}
break;
}
case SEND_NEW_CONFIGURATION:
{
removeMessages(SEND_NEW_CONFIGURATION);
sendNewConfiguration();
break;
}
case REPORT_WINDOWS_CHANGE:
{
if (mWindowsChanged) {
synchronized (mWindowMap) {
mWindowsChanged=false;
}
notifyWindowsChanged();
}
break;
}
case DRAG_START_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG,"Timeout starting drag by win " + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.unregister();
mInputMonitor.updateInputWindowsLw(true);
mDragState.reset();
mDragState=null;
}
}
break;
}
case DRAG_END_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG,"Timeout ending drag to win " + win);
}
synchronized (mWindowMap) {
mDragState.mDragResult=false;
mDragState.endDragLw();
}
break;
}
case REPORT_HARD_KEYBOARD_STATUS_CHANGE:
{
notifyHardKeyboardStatusChange();
break;
}
}
}
