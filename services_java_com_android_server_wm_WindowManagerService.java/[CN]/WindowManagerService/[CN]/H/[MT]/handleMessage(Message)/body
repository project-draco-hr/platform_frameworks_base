{
  if (DEBUG_WINDOW_TRACE) {
    Slog.v(TAG,"handleMessage: entry what=" + msg.what);
  }
switch (msg.what) {
case REPORT_FOCUS_CHANGE:
{
      WindowState lastFocus;
      WindowState newFocus;
synchronized (mWindowMap) {
        lastFocus=mLastFocus;
        newFocus=mCurrentFocus;
        if (lastFocus == newFocus) {
          return;
        }
        mLastFocus=newFocus;
        if (newFocus != null && lastFocus != null && !newFocus.isDisplayedLw()) {
          mLosingFocus.add(lastFocus);
          lastFocus=null;
        }
      }
      if (lastFocus != newFocus) {
        if (newFocus != null) {
          newFocus.reportFocusChangedSerialized(true,mInTouchMode);
          notifyFocusChanged();
        }
        if (lastFocus != null) {
          lastFocus.reportFocusChangedSerialized(false,mInTouchMode);
        }
      }
    }
  break;
case REPORT_LOSING_FOCUS:
{
  ArrayList<WindowState> losers;
synchronized (mWindowMap) {
    losers=mLosingFocus;
    mLosingFocus=new ArrayList<WindowState>();
  }
  final int N=losers.size();
  for (int i=0; i < N; i++) {
    losers.get(i).reportFocusChangedSerialized(false,mInTouchMode);
  }
}
break;
case DO_TRAVERSAL:
{
synchronized (mWindowMap) {
mTraversalScheduled=false;
performLayoutAndPlaceSurfacesLocked();
}
}
break;
case ADD_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
final StartingData sd=wtoken.startingData;
if (sd == null) {
return;
}
if (DEBUG_STARTING_WINDOW) Slog.v(TAG,"Add starting " + wtoken + ": pkg="+ sd.pkg);
View view=null;
try {
view=mPolicy.addStartingWindow(wtoken.token,sd.pkg,sd.theme,sd.compatInfo,sd.nonLocalizedLabel,sd.labelRes,sd.icon,sd.windowFlags);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when adding starting window",e);
}
if (view != null) {
boolean abort=false;
synchronized (mWindowMap) {
if (wtoken.removed || wtoken.startingData == null) {
if (wtoken.startingWindow != null) {
  if (DEBUG_STARTING_WINDOW)   Slog.v(TAG,"Aborted starting " + wtoken + ": removed="+ wtoken.removed+ " startingData="+ wtoken.startingData);
  wtoken.startingWindow=null;
  wtoken.startingData=null;
  abort=true;
}
}
 else {
wtoken.startingView=view;
}
if (DEBUG_STARTING_WINDOW && !abort) Slog.v(TAG,"Added starting " + wtoken + ": startingWindow="+ wtoken.startingWindow+ " startingView="+ wtoken.startingView);
}
if (abort) {
try {
mPolicy.removeStartingWindow(wtoken.token,view);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when removing starting window",e);
}
}
}
}
break;
case REMOVE_STARTING:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
IBinder token=null;
View view=null;
synchronized (mWindowMap) {
if (DEBUG_STARTING_WINDOW) Slog.v(TAG,"Remove starting " + wtoken + ": startingWindow="+ wtoken.startingWindow+ " startingView="+ wtoken.startingView);
if (wtoken.startingWindow != null) {
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
wtoken.startingDisplayed=false;
}
}
if (view != null) {
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when removing starting window",e);
}
}
}
break;
case FINISHED_STARTING:
{
IBinder token=null;
View view=null;
while (true) {
synchronized (mWindowMap) {
final int N=mFinishedStarting.size();
if (N <= 0) {
break;
}
AppWindowToken wtoken=mFinishedStarting.remove(N - 1);
if (DEBUG_STARTING_WINDOW) Slog.v(TAG,"Finished starting " + wtoken + ": startingWindow="+ wtoken.startingWindow+ " startingView="+ wtoken.startingView);
if (wtoken.startingWindow == null) {
continue;
}
view=wtoken.startingView;
token=wtoken.token;
wtoken.startingData=null;
wtoken.startingView=null;
wtoken.startingWindow=null;
wtoken.startingDisplayed=false;
}
try {
mPolicy.removeStartingWindow(token,view);
}
 catch (Exception e) {
Slog.w(TAG,"Exception when removing starting window",e);
}
}
}
break;
case REPORT_APPLICATION_TOKEN_DRAWN:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG,"Reporting drawn in " + wtoken);
wtoken.appToken.windowsDrawn();
}
 catch (RemoteException ex) {
}
}
break;
case REPORT_APPLICATION_TOKEN_WINDOWS:
{
final AppWindowToken wtoken=(AppWindowToken)msg.obj;
boolean nowVisible=msg.arg1 != 0;
boolean nowGone=msg.arg2 != 0;
try {
if (DEBUG_VISIBILITY) Slog.v(TAG,"Reporting visible in " + wtoken + " visible="+ nowVisible+ " gone="+ nowGone);
if (nowVisible) {
wtoken.appToken.windowsVisible();
}
 else {
wtoken.appToken.windowsGone();
}
}
 catch (RemoteException ex) {
}
}
break;
case WINDOW_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG,"Window freeze timeout expired.");
final WindowList windows=getDefaultWindowListLocked();
int i=windows.size();
while (i > 0) {
i--;
WindowState w=windows.get(i);
if (w.mOrientationChanging) {
w.mOrientationChanging=false;
w.mLastFreezeDuration=(int)(SystemClock.elapsedRealtime() - mDisplayFreezeTime);
Slog.w(TAG,"Force clearing orientation change: " + w);
}
}
performLayoutAndPlaceSurfacesLocked();
}
break;
}
case APP_TRANSITION_TIMEOUT:
{
synchronized (mWindowMap) {
if (mAppTransition.isTransitionSet()) {
if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,"*** APP TRANSITION TIMEOUT");
mAppTransition.setTimeout();
performLayoutAndPlaceSurfacesLocked();
}
}
break;
}
case PERSIST_ANIMATION_SCALE:
{
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.WINDOW_ANIMATION_SCALE,mWindowAnimationScale);
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.TRANSITION_ANIMATION_SCALE,mTransitionAnimationScale);
Settings.Global.putFloat(mContext.getContentResolver(),Settings.Global.ANIMATOR_DURATION_SCALE,mAnimatorDurationScale);
break;
}
case FORCE_GC:
{
synchronized (mWindowMap) {
if (mAnimator.mAnimating || mAnimationScheduled) {
sendEmptyMessageDelayed(H.FORCE_GC,2000);
return;
}
if (mDisplayFrozen) {
return;
}
}
Runtime.getRuntime().gc();
break;
}
case ENABLE_SCREEN:
{
performEnableScreen();
break;
}
case APP_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
Slog.w(TAG,"App freeze timeout expired.");
DisplayContent displayContent=getDefaultDisplayContentLocked();
final ArrayList<Task> tasks=displayContent.getTasks();
for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
AppTokenList tokens=tasks.get(taskNdx).mAppTokens;
for (int tokenNdx=tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
AppWindowToken tok=tokens.get(tokenNdx);
if (tok.mAppAnimator.freezingScreen) {
Slog.w(TAG,"Force clearing freeze: " + tok);
unsetAppFreezingScreenLocked(tok,true,true);
}
}
}
}
break;
}
case CLIENT_FREEZE_TIMEOUT:
{
synchronized (mWindowMap) {
if (mClientFreezingScreen) {
mClientFreezingScreen=false;
mLastFinishedFreezeSource="client-timeout";
stopFreezingDisplayLocked();
}
}
break;
}
case SEND_NEW_CONFIGURATION:
{
removeMessages(SEND_NEW_CONFIGURATION);
sendNewConfiguration();
break;
}
case REPORT_WINDOWS_CHANGE:
{
if (mWindowsChanged) {
synchronized (mWindowMap) {
mWindowsChanged=false;
}
notifyWindowsChanged();
}
break;
}
case DRAG_START_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG,"Timeout starting drag by win " + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.unregister();
mInputMonitor.updateInputWindowsLw(true);
mDragState.reset();
mDragState=null;
}
}
break;
}
case DRAG_END_TIMEOUT:
{
IBinder win=(IBinder)msg.obj;
if (DEBUG_DRAG) {
Slog.w(TAG,"Timeout ending drag to win " + win);
}
synchronized (mWindowMap) {
if (mDragState != null) {
mDragState.mDragResult=false;
mDragState.endDragLw();
}
}
break;
}
case REPORT_HARD_KEYBOARD_STATUS_CHANGE:
{
notifyHardKeyboardStatusChange();
break;
}
case BOOT_TIMEOUT:
{
performBootTimeout();
break;
}
case WAITING_FOR_DRAWN_TIMEOUT:
{
Pair<WindowState,IRemoteCallback> pair;
synchronized (mWindowMap) {
pair=(Pair<WindowState,IRemoteCallback>)msg.obj;
Slog.w(TAG,"Timeout waiting for drawn: " + pair.first);
if (!mWaitingForDrawn.remove(pair)) {
return;
}
}
try {
pair.second.sendResult(null);
}
 catch (RemoteException e) {
}
break;
}
case SHOW_STRICT_MODE_VIOLATION:
{
showStrictModeViolation(msg.arg1,msg.arg2);
break;
}
case DO_ANIMATION_CALLBACK:
{
try {
((IRemoteCallback)msg.obj).sendResult(null);
}
 catch (RemoteException e) {
}
break;
}
case DO_DISPLAY_ADDED:
synchronized (mWindowMap) {
handleDisplayAddedLocked(msg.arg1);
}
break;
case DO_DISPLAY_REMOVED:
synchronized (mWindowMap) {
handleDisplayRemovedLocked(msg.arg1);
}
break;
case DO_DISPLAY_CHANGED:
synchronized (mWindowMap) {
handleDisplayChangedLocked(msg.arg1);
}
break;
}
if (DEBUG_WINDOW_TRACE) {
Slog.v(TAG,"handleMessage: exit");
}
}
