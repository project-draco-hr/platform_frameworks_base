{
  int firstIdx=segmentsStart;
  int lastIdx=getLastNonWhitespace() + segmentsStart;
  JustificationInfo jInfos[]=new JustificationInfo[5];
  float gapLeft=gap;
  int highestPriority=-1;
  for (int priority=0; priority <= GlyphJustificationInfo.PRIORITY_NONE + 1; priority++) {
    JustificationInfo jInfo=new JustificationInfo();
    jInfo.lastIdx=lastIdx;
    jInfo.firstIdx=firstIdx;
    jInfo.grow=gap > 0;
    jInfo.gapToFill=gapLeft;
    if (priority <= GlyphJustificationInfo.PRIORITY_NONE) {
      jInfo.priority=priority;
    }
 else {
      jInfo.priority=highestPriority;
    }
    for (int i=0; i < runSegments.size(); i++) {
      TextRunSegment segment=runSegments.get(i);
      if (segment.getStart() <= lastIdx) {
        segment.updateJustificationInfo(jInfo);
      }
    }
    if (jInfo.priority == highestPriority) {
      jInfo.absorb=true;
      jInfo.absorbedWeight=jInfo.weight;
    }
    if (jInfo.weight != 0) {
      if (highestPriority < 0) {
        highestPriority=priority;
      }
      jInfos[priority]=jInfo;
    }
 else {
      continue;
    }
    gapLeft-=jInfo.growLimit;
    if (((gapLeft > 0) ^ jInfo.grow) || gapLeft == 0) {
      gapLeft=0;
      jInfo.gapPerUnit=jInfo.gapToFill / jInfo.weight;
      break;
    }
    jInfo.useLimits=true;
    if (jInfo.absorbedWeight > 0) {
      jInfo.absorb=true;
      jInfo.absorbedGapPerUnit=(jInfo.gapToFill - jInfo.growLimit) / jInfo.absorbedWeight;
      break;
    }
  }
  float currJustificationOffset=0;
  for (int i=0; i < runSegments.size(); i++) {
    TextRunSegment segment=runSegments.get(getSegmentFromVisualOrder(i));
    segment.x+=currJustificationOffset;
    currJustificationOffset+=segment.doJustification(jInfos);
  }
  justification=-1;
}
