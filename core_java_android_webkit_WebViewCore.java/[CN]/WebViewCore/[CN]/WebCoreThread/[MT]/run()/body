{
  Looper.prepare();
  Assert.assertNull(sWebCoreHandler);
synchronized (WebViewCore.class) {
    sWebCoreHandler=new Handler(){
      @Override public void handleMessage(      Message msg){
switch (msg.what) {
case INITIALIZE:
          WebViewCore core=(WebViewCore)msg.obj;
synchronized (core) {
          core.initialize();
          core.notify();
        }
      break;
case REDUCE_PRIORITY:
    Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT + 3 * Process.THREAD_PRIORITY_LESS_FAVORABLE);
  break;
case RESUME_PRIORITY:
Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
break;
case CACHE_TICKER:
if (!mCacheTickersBlocked) {
CacheManager.endCacheTransaction();
CacheManager.startCacheTransaction();
sendMessageDelayed(obtainMessage(CACHE_TICKER),CACHE_TICKER_INTERVAL);
}
break;
case BLOCK_CACHE_TICKER:
if (CacheManager.endCacheTransaction()) {
mCacheTickersBlocked=true;
}
break;
case RESUME_CACHE_TICKER:
if (CacheManager.startCacheTransaction()) {
mCacheTickersBlocked=false;
}
break;
}
}
}
;
WebViewCore.class.notify();
}
Looper.loop();
}
