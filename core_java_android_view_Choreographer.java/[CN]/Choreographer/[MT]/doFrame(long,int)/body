{
  final long startNanos;
synchronized (mLock) {
    if (!mFrameScheduled) {
      return;
    }
    startNanos=System.nanoTime();
    final long jitterNanos=startNanos - frameTimeNanos;
    if (jitterNanos >= mFrameIntervalNanos) {
      final long skippedFrames=jitterNanos / mFrameIntervalNanos;
      if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
        Log.w(TAG,"Skipped " + skippedFrames + " frames!  "+ "The application may be doing too much work on its main thread.");
      }
      final long lastFrameOffset=jitterNanos % mFrameIntervalNanos;
      if (DEBUG) {
        Log.d(TAG,"Missed vsync by " + (jitterNanos * 0.000001f) + " ms "+ "which is more than the frame interval of "+ (mFrameIntervalNanos * 0.000001f)+ " ms!  "+ "Skipping "+ skippedFrames+ " frames and setting frame "+ "time to "+ (lastFrameOffset * 0.000001f)+ " ms in the past.");
      }
      frameTimeNanos=startNanos - lastFrameOffset;
    }
    if (frameTimeNanos < mLastFrameTimeNanos) {
      if (DEBUG) {
        Log.d(TAG,"Frame time appears to be going backwards.  May be due to a " + "previously skipped frame.  Waiting for next vsync.");
      }
      scheduleVsyncLocked();
      return;
    }
    mFrameScheduled=false;
    mLastFrameTimeNanos=frameTimeNanos;
  }
  doCallbacks(Choreographer.CALLBACK_INPUT,frameTimeNanos);
  doCallbacks(Choreographer.CALLBACK_ANIMATION,frameTimeNanos);
  doCallbacks(Choreographer.CALLBACK_TRAVERSAL,frameTimeNanos);
  if (DEBUG) {
    final long endNanos=System.nanoTime();
    Log.d(TAG,"Frame " + frame + ": Finished, took "+ (endNanos - startNanos) * 0.000001f + " ms, latency " + (startNanos - frameTimeNanos) * 0.000001f + " ms.");
  }
}
