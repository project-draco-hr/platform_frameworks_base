{
  final long start;
  Callback callbacks;
synchronized (mLock) {
    if (!mAnimationScheduled) {
      return;
    }
    mAnimationScheduled=false;
    start=SystemClock.uptimeMillis();
    if (DEBUG) {
      Log.d(TAG,"Performing animation: " + Math.max(0,start - mLastAnimationTime) + " ms have elapsed since previous animation.");
    }
    mLastAnimationTime=start;
    callbacks=mAnimationCallbacks;
    if (callbacks != null) {
      if (callbacks.dueTime > start) {
        callbacks=null;
      }
 else {
        Callback predecessor=callbacks;
        Callback successor=predecessor.next;
        while (successor != null) {
          if (successor.dueTime > start) {
            predecessor.next=null;
            break;
          }
          predecessor=successor;
          successor=successor.next;
        }
        mAnimationCallbacks=successor;
      }
    }
  }
  if (callbacks != null) {
    runCallbacks(callbacks);
synchronized (mLock) {
      recycleCallbacksLocked(callbacks);
    }
  }
  if (DEBUG) {
    Log.d(TAG,"Animation took " + (SystemClock.uptimeMillis() - start) + " ms.");
  }
}
