{
  if (!mDragging) {
    return;
  }
  float tx=x - mWaveCenterX;
  float ty=y - mWaveCenterY;
  float touchRadius=(float)Math.sqrt(dist2(tx,ty));
  final float scale=touchRadius > mOuterRadius ? mOuterRadius / touchRadius : 1.0f;
  float limitX=mWaveCenterX + tx * scale;
  float limitY=mWaveCenterY + ty * scale;
  int activeTarget=-1;
  boolean singleTarget=mTargetDrawables.size() == 1;
  if (singleTarget) {
    float snapRadius=mOuterRadius - mSnapMargin;
    if (touchRadius > snapRadius) {
      activeTarget=0;
      x=limitX;
      y=limitY;
    }
  }
 else {
    float best=Float.MAX_VALUE;
    final float hitRadius2=mHitRadius * mHitRadius;
    for (int i=0; i < mTargetDrawables.size(); i++) {
      TargetDrawable target=mTargetDrawables.get(i);
      float dx=limitX - target.getX();
      float dy=limitY - target.getY();
      float dist2=dx * dx + dy * dy;
      if (target.isValid() && dist2 < hitRadius2 && dist2 < best) {
        activeTarget=i;
        best=dist2;
      }
    }
  }
  if (activeTarget != -1) {
    switchToState(STATE_SNAP,x,y);
    mHandleDrawable.setX(singleTarget ? limitX : mTargetDrawables.get(activeTarget).getX());
    mHandleDrawable.setY(singleTarget ? limitY : mTargetDrawables.get(activeTarget).getY());
    TargetDrawable currentTarget=mTargetDrawables.get(activeTarget);
    if (currentTarget.hasState(TargetDrawable.STATE_FOCUSED)) {
      currentTarget.setState(TargetDrawable.STATE_FOCUSED);
      mHandleDrawable.setAlpha(0.0f);
    }
  }
 else {
    switchToState(STATE_TRACKING,x,y);
    mHandleDrawable.setX(x);
    mHandleDrawable.setY(y);
    mHandleDrawable.setAlpha(1.0f);
  }
  invalidateGlobalRegion(mHandleDrawable);
  if (mActiveTarget != activeTarget && activeTarget != -1) {
    vibrate();
  }
  mActiveTarget=activeTarget;
}
