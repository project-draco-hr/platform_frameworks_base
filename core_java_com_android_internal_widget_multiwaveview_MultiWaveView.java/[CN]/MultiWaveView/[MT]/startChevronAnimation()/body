{
  final float chevronStartDistance=mHandleDrawable.getWidth() * 0.8f;
  final float chevronStopDistance=mOuterRadius * 0.9f / 2.0f;
  final float startScale=0.5f;
  final float endScale=2.0f;
  final int directionCount=mFeedbackCount > 0 ? mChevronDrawables.size() / mFeedbackCount : 0;
  mChevronAnimations.stop();
  for (int direction=0; direction < directionCount; direction++) {
    double angle=2.0 * Math.PI * direction / directionCount;
    final float sx=(float)Math.cos(angle);
    final float sy=0.0f - (float)Math.sin(angle);
    final float[] xrange=new float[]{sx * chevronStartDistance,sx * chevronStopDistance};
    final float[] yrange=new float[]{sy * chevronStartDistance,sy * chevronStopDistance};
    for (int count=0; count < mFeedbackCount; count++) {
      int delay=count * CHEVRON_INCREMENTAL_DELAY;
      final TargetDrawable icon=mChevronDrawables.get(direction * mFeedbackCount + count);
      if (icon == null) {
        continue;
      }
      mChevronAnimations.add(Tweener.to(icon,CHEVRON_ANIMATION_DURATION,"ease",mChevronAnimationInterpolator,"delay",delay,"x",xrange,"y",yrange,"alpha",new float[]{1.0f,0.0f},"scaleX",new float[]{startScale,endScale},"scaleY",new float[]{startScale,endScale},"onUpdate",mUpdateListener));
    }
  }
  mChevronAnimations.start();
}
