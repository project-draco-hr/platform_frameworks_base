{
  final Cipher c;
  try {
    c=Cipher.getInstance(encryptionParams.getEncryptionAlgorithm());
    c.init(Cipher.DECRYPT_MODE,encryptionParams.getEncryptionKey(),encryptionParams.getEncryptionSpec());
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IOException(e);
  }
catch (  NoSuchPaddingException e) {
    throw new IOException(e);
  }
catch (  InvalidKeyException e) {
    throw new IOException(e);
  }
catch (  InvalidAlgorithmParameterException e) {
    throw new IOException(e);
  }
  final long encStart=encryptionParams.getEncryptedDataStart();
  final long end=encryptionParams.getDataEnd();
  if (end < encStart) {
    throw new IOException("end <= encStart");
  }
  final Mac mac=getMacInstance(encryptionParams);
  if (mac != null) {
    final long macStart=encryptionParams.getAuthenticatedDataStart();
    if (macStart >= Integer.MAX_VALUE) {
      throw new IOException("macStart >= Integer.MAX_VALUE");
    }
    final long furtherOffset;
    if (macStart >= 0 && encStart >= 0 && macStart < encStart) {
      final long authenticatedLengthLong=encStart - macStart;
      if (authenticatedLengthLong > MAX_AUTHENTICATED_DATA_SIZE) {
        throw new IOException("authenticated data is too long");
      }
      final int authenticatedLength=(int)authenticatedLengthLong;
      final byte[] authenticatedData=new byte[(int)authenticatedLength];
      Streams.readFully(inStream,authenticatedData,(int)macStart,authenticatedLength);
      mac.update(authenticatedData,0,authenticatedLength);
      furtherOffset=0;
    }
 else {
      if (encStart > 0) {
        furtherOffset=encStart;
      }
 else {
        furtherOffset=0;
      }
    }
    if (furtherOffset >= 0 && end > furtherOffset) {
      inStream=new LimitedLengthInputStream(inStream,furtherOffset,end - encStart);
    }
 else     if (furtherOffset > 0) {
      inStream.skip(furtherOffset);
    }
    mAuthenticatedStream=new MacAuthenticatedInputStream(inStream,mac);
    inStream=mAuthenticatedStream;
  }
 else {
    if (encStart >= 0) {
      if (end > encStart) {
        inStream=new LimitedLengthInputStream(inStream,encStart,end - encStart);
      }
 else {
        inStream.skip(encStart);
      }
    }
  }
  return new CipherInputStream(inStream,c);
}
