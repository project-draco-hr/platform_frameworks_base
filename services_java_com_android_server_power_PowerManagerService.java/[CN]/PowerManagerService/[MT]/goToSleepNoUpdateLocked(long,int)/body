{
  if (DEBUG_SPEW) {
    Slog.d(TAG,"goToSleepNoUpdateLocked: eventTime=" + eventTime + ", reason="+ reason);
  }
  if (eventTime < mLastWakeTime || mWakefulness == WAKEFULNESS_ASLEEP || !mBootCompleted || !mSystemReady) {
    return false;
  }
switch (reason) {
case PowerManager.GO_TO_SLEEP_REASON_DEVICE_ADMIN:
    Slog.i(TAG,"Going to sleep due to device administration policy...");
  break;
case PowerManager.GO_TO_SLEEP_REASON_TIMEOUT:
Slog.i(TAG,"Going to sleep due to screen timeout...");
break;
default :
Slog.i(TAG,"Going to sleep by user request...");
reason=PowerManager.GO_TO_SLEEP_REASON_USER;
break;
}
mLastSleepTime=eventTime;
mDirty|=DIRTY_WAKEFULNESS;
mWakefulness=WAKEFULNESS_ASLEEP;
mNotifier.onGoToSleepStarted(reason);
mSendGoToSleepFinishedNotificationWhenReady=true;
mSendWakeUpFinishedNotificationWhenReady=false;
int numWakeLocksCleared=0;
final int numWakeLocks=mWakeLocks.size();
for (int i=0; i < numWakeLocks; i++) {
final WakeLock wakeLock=mWakeLocks.get(i);
switch (wakeLock.mFlags & PowerManager.WAKE_LOCK_LEVEL_MASK) {
case PowerManager.FULL_WAKE_LOCK:
case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:
case PowerManager.SCREEN_DIM_WAKE_LOCK:
numWakeLocksCleared+=1;
break;
}
}
EventLog.writeEvent(EventLogTags.POWER_SLEEP_REQUESTED,numWakeLocksCleared);
return true;
}
