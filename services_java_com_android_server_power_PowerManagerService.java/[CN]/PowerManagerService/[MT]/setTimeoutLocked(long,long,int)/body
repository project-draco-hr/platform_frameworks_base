{
  long timeoutOverride=originalTimeoutOverride;
  if (mBootCompleted) {
synchronized (mLocks) {
      long when=0;
      if (timeoutOverride <= 0) {
switch (nextState) {
case SCREEN_BRIGHT:
          when=now + mKeylightDelay;
        break;
case SCREEN_DIM:
      if (mDimDelay >= 0) {
        when=now + mDimDelay;
        break;
      }
 else {
        Slog.w(TAG,"mDimDelay=" + mDimDelay + " while trying to dim");
      }
case SCREEN_OFF:
synchronized (mLocks) {
      when=now + mScreenOffDelay;
    }
  break;
default :
when=now;
break;
}
}
 else {
override: {
if (timeoutOverride <= mScreenOffDelay) {
when=now + timeoutOverride;
nextState=SCREEN_OFF;
break override;
}
timeoutOverride-=mScreenOffDelay;
if (mDimDelay >= 0) {
if (timeoutOverride <= mDimDelay) {
when=now + timeoutOverride;
nextState=SCREEN_DIM;
break override;
}
timeoutOverride-=mDimDelay;
}
when=now + timeoutOverride;
nextState=SCREEN_BRIGHT;
}
}
if (mSpew) {
Slog.d(TAG,"setTimeoutLocked now=" + now + " timeoutOverride="+ timeoutOverride+ " nextState="+ nextState+ " when="+ when);
}
mHandler.removeCallbacks(mTimeoutTask);
mTimeoutTask.nextState=nextState;
mTimeoutTask.remainingTimeoutOverride=timeoutOverride > 0 ? (originalTimeoutOverride - timeoutOverride) : -1;
mHandler.postAtTime(mTimeoutTask,when);
mNextTimeout=when;
}
}
}
