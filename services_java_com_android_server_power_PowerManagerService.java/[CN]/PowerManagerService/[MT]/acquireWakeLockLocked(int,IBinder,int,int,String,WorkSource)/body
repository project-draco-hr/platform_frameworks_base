{
  if (mSpew) {
    Slog.d(TAG,"acquireWakeLock flags=0x" + Integer.toHexString(flags) + " tag="+ tag);
  }
  if (ws != null && ws.size() == 0) {
    ws=null;
  }
  int index=mLocks.getIndex(lock);
  WakeLock wl;
  boolean newlock;
  boolean diffsource;
  WorkSource oldsource;
  if (index < 0) {
    wl=new WakeLock(flags,lock,tag,uid,pid);
switch (wl.flags & LOCK_MASK) {
case PowerManager.FULL_WAKE_LOCK:
      if (mUseSoftwareAutoBrightness) {
        wl.minState=SCREEN_BRIGHT;
      }
 else {
        wl.minState=(mKeyboardVisible ? ALL_BRIGHT : SCREEN_BUTTON_BRIGHT);
      }
    break;
case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:
  wl.minState=SCREEN_BRIGHT;
break;
case PowerManager.SCREEN_DIM_WAKE_LOCK:
wl.minState=SCREEN_DIM;
break;
case PowerManager.PARTIAL_WAKE_LOCK:
case PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK:
break;
default :
Slog.e(TAG,"bad wakelock type for lock '" + tag + "' "+ " flags="+ flags);
return;
}
mLocks.addLock(wl);
if (ws != null) {
wl.ws=new WorkSource(ws);
}
newlock=true;
diffsource=false;
oldsource=null;
}
 else {
wl=mLocks.get(index);
newlock=false;
oldsource=wl.ws;
if (oldsource != null) {
if (ws == null) {
wl.ws=null;
diffsource=true;
}
 else {
diffsource=oldsource.diff(ws);
}
}
 else if (ws != null) {
diffsource=true;
}
 else {
diffsource=false;
}
if (diffsource) {
wl.ws=new WorkSource(ws);
}
}
if (isScreenLock(flags)) {
if ((flags & LOCK_MASK) == PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK) {
mProximityWakeLockCount++;
if (mProximityWakeLockCount == 1) {
enableProximityLockLocked();
}
}
 else {
if ((wl.flags & PowerManager.ACQUIRE_CAUSES_WAKEUP) != 0) {
int oldWakeLockState=mWakeLockState;
mWakeLockState=mLocks.reactivateScreenLocksLocked();
if ((mWakeLockState & SCREEN_ON_BIT) != 0 && mProximitySensorActive && mProximityWakeLockCount == 0) {
mProximitySensorActive=false;
}
if (mSpew) {
Slog.d(TAG,"wakeup here mUserState=0x" + Integer.toHexString(mUserState) + " mWakeLockState=0x"+ Integer.toHexString(mWakeLockState)+ " previous wakeLockState=0x"+ Integer.toHexString(oldWakeLockState));
}
}
 else {
if (mSpew) {
Slog.d(TAG,"here mUserState=0x" + Integer.toHexString(mUserState) + " mLocks.gatherState()=0x"+ Integer.toHexString(mLocks.gatherState())+ " mWakeLockState=0x"+ Integer.toHexString(mWakeLockState));
}
mWakeLockState=(mUserState | mWakeLockState) & mLocks.gatherState();
}
setPowerState(mWakeLockState | mUserState);
}
}
 else if ((flags & LOCK_MASK) == PowerManager.PARTIAL_WAKE_LOCK) {
if (newlock) {
mPartialCount++;
if (mPartialCount == 1) {
if (LOG_PARTIAL_WL) EventLog.writeEvent(EventLogTags.POWER_PARTIAL_WAKE_STATE,1,tag);
}
}
nativeAcquireWakeLock(PARTIAL_WAKE_LOCK_ID,PARTIAL_NAME);
}
if (diffsource) {
noteStopWakeLocked(wl,oldsource);
}
if (newlock || diffsource) {
noteStartWakeLocked(wl,ws);
}
}
