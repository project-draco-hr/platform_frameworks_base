{
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG,"retrieveServiceLocked: " + service + " type="+ resolvedType+ " callingUid="+ callingUid);
  userId=mAm.handleIncomingUser(callingPid,callingUid,userId,false,true,"service",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG,"Unable to start service " + service + " U="+ userId+ ": not found");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,"Permission Denial: Accessing service " + r.name + " from pid="+ callingPid+ ", uid="+ callingUid+ " that is not exported from uid "+ r.appInfo.uid);
        return new ServiceLookupResult(null,"not exported from uid " + r.appInfo.uid);
      }
      Slog.w(TAG,"Permission Denial: Accessing service " + r.name + " from pid="+ callingPid+ ", uid="+ callingUid+ " requires "+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}
