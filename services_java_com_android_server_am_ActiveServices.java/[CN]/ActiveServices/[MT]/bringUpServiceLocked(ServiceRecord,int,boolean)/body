{
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,false);
    return true;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return true;
  }
  if (DEBUG_SERVICE)   Slog.v(TAG,"Bringing up " + r + " "+ r.intent);
  mRestartingServices.remove(r);
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(r.packageName,false,r.userId);
  }
 catch (  RemoteException e) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,"Failed trying to unstop package " + r.packageName + ": "+ e);
  }
  final boolean isolated=(r.serviceInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;
  final String procName=r.processName;
  ProcessRecord app;
  if (!isolated) {
    app=mAm.getProcessRecordLocked(procName,r.appInfo.uid);
    if (DEBUG_MU)     Slog.v(TAG_MU,"bringUpServiceLocked: appInfo.uid=" + r.appInfo.uid + " app="+ app);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(r.appInfo.packageName);
        realStartServiceLocked(r,app);
        return true;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,"Exception when starting service " + r.shortName,e);
      }
    }
  }
 else {
    app=r.isolatedProc;
  }
  if (app == null) {
    if ((app=mAm.startProcessLocked(procName,r.appInfo,true,intentFlags,"service",r.name,false,isolated)) == null) {
      Slog.w(TAG,"Unable to launch app " + r.appInfo.packageName + "/"+ r.appInfo.uid+ " for service "+ r.intent.getIntent()+ ": process is bad");
      bringDownServiceLocked(r,true);
      return false;
    }
    if (isolated) {
      r.isolatedProc=app;
    }
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  return true;
}
