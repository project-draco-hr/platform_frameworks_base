{
  final Task task1=new Builder(8,mComponent).setRequiresDeviceIdle(true).setPeriodic(10000L).setRequiresCharging(true).build();
  final Task task2=new Builder(12,mComponent).setMinimumLatency(5000L).setBackoffCriteria(15000L,Task.BackoffPolicy.LINEAR).setOverrideDeadline(30000L).setRequiredNetworkCapabilities(Task.NetworkType.UNMETERED).build();
  final TaskStatus taskStatus1=new TaskStatus(task1,SOME_UID,true);
  final TaskStatus taskStatus2=new TaskStatus(task2,SOME_UID,true);
  mTaskStoreUnderTest.add(taskStatus1);
  mTaskStoreUnderTest.add(taskStatus2);
  Thread.sleep(IO_WAIT);
  mTaskStoreUnderTest.readTaskMapFromDisk(new TaskMapReadFinishedListener(){
    @Override public void onTaskMapReadFinished(    List<TaskStatus> tasks){
      assertEquals("Incorrect # of persisted tasks.",2,tasks.size());
      TaskStatus loaded1=tasks.get(0);
      TaskStatus loaded2=tasks.get(1);
      assertTasksEqual(task1,loaded1.getTask());
      assertTasksEqual(task2,loaded2.getTask());
      compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus1.getEarliestRunTime(),loaded1.getEarliestRunTime());
      compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus1.getLatestRunTimeElapsed(),loaded1.getLatestRunTimeElapsed());
      compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus2.getEarliestRunTime(),loaded2.getEarliestRunTime());
      compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus2.getLatestRunTimeElapsed(),loaded2.getLatestRunTimeElapsed());
    }
  }
);
}
