{
  final JobInfo task1=new Builder(8,mComponent).setRequiresDeviceIdle(true).setPeriodic(10000L).setRequiresCharging(true).setIsPersisted(true).build();
  final JobInfo task2=new Builder(12,mComponent).setMinimumLatency(5000L).setBackoffCriteria(15000L,JobInfo.BackoffPolicy.LINEAR).setOverrideDeadline(30000L).setRequiredNetworkCapabilities(JobInfo.NetworkType.UNMETERED).setIsPersisted(true).build();
  final JobStatus taskStatus1=new JobStatus(task1,SOME_UID);
  final JobStatus taskStatus2=new JobStatus(task2,SOME_UID);
  mTaskStoreUnderTest.add(taskStatus1);
  mTaskStoreUnderTest.add(taskStatus2);
  Thread.sleep(IO_WAIT);
  mTaskStoreUnderTest.readJobMapFromDisk(new JobMapReadFinishedListener(){
    @Override public void onJobMapReadFinished(    List<JobStatus> tasks){
      assertEquals("Incorrect # of persisted tasks.",2,tasks.size());
      JobStatus loaded1=tasks.get(0);
      JobStatus loaded2=tasks.get(1);
      assertTasksEqual(task1,loaded1.getJob());
      assertTasksEqual(task2,loaded2.getJob());
      compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus1.getEarliestRunTime(),loaded1.getEarliestRunTime());
      compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus1.getLatestRunTimeElapsed(),loaded1.getLatestRunTimeElapsed());
      compareTimestampsSubjectToIoLatency("Early run-times not the same after read.",taskStatus2.getEarliestRunTime(),loaded2.getEarliestRunTime());
      compareTimestampsSubjectToIoLatency("Late run-times not the same after read.",taskStatus2.getLatestRunTimeElapsed(),loaded2.getLatestRunTimeElapsed());
    }
  }
);
}
