{
  SSLSocket sslSock=null;
  HttpHost proxyHost=mConnectionManager.getProxyHost();
  if (proxyHost != null) {
    AndroidHttpClientConnection proxyConnection=null;
    Socket proxySock=null;
    try {
      proxySock=new Socket(proxyHost.getHostName(),proxyHost.getPort());
      proxySock.setSoTimeout(60 * 1000);
      proxyConnection=new AndroidHttpClientConnection();
      HttpParams params=new BasicHttpParams();
      HttpConnectionParams.setSocketBufferSize(params,8192);
      proxyConnection.bind(proxySock,params);
    }
 catch (    IOException e) {
      if (proxyConnection != null) {
        proxyConnection.close();
      }
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="failed to establish a connection to the proxy";
      }
      throw new IOException(errorMessage);
    }
    StatusLine statusLine=null;
    int statusCode=0;
    Headers headers=new Headers();
    try {
      BasicHttpRequest proxyReq=new BasicHttpRequest("CONNECT",mHost.toHostString());
      for (      Header h : req.mHttpRequest.getAllHeaders()) {
        String headerName=h.getName().toLowerCase();
        if (headerName.startsWith("proxy") || headerName.equals("keep-alive")) {
          proxyReq.addHeader(h);
        }
      }
      proxyConnection.sendRequestHeader(proxyReq);
      proxyConnection.flush();
      do {
        statusLine=proxyConnection.parseResponseHeader(headers);
        statusCode=statusLine.getStatusCode();
      }
 while (statusCode < HttpStatus.SC_OK);
    }
 catch (    ParseException e) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="failed to send a CONNECT request";
      }
      throw new IOException(errorMessage);
    }
catch (    HttpException e) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="failed to send a CONNECT request";
      }
      throw new IOException(errorMessage);
    }
catch (    IOException e) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="failed to send a CONNECT request";
      }
      throw new IOException(errorMessage);
    }
    if (statusCode == HttpStatus.SC_OK) {
      try {
        sslSock=(SSLSocket)getSocketFactory().createSocket(proxySock,mHost.getHostName(),mHost.getPort(),true);
      }
 catch (      IOException e) {
        if (sslSock != null) {
          sslSock.close();
        }
        String errorMessage=e.getMessage();
        if (errorMessage == null) {
          errorMessage="failed to create an SSL socket";
        }
        throw new IOException(errorMessage);
      }
    }
 else {
      ProtocolVersion version=statusLine.getProtocolVersion();
      req.mEventHandler.status(version.getMajor(),version.getMinor(),statusCode,statusLine.getReasonPhrase());
      req.mEventHandler.headers(headers);
      req.mEventHandler.endData();
      proxyConnection.close();
      return null;
    }
  }
 else {
    try {
      sslSock=(SSLSocket)getSocketFactory().createSocket();
      sslSock.setSoTimeout(SOCKET_TIMEOUT);
      sslSock.connect(new InetSocketAddress(mHost.getHostName(),mHost.getPort()));
    }
 catch (    IOException e) {
      if (sslSock != null) {
        sslSock.close();
      }
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="failed to create an SSL socket";
      }
      throw new IOException(errorMessage);
    }
  }
  SslError error=CertificateChainValidator.getInstance().doHandshakeAndValidateServerCertificates(this,sslSock,mHost.getHostName());
  EventHandler eventHandler=req.getEventHandler();
  eventHandler.certificate(mCertificate);
  if (error != null) {
synchronized (mSuspendLock) {
      mSuspended=true;
    }
    eventHandler.handleSslErrorRequest(error);
synchronized (mSuspendLock) {
      if (mSuspended) {
        try {
          mSuspendLock.wait(10 * 60 * 1000);
          if (mSuspended) {
            mSuspended=false;
            mAborted=true;
            if (HttpLog.LOGV) {
              HttpLog.v("HttpsConnection.openConnection():" + " SSL timeout expired and request was cancelled!!!");
            }
          }
        }
 catch (        InterruptedException e) {
        }
      }
      if (mAborted) {
        sslSock.close();
        throw new SSLConnectionClosedByUserException("connection closed by the user");
      }
    }
  }
  AndroidHttpClientConnection conn=new AndroidHttpClientConnection();
  BasicHttpParams params=new BasicHttpParams();
  params.setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE,8192);
  conn.bind(sslSock,params);
  return conn;
}
