{
  if (!mAppIdleEnabled) {
    return false;
  }
  final int[] runningUserIds;
  try {
    runningUserIds=ActivityManagerNative.getDefault().getRunningUserIds();
    if (checkUserId != UserHandle.USER_ALL && !ArrayUtils.contains(runningUserIds,checkUserId)) {
      return false;
    }
  }
 catch (  RemoteException re) {
    return false;
  }
  final long elapsedRealtime=SystemClock.elapsedRealtime();
  for (int i=0; i < runningUserIds.length; i++) {
    final int userId=runningUserIds[i];
    if (checkUserId != UserHandle.USER_ALL && checkUserId != userId) {
      continue;
    }
    if (DEBUG) {
      Slog.d(TAG,"Checking idle state for user " + userId);
    }
    List<PackageInfo> packages=mPackageManager.getInstalledPackagesAsUser(PackageManager.MATCH_DISABLED_COMPONENTS,userId);
    final int packageCount=packages.size();
    for (int p=0; p < packageCount; p++) {
      final PackageInfo pi=packages.get(p);
      final String packageName=pi.packageName;
      final boolean isIdle=isAppIdleFiltered(packageName,UserHandle.getAppId(pi.applicationInfo.uid),userId,elapsedRealtime);
      mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS,userId,isIdle ? 1 : 0,packageName));
      if (isIdle) {
synchronized (mLock) {
          mAppIdleHistory.setIdle(packageName,userId,elapsedRealtime);
        }
      }
    }
  }
  if (DEBUG) {
    Slog.d(TAG,"checkIdleStates took " + (SystemClock.elapsedRealtime() - elapsedRealtime));
  }
  return true;
}
