{
  if (!mAppIdleEnabled) {
    return;
  }
  final int[] userIds;
  try {
    if (checkUserId == UserHandle.USER_ALL) {
      userIds=ActivityManagerNative.getDefault().getRunningUserIds();
    }
 else {
      userIds=new int[]{checkUserId};
    }
  }
 catch (  RemoteException re) {
    return;
  }
  for (int i=0; i < userIds.length; i++) {
    final int userId=userIds[i];
    List<PackageInfo> packages=getContext().getPackageManager().getInstalledPackages(PackageManager.GET_DISABLED_COMPONENTS | PackageManager.GET_UNINSTALLED_PACKAGES,userId);
synchronized (mLock) {
      final long timeNow=checkAndGetTimeLocked();
      final long screenOnTime=getScreenOnTimeLocked(timeNow);
      UserUsageStatsService service=getUserDataAndInitializeIfNeededLocked(userId,timeNow);
      final int packageCount=packages.size();
      for (int p=0; p < packageCount; p++) {
        final PackageInfo pi=packages.get(p);
        final String packageName=pi.packageName;
        final boolean isIdle=isAppIdleFiltered(packageName,UserHandle.getAppId(pi.applicationInfo.uid),userId,service,timeNow,screenOnTime);
        mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS,userId,isIdle ? 1 : 0,packageName));
        mAppIdleHistory.addEntry(packageName,userId,isIdle,timeNow);
      }
    }
  }
  mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_CHECK_IDLE_STATES,checkUserId,0),mCheckIdleIntervalMillis);
}
