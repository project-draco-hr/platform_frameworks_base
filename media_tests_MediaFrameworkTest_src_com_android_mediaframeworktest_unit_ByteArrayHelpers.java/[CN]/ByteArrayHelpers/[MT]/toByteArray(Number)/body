{
  if (numbers.length == 0) {
    throw new IllegalArgumentException("too few numbers");
  }
  if (VERBOSE)   Log.v(TAG,"toByteArray - input: " + Arrays.toString(numbers));
  ByteBuffer byteBuffer=ByteBuffer.allocate(numbers.length * (Double.SIZE / Byte.SIZE)).order(ByteOrder.nativeOrder());
  for (int i=0; i < numbers.length; ++i) {
    Number value=numbers[i];
    Class<? extends Number> klass=value.getClass();
    if (VERBOSE)     Log.v(TAG,"toByteArray - number " + i + ", class "+ klass);
    if (klass == Integer.class) {
      byteBuffer.putInt((Integer)value);
    }
 else     if (klass == Float.class) {
      byteBuffer.putFloat((Float)value);
    }
 else     if (klass == Double.class) {
      byteBuffer.putDouble((Double)value);
    }
 else     if (klass == Short.class) {
      byteBuffer.putShort((Short)value);
    }
 else     if (klass == Long.class) {
      byteBuffer.putLong((Long)value);
    }
 else     if (klass == Byte.class) {
      byteBuffer.put((Byte)value);
    }
 else {
      throw new IllegalArgumentException("number class invalid; must be wrapper around primitive class");
    }
  }
  if (VERBOSE)   Log.v(TAG,"toByteArray - end of loop");
  if (numbers.length != 0 && byteBuffer.position() < numbers.length) {
    throw new AssertionError(String.format("Had %d numbers, but byte buffer position was only %d",numbers.length,byteBuffer.position()));
  }
  byteBuffer.flip();
  byte[] bytes=new byte[byteBuffer.limit()];
  byteBuffer.get(bytes);
  if (VERBOSE)   Log.v(TAG,"toByteArray - output: " + Arrays.toString(bytes));
  return bytes;
}
