{
  int pos=CharArrayBuffers.setLowercaseIndexOf(buffer,':');
  if (pos == -1) {
    return;
  }
  String name=buffer.substringTrimmed(0,pos);
  if (name.length() == 0) {
    return;
  }
  pos++;
  String val=buffer.substringTrimmed(pos,buffer.length());
  if (HttpLog.LOGV) {
    HttpLog.v("hdr " + buffer.length() + " "+ buffer);
  }
switch (name.hashCode()) {
case HASH_TRANSFER_ENCODING:
    if (name.equals(TRANSFER_ENCODING)) {
      mHeaders[IDX_TRANSFER_ENCODING]=val;
      HeaderElement[] encodings=BasicHeaderValueParser.DEFAULT.parseElements(buffer,new ParserCursor(pos,buffer.length()));
      int len=encodings.length;
      if (HTTP.IDENTITY_CODING.equalsIgnoreCase(val)) {
        transferEncoding=ContentLengthStrategy.IDENTITY;
      }
 else       if ((len > 0) && (HTTP.CHUNK_CODING.equalsIgnoreCase(encodings[len - 1].getName()))) {
        transferEncoding=ContentLengthStrategy.CHUNKED;
      }
 else {
        transferEncoding=ContentLengthStrategy.IDENTITY;
      }
    }
  break;
case HASH_CONTENT_LEN:
if (name.equals(CONTENT_LEN)) {
  mHeaders[IDX_CONTENT_LEN]=val;
  try {
    contentLength=Long.parseLong(val);
  }
 catch (  NumberFormatException e) {
    if (Config.LOGV) {
      Log.v(LOGTAG,"Headers.headers(): error parsing" + " content length: " + buffer.toString());
    }
  }
}
break;
case HASH_CONTENT_TYPE:
if (name.equals(CONTENT_TYPE)) {
mHeaders[IDX_CONTENT_TYPE]=val;
}
break;
case HASH_CONTENT_ENCODING:
if (name.equals(CONTENT_ENCODING)) {
mHeaders[IDX_CONTENT_ENCODING]=val;
}
break;
case HASH_CONN_DIRECTIVE:
if (name.equals(CONN_DIRECTIVE)) {
mHeaders[IDX_CONN_DIRECTIVE]=val;
setConnectionType(buffer,pos);
}
break;
case HASH_LOCATION:
if (name.equals(LOCATION)) {
mHeaders[IDX_LOCATION]=val;
}
break;
case HASH_PROXY_CONNECTION:
if (name.equals(PROXY_CONNECTION)) {
mHeaders[IDX_PROXY_CONNECTION]=val;
setConnectionType(buffer,pos);
}
break;
case HASH_WWW_AUTHENTICATE:
if (name.equals(WWW_AUTHENTICATE)) {
mHeaders[IDX_WWW_AUTHENTICATE]=val;
}
break;
case HASH_PROXY_AUTHENTICATE:
if (name.equals(PROXY_AUTHENTICATE)) {
mHeaders[IDX_PROXY_AUTHENTICATE]=val;
}
break;
case HASH_CONTENT_DISPOSITION:
if (name.equals(CONTENT_DISPOSITION)) {
mHeaders[IDX_CONTENT_DISPOSITION]=val;
}
break;
case HASH_ACCEPT_RANGES:
if (name.equals(ACCEPT_RANGES)) {
mHeaders[IDX_ACCEPT_RANGES]=val;
}
break;
case HASH_EXPIRES:
if (name.equals(EXPIRES)) {
mHeaders[IDX_EXPIRES]=val;
}
break;
case HASH_CACHE_CONTROL:
if (name.equals(CACHE_CONTROL)) {
mHeaders[IDX_CACHE_CONTROL]=val;
}
break;
case HASH_LAST_MODIFIED:
if (name.equals(LAST_MODIFIED)) {
mHeaders[IDX_LAST_MODIFIED]=val;
}
break;
case HASH_ETAG:
if (name.equals(ETAG)) {
mHeaders[IDX_ETAG]=val;
}
break;
case HASH_SET_COOKIE:
if (name.equals(SET_COOKIE)) {
mHeaders[IDX_SET_COOKIE]=val;
cookies.add(val);
}
break;
case HASH_PRAGMA:
if (name.equals(PRAGMA)) {
mHeaders[IDX_PRAGMA]=val;
}
break;
case HASH_REFRESH:
if (name.equals(REFRESH)) {
mHeaders[IDX_REFRESH]=val;
}
break;
default :
mExtraHeaderNames.add(name);
mExtraHeaderValues.add(val);
}
}
