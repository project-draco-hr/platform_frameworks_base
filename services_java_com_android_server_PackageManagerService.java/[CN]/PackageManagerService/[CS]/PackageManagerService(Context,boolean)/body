{
  EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Slog.w(TAG,"**** ro.build.version.sdk not set!");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt="eng".equals(SystemProperties.get("ro.build.type"));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP("android.uid.system",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP("android.uid.phone",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP("android.uid.log",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get("debug.separate_processes");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if ("*".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Slog.w(TAG,"Running with debug.separate_processes: * (ALL)");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(",");
      Slog.w(TAG,"Running with debug.separate_processes: " + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,"data");
      mSecureAppDataDir=new File(dataDir,"secure/data");
      mDrmAppPrivateInstallDir=new File(dataDir,"app-private");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,"misc");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mSecureAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR | SCAN_NO_PATHS;
      if (mNoDexOpt) {
        Slog.w(TAG,"Running ENG build: no pre-dexopt!");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),"framework");
      mDalvikCacheDir=new File(dataDir,"dalvik-cache");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty("java.boot.class.path");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,"Boot class path not found: " + paths[i]);
            }
catch (            IOException e) {
              Slog.w(TAG,"Exception reading boot class path: " + paths[i],e);
            }
          }
        }
 else {
          Slog.w(TAG,"No BOOTCLASSPATH found!");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,"Library not found: " + lib);
            }
catch (            IOException e) {
              Slog.w(TAG,"Exception reading library: " + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + "/framework-res.apk");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(".apk") && !path.endsWith(".jar")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Slog.w(TAG,"Jar not found: " + path);
            }
catch (            IOException e) {
              Slog.w(TAG,"Exception reading jar: " + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith("data@app@") || fn.startsWith("data@app-private@")) {
                Slog.i(TAG,"Pruning dalvik file: " + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode | SCAN_NO_DEX,0);
      mSystemAppDir=new File(Environment.getRootDirectory(),"app");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      mVendorAppDir=new File("/vendor/app");
      mVendorInstallObserver=new AppDirObserver(mVendorAppDir.getPath(),OBSERVER_EVENTS,true);
      mVendorInstallObserver.startWatching();
      scanDirLI(mVendorAppDir,PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR,scanMode,0);
      if (mInstaller != null) {
        if (DEBUG_UPGRADE)         Log.v(TAG,"Running installd update commands");
        mInstaller.moveFiles();
      }
      Iterator<PackageSetting> psit=mSettings.mPackages.values().iterator();
      while (psit.hasNext()) {
        PackageSetting ps=psit.next();
        if ((ps.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0 && !mPackages.containsKey(ps.name) && !mSettings.mDisabledSysPackages.containsKey(ps.name)) {
          psit.remove();
          String msg="System package " + ps.name + " no longer exists; wiping its data";
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            mInstaller.remove(ps.name,true);
          }
        }
      }
      mAppInstallDir=new File(dataDir,"app");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode,0);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,PackageParser.PARSE_FORWARD_LOCK,scanMode,0);
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Slog.i(TAG,"Time to scan packages: " + ((SystemClock.uptimeMillis() - startTime) / 1000f) + " seconds");
      final boolean regrantPermissions=mSettings.mInternalSdkPlatform != mSdkVersion;
      if (regrantPermissions)       Slog.i(TAG,"Platform changed from " + mSettings.mInternalSdkPlatform + " to "+ mSdkVersion+ "; regranting permissions for internal storage");
      mSettings.mInternalSdkPlatform=mSdkVersion;
      updatePermissionsLP(null,null,true,regrantPermissions,regrantPermissions);
      mSettings.writeLP();
      EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}
