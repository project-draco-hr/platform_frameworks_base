{
  File scanFile=new File(pkg.mScanPath);
  if (scanFile == null || pkg.applicationInfo.sourceDir == null || pkg.applicationInfo.publicSourceDir == null) {
    Log.w(TAG," Code and resource paths haven't been set correctly");
    mLastScanError=PackageManager.INSTALL_FAILED_INVALID_APK;
    return null;
  }
  mScanningPath=scanFile;
  if (pkg == null) {
    mLastScanError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  final String pkgName=pkg.applicationInfo.packageName;
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SYSTEM;
  }
  if (pkgName.equals("android")) {
synchronized (mPackages) {
      if (mAndroidApplication != null) {
        Log.w(TAG,"*************************************************");
        Log.w(TAG,"Core android package being redefined.  Skipping.");
        Log.w(TAG," file=" + mScanningPath);
        Log.w(TAG,"*************************************************");
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
      mPlatformPackage=pkg;
      pkg.mVersionCode=mSdkVersion;
      mAndroidApplication=pkg.applicationInfo;
      mResolveActivity.applicationInfo=mAndroidApplication;
      mResolveActivity.name=ResolverActivity.class.getName();
      mResolveActivity.packageName=mAndroidApplication.packageName;
      mResolveActivity.processName=mAndroidApplication.processName;
      mResolveActivity.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
      mResolveActivity.flags=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
      mResolveActivity.theme=com.android.internal.R.style.Theme_Dialog_Alert;
      mResolveActivity.exported=true;
      mResolveActivity.enabled=true;
      mResolveInfo.activityInfo=mResolveActivity;
      mResolveInfo.priority=0;
      mResolveInfo.preferredOrder=0;
      mResolveInfo.match=0;
      mResolveComponentName=new ComponentName(mAndroidApplication.packageName,mResolveActivity.name);
    }
  }
  if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)   Log.d(TAG,"Scanning package " + pkgName);
  if (mPackages.containsKey(pkgName) || mSharedLibraries.containsKey(pkgName)) {
    Log.w(TAG,"*************************************************");
    Log.w(TAG,"Application package " + pkgName + " already installed.  Skipping duplicate.");
    Log.w(TAG,"*************************************************");
    mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
    return null;
  }
  File destCodeFile=new File(pkg.applicationInfo.sourceDir);
  File destResourceFile=new File(pkg.applicationInfo.publicSourceDir);
  SharedUserSetting suid=null;
  PackageSetting pkgSetting=null;
  boolean removeExisting=false;
synchronized (mPackages) {
    if (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null) {
      if (mTmpSharedLibraries == null || mTmpSharedLibraries.length < mSharedLibraries.size()) {
        mTmpSharedLibraries=new String[mSharedLibraries.size()];
      }
      int num=0;
      int N=pkg.usesLibraries != null ? pkg.usesLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesLibraries.get(i));
        if (file == null) {
          Log.e(TAG,"Package " + pkg.packageName + " requires unavailable shared library "+ pkg.usesLibraries.get(i)+ "; failing!");
          mLastScanError=PackageManager.INSTALL_FAILED_MISSING_SHARED_LIBRARY;
          return null;
        }
        mTmpSharedLibraries[num]=file;
        num++;
      }
      N=pkg.usesOptionalLibraries != null ? pkg.usesOptionalLibraries.size() : 0;
      for (int i=0; i < N; i++) {
        String file=mSharedLibraries.get(pkg.usesOptionalLibraries.get(i));
        if (file == null) {
          Log.w(TAG,"Package " + pkg.packageName + " desires unavailable shared library "+ pkg.usesOptionalLibraries.get(i)+ "; ignoring!");
        }
 else {
          mTmpSharedLibraries[num]=file;
          num++;
        }
      }
      if (num > 0) {
        pkg.usesLibraryFiles=new String[num];
        System.arraycopy(mTmpSharedLibraries,0,pkg.usesLibraryFiles,0,num);
      }
      if (pkg.reqFeatures != null) {
        N=pkg.reqFeatures.size();
        for (int i=0; i < N; i++) {
          FeatureInfo fi=pkg.reqFeatures.get(i);
          if ((fi.flags & FeatureInfo.FLAG_REQUIRED) == 0) {
            continue;
          }
          if (fi.name != null) {
            if (mAvailableFeatures.get(fi.name) == null) {
              Log.e(TAG,"Package " + pkg.packageName + " requires unavailable feature "+ fi.name+ "; failing!");
              mLastScanError=PackageManager.INSTALL_FAILED_MISSING_FEATURE;
              return null;
            }
          }
        }
      }
    }
    if (pkg.mSharedUserId != null) {
      suid=mSettings.getSharedUserLP(pkg.mSharedUserId,pkg.applicationInfo.flags,true);
      if (suid == null) {
        Log.w(TAG,"Creating application package " + pkgName + " for shared user failed");
        mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        return null;
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD) {
        Log.d(TAG,"Shared UserID " + pkg.mSharedUserId + " (uid="+ suid.userId+ "): packages="+ suid.packages);
      }
    }
    PackageSetting origPackage=null;
    if (pkg.mOriginalPackage != null) {
      origPackage=mSettings.peekPackageLP(pkg.mOriginalPackage);
      if (origPackage != null) {
        if (!verifyPackageUpdate(origPackage,pkg)) {
          origPackage=null;
        }
 else         if (origPackage.sharedUser != null) {
          if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
            Log.w(TAG,"Unable to migrate data from " + origPackage.name + " to "+ pkg.packageName+ ": old uid "+ origPackage.sharedUser.name+ " differs from "+ pkg.mSharedUserId);
            origPackage=null;
          }
        }
 else {
          if (DEBUG_UPGRADE)           Log.v(TAG,"Migrating data from " + origPackage.name + " to "+ pkg.packageName);
        }
      }
    }
    if (mTransferedPackages.contains(pkg.packageName)) {
      Log.w(TAG,"Package " + pkg.packageName + " was transferred to another, but its .apk remains");
    }
    pkgSetting=mSettings.getPackageLP(pkg,origPackage,suid,destCodeFile,destResourceFile,pkg.applicationInfo.flags,true,false);
    if (pkgSetting == null) {
      Log.w(TAG,"Creating application package " + pkgName + " failed");
      mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      return null;
    }
    if (mSettings.mDisabledSysPackages.get(pkg.packageName) != null) {
      pkg.applicationInfo.flags|=ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
    }
    pkg.applicationInfo.uid=pkgSetting.userId;
    pkg.mExtras=pkgSetting;
    if (pkg.mAdoptPermissions != null) {
      for (int i=pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
        String origName=pkg.mAdoptPermissions.get(i);
        PackageSetting orig=mSettings.peekPackageLP(origName);
        if (orig != null) {
          if (verifyPackageUpdate(orig,pkg)) {
            if (DEBUG_UPGRADE)             Log.v(TAG,"Adopting permissions from " + origName + " to "+ pkg.packageName);
            mSettings.transferPermissions(origName,pkg.packageName);
          }
        }
      }
    }
    if (!verifySignaturesLP(pkgSetting,pkg,parseFlags,(scanMode & SCAN_UPDATE_SIGNATURE) != 0)) {
      if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) == 0) {
        mLastScanError=PackageManager.INSTALL_FAILED_UPDATE_INCOMPATIBLE;
        return null;
      }
      pkgSetting.signatures.mSignatures=pkg.mSignatures;
      if (pkgSetting.sharedUser != null) {
        if (!pkgSetting.sharedUser.signatures.mergeSignatures(pkg.mSignatures,false)) {
          mLastScanError=PackageManager.INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES;
          return null;
        }
      }
      removeExisting=true;
    }
    if ((scanMode & SCAN_NEW_INSTALL) != 0) {
      int N=pkg.providers.size();
      int i;
      for (i=0; i < N; i++) {
        PackageParser.Provider p=pkg.providers.get(i);
        String names[]=p.info.authority.split(";");
        for (int j=0; j < names.length; j++) {
          if (mProviders.containsKey(names[j])) {
            PackageParser.Provider other=mProviders.get(names[j]);
            Log.w(TAG,"Can't install because provider name " + names[j] + " (in package "+ pkg.applicationInfo.packageName+ ") is already used by "+ ((other != null && other.component != null) ? other.component.getPackageName() : "?"));
            mLastScanError=PackageManager.INSTALL_FAILED_CONFLICTING_PROVIDER;
            return null;
          }
        }
      }
    }
  }
  if (removeExisting) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (mInstaller != null) {
      int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
      if (ret != 0) {
        String msg="System package " + pkg.packageName + " could not have data directory erased after signature change.";
        reportSettingsProblem(Log.WARN,msg);
        mLastScanError=PackageManager.INSTALL_FAILED_REPLACE_COULDNT_DELETE;
        return null;
      }
    }
    Log.w(TAG,"System package " + pkg.packageName + " signature changed: existing data removed.");
    mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  }
  long scanFileTime=scanFile.lastModified();
  final boolean forceDex=(scanMode & SCAN_FORCE_DEX) != 0;
  final boolean scanFileNewer=forceDex || scanFileTime != pkgSetting.getTimeStamp();
  pkg.applicationInfo.processName=fixProcessName(pkg.applicationInfo.packageName,pkg.applicationInfo.processName,pkg.applicationInfo.uid);
  File dataPath;
  if (mPlatformPackage == pkg) {
    dataPath=new File(Environment.getDataDirectory(),"system");
    pkg.applicationInfo.dataDir=dataPath.getPath();
  }
 else {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(pkg);
    if (useEncryptedFSDir) {
      dataPath=new File(mSecureAppDataDir,pkgName);
    }
 else {
      dataPath=new File(mAppDataDir,pkgName);
    }
    boolean uidError=false;
    if (dataPath.exists()) {
      mOutPermissions[1]=0;
      FileUtils.getPermissions(dataPath.getPath(),mOutPermissions);
      if (mOutPermissions[1] == pkg.applicationInfo.uid || !Process.supportsProcesses()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        boolean recovered=false;
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
          if (mInstaller != null) {
            int ret=mInstaller.remove(pkgName,useEncryptedFSDir);
            if (ret >= 0) {
              String msg="System package " + pkg.packageName + " has changed from uid: "+ mOutPermissions[1]+ " to "+ pkg.applicationInfo.uid+ "; old data erased";
              reportSettingsProblem(Log.WARN,msg);
              recovered=true;
              ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
              if (ret == -1) {
                msg="System package " + pkg.packageName + " could not have data directory re-created after delete.";
                reportSettingsProblem(Log.WARN,msg);
                mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
                return null;
              }
            }
          }
          if (!recovered) {
            mHasSystemUidErrors=true;
          }
        }
        if (!recovered) {
          pkg.applicationInfo.dataDir="/mismatched_uid/settings_" + pkg.applicationInfo.uid + "/fs_"+ mOutPermissions[1];
          String msg="Package " + pkg.packageName + " has mismatched uid: "+ mOutPermissions[1]+ " on disk, "+ pkg.applicationInfo.uid+ " in settings";
synchronized (mPackages) {
            mSettings.mReadMessages.append(msg);
            mSettings.mReadMessages.append('\n');
            uidError=true;
            if (!pkgSetting.uidError) {
              reportSettingsProblem(Log.ERROR,msg);
            }
          }
        }
      }
      pkg.applicationInfo.dataDir=dataPath.getPath();
    }
 else {
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGV)       Log.v(TAG,"Want this data dir: " + dataPath);
      if (pkgSetting.origPackage != null) {
synchronized (mPackages) {
          String msg="Transfering data from old package " + pkgSetting.origPackage.name + " to new package "+ pkgSetting.name;
          reportSettingsProblem(Log.WARN,msg);
          if (mInstaller != null) {
            int ret=mInstaller.rename(pkgSetting.origPackage.name,pkgName,useEncryptedFSDir);
            if (ret < 0) {
              msg="Error transfering data from old package " + pkgSetting.origPackage.name + " to new package "+ pkgSetting.name;
              reportSettingsProblem(Log.WARN,msg);
            }
          }
          mInstaller.remove(pkgSetting.origPackage.name,useEncryptedFSDir);
          mSettings.removePackageLP(pkgSetting.origPackage.name);
        }
      }
      if (mInstaller != null) {
        int ret=mInstaller.install(pkgName,useEncryptedFSDir,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        if (ret < 0) {
          mLastScanError=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          return null;
        }
      }
 else {
        dataPath.mkdirs();
        if (dataPath.exists()) {
          FileUtils.setPermissions(dataPath.toString(),FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH,pkg.applicationInfo.uid,pkg.applicationInfo.uid);
        }
      }
      if (dataPath.exists()) {
        pkg.applicationInfo.dataDir=dataPath.getPath();
      }
 else {
        Log.w(TAG,"Unable to create data directory: " + dataPath);
        pkg.applicationInfo.dataDir=null;
      }
    }
    pkgSetting.uidError=uidError;
  }
  if (pkgSetting.origPackage != null) {
    mTransferedPackages.add(pkgSetting.origPackage.name);
    pkgSetting.origPackage=null;
  }
  if (mInstaller != null) {
    String path=scanFile.getPath();
    if (scanFileNewer) {
      Log.i(TAG,path + " changed; unpacking");
      int err=cachePackageSharedLibsLI(pkg,dataPath,scanFile);
      if (err != PackageManager.INSTALL_SUCCEEDED) {
        mLastScanError=err;
        return null;
      }
    }
    pkg.mScanPath=path;
    if ((scanMode & SCAN_NO_DEX) == 0) {
      if (performDexOptLI(pkg,forceDex) == DEX_OPT_FAILED) {
        mLastScanError=PackageManager.INSTALL_FAILED_DEXOPT;
        return null;
      }
    }
  }
  if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_FACTORY_TEST;
  }
  if ((scanMode & SCAN_MONITOR) != 0) {
    mAppDirs.put(pkg.mPath,pkg);
  }
  if ((parseFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
    killApplication(pkg.applicationInfo.packageName,pkg.applicationInfo.uid);
  }
synchronized (mPackages) {
    mSettings.insertPackageSettingLP(pkgSetting,pkg);
    mPackages.put(pkg.applicationInfo.packageName,pkg);
    mSettings.mPackagesToBeCleaned.remove(pkgName);
    int N=pkg.providers.size();
    StringBuilder r=null;
    int i;
    for (i=0; i < N; i++) {
      PackageParser.Provider p=pkg.providers.get(i);
      p.info.processName=fixProcessName(pkg.applicationInfo.processName,p.info.processName,pkg.applicationInfo.uid);
      mProvidersByComponent.put(new ComponentName(p.info.packageName,p.info.name),p);
      p.syncable=p.info.isSyncable;
      String names[]=p.info.authority.split(";");
      p.info.authority=null;
      for (int j=0; j < names.length; j++) {
        if (j == 1 && p.syncable) {
          p=new PackageParser.Provider(p);
          p.syncable=false;
        }
        if (!mProviders.containsKey(names[j])) {
          mProviders.put(names[j],p);
          if (p.info.authority == null) {
            p.info.authority=names[j];
          }
 else {
            p.info.authority=p.info.authority + ";" + names[j];
          }
          if ((parseFlags & PackageParser.PARSE_CHATTY) != 0 && Config.LOGD)           Log.d(TAG,"Registered content provider: " + names[j] + ", className = "+ p.info.name+ ", isSyncable = "+ p.info.isSyncable);
        }
 else {
          PackageParser.Provider other=mProviders.get(names[j]);
          Log.w(TAG,"Skipping provider name " + names[j] + " (in package "+ pkg.applicationInfo.packageName+ "): name already used by "+ ((other != null && other.component != null) ? other.component.getPackageName() : "?"));
        }
      }
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(p.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Providers: " + r);
    }
    N=pkg.services.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Service s=pkg.services.get(i);
      s.info.processName=fixProcessName(pkg.applicationInfo.processName,s.info.processName,pkg.applicationInfo.uid);
      mServices.addService(s);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(s.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Services: " + r);
    }
    N=pkg.receivers.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.receivers.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mReceivers.addActivity(a,"receiver");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Receivers: " + r);
    }
    N=pkg.activities.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Activity a=pkg.activities.get(i);
      a.info.processName=fixProcessName(pkg.applicationInfo.processName,a.info.processName,pkg.applicationInfo.uid);
      mActivities.addActivity(a,"activity");
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Activities: " + r);
    }
    N=pkg.permissionGroups.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.PermissionGroup pg=pkg.permissionGroups.get(i);
      PackageParser.PermissionGroup cur=mPermissionGroups.get(pg.info.name);
      if (cur == null) {
        mPermissionGroups.put(pg.info.name,pg);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append(pg.info.name);
        }
      }
 else {
        Log.w(TAG,"Permission group " + pg.info.name + " from package "+ pg.info.packageName+ " ignored: original from "+ cur.info.packageName);
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append("DUP:");
          r.append(pg.info.name);
        }
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Permission Groups: " + r);
    }
    N=pkg.permissions.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Permission p=pkg.permissions.get(i);
      HashMap<String,BasePermission> permissionMap=p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
      p.group=mPermissionGroups.get(p.info.group);
      if (p.info.group == null || p.group != null) {
        BasePermission bp=permissionMap.get(p.info.name);
        if (bp == null) {
          bp=new BasePermission(p.info.name,p.info.packageName,BasePermission.TYPE_NORMAL);
          permissionMap.put(p.info.name,bp);
        }
        if (bp.perm == null) {
          if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
            BasePermission tree=findPermissionTreeLP(p.info.name);
            if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
              bp.perm=p;
              bp.uid=pkg.applicationInfo.uid;
              if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                  r=new StringBuilder(256);
                }
 else {
                  r.append(' ');
                }
                r.append(p.info.name);
              }
            }
 else {
              Log.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: base tree "+ tree.name+ " is from package "+ tree.sourcePackage);
            }
          }
 else {
            Log.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: original from "+ bp.sourcePackage);
          }
        }
 else         if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
          if (r == null) {
            r=new StringBuilder(256);
          }
 else {
            r.append(' ');
          }
          r.append("DUP:");
          r.append(p.info.name);
        }
      }
 else {
        Log.w(TAG,"Permission " + p.info.name + " from package "+ p.info.packageName+ " ignored: no group "+ p.group);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Permissions: " + r);
    }
    N=pkg.instrumentation.size();
    r=null;
    for (i=0; i < N; i++) {
      PackageParser.Instrumentation a=pkg.instrumentation.get(i);
      a.info.packageName=pkg.applicationInfo.packageName;
      a.info.sourceDir=pkg.applicationInfo.sourceDir;
      a.info.publicSourceDir=pkg.applicationInfo.publicSourceDir;
      a.info.dataDir=pkg.applicationInfo.dataDir;
      mInstrumentation.put(a.component,a);
      if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
        if (r == null) {
          r=new StringBuilder(256);
        }
 else {
          r.append(' ');
        }
        r.append(a.info.name);
      }
    }
    if (r != null) {
      if (Config.LOGD)       Log.d(TAG,"  Instrumentation: " + r);
    }
    if (pkg.protectedBroadcasts != null) {
      N=pkg.protectedBroadcasts.size();
      for (i=0; i < N; i++) {
        mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
      }
    }
    pkgSetting.setTimeStamp(scanFileTime);
  }
  return pkg;
}
