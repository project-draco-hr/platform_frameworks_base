{
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  parseFlags|=mDefParseFlags;
  PackageParser pp=new PackageParser(scanFile.getPath());
  pp.setSeparateProcesses(mSeparateProcesses);
  final PackageParser.Package pkg=pp.parsePackage(scanFile,scanFile.getPath(),mMetrics,parseFlags);
  if (pkg == null) {
    mLastScanError=pp.getParseError();
    return null;
  }
  PackageSetting ps;
  PackageSetting updatedPkg;
synchronized (mPackages) {
    ps=mSettings.peekPackageLP(pkg.packageName);
    updatedPkg=mSettings.mDisabledSysPackages.get(pkg.packageName);
  }
  if (!collectCertificatesLI(pp,ps,pkg,scanFile,parseFlags)) {
    Log.i(TAG,"Failed verifying certificates for package:" + pkg.packageName);
    return null;
  }
  if (updatedPkg != null) {
    parseFlags|=PackageParser.PARSE_IS_SYSTEM;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    if ((ps != null) && (!ps.codePath.equals(scanFile))) {
      if (pkg.mVersionCode < ps.versionCode) {
        Log.w(TAG,"Package:" + pkg.packageName + " has been updated. Ignoring the one from path:"+ scanFile);
        mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
        return null;
      }
 else {
synchronized (mPackages) {
          mPackages.remove(ps.name);
        }
        deletePackageResourcesLI(ps.name,ps.codePathString,ps.resourcePathString);
        mSettings.enableSystemPackageLP(ps.name);
      }
    }
  }
  if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
    parseFlags|=PackageParser.PARSE_FORWARD_LOCK;
  }
  return scanPackageLI(pkg,parseFlags,scanMode | SCAN_UPDATE_SIGNATURE);
}
