{
  final PackageRemovedInfo info=new PackageRemovedInfo();
  final boolean res;
  IDevicePolicyManager dpm=IDevicePolicyManager.Stub.asInterface(ServiceManager.getService(Context.DEVICE_POLICY_SERVICE));
  try {
    if (dpm != null && dpm.packageHasActiveAdmins(packageName)) {
      Slog.w(TAG,"Not removing package " + packageName + ": has active device admin");
      return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
  }
 catch (  RemoteException e) {
  }
synchronized (mInstallLock) {
    res=deletePackageLI(packageName,deleteCodeAndResources,flags | REMOVE_CHATTY,info,true);
  }
  if (res && sendBroadCast) {
    boolean systemUpdate=info.isRemovedPackageSystemUpdate;
    info.sendBroadcast(deleteCodeAndResources,systemUpdate);
    if (systemUpdate) {
      Bundle extras=new Bundle(1);
      extras.putInt(Intent.EXTRA_UID,info.removedUid >= 0 ? info.removedUid : info.uid);
      extras.putBoolean(Intent.EXTRA_REPLACING,true);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,packageName,extras,null,null);
      sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,packageName,extras,null,null);
      sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,null,null,packageName,null);
    }
  }
  Runtime.getRuntime().gc();
  if (info.args != null) {
synchronized (mInstallLock) {
      info.args.doPostDeleteLI(deleteCodeAndResources);
    }
  }
  return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}
