{
  File tmpPackageFile=null;
  String pkgName=null;
  boolean forwardLocked=false;
  boolean replacingExistingPackage=false;
  PackageInstalledInfo res=new PackageInstalledInfo();
  res.returnCode=PackageManager.INSTALL_SUCCEEDED;
  res.uid=-1;
  res.pkg=null;
  res.removedInfo=new PackageRemovedInfo();
  main_flow:   try {
    tmpPackageFile=createTempPackageFile();
    if (tmpPackageFile == null) {
      res.returnCode=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
      break main_flow;
    }
    tmpPackageFile.deleteOnExit();
    if (pPackageURI.getScheme().equals("file")) {
      final File srcPackageFile=new File(pPackageURI.getPath());
      if (!FileUtils.copyFile(srcPackageFile,tmpPackageFile)) {
        Log.e(TAG,"Couldn't copy package file to temp file.");
        res.returnCode=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        break main_flow;
      }
    }
 else     if (pPackageURI.getScheme().equals("content")) {
      ParcelFileDescriptor fd;
      try {
        fd=mContext.getContentResolver().openFileDescriptor(pPackageURI,"r");
      }
 catch (      FileNotFoundException e) {
        Log.e(TAG,"Couldn't open file descriptor from download service.");
        res.returnCode=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        break main_flow;
      }
      if (fd == null) {
        Log.e(TAG,"Couldn't open file descriptor from download service (null).");
        res.returnCode=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        break main_flow;
      }
      if (Config.LOGV) {
        Log.v(TAG,"Opened file descriptor from download service.");
      }
      ParcelFileDescriptor.AutoCloseInputStream dlStream=new ParcelFileDescriptor.AutoCloseInputStream(fd);
      if (!FileUtils.copyToFile(dlStream,tmpPackageFile)) {
        Log.e(TAG,"Couldn't copy package stream to temp file.");
        res.returnCode=PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
        break main_flow;
      }
    }
 else {
      Log.e(TAG,"Package URI is not 'file:' or 'content:' - " + pPackageURI);
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_URI;
      break main_flow;
    }
    pkgName=PackageParser.parsePackageName(tmpPackageFile.getAbsolutePath(),0);
    if (pkgName == null) {
      Log.e(TAG,"Couldn't find a package name in : " + tmpPackageFile);
      res.returnCode=PackageManager.INSTALL_FAILED_INVALID_APK;
      break main_flow;
    }
    res.name=pkgName;
    final String pkgFileName=pkgName + ".apk";
    final File destDir=((pFlags & PackageManager.FORWARD_LOCK_PACKAGE) != 0) ? mDrmAppPrivateInstallDir : mAppInstallDir;
    final File destPackageFile=new File(destDir,pkgFileName);
    final String destFilePath=destPackageFile.getAbsolutePath();
    File destResourceFile;
    if ((pFlags & PackageManager.FORWARD_LOCK_PACKAGE) != 0) {
      final String publicZipFileName=pkgName + ".zip";
      destResourceFile=new File(mAppInstallDir,publicZipFileName);
      forwardLocked=true;
    }
 else {
      destResourceFile=destPackageFile;
    }
    int parseFlags=PackageParser.PARSE_CHATTY;
    parseFlags|=mDefParseFlags;
    PackageParser pp=new PackageParser(tmpPackageFile.getPath());
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setSdkVersion(mSdkVersion,mSdkCodename);
    final PackageParser.Package pkg=pp.parsePackage(tmpPackageFile,destPackageFile.getAbsolutePath(),mMetrics,parseFlags);
    if (pkg == null) {
      res.returnCode=pp.getParseError();
      break main_flow;
    }
    if (GET_CERTIFICATES && !pp.collectCertificates(pkg,parseFlags)) {
      res.returnCode=pp.getParseError();
      break main_flow;
    }
synchronized (mPackages) {
      if ((pFlags & PackageManager.REPLACE_EXISTING_PACKAGE) != 0 && mPackages.containsKey(pkgName)) {
        replacingExistingPackage=true;
      }
    }
    if (replacingExistingPackage) {
      replacePackageLI(pkgName,tmpPackageFile,destFilePath,destPackageFile,destResourceFile,pkg,forwardLocked,newInstall,installerPackageName,res);
    }
 else {
      installNewPackageLI(pkgName,tmpPackageFile,destFilePath,destPackageFile,destResourceFile,pkg,forwardLocked,newInstall,installerPackageName,res);
    }
  }
  finally {
    if (tmpPackageFile != null && tmpPackageFile.exists()) {
      tmpPackageFile.delete();
    }
  }
  return res;
}
