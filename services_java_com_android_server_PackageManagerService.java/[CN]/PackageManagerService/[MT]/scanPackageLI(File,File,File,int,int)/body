{
  mLastScanError=PackageManager.INSTALL_SUCCEEDED;
  parseFlags|=mDefParseFlags;
  PackageParser pp=new PackageParser(scanFile.getPath());
  pp.setSeparateProcesses(mSeparateProcesses);
  pp.setSdkVersion(mSdkVersion);
  final PackageParser.Package pkg=pp.parsePackage(scanFile,destCodeFile.getAbsolutePath(),mMetrics,parseFlags);
  if (pkg == null) {
    mLastScanError=pp.getParseError();
    return null;
  }
  PackageSetting ps;
  PackageSetting updatedPkg;
synchronized (mPackages) {
    ps=mSettings.peekPackageLP(pkg.packageName,scanFile.toString());
    updatedPkg=mSettings.mDisabledSysPackages.get(pkg.packageName);
  }
  if (updatedPkg != null) {
    parseFlags|=PackageParser.PARSE_IS_SYSTEM;
  }
  if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
    if ((updatedPkg != null) && (ps == null)) {
      Log.w(TAG,"Package:" + pkg.packageName + " has been updated. Ignoring the one from path:"+ scanFile);
      mLastScanError=PackageManager.INSTALL_FAILED_DUPLICATE_PACKAGE;
      return null;
    }
  }
  if (!collectCertificatesLI(pp,ps,pkg,scanFile,parseFlags)) {
    Log.i(TAG,"Failed verifying certificates for package:" + pkg.packageName);
    return null;
  }
  if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
    scanMode|=SCAN_FORWARD_LOCKED;
  }
  return scanPackageLI(scanFile,destCodeFile,destResourceFile,pkg,parseFlags,scanMode | SCAN_UPDATE_SIGNATURE);
}
