{
  FileInputStream str=null;
  if (mBackupSettingsFilename.exists()) {
    try {
      str=new FileInputStream(mBackupSettingsFilename);
      mReadMessages.append("Reading from backup settings file\n");
      reportSettingsProblem(Log.INFO,"Need to read from backup settings file");
      if (mSettingsFilename.exists()) {
        Slog.w(TAG,"Cleaning up settings file " + mSettingsFilename);
        mSettingsFilename.delete();
      }
    }
 catch (    java.io.IOException e) {
    }
  }
  mPastSignatures.clear();
  try {
    if (str == null) {
      if (!mSettingsFilename.exists()) {
        mReadMessages.append("No settings file found\n");
        reportSettingsProblem(Log.INFO,"No settings file; creating initial state");
        return false;
      }
      str=new FileInputStream(mSettingsFilename);
    }
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(str,null);
    int type;
    while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
      ;
    }
    if (type != XmlPullParser.START_TAG) {
      mReadMessages.append("No start tag found in settings file\n");
      reportSettingsProblem(Log.WARN,"No start tag found in package manager settings");
      Log.wtf(TAG,"No start tag found in package manager settings");
      return false;
    }
    int outerDepth=parser.getDepth();
    while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
      if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
        continue;
      }
      String tagName=parser.getName();
      if (tagName.equals("package")) {
        readPackageLP(parser);
      }
 else       if (tagName.equals("permissions")) {
        readPermissionsLP(mPermissions,parser);
      }
 else       if (tagName.equals("permission-trees")) {
        readPermissionsLP(mPermissionTrees,parser);
      }
 else       if (tagName.equals("shared-user")) {
        readSharedUserLP(parser);
      }
 else       if (tagName.equals("preferred-packages")) {
      }
 else       if (tagName.equals("preferred-activities")) {
        readPreferredActivitiesLP(parser);
      }
 else       if (tagName.equals("updated-package")) {
        readDisabledSysPackageLP(parser);
      }
 else       if (tagName.equals("cleaning-package")) {
        String name=parser.getAttributeValue(null,"name");
        if (name != null) {
          mPackagesToBeCleaned.add(name);
        }
      }
 else       if (tagName.equals("renamed-package")) {
        String nname=parser.getAttributeValue(null,"new");
        String oname=parser.getAttributeValue(null,"old");
        if (nname != null && oname != null) {
          mRenamedPackages.put(nname,oname);
        }
      }
 else       if (tagName.equals("last-platform-version")) {
        mInternalSdkPlatform=mExternalSdkPlatform=0;
        try {
          String internal=parser.getAttributeValue(null,"internal");
          if (internal != null) {
            mInternalSdkPlatform=Integer.parseInt(internal);
          }
          String external=parser.getAttributeValue(null,"external");
          if (external != null) {
            mExternalSdkPlatform=Integer.parseInt(external);
          }
        }
 catch (        NumberFormatException e) {
        }
      }
 else {
        Slog.w(TAG,"Unknown element under <packages>: " + parser.getName());
        XmlUtils.skipCurrentTag(parser);
      }
    }
    str.close();
  }
 catch (  XmlPullParserException e) {
    mReadMessages.append("Error reading: " + e.toString());
    reportSettingsProblem(Log.ERROR,"Error reading settings: " + e);
    Log.wtf(TAG,"Error reading package manager settings",e);
  }
catch (  java.io.IOException e) {
    mReadMessages.append("Error reading: " + e.toString());
    reportSettingsProblem(Log.ERROR,"Error reading settings: " + e);
    Log.wtf(TAG,"Error reading package manager settings",e);
  }
  int N=mPendingPackages.size();
  for (int i=0; i < N; i++) {
    final PendingPackage pp=mPendingPackages.get(i);
    Object idObj=getUserIdLP(pp.sharedId);
    if (idObj != null && idObj instanceof SharedUserSetting) {
      PackageSetting p=getPackageLP(pp.name,null,pp.realName,(SharedUserSetting)idObj,pp.codePath,pp.resourcePath,pp.nativeLibraryPathString,pp.versionCode,pp.pkgFlags,true,true);
      if (p == null) {
        reportSettingsProblem(Log.WARN,"Unable to create application package for " + pp.name);
        continue;
      }
      p.copyFrom(pp);
    }
 else     if (idObj != null) {
      String msg="Bad package setting: package " + pp.name + " has shared uid "+ pp.sharedId+ " that is not a shared uid\n";
      mReadMessages.append(msg);
      reportSettingsProblem(Log.ERROR,msg);
    }
 else {
      String msg="Bad package setting: package " + pp.name + " has shared uid "+ pp.sharedId+ " that is not defined\n";
      mReadMessages.append(msg);
      reportSettingsProblem(Log.ERROR,msg);
    }
  }
  mPendingPackages.clear();
  final Iterator<PackageSetting> disabledIt=mDisabledSysPackages.values().iterator();
  while (disabledIt.hasNext()) {
    final PackageSetting disabledPs=disabledIt.next();
    final Object id=getUserIdLP(disabledPs.userId);
    if (id != null && id instanceof SharedUserSetting) {
      disabledPs.sharedUser=(SharedUserSetting)id;
    }
  }
  readStoppedLP();
  mReadMessages.append("Read completed successfully: " + mPackages.size() + " packages, "+ mSharedUsers.size()+ " shared uids\n");
  return true;
}
