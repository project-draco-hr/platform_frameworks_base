{
switch (msg.what) {
case INIT_COPY:
{
      HandlerParams params=(HandlerParams)msg.obj;
      Intent service=new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
      if (mContainerService != null) {
        params.handleStartCopy(mContainerService);
      }
 else {
        if (mContext.bindService(service,mDefContainerConn,Context.BIND_AUTO_CREATE)) {
          mPendingInstalls.add(params);
        }
 else {
          Log.e(TAG,"Failed to bind to media container service");
          params.handleServiceError();
        }
      }
      break;
    }
case MCS_BOUND:
{
    if (msg.obj != null) {
      mContainerService=(IMediaContainerService)msg.obj;
    }
    if (mPendingInstalls.size() > 0) {
      HandlerParams params=mPendingInstalls.remove(0);
      if (params != null) {
        params.handleStartCopy(mContainerService);
      }
    }
    break;
  }
case MCS_UNBIND:
{
  if (mPendingInstalls.size() == 0) {
    mContext.unbindService(mDefContainerConn);
    mContainerService=null;
  }
  break;
}
case SEND_PENDING_BROADCAST:
{
String packages[];
ArrayList components[];
int size=0;
int uids[];
synchronized (mPackages) {
  if (mPendingBroadcasts == null) {
    return;
  }
  size=mPendingBroadcasts.size();
  if (size <= 0) {
    return;
  }
  packages=new String[size];
  components=new ArrayList[size];
  uids=new int[size];
  Iterator<HashMap.Entry<String,ArrayList<String>>> it=mPendingBroadcasts.entrySet().iterator();
  int i=0;
  while (it.hasNext() && i < size) {
    HashMap.Entry<String,ArrayList<String>> ent=it.next();
    packages[i]=ent.getKey();
    components[i]=ent.getValue();
    PackageSetting ps=mSettings.mPackages.get(ent.getKey());
    uids[i]=(ps != null) ? ps.userId : -1;
    i++;
  }
  size=i;
  mPendingBroadcasts.clear();
}
for (int i=0; i < size; i++) {
  sendPackageChangedBroadcast(packages[i],true,(ArrayList<String>)components[i],uids[i]);
}
break;
}
case START_CLEANING_PACKAGE:
{
String packageName=(String)msg.obj;
synchronized (mPackages) {
if (!mSettings.mPackagesToBeCleaned.contains(packageName)) {
  mSettings.mPackagesToBeCleaned.add(packageName);
}
}
startCleaningPackages();
}
break;
case POST_INSTALL:
{
if (DEBUG_INSTALL) Log.v(TAG,"Handling post-install for " + msg.arg1);
PostInstallData data=mRunningInstalls.get(msg.arg1);
mRunningInstalls.delete(msg.arg1);
if (data != null) {
InstallArgs args=data.args;
PackageInstalledInfo res=data.res;
if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
res.removedInfo.sendBroadcast(false,true);
Bundle extras=new Bundle(1);
extras.putInt(Intent.EXTRA_UID,res.uid);
final boolean update=res.removedInfo.removedPackage != null;
if (update) {
extras.putBoolean(Intent.EXTRA_REPLACING,true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,res.pkg.applicationInfo.packageName,extras);
if (update) {
sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,res.pkg.applicationInfo.packageName,extras);
}
if (res.removedInfo.args != null) {
synchronized (mInstallLock) {
  res.removedInfo.args.doPostDeleteLI(true);
}
}
}
Runtime.getRuntime().gc();
if (args.observer != null) {
try {
args.observer.packageInstalled(res.name,res.returnCode);
}
 catch (RemoteException e) {
Log.i(TAG,"Observer no longer exists.");
}
}
}
 else {
Log.e(TAG,"Bogus post-install token " + msg.arg1);
}
}
break;
}
}
