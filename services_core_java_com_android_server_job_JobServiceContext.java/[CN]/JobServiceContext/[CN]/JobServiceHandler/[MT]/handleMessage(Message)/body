{
switch (message.what) {
case MSG_SERVICE_BOUND:
    removeOpTimeOut();
  handleServiceBoundH();
break;
case MSG_CALLBACK:
if (DEBUG) {
Slog.d(TAG,"MSG_CALLBACK of : " + mRunningJob + " v:"+ VERB_STRINGS[mVerb]);
}
removeOpTimeOut();
if (mVerb == VERB_STARTING) {
final boolean workOngoing=message.arg2 == 1;
handleStartedH(workOngoing);
}
 else if (mVerb == VERB_EXECUTING || mVerb == VERB_STOPPING) {
final boolean reschedule=message.arg2 == 1;
handleFinishedH(reschedule);
}
 else {
if (DEBUG) {
Slog.d(TAG,"Unrecognised callback: " + mRunningJob);
}
}
break;
case MSG_CANCEL:
if (mVerb == VERB_FINISHED) {
if (DEBUG) {
Slog.d(TAG,"Trying to process cancel for torn-down context, ignoring.");
}
return;
}
mParams.setStopReason(message.arg1);
if (message.arg1 == JobParameters.REASON_PREEMPT) {
mPreferredUid=mRunningJob != null ? mRunningJob.getUid() : NO_PREFERRED_UID;
}
handleCancelH();
break;
case MSG_TIMEOUT:
handleOpTimeoutH();
break;
case MSG_SHUTDOWN_EXECUTION:
closeAndCleanupJobH(true);
break;
default :
Slog.e(TAG,"Unrecognised message: " + message);
}
}
