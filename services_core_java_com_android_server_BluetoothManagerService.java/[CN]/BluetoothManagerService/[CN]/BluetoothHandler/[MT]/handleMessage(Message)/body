{
  if (DBG)   Log.d(TAG,"Message: " + msg.what);
switch (msg.what) {
case MESSAGE_GET_NAME_AND_ADDRESS:
    if (DBG)     Log.d(TAG,"MESSAGE_GET_NAME_AND_ADDRESS");
  try {
    mBluetoothLock.writeLock().lock();
    if ((mBluetooth == null) && (!mBinding)) {
      if (DBG)       Log.d(TAG,"Binding to service to get name and address");
      mConnection.setGetNameAddressOnly(true);
      Message timeoutMsg=mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
      mHandler.sendMessageDelayed(timeoutMsg,TIMEOUT_BIND_MS);
      Intent i=new Intent(IBluetooth.class.getName());
      if (!doBind(i,mConnection,Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT,UserHandle.CURRENT)) {
        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
      }
 else {
        mBinding=true;
      }
    }
 else {
      Message saveMsg=mHandler.obtainMessage(MESSAGE_SAVE_NAME_AND_ADDRESS);
      saveMsg.arg1=0;
      if (mBluetooth != null) {
        mHandler.sendMessage(saveMsg);
      }
 else {
        mHandler.sendMessageDelayed(saveMsg,TIMEOUT_SAVE_MS);
      }
    }
  }
  finally {
    mBluetoothLock.writeLock().unlock();
  }
break;
case MESSAGE_SAVE_NAME_AND_ADDRESS:
{
boolean unbind=false;
if (DBG) Log.d(TAG,"MESSAGE_SAVE_NAME_AND_ADDRESS");
try {
  mBluetoothLock.readLock().lock();
  if (!mEnable && mBluetooth != null && !mConnection.isGetNameAddressOnly()) {
    mBluetooth.enable();
  }
}
 catch (RemoteException e) {
  Log.e(TAG,"Unable to call enable()",e);
}
 finally {
  mBluetoothLock.readLock().unlock();
}
if (mBluetooth != null && !mConnection.isGetNameAddressOnly()) waitForOnOff(true,false);
try {
  mBluetoothLock.writeLock().lock();
  if (mBluetooth != null) {
    String name=null;
    String address=null;
    try {
      name=mBluetooth.getName();
      address=mBluetooth.getAddress();
    }
 catch (    RemoteException re) {
      Log.e(TAG,"",re);
    }
    if (name != null && address != null) {
      storeNameAndAddress(name,address);
      if (mConnection.isGetNameAddressOnly()) {
        unbind=true;
      }
    }
 else {
      if (msg.arg1 < MAX_SAVE_RETRIES) {
        Message retryMsg=mHandler.obtainMessage(MESSAGE_SAVE_NAME_AND_ADDRESS);
        retryMsg.arg1=1 + msg.arg1;
        if (DBG)         Log.d(TAG,"Retrying name/address remote retrieval and save.....Retry count =" + retryMsg.arg1);
        mHandler.sendMessageDelayed(retryMsg,TIMEOUT_SAVE_MS);
      }
 else {
        Log.w(TAG,"Maximum name/address remote retrieval retry exceeded");
        if (mConnection.isGetNameAddressOnly()) {
          unbind=true;
        }
      }
    }
    if (!mEnable && !mConnection.isGetNameAddressOnly()) {
      try {
        mBluetooth.disable();
      }
 catch (      RemoteException e) {
        Log.e(TAG,"Unable to call disable()",e);
      }
    }
  }
 else {
    Message getMsg=mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
    mHandler.sendMessage(getMsg);
  }
}
  finally {
  mBluetoothLock.writeLock().unlock();
}
if (!mEnable && mBluetooth != null && !mConnection.isGetNameAddressOnly()) {
  waitForOnOff(false,true);
}
if (unbind) {
  unbindAndFinish();
}
break;
}
case MESSAGE_ENABLE:
if (DBG) {
Log.d(TAG,"MESSAGE_ENABLE: mBluetooth = " + mBluetooth);
}
mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
mEnable=true;
if (mBluetooth == null) {
handleEnable(msg.arg1 == 1);
}
 else {
waitForOnOff(false,true);
mQuietEnable=(msg.arg1 == 1);
Message restartMsg=mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
mHandler.sendMessageDelayed(restartMsg,2 * SERVICE_RESTART_TIME_MS);
}
break;
case MESSAGE_DISABLE:
mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
if (mEnable && mBluetooth != null) {
waitForOnOff(true,false);
mEnable=false;
handleDisable();
waitForOnOff(false,false);
}
 else {
mEnable=false;
handleDisable();
}
break;
case MESSAGE_REGISTER_ADAPTER:
{
IBluetoothManagerCallback callback=(IBluetoothManagerCallback)msg.obj;
boolean added=mCallbacks.register(callback);
Log.d(TAG,"Added callback: " + (callback == null ? "null" : callback) + ":"+ added);
}
break;
case MESSAGE_UNREGISTER_ADAPTER:
{
IBluetoothManagerCallback callback=(IBluetoothManagerCallback)msg.obj;
boolean removed=mCallbacks.unregister(callback);
Log.d(TAG,"Removed callback: " + (callback == null ? "null" : callback) + ":"+ removed);
break;
}
case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
{
IBluetoothStateChangeCallback callback=(IBluetoothStateChangeCallback)msg.obj;
if (callback != null) {
mStateChangeCallbacks.register(callback);
}
break;
}
case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
{
IBluetoothStateChangeCallback callback=(IBluetoothStateChangeCallback)msg.obj;
if (callback != null) {
mStateChangeCallbacks.unregister(callback);
}
break;
}
case MESSAGE_ADD_PROXY_DELAYED:
{
ProfileServiceConnections psc=mProfileServices.get(new Integer(msg.arg1));
if (psc == null) {
break;
}
IBluetoothProfileServiceConnection proxy=(IBluetoothProfileServiceConnection)msg.obj;
psc.addProxy(proxy);
break;
}
case MESSAGE_BIND_PROFILE_SERVICE:
{
ProfileServiceConnections psc=(ProfileServiceConnections)msg.obj;
removeMessages(MESSAGE_BIND_PROFILE_SERVICE,msg.obj);
if (psc == null) {
break;
}
psc.bindService();
break;
}
case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
{
if (DBG) Log.d(TAG,"MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
IBinder service=(IBinder)msg.obj;
try {
mBluetoothLock.writeLock().lock();
if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
mBluetoothGatt=IBluetoothGatt.Stub.asInterface(service);
onBluetoothGattServiceUp();
break;
}
mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
mBinding=false;
mBluetoothBinder=service;
mBluetooth=IBluetooth.Stub.asInterface(service);
try {
boolean enableHciSnoopLog=(Settings.Secure.getInt(mContentResolver,Settings.Secure.BLUETOOTH_HCI_LOG,0) == 1);
if (!mBluetooth.configHciSnoopLog(enableHciSnoopLog)) {
Log.e(TAG,"IBluetooth.configHciSnoopLog return false");
}
}
 catch (RemoteException e) {
Log.e(TAG,"Unable to call configHciSnoopLog",e);
}
if (mConnection.isGetNameAddressOnly()) {
Message getMsg=mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
mHandler.sendMessage(getMsg);
if (!mEnable) return;
}
mConnection.setGetNameAddressOnly(false);
try {
mBluetooth.registerCallback(mBluetoothCallback);
}
 catch (RemoteException re) {
Log.e(TAG,"Unable to register BluetoothCallback",re);
}
sendBluetoothServiceUpCallback();
try {
if (mQuietEnable == false) {
if (!mBluetooth.enable()) {
Log.e(TAG,"IBluetooth.enable() returned false");
}
}
 else {
if (!mBluetooth.enableNoAutoConnect()) {
Log.e(TAG,"IBluetooth.enableNoAutoConnect() returned false");
}
}
}
 catch (RemoteException e) {
Log.e(TAG,"Unable to call enable()",e);
}
}
  finally {
mBluetoothLock.writeLock().unlock();
}
if (!mEnable) {
waitForOnOff(true,false);
handleDisable();
waitForOnOff(false,false);
}
break;
}
case MESSAGE_TIMEOUT_BIND:
{
Log.e(TAG,"MESSAGE_TIMEOUT_BIND");
mBluetoothLock.writeLock().lock();
mBinding=false;
mBluetoothLock.writeLock().unlock();
break;
}
case MESSAGE_BLUETOOTH_STATE_CHANGE:
{
int prevState=msg.arg1;
int newState=msg.arg2;
if (DBG) Log.d(TAG,"MESSAGE_BLUETOOTH_STATE_CHANGE: prevState = " + prevState + ", newState="+ newState);
mState=newState;
bluetoothStateChangeHandler(prevState,newState);
if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null)&& mEnable) {
recoverBluetoothServiceFromError();
}
if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null)&& mEnable) {
recoverBluetoothServiceFromError();
}
if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
if (mErrorRecoveryRetryCounter != 0) {
Log.w(TAG,"bluetooth is recovered from error");
mErrorRecoveryRetryCounter=0;
}
}
break;
}
case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
{
Log.e(TAG,"MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED: " + msg.arg1);
try {
mBluetoothLock.writeLock().lock();
if (msg.arg1 == SERVICE_IBLUETOOTH) {
if (mBluetooth == null) break;
mBluetooth=null;
}
 else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
mBluetoothGatt=null;
break;
}
 else {
Log.e(TAG,"Bad msg.arg1: " + msg.arg1);
break;
}
}
  finally {
mBluetoothLock.writeLock().unlock();
}
if (mEnable) {
mEnable=false;
Message restartMsg=mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
mHandler.sendMessageDelayed(restartMsg,SERVICE_RESTART_TIME_MS);
}
if (!mConnection.isGetNameAddressOnly()) {
sendBluetoothServiceDownCallback();
if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON,BluetoothAdapter.STATE_TURNING_OFF);
mState=BluetoothAdapter.STATE_TURNING_OFF;
}
if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,BluetoothAdapter.STATE_OFF);
}
mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
mState=BluetoothAdapter.STATE_OFF;
}
break;
}
case MESSAGE_RESTART_BLUETOOTH_SERVICE:
{
Log.d(TAG,"MESSAGE_RESTART_BLUETOOTH_SERVICE:" + " Restart IBluetooth service");
mEnable=true;
handleEnable(mQuietEnable);
break;
}
case MESSAGE_TIMEOUT_UNBIND:
{
Log.e(TAG,"MESSAGE_TIMEOUT_UNBIND");
mBluetoothLock.writeLock().lock();
mUnbinding=false;
mBluetoothLock.writeLock().unlock();
break;
}
case MESSAGE_USER_SWITCHED:
{
if (DBG) {
Log.d(TAG,"MESSAGE_USER_SWITCHED");
}
mHandler.removeMessages(MESSAGE_USER_SWITCHED);
if (mEnable && mBluetooth != null) {
try {
mBluetoothLock.readLock().lock();
if (mBluetooth != null) {
mBluetooth.unregisterCallback(mBluetoothCallback);
}
}
 catch (RemoteException re) {
Log.e(TAG,"Unable to unregister",re);
}
 finally {
mBluetoothLock.readLock().unlock();
}
if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
bluetoothStateChangeHandler(mState,BluetoothAdapter.STATE_OFF);
mState=BluetoothAdapter.STATE_OFF;
}
if (mState == BluetoothAdapter.STATE_OFF) {
bluetoothStateChangeHandler(mState,BluetoothAdapter.STATE_TURNING_ON);
mState=BluetoothAdapter.STATE_TURNING_ON;
}
waitForOnOff(true,false);
if (mState == BluetoothAdapter.STATE_TURNING_ON) {
bluetoothStateChangeHandler(mState,BluetoothAdapter.STATE_ON);
}
unbindAllBluetoothProfileServices();
handleDisable();
bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON,BluetoothAdapter.STATE_TURNING_OFF);
waitForOnOff(false,true);
bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,BluetoothAdapter.STATE_OFF);
sendBluetoothServiceDownCallback();
try {
mBluetoothLock.writeLock().lock();
if (mBluetooth != null) {
mBluetooth=null;
mContext.unbindService(mConnection);
}
mBluetoothGatt=null;
}
  finally {
mBluetoothLock.writeLock().unlock();
}
SystemClock.sleep(100);
mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
mState=BluetoothAdapter.STATE_OFF;
handleEnable(mQuietEnable);
}
 else if (mBinding || mBluetooth != null) {
Message userMsg=mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
userMsg.arg2=1 + msg.arg2;
mHandler.sendMessageDelayed(userMsg,USER_SWITCHED_TIME_MS);
if (DBG) {
Log.d(TAG,"delay MESSAGE_USER_SWITCHED " + userMsg.arg2);
}
}
break;
}
}
}
