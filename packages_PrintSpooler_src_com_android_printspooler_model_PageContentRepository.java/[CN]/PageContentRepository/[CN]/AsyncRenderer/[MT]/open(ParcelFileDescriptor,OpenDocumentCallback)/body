{
  mPageContentCache.invalidate();
  new AsyncTask<Void,Void,Integer>(){
    @Override protected void onPreExecute(){
      if (mDestroyed) {
        cancel(true);
        return;
      }
      Intent intent=new Intent(PdfManipulationService.ACTION_GET_RENDERER);
      intent.setClass(mContext,PdfManipulationService.class);
      intent.setData(Uri.fromParts("fake-scheme",String.valueOf(AsyncRenderer.this.hashCode()),null));
      mContext.bindService(intent,AsyncRenderer.this,Context.BIND_AUTO_CREATE);
      mBoundToService=true;
    }
    @Override protected Integer doInBackground(    Void... params){
synchronized (mLock) {
        while (mRenderer == null) {
          try {
            mLock.wait();
          }
 catch (          InterruptedException ie) {
          }
        }
        try {
          return mRenderer.openDocument(source);
        }
 catch (        RemoteException re) {
          Log.e(LOG_TAG,"Cannot open PDF document");
          return PdfManipulationService.ERROR_MALFORMED_PDF_FILE;
        }
 finally {
          IoUtils.closeQuietly(source);
        }
      }
    }
    @Override public void onPostExecute(    Integer pageCount){
switch (pageCount) {
case PdfManipulationService.ERROR_MALFORMED_PDF_FILE:
{
          mPageCount=PrintDocumentInfo.PAGE_COUNT_UNKNOWN;
          if (callback != null) {
            callback.onFailure(OpenDocumentCallback.ERROR_MALFORMED_PDF_FILE);
          }
        }
      break;
case PdfManipulationService.ERROR_SECURE_PDF_FILE:
{
      mPageCount=PrintDocumentInfo.PAGE_COUNT_UNKNOWN;
      if (callback != null) {
        callback.onFailure(OpenDocumentCallback.ERROR_SECURE_PDF_FILE);
      }
    }
  break;
default :
{
  mPageCount=pageCount;
  if (callback != null) {
    callback.onSuccess();
  }
}
break;
}
}
}
.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR);
}
