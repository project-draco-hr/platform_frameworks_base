{
  if (mNativeClass == 0 || (!isClickable() && !isLongClickable())) {
    return false;
  }
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,ev + " at " + ev.getEventTime()+ " mTouchMode="+ mTouchMode+ " numPointers="+ ev.getPointerCount());
  }
  int action=ev.getAction();
  float x=ev.getX();
  float y=ev.getY();
  long eventTime=ev.getEventTime();
  final ScaleGestureDetector detector=mZoomManager.getMultiTouchGestureDetector();
  boolean skipScaleGesture=false;
  float gestureX=x;
  float gestureY=y;
  if (detector == null || !detector.isInProgress()) {
    if (ev.getPointerCount() > 1) {
      float dx=ev.getX(1) - ev.getX(0);
      float dy=ev.getY(1) - ev.getY(0);
      float dist=(dx * dx + dy * dy) * DRAG_LAYER_INVERSE_DENSITY_SQUARED;
      gestureX=ev.getX(0) + (dx * .5f);
      gestureY=ev.getY(0) + (dy * .5f);
      if (ev.getX(0) < ev.getX(1)) {
        x=ev.getX(0);
        y=ev.getY(0);
      }
 else {
        x=ev.getX(1);
        y=ev.getY(1);
      }
      action=ev.getActionMasked();
      if (dist < DRAG_LAYER_FINGER_DISTANCE) {
        skipScaleGesture=true;
      }
 else       if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
    }
  }
  if (ev.getPointerCount() > 1 && (mZoomManager.isZoomScaleFixed() || mDeferMultitouch)) {
    if (DebugFlags.WEB_VIEW) {
      Log.v(LOGTAG,"passing " + ev.getPointerCount() + " points to webkit");
    }
    passMultiTouchToWebKit(ev);
    return true;
  }
  if (mZoomManager.supportsMultiTouchZoom() && ev.getPointerCount() > 1 && mTouchMode != TOUCH_DRAG_LAYER_MODE && !skipScaleGesture) {
    if (!detector.isInProgress() && ev.getActionMasked() != MotionEvent.ACTION_POINTER_DOWN) {
      MotionEvent temp=MotionEvent.obtain(ev);
      try {
        temp.setAction(temp.getAction() & ~MotionEvent.ACTION_MASK | MotionEvent.ACTION_POINTER_DOWN);
        detector.onTouchEvent(temp);
      }
  finally {
        temp.recycle();
      }
    }
    detector.onTouchEvent(ev);
    if (detector.isInProgress()) {
      mLastTouchTime=eventTime;
      cancelLongPress();
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      if (!mZoomManager.supportsPanDuringZoom()) {
        return true;
      }
      mTouchMode=TOUCH_DRAG_MODE;
      if (mVelocityTracker == null) {
        mVelocityTracker=VelocityTracker.obtain();
      }
    }
    x=detector.getFocusX();
    y=detector.getFocusY();
    action=ev.getAction() & MotionEvent.ACTION_MASK;
    if (action == MotionEvent.ACTION_POINTER_DOWN) {
      cancelTouch();
      action=MotionEvent.ACTION_DOWN;
    }
 else     if (action == MotionEvent.ACTION_POINTER_UP) {
      mLastTouchX=x;
      mLastTouchY=y;
    }
 else     if (action == MotionEvent.ACTION_MOVE) {
      if (x < 0 || y < 0) {
        return true;
      }
    }
  }
  x=Math.min(x,getViewWidth() - 1);
  y=Math.min(y,getViewHeightWithTitle() - 1);
  float fDeltaX=mLastTouchX - x;
  float fDeltaY=mLastTouchY - y;
  int deltaX=(int)fDeltaX;
  int deltaY=(int)fDeltaY;
  int contentX=viewToContentX((int)x + mScrollX);
  int contentY=viewToContentY((int)y + mScrollY);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      mPreventDefault=PREVENT_DEFAULT_NO;
      mConfirmMove=false;
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
        mTouchMode=TOUCH_DRAG_START_MODE;
        mConfirmMove=true;
        mPrivateHandler.removeMessages(RESUME_WEBCORE_PRIORITY);
      }
 else       if (mPrivateHandler.hasMessages(RELEASE_SINGLE_TAP)) {
        mPrivateHandler.removeMessages(RELEASE_SINGLE_TAP);
        if (getSettings().supportTouchOnly()) {
          removeTouchHighlight(true);
        }
        if (deltaX * deltaX + deltaY * deltaY < mDoubleTapSlopSquare) {
          mTouchMode=TOUCH_DOUBLE_TAP_MODE;
        }
 else {
          doShortPress();
          mTouchMode=TOUCH_INIT_MODE;
          mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        }
      }
 else {
        mTouchMode=TOUCH_INIT_MODE;
        mDeferTouchProcess=(!inFullScreenMode() && mForwardTouchEvents) ? hitFocusedPlugin(contentX,contentY) : false;
        mWebViewCore.sendMessage(EventHub.UPDATE_FRAME_CACHE_IF_LOADING);
        if (getSettings().supportTouchOnly()) {
          TouchHighlightData data=new TouchHighlightData();
          data.mX=contentX;
          data.mY=contentY;
          data.mSlop=viewToContentDimension(mNavSlop);
          mWebViewCore.sendMessageDelayed(EventHub.GET_TOUCH_HIGHLIGHT_RECTS,data,ViewConfiguration.getTapTimeout());
          if (DEBUG_TOUCH_HIGHLIGHT) {
            if (getSettings().getNavDump()) {
              mTouchHighlightX=(int)x + mScrollX;
              mTouchHighlightY=(int)y + mScrollY;
              mPrivateHandler.postDelayed(new Runnable(){
                public void run(){
                  mTouchHighlightX=mTouchHighlightY=0;
                  invalidate();
                }
              }
,TOUCH_HIGHLIGHT_ELAPSE_TIME);
            }
          }
        }
        if (mLogEvent && eventTime - mLastTouchUpTime < 1000) {
          EventLog.writeEvent(EventLogTags.BROWSER_DOUBLE_TAP_DURATION,(eventTime - mLastTouchUpTime),eventTime);
        }
        if (mSelectingText) {
          mDrawSelectionPointer=false;
          mSelectionStarted=nativeStartSelection(contentX,contentY);
          if (DebugFlags.WEB_VIEW) {
            Log.v(LOGTAG,"select=" + contentX + ","+ contentY);
          }
          invalidate();
        }
      }
      if (mTouchMode == TOUCH_INIT_MODE || mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_SHORTPRESS,TAP_TIMEOUT);
        mPrivateHandler.sendEmptyMessageDelayed(SWITCH_TO_LONGPRESS,LONG_PRESS_TIMEOUT);
        if (inFullScreenMode() || mDeferTouchProcess) {
          mPreventDefault=PREVENT_DEFAULT_YES;
        }
 else         if (mForwardTouchEvents) {
          mPreventDefault=PREVENT_DEFAULT_MAYBE_YES;
        }
 else {
          mPreventDefault=PREVENT_DEFAULT_NO;
        }
        if (shouldForwardTouchEvent()) {
          TouchEventData ted=new TouchEventData();
          ted.mAction=action;
          ted.mPoints=new Point[1];
          ted.mPoints[0]=new Point(contentX,contentY);
          ted.mMetaState=ev.getMetaState();
          ted.mReprocess=mDeferTouchProcess;
          mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
          if (mDeferTouchProcess) {
            mLastTouchX=x;
            mLastTouchY=y;
            break;
          }
          if (!inFullScreenMode()) {
            mPrivateHandler.removeMessages(PREVENT_DEFAULT_TIMEOUT);
            mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
          }
        }
      }
      startTouch(x,y,eventTime);
      break;
    }
case MotionEvent.ACTION_MOVE:
{
    boolean firstMove=false;
    if (!mConfirmMove && (deltaX * deltaX + deltaY * deltaY) >= mTouchSlopSquare) {
      mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
      mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
      mConfirmMove=true;
      firstMove=true;
      if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
        mTouchMode=TOUCH_INIT_MODE;
      }
      if (getSettings().supportTouchOnly()) {
        removeTouchHighlight(true);
      }
    }
    if (shouldForwardTouchEvent() && mConfirmMove && (firstMove || eventTime - mLastSentTouchTime > mCurrentTouchInterval)) {
      TouchEventData ted=new TouchEventData();
      ted.mAction=action;
      ted.mPoints=new Point[1];
      ted.mPoints[0]=new Point(contentX,contentY);
      ted.mMetaState=ev.getMetaState();
      ted.mReprocess=mDeferTouchProcess;
      mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
      mLastSentTouchTime=eventTime;
      if (mDeferTouchProcess) {
        break;
      }
      if (firstMove && !inFullScreenMode()) {
        mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(PREVENT_DEFAULT_TIMEOUT,action,0),TAP_TIMEOUT);
      }
    }
    if (mTouchMode == TOUCH_DONE_MODE || mPreventDefault == PREVENT_DEFAULT_YES) {
      break;
    }
    if (mVelocityTracker == null) {
      Log.e(LOGTAG,"Got null mVelocityTracker when " + "mPreventDefault = " + mPreventDefault + " mDeferTouchProcess = "+ mDeferTouchProcess+ " mTouchMode = "+ mTouchMode);
    }
    mVelocityTracker.addMovement(ev);
    if (mSelectingText && mSelectionStarted) {
      if (DebugFlags.WEB_VIEW) {
        Log.v(LOGTAG,"extend=" + contentX + ","+ contentY);
      }
      nativeExtendSelection(contentX,contentY);
      invalidate();
      break;
    }
    if (mTouchMode != TOUCH_DRAG_MODE && mTouchMode != TOUCH_DRAG_LAYER_MODE) {
      if (!mConfirmMove) {
        break;
      }
      if (mPreventDefault == PREVENT_DEFAULT_MAYBE_YES || mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
        mLastTouchTime=eventTime;
        break;
      }
      if (detector != null && !detector.isInProgress()) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (ax > MAX_SLOPE_FOR_DIAG * ay) {
          mSnapScrollMode=SNAP_X;
          mSnapPositive=deltaX > 0;
        }
 else         if (ay > MAX_SLOPE_FOR_DIAG * ax) {
          mSnapScrollMode=SNAP_Y;
          mSnapPositive=deltaY > 0;
        }
      }
      mTouchMode=TOUCH_DRAG_MODE;
      mLastTouchX=x;
      mLastTouchY=y;
      fDeltaX=0.0f;
      fDeltaY=0.0f;
      deltaX=0;
      deltaY=0;
      if (skipScaleGesture) {
        startScrollingLayer(gestureX,gestureY);
      }
      startDrag();
    }
    if (mDragTrackerHandler != null) {
      mDragTrackerHandler.dragTo(x,y);
    }
    if (mTouchMode != TOUCH_DRAG_LAYER_MODE) {
      int newScrollX=pinLocX(mScrollX + deltaX);
      int newDeltaX=newScrollX - mScrollX;
      if (deltaX != newDeltaX) {
        deltaX=newDeltaX;
        fDeltaX=(float)newDeltaX;
      }
      int newScrollY=pinLocY(mScrollY + deltaY);
      int newDeltaY=newScrollY - mScrollY;
      if (deltaY != newDeltaY) {
        deltaY=newDeltaY;
        fDeltaY=(float)newDeltaY;
      }
    }
    boolean done=false;
    boolean keepScrollBarsVisible=false;
    if (Math.abs(fDeltaX) < 1.0f && Math.abs(fDeltaY) < 1.0f) {
      mLastTouchX=x;
      mLastTouchY=y;
      keepScrollBarsVisible=done=true;
    }
 else {
      if (mSnapScrollMode == SNAP_X || mSnapScrollMode == SNAP_Y) {
        int ax=Math.abs(deltaX);
        int ay=Math.abs(deltaY);
        if (mSnapScrollMode == SNAP_X) {
          if (ay > MAX_SLOPE_FOR_DIAG * ax && ay > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ax > MAX_SLOPE_FOR_DIAG * ay && (mSnapPositive ? deltaX < -mMinLockSnapReverseDistance : deltaX > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
 else {
          if (ax > MAX_SLOPE_FOR_DIAG * ay && ax > MIN_BREAK_SNAP_CROSS_DISTANCE) {
            mSnapScrollMode=SNAP_NONE;
          }
          if (ay > MAX_SLOPE_FOR_DIAG * ax && (mSnapPositive ? deltaY < -mMinLockSnapReverseDistance : deltaY > mMinLockSnapReverseDistance)) {
            mSnapScrollMode|=SNAP_LOCK;
          }
        }
      }
      if (mSnapScrollMode != SNAP_NONE) {
        if ((mSnapScrollMode & SNAP_X) == SNAP_X) {
          deltaY=0;
        }
 else {
          deltaX=0;
        }
      }
      if ((deltaX | deltaY) != 0) {
        if (deltaX != 0) {
          mLastTouchX=x;
        }
        if (deltaY != 0) {
          mLastTouchY=y;
        }
        mHeldMotionless=MOTIONLESS_FALSE;
      }
 else {
        mLastTouchX=x;
        mLastTouchY=y;
        keepScrollBarsVisible=true;
      }
      mLastTouchTime=eventTime;
      mUserScroll=true;
    }
    doDrag(deltaX,deltaY);
    if (keepScrollBarsVisible && mTouchMode != TOUCH_DRAG_LAYER_MODE) {
      if (mHeldMotionless != MOTIONLESS_TRUE) {
        mHeldMotionless=MOTIONLESS_TRUE;
        invalidate();
      }
      awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
      return !done;
    }
    break;
  }
case MotionEvent.ACTION_UP:
{
  if (!isFocused())   requestFocus();
  if (shouldForwardTouchEvent()) {
    TouchEventData ted=new TouchEventData();
    ted.mAction=action;
    ted.mPoints=new Point[1];
    ted.mPoints[0]=new Point(contentX,contentY);
    ted.mMetaState=ev.getMetaState();
    ted.mReprocess=mDeferTouchProcess;
    mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
  }
  mLastTouchUpTime=eventTime;
switch (mTouchMode) {
case TOUCH_DOUBLE_TAP_MODE:
    mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
  mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (inFullScreenMode() || mDeferTouchProcess) {
  TouchEventData ted=new TouchEventData();
  ted.mAction=WebViewCore.ACTION_DOUBLETAP;
  ted.mPoints=new Point[1];
  ted.mPoints[0]=new Point(contentX,contentY);
  ted.mMetaState=ev.getMetaState();
  ted.mReprocess=mDeferTouchProcess;
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
  mZoomManager.handleDoubleTap(mLastTouchX,mLastTouchY);
  mTouchMode=TOUCH_DONE_MODE;
}
break;
case TOUCH_INIT_MODE:
case TOUCH_SHORTPRESS_START_MODE:
case TOUCH_SHORTPRESS_MODE:
mPrivateHandler.removeMessages(SWITCH_TO_SHORTPRESS);
mPrivateHandler.removeMessages(SWITCH_TO_LONGPRESS);
if (mConfirmMove) {
Log.w(LOGTAG,"Miss a drag as we are waiting for" + " WebCore's response for touch down.");
if (mPreventDefault != PREVENT_DEFAULT_YES && (computeMaxScrollX() > 0 || computeMaxScrollY() > 0)) {
WebViewCore.reducePriority();
WebViewCore.pauseUpdatePicture(mWebViewCore);
}
 else {
invalidate();
break;
}
}
 else {
if (mSelectingText) {
if (!nativeHitSelection(contentX,contentY)) {
selectionDone();
}
break;
}
if (mTouchMode == TOUCH_INIT_MODE && (canZoomIn() || canZoomOut())) {
mPrivateHandler.sendEmptyMessageDelayed(RELEASE_SINGLE_TAP,ViewConfiguration.getDoubleTapTimeout());
}
 else {
doShortPress();
}
break;
}
case TOUCH_DRAG_MODE:
mPrivateHandler.removeMessages(DRAG_HELD_MOTIONLESS);
mPrivateHandler.removeMessages(AWAKEN_SCROLL_BARS);
if (eventTime - mLastTouchTime <= MIN_FLING_TIME) {
if (mVelocityTracker == null) {
Log.e(LOGTAG,"Got null mVelocityTracker when " + "mPreventDefault = " + mPreventDefault + " mDeferTouchProcess = "+ mDeferTouchProcess);
}
mVelocityTracker.addMovement(ev);
mHeldMotionless=MOTIONLESS_IGNORE;
doFling();
break;
}
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case TOUCH_DRAG_START_MODE:
case TOUCH_DRAG_LAYER_MODE:
mLastVelocity=0;
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
}
stopTouch();
break;
}
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_DRAG_MODE) {
invalidate();
}
cancelWebCoreTouchEvent(contentX,contentY,false);
cancelTouch();
break;
}
}
return true;
}
