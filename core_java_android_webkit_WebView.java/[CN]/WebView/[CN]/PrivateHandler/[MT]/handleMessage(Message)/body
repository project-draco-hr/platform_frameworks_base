{
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
      Log.v(LOGTAG,HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
    }
 else     if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
      Log.v(LOGTAG,HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
    }
 else {
      Log.v(LOGTAG,Integer.toString(msg.what));
    }
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString("host"),msg.getData().getString("username"),msg.getData().getString("password"));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString("host"),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case PREVENT_DEFAULT_TIMEOUT:
{
  if ((msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) || (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN)) {
    cancelWebCoreTouchEvent(viewToContentX((int)mLastTouchX + mScrollX),viewToContentY((int)mLastTouchY + mScrollY),true);
  }
  break;
}
case SWITCH_TO_SHORTPRESS:
{
if (mTouchMode == TOUCH_INIT_MODE) {
  if (!getSettings().supportTouchOnly() && mPreventDefault != PREVENT_DEFAULT_YES) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else {
    mTouchMode=TOUCH_SHORTPRESS_MODE;
  }
}
 else if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
  mTouchMode=TOUCH_DONE_MODE;
}
break;
}
case SWITCH_TO_LONGPRESS:
{
if (getSettings().supportTouchOnly()) {
removeTouchHighlight(false);
}
if (inFullScreenMode() || mDeferTouchProcess) {
TouchEventData ted=new TouchEventData();
ted.mAction=WebViewCore.ACTION_LONGPRESS;
ted.mPoints=new Point[1];
ted.mPoints[0]=new Point(viewToContentX((int)mLastTouchX + mScrollX),viewToContentY((int)mLastTouchY + mScrollY));
ted.mMetaState=0;
ted.mReprocess=mDeferTouchProcess;
mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDefault != PREVENT_DEFAULT_YES) {
mTouchMode=TOUCH_DONE_MODE;
performLongClick();
}
break;
}
case RELEASE_SINGLE_TAP:
{
doShortPress();
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case UPDATE_ZOOM_RANGE:
{
WebViewCore.ViewState viewState=(WebViewCore.ViewState)msg.obj;
mZoomManager.updateZoomRange(viewState,getViewWidth(),viewState.mScrollX);
break;
}
case REPLACE_BASE_CONTENT:
{
nativeReplaceBaseContent(msg.arg1);
break;
}
case NEW_PICTURE_MSG_ID:
{
mUserScroll=false;
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
setBaseLayer(draw.mBaseLayer,draw.mInvalRegion.getBounds());
final Point viewSize=draw.mViewPoint;
WebViewCore.ViewState viewState=draw.mViewState;
boolean isPictureAfterFirstLayout=viewState != null;
if (isPictureAfterFirstLayout) {
mLastWidthSent=0;
mZoomManager.onFirstLayout(draw);
if (!mDrawHistory) {
setContentScrollTo(viewState.mScrollX,viewState.mScrollY);
clearTextEntry();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y,updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,"NEW_PICTURE_MSG_ID {" + b.left + ","+ b.top+ ","+ b.right+ ","+ b.bottom+ "}");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
mZoomManager.onNewPicture(draw);
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (isPictureAfterFirstLayout) {
mViewManager.postReadyToDrawAll();
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean("password")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case REQUEST_KEYBOARD_WITH_SELECTION_MSG_ID:
displaySoftKeyboard(true);
case UPDATE_TEXT_SELECTION_MSG_ID:
updateTextSelectionFromMessage(msg.arg1,msg.arg2,(WebViewCore.TextSelectionData)msg.obj);
break;
case FORM_DID_BLUR:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
hideSoftKeyboard();
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case UNHANDLED_NAV_KEY:
navHandledKey(msg.arg1,1,false,0);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
performLongClick();
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (inFullScreenMode()) {
break;
}
if (msg.obj == null) {
if (msg.arg1 == MotionEvent.ACTION_DOWN && mPreventDefault == PREVENT_DEFAULT_MAYBE_YES) {
mPreventDefault=msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN;
}
 else if (msg.arg1 == MotionEvent.ACTION_MOVE && mPreventDefault == PREVENT_DEFAULT_NO_FROM_TOUCH_DOWN) {
mPreventDefault=msg.arg2 == 1 ? PREVENT_DEFAULT_YES : PREVENT_DEFAULT_NO;
}
if (mPreventDefault == PREVENT_DEFAULT_YES) {
mTouchHighlightRegion.setEmpty();
}
}
 else if (msg.arg2 == 0) {
TouchEventData ted=(TouchEventData)msg.obj;
switch (ted.mAction) {
case MotionEvent.ACTION_DOWN:
mLastDeferTouchX=contentToViewX(ted.mPoints[0].x) - mScrollX;
mLastDeferTouchY=contentToViewY(ted.mPoints[0].y) - mScrollY;
mDeferTouchMode=TOUCH_INIT_MODE;
break;
case MotionEvent.ACTION_MOVE:
{
int x=contentToViewX(ted.mPoints[0].x) - mScrollX;
int y=contentToViewY(ted.mPoints[0].y) - mScrollY;
if (mDeferTouchMode != TOUCH_DRAG_MODE) {
mDeferTouchMode=TOUCH_DRAG_MODE;
mLastDeferTouchX=x;
mLastDeferTouchY=y;
startDrag();
}
int deltaX=pinLocX((int)(mScrollX + mLastDeferTouchX - x)) - mScrollX;
int deltaY=pinLocY((int)(mScrollY + mLastDeferTouchY - y)) - mScrollY;
doDrag(deltaX,deltaY);
if (deltaX != 0) mLastDeferTouchX=x;
if (deltaY != 0) mLastDeferTouchY=y;
break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (mDeferTouchMode == TOUCH_DRAG_MODE) {
WebViewCore.resumePriority();
WebViewCore.resumeUpdatePicture(mWebViewCore);
}
mDeferTouchMode=TOUCH_DONE_MODE;
break;
case WebViewCore.ACTION_DOUBLETAP:
mLastTouchX=contentToViewX(ted.mPoints[0].x) - mScrollX;
mLastTouchY=contentToViewY(ted.mPoints[0].y) - mScrollY;
mZoomManager.handleDoubleTap(mLastTouchX,mLastTouchY);
mDeferTouchMode=TOUCH_DONE_MODE;
break;
case WebViewCore.ACTION_LONGPRESS:
HitTestResult hitTest=getHitTestResult();
if (hitTest != null && hitTest.mType != HitTestResult.UNKNOWN_TYPE) {
performLongClick();
}
mDeferTouchMode=TOUCH_DONE_MODE;
break;
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case FIND_AGAIN:
if (mFindIsUp && mFindCallback != null) {
mFindCallback.findAll();
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SHOW_FULLSCREEN:
{
View view=(View)msg.obj;
int npp=msg.arg1;
if (inFullScreenMode()) {
Log.w(LOGTAG,"Should not have another full screen.");
dismissFullScreenMode();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,npp);
mFullScreenHolder.setContentView(view);
mFullScreenHolder.setCancelable(false);
mFullScreenHolder.setCanceledOnTouchOutside(false);
mFullScreenHolder.show();
break;
}
case HIDE_FULLSCREEN:
dismissFullScreenMode();
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewX(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"showRectMsg=(left=" + left + ",width="+ width+ ",maxWidth="+ maxWidth+ ",viewWidth="+ viewWidth+ ",x="+ x+ ",xPercentInDoc="+ data.mXPercentInDoc+ ",xPercentInView="+ data.mXPercentInView+ ")");
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int top=contentToViewY(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
int y=(int)(top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"showRectMsg=(top=" + top + ",height="+ height+ ",maxHeight="+ maxHeight+ ",viewHeight="+ viewHeight+ ",y="+ y+ ",yPercentInDoc="+ data.mYPercentInDoc+ ",yPercentInView="+ data.mYPercentInView+ ")");
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
y=Math.max(0,y - getVisibleTitleHeight());
scrollTo(x,y);
}
break;
case CENTER_FIT_RECT:
Rect r=(Rect)msg.obj;
centerFitRect(r.left,r.top,r.width(),r.height());
break;
case SET_SCROLLBAR_MODES:
mHorizontalScrollBarMode=msg.arg1;
mVerticalScrollBarMode=msg.arg2;
break;
case SELECTION_STRING_CHANGED:
if (mAccessibilityInjector != null) {
String selectionString=(String)msg.obj;
mAccessibilityInjector.onSelectionStringChange(selectionString);
}
break;
case SET_TOUCH_HIGHLIGHT_RECTS:
invalidate(mTouchHighlightRegion.getBounds());
mTouchHighlightRegion.setEmpty();
if (msg.obj != null) {
ArrayList<Rect> rects=(ArrayList<Rect>)msg.obj;
for (Rect rect : rects) {
Rect viewRect=contentToViewRect(rect);
if (viewRect.width() < getWidth() >> 1 || viewRect.height() < getHeight() >> 1) {
mTouchHighlightRegion.union(viewRect);
invalidate(viewRect);
}
 else {
Log.w(LOGTAG,"Skip the huge selection rect:" + viewRect);
}
}
}
break;
case SAVE_WEBARCHIVE_FINISHED:
SaveWebArchiveMessage saveMessage=(SaveWebArchiveMessage)msg.obj;
if (saveMessage.mCallback != null) {
saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
}
break;
case SET_AUTOFILLABLE:
mAutoFillQueryId=msg.arg1;
if (mWebTextView != null) {
mWebTextView.setAutoFillable(mAutoFillQueryId);
rebuildWebTextView();
}
break;
default :
super.handleMessage(msg);
break;
}
}
