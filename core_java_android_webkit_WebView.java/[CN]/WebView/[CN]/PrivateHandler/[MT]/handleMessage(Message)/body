{
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > INVAL_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString("host"),msg.getData().getString("username"),msg.getData().getString("password"));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString("host"),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (!mPreventDrag) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (!mPreventDrag) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SWITCH_TO_CLICK:
mTouchMode=TOUCH_DONE_MODE;
Rect visibleRect=sendOurVisibleRect();
if (!nativeCursorIntersects(visibleRect)) {
break;
}
nativeSetFollowedLink(true);
nativeUpdatePluginReceivesEvents();
WebViewCore.CursorData data=cursorData();
mWebViewCore.sendMessage(EventHub.SET_MOVE_MOUSE,data);
playSoundEffect(SoundEffectConstants.CLICK);
boolean isTextInput=nativeCursorIsTextInput();
if (isTextInput || !mCallbackProxy.uiOverrideUrlLoading(nativeCursorText())) {
mWebViewCore.sendMessage(EventHub.CLICK,data.mFrame,nativeCursorNodePointer());
}
if (isTextInput) {
rebuildWebTextView();
}
break;
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
mLastScale=restoreState.mTextWrapScale;
if (restoreState.mMinScale == 0) {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (useWideViewport && restoreState.mViewScale == 0) {
mInZoomOverview=ENABLE_DOUBLETAP_ZOOM && settings.getLoadWithOverviewMode();
}
setNewZoomScale(mLastScale,false);
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y,updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,"NEW_PICTURE_MSG_ID {" + b.left + ","+ b.top+ ","+ b.right+ ","+ b.bottom+ "}");
}
invalidate(contentToView(draw.mInvalRegion.getBounds()));
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max(draw.mMinPrefWidth,draw.mViewPoint.x);
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean("password")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"UPDATE_CLIPBOARD " + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService("clipboard"));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,"Clipboard failed",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
mPreventDrag=msg.arg2 == 1;
if (mPreventDrag) {
mTouchMode=TOUCH_DONE_MODE;
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
default :
super.handleMessage(msg);
break;
}
}
