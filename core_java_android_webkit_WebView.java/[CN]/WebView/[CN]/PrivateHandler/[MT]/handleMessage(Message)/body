{
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > RETURN_LABEL ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString("host"),msg.getData().getString("username"),msg.getData().getString("password"));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString("host"),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
    mPreventLongPress=false;
    mPreventDoubleTap=false;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=mFullScreenHolder == null ? TOUCH_SHORTPRESS_START_MODE : TOUCH_SHORTPRESS_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventLongPress) {
  mTouchMode=TOUCH_DONE_MODE;
  WebViewCore.TouchEventData ted=new WebViewCore.TouchEventData();
  ted.mAction=WebViewCore.ACTION_LONGPRESS;
  ted.mX=viewToContentX((int)mLastTouchX + mScrollX);
  ted.mY=viewToContentY((int)mLastTouchY + mScrollY);
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  if (mFullScreenHolder == null) {
    performLongClick();
    rebuildWebTextView();
  }
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=PREVENT_DRAG_NO;
mPreventLongPress=false;
mPreventDoubleTap=false;
}
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
boolean hasRestoreState=restoreState != null;
if (hasRestoreState) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
if (getSettings().getBuiltInZoomControls()) {
updateZoomButtonsEnabled();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,"NEW_PICTURE_MSG_ID {" + b.left + ","+ b.top+ ","+ b.right+ ","+ b.bottom+ "}");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.min(sMaxViewportWidth,Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x)));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (hasRestoreState) {
mViewManager.postReadyToDrawAll();
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean("password")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case MOVE_OUT_OF_PLUGIN:
navHandledKey(msg.arg1,1,false,0,true);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case IMMEDIATE_REPAINT_MSG_ID:
{
int updates=msg.arg1;
if (updates != 0) {
nativeUpdateLayers(mRootLayer,updates);
}
invalidate();
break;
}
case SET_ROOT_LAYER_MSG_ID:
{
int oldLayer=mRootLayer;
mRootLayer=msg.arg1;
if (oldLayer > 0) {
nativeDestroyLayer(oldLayer);
}
if (mRootLayer == 0) {
mLayersHaveAnimations=false;
}
if (mEvaluateThread != null) {
mEvaluateThread.cancel();
mEvaluateThread=null;
}
if (nativeLayersHaveAnimations(mRootLayer)) {
mLayersHaveAnimations=true;
mEvaluateThread=new EvaluateLayersAnimations();
mEvaluateThread.start();
}
invalidate();
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=(msg.arg2 & TOUCH_PREVENT_DRAG) == TOUCH_PREVENT_DRAG ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
 else {
mPreventLongPress=(msg.arg2 & TOUCH_PREVENT_LONGPRESS) == TOUCH_PREVENT_LONGPRESS;
mPreventDoubleTap=(msg.arg2 & TOUCH_PREVENT_DOUBLETAP) == TOUCH_PREVENT_DOUBLETAP;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(1 == msg.arg2);
}
break;
case FIND_AGAIN:
if (mFindIsUp) {
findAll(mLastFind);
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SHOW_FULLSCREEN:
{
WebViewCore.PluginFullScreenData data=(WebViewCore.PluginFullScreenData)msg.obj;
if (data.mNpp != 0 && data.mView != null) {
if (mFullScreenHolder != null) {
Log.w(LOGTAG,"Should not have another full screen.");
mFullScreenHolder.dismiss();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,data.mNpp);
data.mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT));
mFullScreenHolder.setContentView(data.mView);
mFullScreenHolder.setCancelable(false);
mFullScreenHolder.setCanceledOnTouchOutside(false);
mFullScreenHolder.show();
}
 else if (mFullScreenHolder == null) {
break;
}
int x=contentToViewX(data.mDocX);
int y=contentToViewY(data.mDocY);
int width=contentToViewDimension(data.mDocWidth);
int height=contentToViewDimension(data.mDocHeight);
int viewWidth=getViewWidth();
int viewHeight=getViewHeight();
int newX=mScrollX;
int newY=mScrollY;
if (x < mScrollX) {
newX=x + (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
 else if (x + width > mScrollX + viewWidth) {
newX=x + width - viewWidth - (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
if (y < mScrollY) {
newY=y + (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
 else if (y + height > mScrollY + viewHeight) {
newY=y + height - viewHeight - (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
scrollTo(newX,newY);
if (width > viewWidth || height > viewHeight) {
mZoomCenterX=viewWidth * .5f;
mZoomCenterY=viewHeight * .5f;
setNewZoomScale(mActualScale / Math.max((float)width / viewWidth,(float)height / viewHeight),false,false);
}
mFullScreenHolder.updateBound(contentToViewX(data.mDocX) - mScrollX,contentToViewY(data.mDocY) - mScrollY,contentToViewDimension(data.mDocWidth),contentToViewDimension(data.mDocHeight));
}
break;
case HIDE_FULLSCREEN:
if (mFullScreenHolder != null) {
mFullScreenHolder.dismiss();
mFullScreenHolder=null;
}
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
}
break;
default :
super.handleMessage(msg);
break;
}
}
