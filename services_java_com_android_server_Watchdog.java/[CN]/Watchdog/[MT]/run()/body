{
  boolean waitedHalf=false;
  while (true) {
    final String name;
synchronized (this) {
      long timeout=TIME_TO_WAIT;
      if (!waitedHalf) {
        for (int i=0; i < mHandlerCheckers.size(); i++) {
          HandlerChecker hc=mHandlerCheckers.get(i);
          hc.scheduleCheckLocked();
        }
      }
      long start=SystemClock.uptimeMillis();
      while (timeout > 0) {
        try {
          wait(timeout);
        }
 catch (        InterruptedException e) {
          Log.wtf(TAG,e);
        }
        timeout=TIME_TO_WAIT - (SystemClock.uptimeMillis() - start);
      }
      if (haveAllCheckersCompletedLocked()) {
        waitedHalf=false;
        continue;
      }
      if (!waitedHalf) {
        ArrayList<Integer> pids=new ArrayList<Integer>();
        pids.add(Process.myPid());
        ActivityManagerService.dumpStackTraces(true,pids,null,null,NATIVE_STACKS_OF_INTEREST);
        waitedHalf=true;
        continue;
      }
      name=describeBlockedCheckersLocked();
    }
    EventLog.writeEvent(EventLogTags.WATCHDOG,name);
    ArrayList<Integer> pids=new ArrayList<Integer>();
    pids.add(Process.myPid());
    if (mPhonePid > 0)     pids.add(mPhonePid);
    final File stack=ActivityManagerService.dumpStackTraces(!waitedHalf,pids,null,null,NATIVE_STACKS_OF_INTEREST);
    SystemClock.sleep(2000);
    if (RECORD_KERNEL_THREADS) {
      dumpKernelStackTraces();
    }
    try {
      FileWriter sysrq_trigger=new FileWriter("/proc/sysrq-trigger");
      sysrq_trigger.write("w");
      sysrq_trigger.close();
    }
 catch (    IOException e) {
      Slog.e(TAG,"Failed to write to /proc/sysrq-trigger");
      Slog.e(TAG,e.getMessage());
    }
    Thread dropboxThread=new Thread("watchdogWriteToDropbox"){
      public void run(){
        mActivity.addErrorToDropBox("watchdog",null,"system_server",null,null,name,null,stack,null);
      }
    }
;
    dropboxThread.start();
    try {
      dropboxThread.join(2000);
    }
 catch (    InterruptedException ignored) {
    }
    IActivityController controller;
synchronized (this) {
      controller=mController;
    }
    if (controller != null) {
      Slog.i(TAG,"Reporting stuck state to activity controller");
      try {
        Binder.setDumpDisabled("Service dumps disabled due to hung system process.");
        int res=controller.systemNotResponding(name);
        if (res >= 0) {
          Slog.i(TAG,"Activity controller requested to coninue to wait");
          waitedHalf=false;
          continue;
        }
      }
 catch (      RemoteException e) {
      }
    }
    if (!Debug.isDebuggerConnected()) {
      Slog.w(TAG,"*** WATCHDOG KILLING SYSTEM PROCESS: " + name);
      Slog.w(TAG,"Main thread stack trace:");
      StackTraceElement[] stackTrace=Looper.getMainLooper().getThread().getStackTrace();
      for (      StackTraceElement element : stackTrace) {
        Slog.w(TAG,"\tat " + element);
      }
      Slog.w(TAG,"<End of main thread stack trace>");
      Process.killProcess(Process.myPid());
      System.exit(10);
    }
 else {
      Slog.w(TAG,"Debugger connected: Watchdog is *not* killing the system process");
    }
    waitedHalf=false;
  }
}
