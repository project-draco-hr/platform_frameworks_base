{
  boolean needScheduledCheck;
  long curTime;
  long nextTime=0;
  long recheckInterval=Settings.Gservices.getLong(mResolver,Settings.Gservices.MEMCHECK_RECHECK_INTERVAL,MEMCHECK_DEFAULT_RECHECK_INTERVAL) * 1000;
  mSystemMemMonitor.retrieveSettings(mResolver);
  mPhoneMemMonitor.retrieveSettings(mResolver);
  retrieveBrutalityAmount();
synchronized (this) {
    curTime=System.currentTimeMillis();
    mNeedScheduledCheck=false;
    if (mSystemMemMonitor.checkLocked(curTime,Process.myPid(),(int)Process.getPss(Process.myPid()))) {
      mForceKillSystem=true;
      notifyAll();
      return;
    }
    if (mPhoneReq != null) {
      if (mPhoneMemMonitor.checkLocked(curTime,mPhonePid,mPhonePss)) {
        Log.i(TAG,"Watchdog is killing the phone process");
        Process.killProcess(mPhonePid);
      }
    }
 else {
      mPhoneMemMonitor.clear();
    }
    needScheduledCheck=mNeedScheduledCheck;
    if (needScheduledCheck) {
      nextTime=curTime + recheckInterval;
      if (nextTime < mMemcheckExecStartTime) {
        nextTime=mMemcheckExecStartTime;
      }
 else       if (nextTime >= mMemcheckExecEndTime) {
        if (localLOGV)         Log.v(TAG,"Computing next time range");
        computeMemcheckTimesLocked(nextTime);
        nextTime=mMemcheckExecStartTime;
      }
      if (localLOGV) {
        mCalendar.setTimeInMillis(nextTime);
        Log.v(TAG,"Next Alarm Time: " + mCalendar);
      }
    }
  }
  if (needScheduledCheck) {
    if (localLOGV)     Log.v(TAG,"Scheduling next memcheck alarm for " + ((nextTime - curTime) / 1000 / 60) + "m from now");
    mAlarm.remove(mCheckupIntent);
    mAlarm.set(AlarmManager.RTC_WAKEUP,nextTime,mCheckupIntent);
  }
 else {
    if (localLOGV)     Log.v(TAG,"No need to schedule a memcheck alarm!");
    mAlarm.remove(mCheckupIntent);
  }
}
