{
  if (mCommFd == null) {
    if (msg != null) {
      Log.w(TAG,"Unable to inform peer: " + msg);
    }
    return;
  }
  if (status == Status.DETACHED) {
    Log.w(TAG,"Peer expected signal when closed; unable to deliver after detach");
  }
  try {
    try {
      if (status != Status.SILENCE) {
        final byte[] buf=getOrCreateStatusBuffer();
        int writePtr=0;
        Memory.pokeInt(buf,writePtr,status,ByteOrder.BIG_ENDIAN);
        writePtr+=4;
        if (msg != null) {
          final byte[] rawMsg=msg.getBytes();
          final int len=Math.min(rawMsg.length,buf.length - writePtr);
          System.arraycopy(rawMsg,0,buf,writePtr,len);
          writePtr+=len;
        }
        Libcore.os.write(mCommFd,buf,0,writePtr);
      }
    }
 catch (    ErrnoException e) {
      Log.w(TAG,"Failed to report status: " + e);
    }
    if (status != Status.SILENCE) {
      mStatus=readCommStatus(mCommFd,getOrCreateStatusBuffer());
    }
  }
  finally {
    IoUtils.closeQuietly(mCommFd);
    mCommFd=null;
  }
}
