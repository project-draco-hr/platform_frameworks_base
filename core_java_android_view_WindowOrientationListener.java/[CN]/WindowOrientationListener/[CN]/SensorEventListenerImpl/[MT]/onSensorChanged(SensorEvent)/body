{
  float[] values=event.values;
  float X=values[_DATA_X];
  float Y=values[_DATA_Y];
  float Z=values[_DATA_Z];
  float OneEightyOverPi=57.29577957855f;
  float gravity=(float)Math.sqrt(X * X + Y * Y + Z * Z);
  float zyangle=(float)Math.asin(Z / gravity) * OneEightyOverPi;
  int rotation=-1;
  if ((zyangle <= PIVOT_UPPER) && (zyangle >= PIVOT_LOWER)) {
    float angle=(float)Math.atan2(Y,-X) * OneEightyOverPi;
    int orientation=90 - (int)Math.round(angle);
    while (orientation >= 360) {
      orientation-=360;
    }
    while (orientation < 0) {
      orientation+=360;
    }
    if ((orientation >= PL_LOWER) && (orientation <= LP_UPPER)) {
      float threshold;
      float delta=zyangle - PIVOT;
      if (mSensorRotation == Surface.ROTATION_90) {
        if (delta < 0) {
          threshold=LP_LOWER - (LP_LF_LOWER * delta);
        }
 else {
          threshold=LP_LOWER + (LP_LF_UPPER * delta);
        }
        rotation=(orientation >= threshold) ? Surface.ROTATION_0 : Surface.ROTATION_90;
      }
 else {
        if (delta < 0) {
          threshold=PL_UPPER + (PL_LF_LOWER * delta);
        }
 else {
          threshold=PL_UPPER - (PL_LF_UPPER * delta);
        }
        rotation=(orientation <= threshold) ? Surface.ROTATION_90 : Surface.ROTATION_0;
      }
    }
 else     if ((orientation >= LANDSCAPE_LOWER) && (orientation < LP_LOWER)) {
      rotation=Surface.ROTATION_90;
    }
 else     if ((orientation >= PL_UPPER) || (orientation <= PORTRAIT_LOWER)) {
      rotation=Surface.ROTATION_0;
    }
    if ((rotation != -1) && (rotation != mSensorRotation)) {
      mSensorRotation=rotation;
      onOrientationChanged(mSensorRotation);
    }
  }
}
