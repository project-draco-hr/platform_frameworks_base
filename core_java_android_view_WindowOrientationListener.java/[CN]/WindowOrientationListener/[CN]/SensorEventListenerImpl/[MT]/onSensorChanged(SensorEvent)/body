{
  final boolean log=mOrientationListener.mLogEnabled;
  float x=event.values[ACCELEROMETER_DATA_X];
  float y=event.values[ACCELEROMETER_DATA_Y];
  float z=event.values[ACCELEROMETER_DATA_Z];
  if (log) {
    Slog.v(TAG,"Raw acceleration vector: " + "x=" + x + ", y="+ y+ ", z="+ z);
  }
  final long now=event.timestamp;
  final float timeDeltaMS=(now - mLastTimestamp) * 0.000001f;
  boolean skipSample;
  if (timeDeltaMS <= 0 || timeDeltaMS > MAX_FILTER_DELTA_TIME_MS || (x == 0 && y == 0 && z == 0)) {
    if (log) {
      Slog.v(TAG,"Resetting orientation listener.");
    }
    clearProposal();
    skipSample=true;
  }
 else {
    final float alpha=timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS);
    x=alpha * (x - mLastFilteredX) + mLastFilteredX;
    y=alpha * (y - mLastFilteredY) + mLastFilteredY;
    z=alpha * (z - mLastFilteredZ) + mLastFilteredZ;
    if (log) {
      Slog.v(TAG,"Filtered acceleration vector: " + "x=" + x + ", y="+ y+ ", z="+ z);
    }
    skipSample=false;
  }
  mLastTimestamp=now;
  mLastFilteredX=x;
  mLastFilteredY=y;
  mLastFilteredZ=z;
  final int oldProposedRotation=getProposedRotation();
  if (!skipSample) {
    final float magnitude=(float)Math.sqrt(x * x + y * y + z * z);
    if (magnitude < MIN_ACCELERATION_MAGNITUDE || magnitude > MAX_ACCELERATION_MAGNITUDE) {
      if (log) {
        Slog.v(TAG,"Ignoring sensor data, magnitude out of range: " + "magnitude=" + magnitude);
      }
      clearProposal();
    }
 else {
      final int tiltAngle=(int)Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
      if (Math.abs(tiltAngle) > MAX_TILT) {
        if (log) {
          Slog.v(TAG,"Ignoring sensor data, tilt angle too high: " + "magnitude=" + magnitude + ", tiltAngle="+ tiltAngle);
        }
        clearProposal();
      }
 else {
        int orientationAngle=(int)Math.round(-Math.atan2(-x,y) * RADIANS_TO_DEGREES);
        if (orientationAngle < 0) {
          orientationAngle+=360;
        }
        int nearestRotation=(orientationAngle + 45) / 90;
        if (nearestRotation == 4) {
          nearestRotation=0;
        }
        if (!isTiltAngleAcceptable(nearestRotation,tiltAngle) || !isOrientationAngleAcceptable(nearestRotation,orientationAngle)) {
          if (log) {
            Slog.v(TAG,"Ignoring sensor data, no proposal: " + "magnitude=" + magnitude + ", tiltAngle="+ tiltAngle+ ", orientationAngle="+ orientationAngle);
          }
          clearProposal();
        }
 else {
          if (log) {
            Slog.v(TAG,"Proposal: " + "magnitude=" + magnitude + ", tiltAngle="+ tiltAngle+ ", orientationAngle="+ orientationAngle+ ", proposalRotation="+ mProposalRotation);
          }
          updateProposal(nearestRotation,now / 1000000L,magnitude,tiltAngle,orientationAngle);
        }
      }
    }
  }
  final int proposedRotation=getProposedRotation();
  if (log) {
    final float proposalConfidence=Math.min(mProposalAgeMS * 1.0f / SETTLE_TIME_MS,1.0f);
    Slog.v(TAG,"Result: currentRotation=" + mOrientationListener.mCurrentRotation + ", proposedRotation="+ proposedRotation+ ", timeDeltaMS="+ timeDeltaMS+ ", proposalRotation="+ mProposalRotation+ ", proposalAgeMS="+ mProposalAgeMS+ ", proposalConfidence="+ proposalConfidence);
  }
  if (proposedRotation != oldProposedRotation && proposedRotation >= 0) {
    if (log) {
      Slog.v(TAG,"Proposed rotation changed!  proposedRotation=" + proposedRotation + ", oldProposedRotation="+ oldProposedRotation);
    }
    mOrientationListener.onProposedRotationChanged(proposedRotation);
  }
}
