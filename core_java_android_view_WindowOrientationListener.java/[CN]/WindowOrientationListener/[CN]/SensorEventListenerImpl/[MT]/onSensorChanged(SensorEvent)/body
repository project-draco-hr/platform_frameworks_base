{
  float x=event.values[_DATA_X];
  float y=event.values[_DATA_Y];
  float z=event.values[_DATA_Z];
  float magnitude=vectorMagnitude(x,y,z);
  float deviation=Math.abs(magnitude - SensorManager.STANDARD_GRAVITY);
  float tiltAngle=tiltAngle(z,magnitude);
  float alpha=DEFAULT_LOWPASS_ALPHA;
  if (tiltAngle > MAX_TILT) {
    return;
  }
 else   if (deviation > MAX_DEVIATION_FROM_GRAVITY) {
    alpha=ACCELERATING_LOWPASS_ALPHA;
  }
 else   if (tiltAngle > PARTIAL_TILT) {
    alpha=TILTED_LOWPASS_ALPHA;
  }
  x=mFilteredVector[0]=lowpassFilter(x,mFilteredVector[0],alpha);
  y=mFilteredVector[1]=lowpassFilter(y,mFilteredVector[1],alpha);
  z=mFilteredVector[2]=lowpassFilter(z,mFilteredVector[2],alpha);
  magnitude=vectorMagnitude(x,y,z);
  tiltAngle=tiltAngle(z,magnitude);
  float orientationAngle=(float)Math.atan2(-x,y) * RADIANS_TO_DEGREES;
  int orientation=Math.round(orientationAngle);
  if (orientation < 0) {
    orientation+=360;
  }
  calculateNewRotation(orientation,Math.round(tiltAngle));
}
