{
  final int version=in.readInt();
  if (version != VERSION) {
    Slog.w("BatteryStats","readFromParcel: version got " + version + ", expected "+ VERSION+ "; erasing old stats");
    return;
  }
  readHistory(in,true);
  mStartCount=in.readInt();
  mUptime=in.readLong();
  mRealtime=in.readLong();
  mStartClockTime=in.readLong();
  mStartPlatformVersion=in.readString();
  mEndPlatformVersion=in.readString();
  mOnBatteryTimeBase.readSummaryFromParcel(in);
  mOnBatteryScreenOffTimeBase.readSummaryFromParcel(in);
  mDischargeUnplugLevel=in.readInt();
  mDischargePlugLevel=in.readInt();
  mDischargeCurrentLevel=in.readInt();
  mCurrentBatteryLevel=in.readInt();
  mLowDischargeAmountSinceCharge=in.readInt();
  mHighDischargeAmountSinceCharge=in.readInt();
  mDischargeAmountScreenOnSinceCharge=in.readInt();
  mDischargeAmountScreenOffSinceCharge=in.readInt();
  mNumDischargeStepDurations=in.readInt();
  in.readLongArray(mDischargeStepDurations);
  mNumChargeStepDurations=in.readInt();
  in.readLongArray(mChargeStepDurations);
  mStartCount++;
  mScreenState=Display.STATE_UNKNOWN;
  mScreenOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
    mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
  }
  mInteractive=false;
  mInteractiveTimer.readSummaryFromParcelLocked(in);
  mPhoneOn=false;
  mLowPowerModeEnabledTimer.readSummaryFromParcelLocked(in);
  mPhoneOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
    mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_DATA_CONNECTION_TYPES; i++) {
    mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
    mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
    mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
  }
  mMobileRadioPowerState=DataConnectionRealTimeInfo.DC_POWER_STATE_LOW;
  mMobileRadioActiveTimer.readSummaryFromParcelLocked(in);
  mMobileRadioActivePerAppTimer.readSummaryFromParcelLocked(in);
  mMobileRadioActiveAdjustedTime.readSummaryFromParcelLocked(in);
  mMobileRadioActiveUnknownTime.readSummaryFromParcelLocked(in);
  mMobileRadioActiveUnknownCount.readSummaryFromParcelLocked(in);
  mWifiOn=false;
  mWifiOnTimer.readSummaryFromParcelLocked(in);
  mGlobalWifiRunning=false;
  mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_WIFI_STATES; i++) {
    mWifiStateTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_WIFI_SUPPL_STATES; i++) {
    mWifiSupplStateTimer[i].readSummaryFromParcelLocked(in);
  }
  for (int i=0; i < NUM_WIFI_SIGNAL_STRENGTH_BINS; i++) {
    mWifiSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
  }
  mBluetoothOn=false;
  mBluetoothOnTimer.readSummaryFromParcelLocked(in);
  for (int i=0; i < NUM_BLUETOOTH_STATES; i++) {
    mBluetoothStateTimer[i].readSummaryFromParcelLocked(in);
  }
  mNumConnectivityChange=mLoadedNumConnectivityChange=in.readInt();
  mFlashlightOn=false;
  mFlashlightOnTimer.readSummaryFromParcelLocked(in);
  int NKW=in.readInt();
  if (NKW > 10000) {
    Slog.w(TAG,"File corrupt: too many kernel wake locks " + NKW);
    return;
  }
  for (int ikw=0; ikw < NKW; ikw++) {
    if (in.readInt() != 0) {
      String kwltName=in.readString();
      getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
    }
  }
  int NWR=in.readInt();
  if (NWR > 10000) {
    Slog.w(TAG,"File corrupt: too many wakeup reasons " + NWR);
    return;
  }
  for (int iwr=0; iwr < NWR; iwr++) {
    if (in.readInt() != 0) {
      String reasonName=in.readString();
      getWakeupReasonTimerLocked(reasonName).readSummaryFromParcelLocked(in);
    }
  }
  sNumSpeedSteps=in.readInt();
  if (sNumSpeedSteps < 0 || sNumSpeedSteps > 100) {
    throw new BadParcelableException("Bad speed steps in data: " + sNumSpeedSteps);
  }
  final int NU=in.readInt();
  if (NU > 10000) {
    Slog.w(TAG,"File corrupt: too many uids " + NU);
    return;
  }
  for (int iu=0; iu < NU; iu++) {
    int uid=in.readInt();
    Uid u=new Uid(uid);
    mUidStats.put(uid,u);
    u.mWifiRunning=false;
    if (in.readInt() != 0) {
      u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
    }
    u.mFullWifiLockOut=false;
    if (in.readInt() != 0) {
      u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiScanStarted=false;
    if (in.readInt() != 0) {
      u.mWifiScanTimer.readSummaryFromParcelLocked(in);
    }
    u.mWifiBatchedScanBinStarted=Uid.NO_BATCHED_SCAN_STARTED;
    for (int i=0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
      if (in.readInt() != 0) {
        u.makeWifiBatchedScanBin(i,null);
        u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    u.mWifiMulticastEnabled=false;
    if (in.readInt() != 0) {
      u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
    }
    u.mProcessState=Uid.PROCESS_STATE_NONE;
    for (int i=0; i < Uid.NUM_PROCESS_STATE; i++) {
      if (in.readInt() != 0) {
        u.makeProcessState(i,null);
        u.mProcessStateTimer[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
    }
    if (in.readInt() != 0) {
      if (u.mUserActivityCounters == null) {
        u.initUserActivityLocked();
      }
      for (int i=0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
        u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
      }
    }
    if (in.readInt() != 0) {
      if (u.mNetworkByteActivityCounters == null) {
        u.initNetworkActivityLocked();
      }
      for (int i=0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        u.mNetworkByteActivityCounters[i].readSummaryFromParcelLocked(in);
        u.mNetworkPacketActivityCounters[i].readSummaryFromParcelLocked(in);
      }
      u.mMobileRadioActiveTime.readSummaryFromParcelLocked(in);
      u.mMobileRadioActiveCount.readSummaryFromParcelLocked(in);
    }
    int NW=in.readInt();
    if (NW > 100) {
      Slog.w(TAG,"File corrupt: too many wake locks " + NW);
      return;
    }
    for (int iw=0; iw < NW; iw++) {
      String wlName=in.readString();
      u.readWakeSummaryFromParcelLocked(wlName,in);
    }
    int NS=in.readInt();
    if (NS > 100) {
      Slog.w(TAG,"File corrupt: too many syncs " + NS);
      return;
    }
    for (int is=0; is < NS; is++) {
      String name=in.readString();
      u.readSyncSummaryFromParcelLocked(name,in);
    }
    int NJ=in.readInt();
    if (NJ > 100) {
      Slog.w(TAG,"File corrupt: too many job timers " + NJ);
      return;
    }
    for (int ij=0; ij < NJ; ij++) {
      String name=in.readString();
      u.readJobSummaryFromParcelLocked(name,in);
    }
    int NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,"File corrupt: too many sensors " + NP);
      return;
    }
    for (int is=0; is < NP; is++) {
      int seNumber=in.readInt();
      if (in.readInt() != 0) {
        u.getSensorTimerLocked(seNumber,true).readSummaryFromParcelLocked(in);
      }
    }
    NP=in.readInt();
    if (NP > 1000) {
      Slog.w(TAG,"File corrupt: too many processes " + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String procName=in.readString();
      Uid.Proc p=u.getProcessStatsLocked(procName);
      p.mUserTime=p.mLoadedUserTime=in.readLong();
      p.mSystemTime=p.mLoadedSystemTime=in.readLong();
      p.mForegroundTime=p.mLoadedForegroundTime=in.readLong();
      p.mStarts=p.mLoadedStarts=in.readInt();
      p.mNumCrashes=p.mLoadedNumCrashes=in.readInt();
      p.mNumAnrs=p.mLoadedNumAnrs=in.readInt();
      int NSB=in.readInt();
      if (NSB > 100) {
        Slog.w(TAG,"File corrupt: too many speed bins " + NSB);
        return;
      }
      p.mSpeedBins=new SamplingCounter[NSB];
      for (int i=0; i < NSB; i++) {
        if (in.readInt() != 0) {
          p.mSpeedBins[i]=new SamplingCounter(mOnBatteryTimeBase);
          p.mSpeedBins[i].readSummaryFromParcelLocked(in);
        }
      }
      if (!p.readExcessivePowerFromParcelLocked(in)) {
        return;
      }
    }
    NP=in.readInt();
    if (NP > 10000) {
      Slog.w(TAG,"File corrupt: too many packages " + NP);
      return;
    }
    for (int ip=0; ip < NP; ip++) {
      String pkgName=in.readString();
      Uid.Pkg p=u.getPackageStatsLocked(pkgName);
      p.mWakeups=p.mLoadedWakeups=in.readInt();
      NS=in.readInt();
      if (NS > 1000) {
        Slog.w(TAG,"File corrupt: too many services " + NS);
        return;
      }
      for (int is=0; is < NS; is++) {
        String servName=in.readString();
        Uid.Pkg.Serv s=u.getServiceStatsLocked(pkgName,servName);
        s.mStartTime=s.mLoadedStartTime=in.readLong();
        s.mStarts=s.mLoadedStarts=in.readInt();
        s.mLaunches=s.mLoadedLaunches=in.readInt();
      }
    }
  }
}
