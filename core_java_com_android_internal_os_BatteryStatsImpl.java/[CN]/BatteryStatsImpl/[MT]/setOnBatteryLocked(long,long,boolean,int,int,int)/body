{
  boolean doWrite=false;
  Message m=mHandler.obtainMessage(MSG_REPORT_POWER_CHANGE);
  m.arg1=onBattery ? 1 : 0;
  mHandler.sendMessage(m);
  final long uptime=mSecUptime * 1000;
  final long realtime=mSecRealtime * 1000;
  final boolean screenOn=mScreenState == Display.STATE_ON;
  if (onBattery) {
    boolean reset=false;
    if (!mNoAutoReset && (oldStatus == BatteryManager.BATTERY_STATUS_FULL || level >= 90 || (mDischargeCurrentLevel < 20 && level >= 80) || (getHighDischargeAmountSinceCharge() >= 200 && mHistoryBuffer.dataSize() >= MAX_HISTORY_BUFFER))) {
      Slog.i(TAG,"Resetting battery stats: level=" + level + " status="+ oldStatus+ " dischargeLevel="+ mDischargeCurrentLevel+ " lowAmount="+ getLowDischargeAmountSinceCharge()+ " highAmount="+ getHighDischargeAmountSinceCharge());
      if (getLowDischargeAmountSinceCharge() >= 20) {
        final Parcel parcel=Parcel.obtain();
        writeSummaryToParcel(parcel,true);
        BackgroundThread.getHandler().post(new Runnable(){
          @Override public void run(){
synchronized (mCheckinFile) {
              FileOutputStream stream=null;
              try {
                stream=mCheckinFile.startWrite();
                stream.write(parcel.marshall());
                stream.flush();
                FileUtils.sync(stream);
                stream.close();
                mCheckinFile.finishWrite(stream);
              }
 catch (              IOException e) {
                Slog.w("BatteryStats","Error writing checkin battery statistics",e);
                mCheckinFile.failWrite(stream);
              }
 finally {
                parcel.recycle();
              }
            }
          }
        }
);
      }
      doWrite=true;
      resetAllStatsLocked();
      if (chargeUAh > 0) {
        mEstimatedBatteryCapacity=(int)((level / 100.0) * (chargeUAh / 1000));
      }
      mDischargeStartLevel=level;
      reset=true;
      mDischargeStepTracker.init();
    }
    if (mCharging) {
      setChargingLocked(false);
    }
    mLastChargingStateLevel=level;
    mOnBattery=mOnBatteryInternal=true;
    mLastDischargeStepLevel=level;
    mMinDischargeStepLevel=level;
    mDischargeStepTracker.clearTime();
    mDailyDischargeStepTracker.clearTime();
    mInitStepMode=mCurStepMode;
    mModStepMode=0;
    pullPendingStateUpdatesLocked();
    mHistoryCur.batteryLevel=(byte)level;
    mHistoryCur.states&=~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,"Battery unplugged to: " + Integer.toHexString(mHistoryCur.states));
    if (reset) {
      mRecordingHistory=true;
      startRecordingHistory(mSecRealtime,mSecUptime,reset);
    }
    addHistoryRecordLocked(mSecRealtime,mSecUptime);
    mDischargeCurrentLevel=mDischargeUnplugLevel=level;
    if (screenOn) {
      mDischargeScreenOnUnplugLevel=level;
      mDischargeScreenOffUnplugLevel=0;
    }
 else {
      mDischargeScreenOnUnplugLevel=0;
      mDischargeScreenOffUnplugLevel=level;
    }
    mDischargeAmountScreenOn=0;
    mDischargeAmountScreenOff=0;
    updateTimeBasesLocked(true,!screenOn,uptime,realtime);
  }
 else {
    mLastChargingStateLevel=level;
    mOnBattery=mOnBatteryInternal=false;
    pullPendingStateUpdatesLocked();
    mHistoryCur.batteryLevel=(byte)level;
    mHistoryCur.states|=HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
    if (DEBUG_HISTORY)     Slog.v(TAG,"Battery plugged to: " + Integer.toHexString(mHistoryCur.states));
    addHistoryRecordLocked(mSecRealtime,mSecUptime);
    mDischargeCurrentLevel=mDischargePlugLevel=level;
    if (level < mDischargeUnplugLevel) {
      mLowDischargeAmountSinceCharge+=mDischargeUnplugLevel - level - 1;
      mHighDischargeAmountSinceCharge+=mDischargeUnplugLevel - level;
    }
    updateDischargeScreenLevelsLocked(screenOn,screenOn);
    updateTimeBasesLocked(false,!screenOn,uptime,realtime);
    mChargeStepTracker.init();
    mLastChargeStepLevel=level;
    mMaxChargeStepLevel=level;
    mInitStepMode=mCurStepMode;
    mModStepMode=0;
  }
  if (doWrite || (mLastWriteTime + (60 * 1000)) < mSecRealtime) {
    if (mFile != null) {
      writeAsyncLocked();
    }
  }
}
