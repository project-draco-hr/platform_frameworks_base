{
  int drawableRes=0;
  int fromId=0;
  int toId=0;
  boolean reversible=false;
  final int numAttrs=attrs.getAttributeCount();
  for (int i=0; i < numAttrs; i++) {
    final int stateResId=attrs.getAttributeNameResource(i);
switch (stateResId) {
case 0:
      break;
case R.attr.fromId:
    fromId=attrs.getAttributeResourceValue(i,0);
  break;
case R.attr.toId:
toId=attrs.getAttributeResourceValue(i,0);
break;
case R.attr.drawable:
drawableRes=attrs.getAttributeResourceValue(i,0);
break;
case R.attr.reversible:
reversible=attrs.getAttributeBooleanValue(i,false);
break;
}
}
final Drawable dr;
if (drawableRes != 0) {
dr=r.getDrawable(drawableRes);
}
 else {
int type;
while ((type=parser.next()) == XmlPullParser.TEXT) {
}
if (type != XmlPullParser.START_TAG) {
throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
}
dr=Drawable.createFromXmlInnerThemed(r,parser,attrs,theme);
}
final AnimationDrawable anim;
if (dr instanceof AnimationDrawable) {
anim=(AnimationDrawable)dr;
}
 else {
throw new XmlPullParserException(parser.getPositionDescription() + ": <transition> tag requires a 'drawable' attribute or " + "child tag defining a drawable of type <animation>");
}
return mState.addTransition(fromId,toId,anim,reversible);
}
