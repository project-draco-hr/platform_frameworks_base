{
  int drawableRes=0;
  int keyframeId=0;
  int j=0;
  final int numAttrs=attrs.getAttributeCount();
  int[] states=new int[numAttrs];
  for (int i=0; i < numAttrs; i++) {
    final int stateResId=attrs.getAttributeNameResource(i);
switch (stateResId) {
case 0:
      break;
case R.attr.id:
    keyframeId=attrs.getAttributeResourceValue(i,0);
  break;
case R.attr.drawable:
drawableRes=attrs.getAttributeResourceValue(i,0);
break;
default :
final boolean hasState=attrs.getAttributeBooleanValue(i,false);
states[j++]=hasState ? stateResId : -stateResId;
}
}
states=StateSet.trimStateSet(states,j);
final Drawable dr;
if (drawableRes != 0) {
dr=r.getDrawable(drawableRes);
}
 else {
int type;
while ((type=parser.next()) == XmlPullParser.TEXT) {
}
if (type != XmlPullParser.START_TAG) {
throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
}
dr=Drawable.createFromXmlInnerThemed(r,parser,attrs,theme);
}
return mState.addStateSet(states,dr,keyframeId);
}
