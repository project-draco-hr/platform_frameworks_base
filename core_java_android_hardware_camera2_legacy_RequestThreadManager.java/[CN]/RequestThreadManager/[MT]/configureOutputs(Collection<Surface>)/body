{
  if (DEBUG) {
    String outputsStr=outputs == null ? "null" : (outputs.size() + " surfaces");
    Log.d(TAG,"configureOutputs with " + outputsStr);
  }
  stopPreview();
  try {
    mCamera.setPreviewTexture(null);
  }
 catch (  IOException e) {
    Log.w(TAG,"Failed to clear prior SurfaceTexture, may cause GL deadlock: ",e);
  }
  if (mGLThreadManager != null) {
    mGLThreadManager.waitUntilStarted();
    mGLThreadManager.ignoreNewFrames();
    mGLThreadManager.waitUntilIdle();
  }
  resetJpegSurfaceFormats(mCallbackOutputs);
  mPreviewOutputs.clear();
  mCallbackOutputs.clear();
  mPreviewTexture=null;
  int facing=mCharacteristics.get(CameraCharacteristics.LENS_FACING);
  int orientation=mCharacteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
  if (outputs != null) {
    for (    Surface s : outputs) {
      try {
        int format=LegacyCameraDevice.detectSurfaceType(s);
        LegacyCameraDevice.setSurfaceOrientation(s,facing,orientation);
switch (format) {
case CameraMetadataNative.NATIVE_JPEG_FORMAT:
          if (USE_BLOB_FORMAT_OVERRIDE) {
            LegacyCameraDevice.setSurfaceFormat(s,LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888);
          }
        mJpegSurfaceIds.add(LegacyCameraDevice.getSurfaceId(s));
      mCallbackOutputs.add(s);
    break;
default :
  mPreviewOutputs.add(s);
break;
}
}
 catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
Log.w(TAG,"Surface abandoned, skipping...",e);
}
}
}
try {
mParams=mCamera.getParameters();
}
 catch (RuntimeException e) {
Log.e(TAG,"Received device exception: ",e);
mDeviceState.setError(CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_DEVICE);
return;
}
List<int[]> supportedFpsRanges=mParams.getSupportedPreviewFpsRange();
int[] bestRange=getPhotoPreviewFpsRange(supportedFpsRanges);
if (DEBUG) {
Log.d(TAG,"doPreviewCapture - Selected range [" + bestRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX] + ","+ bestRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]+ "]");
}
mParams.setPreviewFpsRange(bestRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],bestRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
if (mPreviewOutputs.size() > 0) {
List<Size> outputSizes=new ArrayList<>(outputs.size());
for (Surface s : mPreviewOutputs) {
try {
Size size=LegacyCameraDevice.getSurfaceSize(s);
outputSizes.add(size);
}
 catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
Log.w(TAG,"Surface abandoned, skipping...",e);
}
}
Size largestOutput=SizeAreaComparator.findLargestByArea(outputSizes);
Size largestJpegDimen=ParameterUtils.getLargestSupportedJpegSizeByArea(mParams);
List<Size> supportedPreviewSizes=ParameterUtils.convertSizeList(mParams.getSupportedPreviewSizes());
long largestOutputArea=largestOutput.getHeight() * (long)largestOutput.getWidth();
Size bestPreviewDimen=SizeAreaComparator.findLargestByArea(supportedPreviewSizes);
for (Size s : supportedPreviewSizes) {
long currArea=s.getWidth() * s.getHeight();
long bestArea=bestPreviewDimen.getWidth() * bestPreviewDimen.getHeight();
if (checkAspectRatiosMatch(largestJpegDimen,s) && (currArea < bestArea && currArea >= largestOutputArea)) {
bestPreviewDimen=s;
}
}
mIntermediateBufferSize=bestPreviewDimen;
mParams.setPreviewSize(mIntermediateBufferSize.getWidth(),mIntermediateBufferSize.getHeight());
if (DEBUG) {
Log.d(TAG,"Intermediate buffer selected with dimens: " + bestPreviewDimen.toString());
}
}
 else {
mIntermediateBufferSize=null;
if (DEBUG) {
Log.d(TAG,"No Intermediate buffer selected, no preview outputs were configured");
}
}
Size smallestSupportedJpegSize=calculatePictureSize(mCallbackOutputs,mParams);
if (smallestSupportedJpegSize != null) {
Log.i(TAG,"configureOutputs - set take picture size to " + smallestSupportedJpegSize);
mParams.setPictureSize(smallestSupportedJpegSize.getWidth(),smallestSupportedJpegSize.getHeight());
}
if (mGLThreadManager == null) {
mGLThreadManager=new GLThreadManager(mCameraId,facing,mDeviceState);
mGLThreadManager.start();
}
mGLThreadManager.waitUntilStarted();
mGLThreadManager.setConfigurationAndWait(mPreviewOutputs,mCaptureCollector);
mGLThreadManager.allowNewFrames();
mPreviewTexture=mGLThreadManager.getCurrentSurfaceTexture();
if (mPreviewTexture != null) {
mPreviewTexture.setOnFrameAvailableListener(mPreviewCallback);
}
mCamera.setParameters(mParams);
}
