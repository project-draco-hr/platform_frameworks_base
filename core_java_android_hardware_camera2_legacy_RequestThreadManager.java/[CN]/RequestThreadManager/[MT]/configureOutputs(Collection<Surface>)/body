{
  stopPreview();
  if (mGLThreadManager != null) {
    mGLThreadManager.waitUntilStarted();
    mGLThreadManager.ignoreNewFrames();
    mGLThreadManager.waitUntilIdle();
  }
  mPreviewOutputs.clear();
  mCallbackOutputs.clear();
  mPreviewTexture=null;
  mInFlightPreview=null;
  mInFlightJpeg=null;
  if (outputs != null) {
    for (    Surface s : outputs) {
      int format=LegacyCameraDevice.nativeDetectSurfaceType(s);
switch (format) {
case CameraMetadataNative.NATIVE_JPEG_FORMAT:
        mCallbackOutputs.add(s);
      break;
default :
    mPreviewOutputs.add(s);
  break;
}
}
}
mParams=mCamera.getParameters();
if (mPreviewOutputs.size() > 0) {
List<Size> outputSizes=new ArrayList<>(outputs.size());
for (Surface s : mPreviewOutputs) {
int[] dimens={0,0};
LegacyCameraDevice.nativeDetectSurfaceDimens(s,dimens);
outputSizes.add(new Size(dimens[0],dimens[1]));
}
Size largestOutput=findLargestByArea(outputSizes);
List<Size> supportedJpegSizes=convertSizeList(mParams.getSupportedPictureSizes());
Size largestJpegDimen=findLargestByArea(supportedJpegSizes);
List<Size> supportedPreviewSizes=convertSizeList(mParams.getSupportedPreviewSizes());
long largestOutputArea=largestOutput.getHeight() * (long)largestOutput.getWidth();
Size bestPreviewDimen=findLargestByArea(supportedPreviewSizes);
for (Size s : supportedPreviewSizes) {
long currArea=s.getWidth() * s.getHeight();
long bestArea=bestPreviewDimen.getWidth() * bestPreviewDimen.getHeight();
if (checkAspectRatiosMatch(largestJpegDimen,s) && (currArea < bestArea && currArea >= largestOutputArea)) {
bestPreviewDimen=s;
}
}
mIntermediateBufferSize=bestPreviewDimen;
if (DEBUG) {
Log.d(TAG,"Intermediate buffer selected with dimens: " + bestPreviewDimen.toString());
}
}
 else {
mIntermediateBufferSize=null;
if (DEBUG) {
Log.d(TAG,"No Intermediate buffer selected, no preview outputs were configured");
}
}
if (mGLThreadManager == null) {
mGLThreadManager=new GLThreadManager(mCameraId);
mGLThreadManager.start();
}
mGLThreadManager.waitUntilStarted();
mGLThreadManager.setConfigurationAndWait(mPreviewOutputs);
mGLThreadManager.allowNewFrames();
mPreviewTexture=mGLThreadManager.getCurrentSurfaceTexture();
if (mPreviewTexture != null) {
mPreviewTexture.setOnFrameAvailableListener(mPreviewCallback);
}
}
