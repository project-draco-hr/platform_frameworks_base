{
  if (DEBUG) {
    String outputsStr=outputs == null ? "null" : (outputs.size() + " surfaces");
    Log.d(TAG,"configureOutputs with " + outputsStr);
  }
  try {
    startPreview();
    stopPreview();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,"Received device exception in configure call: ",e);
    mDeviceState.setError(CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_DEVICE);
    return;
  }
  try {
    mCamera.setPreviewTexture(null);
  }
 catch (  IOException e) {
    Log.w(TAG,"Failed to clear prior SurfaceTexture, may cause GL deadlock: ",e);
  }
catch (  RuntimeException e) {
    Log.e(TAG,"Received device exception in configure call: ",e);
    mDeviceState.setError(CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_DEVICE);
    return;
  }
  if (mGLThreadManager != null) {
    mGLThreadManager.waitUntilStarted();
    mGLThreadManager.ignoreNewFrames();
    mGLThreadManager.waitUntilIdle();
  }
  resetJpegSurfaceFormats(mCallbackOutputs);
  mPreviewOutputs.clear();
  mCallbackOutputs.clear();
  mJpegSurfaceIds.clear();
  mPreviewTexture=null;
  List<Size> previewOutputSizes=new ArrayList<>();
  List<Size> callbackOutputSizes=new ArrayList<>();
  int facing=mCharacteristics.get(CameraCharacteristics.LENS_FACING);
  int orientation=mCharacteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
  if (outputs != null) {
    for (    Pair<Surface,Size> outPair : outputs) {
      Surface s=outPair.first;
      Size outSize=outPair.second;
      try {
        int format=LegacyCameraDevice.detectSurfaceType(s);
        LegacyCameraDevice.setSurfaceOrientation(s,facing,orientation);
switch (format) {
case CameraMetadataNative.NATIVE_JPEG_FORMAT:
          if (USE_BLOB_FORMAT_OVERRIDE) {
            LegacyCameraDevice.setSurfaceFormat(s,LegacyMetadataMapper.HAL_PIXEL_FORMAT_RGBA_8888);
          }
        mJpegSurfaceIds.add(LegacyCameraDevice.getSurfaceId(s));
      mCallbackOutputs.add(s);
    callbackOutputSizes.add(outSize);
  break;
default :
mPreviewOutputs.add(s);
previewOutputSizes.add(outSize);
break;
}
}
 catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
Log.w(TAG,"Surface abandoned, skipping...",e);
}
}
}
try {
mParams=mCamera.getParameters();
}
 catch (RuntimeException e) {
Log.e(TAG,"Received device exception: ",e);
mDeviceState.setError(CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_DEVICE);
return;
}
List<int[]> supportedFpsRanges=mParams.getSupportedPreviewFpsRange();
int[] bestRange=getPhotoPreviewFpsRange(supportedFpsRanges);
if (DEBUG) {
Log.d(TAG,"doPreviewCapture - Selected range [" + bestRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX] + ","+ bestRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]+ "]");
}
mParams.setPreviewFpsRange(bestRange[Camera.Parameters.PREVIEW_FPS_MIN_INDEX],bestRange[Camera.Parameters.PREVIEW_FPS_MAX_INDEX]);
if (previewOutputSizes.size() > 0) {
Size largestOutput=SizeAreaComparator.findLargestByArea(previewOutputSizes);
Size largestJpegDimen=ParameterUtils.getLargestSupportedJpegSizeByArea(mParams);
List<Size> supportedPreviewSizes=ParameterUtils.convertSizeList(mParams.getSupportedPreviewSizes());
long largestOutputArea=largestOutput.getHeight() * (long)largestOutput.getWidth();
Size bestPreviewDimen=SizeAreaComparator.findLargestByArea(supportedPreviewSizes);
for (Size s : supportedPreviewSizes) {
long currArea=s.getWidth() * s.getHeight();
long bestArea=bestPreviewDimen.getWidth() * bestPreviewDimen.getHeight();
if (checkAspectRatiosMatch(largestJpegDimen,s) && (currArea < bestArea && currArea >= largestOutputArea)) {
bestPreviewDimen=s;
}
}
mIntermediateBufferSize=bestPreviewDimen;
mParams.setPreviewSize(mIntermediateBufferSize.getWidth(),mIntermediateBufferSize.getHeight());
if (DEBUG) {
Log.d(TAG,"Intermediate buffer selected with dimens: " + bestPreviewDimen.toString());
}
}
 else {
mIntermediateBufferSize=null;
if (DEBUG) {
Log.d(TAG,"No Intermediate buffer selected, no preview outputs were configured");
}
}
Size smallestSupportedJpegSize=calculatePictureSize(mCallbackOutputs,callbackOutputSizes,mParams);
if (smallestSupportedJpegSize != null) {
Log.i(TAG,"configureOutputs - set take picture size to " + smallestSupportedJpegSize);
mParams.setPictureSize(smallestSupportedJpegSize.getWidth(),smallestSupportedJpegSize.getHeight());
}
if (mGLThreadManager == null) {
mGLThreadManager=new GLThreadManager(mCameraId,facing,mDeviceState);
mGLThreadManager.start();
}
mGLThreadManager.waitUntilStarted();
List<Pair<Surface,Size>> previews=new ArrayList<>();
Iterator<Size> previewSizeIter=previewOutputSizes.iterator();
for (Surface p : mPreviewOutputs) {
previews.add(new Pair<>(p,previewSizeIter.next()));
}
mGLThreadManager.setConfigurationAndWait(previews,mCaptureCollector);
mGLThreadManager.allowNewFrames();
mPreviewTexture=mGLThreadManager.getCurrentSurfaceTexture();
if (mPreviewTexture != null) {
mPreviewTexture.setOnFrameAvailableListener(mPreviewCallback);
}
try {
mCamera.setParameters(mParams);
}
 catch (RuntimeException e) {
Log.e(TAG,"Received device exception while configuring: ",e);
mDeviceState.setError(CameraDeviceImpl.CameraDeviceCallbacks.ERROR_CAMERA_DEVICE);
}
}
