{
  Log.i(TAG,"Calling uncrypt and monitoring the progress...");
  final RecoverySystem.ProgressListener progressListener=new RecoverySystem.ProgressListener(){
    @Override public void onProgress(    int status){
      if (status >= 0 && status < 100) {
        status=(int)(status * (100.0 - MOUNT_SERVICE_STOP_PERCENT) / 100);
        status+=MOUNT_SERVICE_STOP_PERCENT;
        CharSequence msg=mContext.getText(com.android.internal.R.string.reboot_to_update_package);
        sInstance.setRebootProgress(status,msg);
      }
 else       if (status == 100) {
        CharSequence msg=mContext.getText(com.android.internal.R.string.reboot_to_update_reboot);
        sInstance.setRebootProgress(status,msg);
      }
 else {
      }
    }
  }
;
  final boolean[] done=new boolean[1];
  done[0]=false;
  Thread t=new Thread(){
    @Override public void run(){
      RecoverySystem rs=(RecoverySystem)mContext.getSystemService(Context.RECOVERY_SERVICE);
      String filename=null;
      try {
        filename=FileUtils.readTextFile(RecoverySystem.UNCRYPT_PACKAGE_FILE,0,null);
        rs.processPackage(mContext,new File(filename),progressListener);
      }
 catch (      IOException e) {
        Log.e(TAG,"Error uncrypting file",e);
      }
      done[0]=true;
    }
  }
;
  t.start();
  try {
    t.join(MAX_UNCRYPT_WAIT_TIME);
  }
 catch (  InterruptedException unused) {
  }
  if (!done[0]) {
    Log.w(TAG,"Timed out waiting for uncrypt.");
    final int uncryptTimeoutError=100;
    String timeoutMessage=String.format("uncrypt_time: %d\n" + "uncrypt_error: %d\n",MAX_UNCRYPT_WAIT_TIME / 1000,uncryptTimeoutError);
    try {
      FileUtils.stringToFile(RecoverySystem.UNCRYPT_STATUS_FILE,timeoutMessage);
    }
 catch (    IOException e) {
      Log.e(TAG,"Failed to write timeout message to uncrypt status",e);
    }
  }
}
