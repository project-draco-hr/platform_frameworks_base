{
  ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mState.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    if (reqPackage != null && !reqPackage.equals(pkgMap.keyAt(ip))) {
      continue;
    }
    SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      PackageState state=procs.valueAt(iu);
      for (int iproc=0; iproc < state.mProcesses.size(); iproc++) {
        ProcessState proc=state.mProcesses.valueAt(iproc);
        if (proc.mCommonProcess != null) {
          proc=proc.mCommonProcess;
        }
        foundProcs.add(proc);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}
