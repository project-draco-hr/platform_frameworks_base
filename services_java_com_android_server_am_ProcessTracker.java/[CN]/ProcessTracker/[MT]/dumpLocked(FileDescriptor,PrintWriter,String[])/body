{
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean includeCommitted=false;
  boolean dumpAll=false;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ADJ_SCREEN_OFF,ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=new int[]{STATE_PERSISTENT,STATE_TOP,STATE_FOREGROUND,STATE_VISIBLE,STATE_PERCEPTIBLE,STATE_BACKUP,STATE_SERVICE,STATE_HOME,STATE_PREVIOUS,STATE_CACHED};
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if ("--checkin".equals(arg)) {
        isCheckin=true;
      }
 else       if ("-c".equals(arg)) {
        isCompact=true;
      }
 else       if ("--csv".equals(arg)) {
        isCsv=true;
      }
 else       if ("--csv-screen".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --csv-screen");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ADJ_SCREEN_NAMES_CSV,ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println("Error in \"" + args[i] + "\": "+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if ("--csv-mem".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --csv-mem");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println("Error in \"" + args[i] + "\": "+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if ("--csv-proc".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --csv-proc");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println("Error in \"" + args[i] + "\": "+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if ("--include-committed".equals(arg)) {
        includeCommitted=true;
      }
 else       if ("--commit".equals(arg)) {
        mState.writeStateLocked(true,true);
        pw.println("Process stats committed.");
        return;
      }
 else       if ("--write".equals(arg)) {
        writeStateSyncLocked();
        pw.println("Process stats written.");
        return;
      }
 else       if ("--read".equals(arg)) {
        readLocked();
        pw.println("Process stats read.");
        return;
      }
 else       if ("-h".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if ("-a".equals(arg)) {
        dumpAll=true;
        includeCommitted=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println("Unknown option: " + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            includeCommitted=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println("Unknown package: " + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print("Processes running summed over");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(" ");
        printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(" ");
        printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(" ");
        pw.print(STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
    dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    return;
  }
  boolean sepNeeded=false;
  if (includeCommitted || isCheckin) {
    ArrayList<String> files=getCommittedFiles(0);
    if (files != null) {
      for (int i=0; i < files.size(); i++) {
        if (DEBUG)         Slog.d(TAG,"Retrieving state: " + files.get(i));
        try {
          State state=new State(files.get(i));
          if (isCheckin || isCompact) {
            state.dumpCheckinLocked(pw,reqPackage);
          }
 else {
            if (sepNeeded) {
              pw.println();
            }
 else {
              sepNeeded=true;
            }
            pw.print("COMMITTED STATS FROM ");
            pw.print(state.mTimePeriodStartClockStr);
            pw.println(":");
            state.dumpLocked(pw,reqPackage,dumpAll);
          }
          if (isCheckin) {
            state.mFile.delete();
          }
        }
 catch (        Throwable e) {
          pw.print("**** FAILURE DUMPING STATE: ");
          pw.println(files.get(i));
          e.printStackTrace(pw);
        }
        if (DEBUG)         Slog.d(TAG,"Deleting state: " + files.get(i));
      }
    }
  }
  if (!isCheckin) {
    if (isCompact) {
      mState.dumpCheckinLocked(pw,reqPackage);
    }
 else {
      if (sepNeeded) {
        pw.println();
        pw.println("CURRENT STATS:");
      }
      mState.dumpLocked(pw,reqPackage,dumpAll);
    }
  }
}
