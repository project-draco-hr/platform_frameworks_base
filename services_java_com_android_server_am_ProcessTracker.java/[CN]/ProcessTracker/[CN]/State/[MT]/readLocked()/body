{
  try {
    FileInputStream stream=mFile.openRead();
    byte[] raw=readFully(stream);
    Parcel in=Parcel.obtain();
    in.unmarshall(raw,0,raw.length);
    in.setDataPosition(0);
    stream.close();
    readFromParcel(in);
    if (mReadError != null) {
      Slog.w(TAG,"Ignoring existing stats; " + mReadError);
      if (DEBUG) {
        ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
        final int NPROC=procMap.size();
        for (int ip=0; ip < NPROC; ip++) {
          Slog.w(TAG,"Process: " + procMap.keyAt(ip));
          SparseArray<ProcessState> uids=procMap.valueAt(ip);
          final int NUID=uids.size();
          for (int iu=0; iu < NUID; iu++) {
            Slog.w(TAG,"  Uid " + uids.keyAt(iu) + ": "+ uids.valueAt(iu));
          }
        }
        ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
        final int NPKG=pkgMap.size();
        for (int ip=0; ip < NPKG; ip++) {
          Slog.w(TAG,"Package: " + pkgMap.keyAt(ip));
          SparseArray<PackageState> uids=pkgMap.valueAt(ip);
          final int NUID=uids.size();
          for (int iu=0; iu < NUID; iu++) {
            Slog.w(TAG,"  Uid: " + uids.keyAt(iu));
            PackageState pkgState=uids.valueAt(iu);
            final int NPROCS=pkgState.mProcesses.size();
            for (int iproc=0; iproc < NPROCS; iproc++) {
              Slog.w(TAG,"    Process " + pkgState.mProcesses.keyAt(iproc) + ": "+ pkgState.mProcesses.valueAt(iproc));
            }
            final int NSRVS=pkgState.mServices.size();
            for (int isvc=0; isvc < NSRVS; isvc++) {
              Slog.w(TAG,"    Service " + pkgState.mServices.keyAt(isvc) + ": "+ pkgState.mServices.valueAt(isvc));
            }
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    mReadError="error reading: " + e;
    Slog.e(TAG,"Error reading process statistics",e);
  }
}
