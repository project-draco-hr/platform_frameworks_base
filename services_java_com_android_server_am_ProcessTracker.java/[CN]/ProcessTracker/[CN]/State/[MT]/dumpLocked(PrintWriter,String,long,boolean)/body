{
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println("Per-Package Process Stats:");
          printedHeader=true;
        }
        pw.print("  * ");
        pw.print(pkgName);
        pw.print(" / ");
        UserHandle.formatUid(pw,uid);
        pw.println(":");
      }
      for (int iproc=0; iproc < NPROCS; iproc++) {
        ProcessState proc=pkgState.mProcesses.valueAt(iproc);
        pw.print("      Process ");
        pw.print(pkgState.mProcesses.keyAt(iproc));
        pw.print(" (");
        pw.print(proc.mDurationsTableSize);
        pw.print(" entries)");
        pw.println(":");
        dumpProcessState(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        pw.print("      Service ");
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(":");
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (svc.mStartedCount != 0) {
          pw.print("        Started op count ");
          pw.print(svc.mStartedCount);
          pw.println(":");
          dumpSingleTime(pw,"          ",svc.mStartedDurations,svc.mStartedState,svc.mStartedStartTime,now);
        }
        if (svc.mBoundCount != 0) {
          pw.print("        Bound op count ");
          pw.print(svc.mBoundCount);
          pw.println(":");
          dumpSingleTime(pw,"          ",svc.mBoundDurations,svc.mBoundState,svc.mBoundStartTime,now);
        }
        if (svc.mExecCount != 0) {
          pw.print("        Executing op count ");
          pw.print(svc.mExecCount);
          pw.println(":");
          dumpSingleTime(pw,"          ",svc.mExecDurations,svc.mExecState,svc.mExecStartTime,now);
        }
      }
    }
  }
  if (reqPackage == null) {
    ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
    printedHeader=false;
    for (int ip=0; ip < procMap.size(); ip++) {
      String procName=procMap.keyAt(ip);
      SparseArray<ProcessState> uids=procMap.valueAt(ip);
      for (int iu=0; iu < uids.size(); iu++) {
        int uid=uids.keyAt(iu);
        ProcessState proc=uids.valueAt(iu);
        if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
          continue;
        }
        if (!printedHeader) {
          pw.println("Process Stats:");
          printedHeader=true;
        }
        pw.print("  * ");
        pw.print(procName);
        pw.print(" / ");
        UserHandle.formatUid(pw,uid);
        pw.print(" (");
        pw.print(proc.mDurationsTableSize);
        pw.print(" entries)");
        pw.println(":");
        dumpProcessState(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
        dumpProcessPss(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      }
    }
    pw.println();
    pw.println("Summary:");
    dumpSummaryLocked(pw,reqPackage,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println("Internal state:");
    pw.print("  mFile=");
    pw.println(mFile.getBaseFile());
    pw.print("  Num long arrays: ");
    pw.println(mLongs.size());
    pw.print("  Next long entry: ");
    pw.println(mNextLong);
    pw.print("  mRunning=");
    pw.println(mRunning);
  }
}
