{
  final long now=SystemClock.uptimeMillis();
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  pw.println("vers,2");
  pw.print("period,");
  pw.print(mTimePeriodStartClockStr);
  pw.print(",");
  pw.print(mTimePeriodStartRealtime);
  pw.print(",");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  if ((mFlags & FLAG_COMPLETE) != 0)   pw.print(",complete");
 else   if ((mFlags & FLAG_SHUTDOWN) != 0)   pw.print(",shutdown");
 else   pw.print(",partial");
  pw.println();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      for (int iproc=0; iproc < NPROCS; iproc++) {
        ProcessState proc=pkgState.mProcesses.valueAt(iproc);
        pw.print("pkgproc,");
        pw.print(pkgName);
        pw.print(",");
        pw.print(uid);
        pw.print(",");
        pw.print(collapseString(pkgName,pkgState.mProcesses.keyAt(iproc)));
        dumpAllProcessStateCheckin(pw,proc,now);
        pw.println();
        if (proc.mPssTableSize > 0) {
          pw.print("pkgpss,");
          pw.print(pkgName);
          pw.print(",");
          pw.print(uid);
          pw.print(",");
          pw.print(collapseString(pkgName,pkgState.mProcesses.keyAt(iproc)));
          dumpAllProcessPssCheckin(pw,proc);
          pw.println();
        }
        if (proc.mNumExcessiveWake > 0 || proc.mNumExcessiveCpu > 0) {
          pw.print("pkgkills,");
          pw.print(pkgName);
          pw.print(",");
          pw.print(uid);
          pw.print(",");
          pw.print(collapseString(pkgName,pkgState.mProcesses.keyAt(iproc)));
          pw.print(",");
          pw.print(proc.mNumExcessiveWake);
          pw.print(",");
          pw.print(proc.mNumExcessiveCpu);
          pw.println();
        }
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        String serviceName=collapseString(pkgName,pkgState.mServices.keyAt(isvc));
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        dumpServiceTimeCheckin(pw,"pkgsvc-start",pkgName,uid,serviceName,svc,svc.mStartedCount,svc.mStartedDurations,svc.mStartedState,svc.mStartedStartTime,now);
        dumpServiceTimeCheckin(pw,"pkgsvc-bound",pkgName,uid,serviceName,svc,svc.mBoundCount,svc.mBoundDurations,svc.mBoundState,svc.mBoundStartTime,now);
        dumpServiceTimeCheckin(pw,"pkgsvc-exec",pkgName,uid,serviceName,svc,svc.mExecCount,svc.mExecDurations,svc.mExecState,svc.mExecStartTime,now);
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState procState=uids.valueAt(iu);
      if (procState.mDurationsTableSize > 0) {
        pw.print("proc,");
        pw.print(procName);
        pw.print(",");
        pw.print(uid);
        dumpAllProcessStateCheckin(pw,procState,now);
        pw.println();
      }
      if (procState.mPssTableSize > 0) {
        pw.print("pss,");
        pw.print(procName);
        pw.print(",");
        pw.print(uid);
        dumpAllProcessPssCheckin(pw,procState);
        pw.println();
      }
      if (procState.mNumExcessiveWake > 0 || procState.mNumExcessiveCpu > 0) {
        pw.print("kills,");
        pw.print(procName);
        pw.print(",");
        pw.print(uid);
        pw.print(",");
        pw.print(procState.mNumExcessiveWake);
        pw.print(",");
        pw.print(procState.mNumExcessiveCpu);
        pw.println();
      }
    }
  }
  pw.print("total");
  dumpAdjTimesCheckin(pw,",",mMemFactorDurations,mMemFactor,mStartTime,now);
  pw.println();
}
