{
  if (DBG) {
    log("startUsingNetworkFeature for net " + networkType + ": "+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType) || mNetConfigs[networkType] == null) {
    return Phone.APN_REQUEST_FAILED;
  }
  FeatureUser f=new FeatureUser(networkType,feature,binder);
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    usedNetworkType=convertFeatureToNetworkType(feature);
    if (usedNetworkType < 0) {
      Slog.e(TAG,"Can't match any netTracker!");
      usedNetworkType=networkType;
    }
  }
  if (mProtectedNetworks.contains(usedNetworkType)) {
    enforceConnectivityInternalPermission();
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    Integer currentPid=new Integer(getCallingPid());
    if (usedNetworkType != networkType) {
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         log("special network not available");
        if (!TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN_ALWAYS)) {
          return Phone.APN_TYPE_NOT_AVAILABLE;
        }
 else {
        }
      }
synchronized (this) {
        mFeatureUsers.add(f);
        if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
          mNetRequestersPids[usedNetworkType].add(currentPid);
        }
      }
      int restoreTimer=getRestoreDefaultNetworkDelay(usedNetworkType);
      if (restoreTimer >= 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_RESTORE_DEFAULT_NETWORK,f),restoreTimer);
      }
      if ((ni.isConnectedOrConnecting() == true) && !network.isTeardownRequested()) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange(networkType);
          if (DBG)           log("special network already active");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         log("special network already connecting");
        return Phone.APN_REQUEST_STARTED;
      }
      if (DBG)       log("reconnecting to special network");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
synchronized (this) {
        mFeatureUsers.add(f);
        if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
          mNetRequestersPids[usedNetworkType].add(currentPid);
        }
      }
      return -1;
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}
