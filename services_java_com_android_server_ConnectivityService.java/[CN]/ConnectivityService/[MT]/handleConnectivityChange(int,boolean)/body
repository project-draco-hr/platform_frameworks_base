{
  int resetMask=doReset ? NetworkUtils.RESET_ALL_ADDRESSES : 0;
  if (VDBG) {
    log("handleConnectivityChange: netType=" + netType + " doReset="+ doReset+ " resetMask="+ resetMask);
  }
  handleDnsConfigurationChange(netType);
  LinkProperties curLp=mCurrentLinkProperties[netType];
  LinkProperties newLp=null;
  if (mNetTrackers[netType].getNetworkInfo().isConnected()) {
    newLp=mNetTrackers[netType].getLinkProperties();
    if (VDBG) {
      log("handleConnectivityChange: changed linkProperty[" + netType + "]:"+ " doReset="+ doReset+ " resetMask="+ resetMask+ "\n   curLp="+ curLp+ "\n   newLp="+ newLp);
    }
    if (curLp != null) {
      if (curLp.isIdenticalInterfaceName(newLp)) {
        CompareResult<LinkAddress> car=curLp.compareAddresses(newLp);
        if ((car.removed.size() != 0) || (car.added.size() != 0)) {
          for (          LinkAddress linkAddr : car.removed) {
            if (linkAddr.getAddress() instanceof Inet4Address) {
              resetMask|=NetworkUtils.RESET_IPV4_ADDRESSES;
            }
            if (linkAddr.getAddress() instanceof Inet6Address) {
              resetMask|=NetworkUtils.RESET_IPV6_ADDRESSES;
            }
          }
          if (DBG) {
            log("handleConnectivityChange: addresses changed" + " linkProperty[" + netType + "]:"+ " resetMask="+ resetMask+ "\n   car="+ car);
          }
        }
 else {
          if (DBG) {
            log("handleConnectivityChange: address are the same reset per doReset" + " linkProperty[" + netType + "]:"+ " resetMask="+ resetMask);
          }
        }
      }
 else {
        resetMask=NetworkUtils.RESET_ALL_ADDRESSES;
        if (DBG) {
          log("handleConnectivityChange: interface not not equivalent reset both" + " linkProperty[" + netType + "]:"+ " resetMask="+ resetMask);
        }
      }
    }
    if (mNetConfigs[netType].isDefault()) {
      handleApplyDefaultProxy(newLp.getHttpProxy());
    }
  }
 else {
    if (VDBG) {
      log("handleConnectivityChange: changed linkProperty[" + netType + "]:"+ " doReset="+ doReset+ " resetMask="+ resetMask+ "\n  curLp="+ curLp+ "\n  newLp= null");
    }
  }
  mCurrentLinkProperties[netType]=newLp;
  boolean resetDns=updateRoutes(newLp,curLp,mNetConfigs[netType].isDefault());
  if (resetMask != 0 || resetDns) {
    if (VDBG)     log("handleConnectivityChange: resetting");
    if (curLp != null) {
      if (VDBG)       log("handleConnectivityChange: resetting curLp=" + curLp);
      for (      String iface : curLp.getAllInterfaceNames()) {
        if (TextUtils.isEmpty(iface) == false) {
          if (resetMask != 0) {
            if (DBG)             log("resetConnections(" + iface + ", "+ resetMask+ ")");
            NetworkUtils.resetConnections(iface,resetMask);
            if ((resetMask & NetworkUtils.RESET_IPV4_ADDRESSES) != 0) {
              mVpn.interfaceStatusChanged(iface,false);
            }
          }
          if (resetDns) {
            flushVmDnsCache();
            if (VDBG)             log("resetting DNS cache for " + iface);
            try {
              mNetd.flushInterfaceDnsCache(iface);
            }
 catch (            Exception e) {
              if (DBG)               loge("Exception resetting dns cache: " + e);
            }
          }
        }
 else {
          loge("Can't reset connection for type " + netType);
        }
      }
    }
  }
  NetworkStateTracker tracker=mNetTrackers[netType];
  if (mClat.requiresClat(netType,tracker)) {
    if (Nat464Xlat.isRunningClat(curLp) && !Nat464Xlat.isRunningClat(newLp)) {
      mClat.stopClat();
    }
    if (mNetTrackers[netType].getNetworkInfo().isConnected()) {
      mClat.startClat(tracker);
    }
 else {
      mClat.stopClat();
    }
  }
  if (TextUtils.equals(mNetTrackers[netType].getNetworkInfo().getReason(),PhoneConstants.REASON_LINK_PROPERTIES_CHANGED)) {
    if (isTetheringSupported()) {
      mTethering.handleTetherIfaceChange();
    }
  }
}
