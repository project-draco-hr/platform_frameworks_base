{
  int networkType=u.mNetworkType;
  String feature=u.mFeature;
  int pid=u.mPid;
  int uid=u.mUid;
  NetworkStateTracker tracker=null;
  boolean callTeardown=false;
  if (VDBG) {
    log("stopUsingNetworkFeature: net " + networkType + ": "+ feature);
  }
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    if (DBG) {
      log("stopUsingNetworkFeature: net " + networkType + ": "+ feature+ ", net is invalid");
    }
    return -1;
  }
synchronized (this) {
    if (!mFeatureUsers.contains(u)) {
      if (VDBG) {
        log("stopUsingNetworkFeature: this process has no outstanding requests" + ", ignoring");
      }
      return 1;
    }
    u.unlinkDeathRecipient();
    mFeatureUsers.remove(mFeatureUsers.indexOf(u));
    if (ignoreDups == false) {
      for (      FeatureUser x : mFeatureUsers) {
        if (x.isSameUser(u)) {
          if (VDBG)           log("stopUsingNetworkFeature: dup is found, ignoring");
          return 1;
        }
      }
    }
    int usedNetworkType=convertFeatureToNetworkType(networkType,feature);
    tracker=mNetTrackers[usedNetworkType];
    if (tracker == null) {
      if (DBG) {
        log("stopUsingNetworkFeature: net " + networkType + ": "+ feature+ " no known tracker for used net type "+ usedNetworkType);
      }
      return -1;
    }
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(pid);
      mNetRequestersPids[usedNetworkType].remove(currentPid);
      reassessPidDns(pid,true);
      if (mNetRequestersPids[usedNetworkType].size() != 0) {
        if (VDBG) {
          log("stopUsingNetworkFeature: net " + networkType + ": "+ feature+ " others still using it");
        }
        return 1;
      }
      callTeardown=true;
    }
 else {
      if (DBG) {
        log("stopUsingNetworkFeature: net " + networkType + ": "+ feature+ " not a known feature - dropping");
      }
    }
  }
  if (callTeardown) {
    if (DBG) {
      log("stopUsingNetworkFeature: teardown net " + networkType + ": "+ feature);
    }
    tracker.teardown();
    return 1;
  }
 else {
    return -1;
  }
}
