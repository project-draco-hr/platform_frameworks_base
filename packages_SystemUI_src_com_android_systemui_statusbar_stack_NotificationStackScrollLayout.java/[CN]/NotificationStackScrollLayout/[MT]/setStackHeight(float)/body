{
  mLastSetStackHeight=height;
  setIsExpanded(height > 0.0f);
  int newStackHeight=(int)height;
  int minStackHeight=getMinStackHeight();
  int stackHeight;
  float paddingOffset;
  boolean trackingHeadsUp=mTrackingHeadsUp || mHeadsUpManager.hasPinnedHeadsUp();
  int normalUnfoldPositionStart=trackingHeadsUp ? mHeadsUpManager.getTopHeadsUpPinnedHeight() : minStackHeight;
  if (newStackHeight - mTopPadding - mTopPaddingOverflow >= normalUnfoldPositionStart || getNotGoneChildCount() == 0) {
    paddingOffset=mTopPaddingOverflow;
    stackHeight=newStackHeight;
  }
 else {
    int translationY;
    if (!trackingHeadsUp) {
      translationY=(newStackHeight - minStackHeight);
      float partiallyThere=(newStackHeight - mTopPadding - mTopPaddingOverflow) / minStackHeight;
      partiallyThere=Math.max(0,partiallyThere);
      translationY+=(1 - partiallyThere) * (mBottomStackPeekSize + mCollapseSecondCardPadding);
    }
 else {
      translationY=(int)(height - normalUnfoldPositionStart);
    }
    paddingOffset=translationY - mTopPadding;
    stackHeight=(int)(height - (translationY - mTopPadding));
  }
  if (stackHeight != mCurrentStackHeight) {
    mCurrentStackHeight=stackHeight;
    updateAlgorithmHeightAndPadding();
    requestChildrenUpdate();
  }
  setStackTranslation(paddingOffset);
}
