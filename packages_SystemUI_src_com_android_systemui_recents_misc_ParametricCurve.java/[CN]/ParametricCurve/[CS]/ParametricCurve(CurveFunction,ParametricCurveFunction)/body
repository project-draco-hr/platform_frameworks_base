{
  long t1;
  if (DEBUG) {
    t1=SystemClock.currentThreadTimeMicro();
    Log.d(TAG,"initializeCurve");
  }
  mFn=fn;
  mScaleFn=scaleFn;
  xp=new float[PrecisionSteps + 1];
  px=new float[PrecisionSteps + 1];
  float[] fx=new float[PrecisionSteps + 1];
  float step=1f / PrecisionSteps;
  float x=0;
  for (int xStep=0; xStep <= PrecisionSteps; xStep++) {
    fx[xStep]=fn.f(x);
    x+=step;
  }
  float pLength=0;
  float[] dx=new float[PrecisionSteps + 1];
  dx[0]=0;
  for (int xStep=1; xStep < PrecisionSteps; xStep++) {
    dx[xStep]=(float)Math.hypot(fx[xStep] - fx[xStep - 1],step);
    pLength+=dx[xStep];
  }
  float p=0;
  px[0]=0f;
  px[PrecisionSteps]=1f;
  if (DEBUG) {
    Log.d(TAG,"p[0]=0");
    Log.d(TAG,"p[" + PrecisionSteps + "]=1");
  }
  for (int xStep=1; xStep < PrecisionSteps; xStep++) {
    p+=Math.abs(dx[xStep] / pLength);
    px[xStep]=p;
    if (DEBUG) {
      Log.d(TAG,"p[" + xStep + "]="+ p);
    }
  }
  int xStep=0;
  p=0;
  xp[0]=0f;
  xp[PrecisionSteps]=1f;
  if (DEBUG) {
    Log.d(TAG,"x[0]=0");
    Log.d(TAG,"x[" + PrecisionSteps + "]=1");
  }
  for (int pStep=0; pStep < PrecisionSteps; pStep++) {
    while (xStep < PrecisionSteps) {
      if (px[xStep] > p)       break;
      xStep++;
    }
    if (xStep == 0) {
      xp[pStep]=0;
    }
 else {
      float fraction=(p - px[xStep - 1]) / (px[xStep] - px[xStep - 1]);
      x=(xStep - 1 + fraction) * step;
      xp[pStep]=x;
    }
    if (DEBUG) {
      Log.d(TAG,"x[" + pStep + "]="+ xp[pStep]);
    }
    p+=step;
  }
  if (DEBUG) {
    Log.d(TAG,"\t1t: " + (SystemClock.currentThreadTimeMicro() - t1) + "microsecs");
  }
}
