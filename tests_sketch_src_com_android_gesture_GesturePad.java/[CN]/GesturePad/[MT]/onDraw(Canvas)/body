{
  canvas.drawColor(background);
  if (mCacheGesture)   canvas.drawBitmap(mBitmap,0,0,mBitmapPaint);
  if (mIsFadingOut) {
    int color=foreground;
    int alpha=(int)(Color.alpha(color) * mFadingAlpha);
    mPaint.setColor(Color.argb(alpha,Color.red(color),Color.green(color),Color.blue(color)));
  }
 else   if (mEnableRendering == false) {
    mPaint.setColor(uncertain_foreground);
  }
 else {
    mPaint.setColor(foreground);
  }
  if (reconstruct) {
    if (this.mCurrentGesture != null) {
      float xedge=30;
      float yedge=30;
      float w=this.getWidth() - 2 * xedge;
      float h=this.getHeight() - 2 * yedge;
      float sx=w / this.mCurrentGesture.getBBX().width();
      float sy=h / mCurrentGesture.getBBX().height();
      float scale=sx > sy ? sy : sx;
      convertFromStroke(mCurrentGesture);
      Matrix matrix=new Matrix();
      matrix.preTranslate(-mCurrentGesture.getBBX().centerX(),-mCurrentGesture.getBBX().centerY());
      matrix.postScale(scale,scale);
      matrix.postTranslate(this.getWidth() / 2,this.getHeight() / 2);
      this.mPath.transform(matrix);
    }
 else {
      mPath.reset();
    }
    reconstruct=false;
  }
  canvas.drawPath(mPath,mPaint);
  Iterator<Path> it=debug.iterator();
  while (it.hasNext()) {
    Path path=it.next();
    canvas.drawPath(path,mDebugPaint);
  }
}
