{
  if (VERBOSE)   Log.v(TAG,"reportLocation lat: " + latitude + " long: "+ longitude+ " timestamp: "+ timestamp);
synchronized (mLocation) {
    mLocationFlags=flags;
    if ((flags & LOCATION_HAS_LAT_LONG) == LOCATION_HAS_LAT_LONG) {
      mLocation.setLatitude(latitude);
      mLocation.setLongitude(longitude);
      mLocation.setTime(timestamp);
    }
    if ((flags & LOCATION_HAS_ALTITUDE) == LOCATION_HAS_ALTITUDE) {
      mLocation.setAltitude(altitude);
    }
 else {
      mLocation.removeAltitude();
    }
    if ((flags & LOCATION_HAS_SPEED) == LOCATION_HAS_SPEED) {
      mLocation.setSpeed(speed);
    }
 else {
      mLocation.removeSpeed();
    }
    if ((flags & LOCATION_HAS_BEARING) == LOCATION_HAS_BEARING) {
      mLocation.setBearing(bearing);
    }
 else {
      mLocation.removeBearing();
    }
    if ((flags & LOCATION_HAS_ACCURACY) == LOCATION_HAS_ACCURACY) {
      mLocation.setAccuracy(accuracy);
    }
 else {
      mLocation.removeAccuracy();
    }
    try {
      mLocationManager.reportLocation(mLocation,false);
    }
 catch (    RemoteException e) {
      Log.e(TAG,"RemoteException calling reportLocation");
    }
  }
  mLastFixTime=System.currentTimeMillis();
  if (mTTFF == 0 && (flags & LOCATION_HAS_LAT_LONG) == LOCATION_HAS_LAT_LONG) {
    mTTFF=(int)(mLastFixTime - mFixRequestTime);
    if (DEBUG)     Log.d(TAG,"TTFF: " + mTTFF);
synchronized (mListeners) {
      int size=mListeners.size();
      for (int i=0; i < size; i++) {
        Listener listener=mListeners.get(i);
        try {
          listener.mListener.onFirstFix(mTTFF);
        }
 catch (        RemoteException e) {
          Log.w(TAG,"RemoteException in stopNavigating");
          mListeners.remove(listener);
          size--;
        }
      }
    }
  }
  if (mSingleShot) {
    stopNavigating();
  }
  if (mStarted && mStatus != LocationProvider.AVAILABLE) {
    if (!hasCapability(GPS_CAPABILITY_SCHEDULING) && mFixInterval < NO_FIX_TIMEOUT) {
      mAlarmManager.cancel(mTimeoutIntent);
    }
    Intent intent=new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
    intent.putExtra(LocationManager.EXTRA_GPS_ENABLED,true);
    mContext.sendBroadcast(intent);
    updateStatus(LocationProvider.AVAILABLE,mSvCount);
  }
  if (!hasCapability(GPS_CAPABILITY_SCHEDULING) && mStarted && mFixInterval > 1000) {
    if (DEBUG)     Log.d(TAG,"got fix, hibernating");
    hibernate();
  }
}
