{
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Slog.d(TAG,"touch: act=" + (action) + " stretching="+ mStretching+ " onefinger="+ mPullingWithOneFinger);
  if (mStretching) {
    mDetector.onTouchEvent(ev);
  }
switch (action) {
case MotionEvent.ACTION_MOVE:
{
      if (mPullingWithOneFinger) {
        final float rawHeight=ev.getY() - mInitialTouchY + mOldHeight;
        final float newHeight=clamp(rawHeight);
        final boolean wasClosed=(mOldHeight == mSmallSize);
        boolean isFinished=false;
        if (rawHeight > mNaturalHeight) {
          isFinished=true;
        }
        if (rawHeight < mSmallSize) {
          isFinished=true;
        }
        final float pull=Math.abs(ev.getY() - mInitialTouchY);
        if (mHasPopped || pull > mPopLimit) {
          if (!mHasPopped) {
            vibrate(mPopDuration);
            mHasPopped=true;
          }
        }
        if (mHasPopped) {
          mScaler.setHeight(newHeight);
          setGlow(GLOW_BASE);
        }
 else {
          setGlow(calculateGlow(4f * pull,0f));
        }
        final int x=(int)ev.getX();
        final int y=(int)ev.getY();
        View underPointer=findView(x,y);
        if (isFinished && underPointer != null && underPointer != mCurrView) {
          finishScale(false);
          initScale(underPointer);
          mInitialTouchY=ev.getY();
          mHasPopped=false;
        }
        return true;
      }
      break;
    }
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
  if (DEBUG)   Slog.d(TAG,"cancel");
mStretching=false;
if (mPullingWithOneFinger) {
finishScale(false);
mPullingWithOneFinger=false;
}
clearView();
break;
}
return true;
}
