{
  TreeMap<Integer,String> candidateCodecs=new TreeMap<Integer,String>();
  SparseIntArray colorPriorities=intArrayToPriorityMap(requiredColorFormats);
  for (int i=0; i < MediaCodecList.getCodecCount(); ++i) {
    MediaCodecInfo info=MediaCodecList.getCodecInfoAt(i);
    if (info.isEncoder()) {
      continue;
    }
    String requiredType=format.getString(MediaFormat.KEY_MIME);
    String[] supportedTypes=info.getSupportedTypes();
    Set<String> typeSet=new HashSet<String>(Arrays.asList(supportedTypes));
    if (typeSet.contains(requiredType)) {
      CodecCapabilities capabilities=info.getCapabilitiesForType(requiredType);
      for (      int supportedColorFormat : capabilities.colorFormats) {
        if (colorPriorities.indexOfKey(supportedColorFormat) >= 0) {
          int priority=colorPriorities.get(supportedColorFormat);
          candidateCodecs.put(priority,info.getName());
        }
      }
    }
  }
  if (candidateCodecs.isEmpty()) {
    return null;
  }
 else {
    String bestCodec=candidateCodecs.firstEntry().getValue();
    return MediaCodec.createByCodecName(bestCodec);
  }
}
