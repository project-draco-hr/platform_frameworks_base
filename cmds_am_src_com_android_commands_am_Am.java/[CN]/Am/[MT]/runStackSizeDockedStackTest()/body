{
  final int stepSize=Integer.parseInt(nextArgRequired());
  final String side=nextArgRequired();
  final String delayStr=nextArg();
  final int delayMs=(delayStr != null) ? Integer.parseInt(delayStr) : 0;
  Rect bounds;
  try {
    StackInfo info=mAm.getStackInfo(DOCKED_STACK_ID);
    if (info == null) {
      showError("Docked stack doesn't exist");
      return;
    }
    if (info.bounds == null) {
      showError("Docked stack doesn't have a bounds");
      return;
    }
    bounds=info.bounds;
  }
 catch (  RemoteException e) {
    showError("Unable to get docked stack info:" + e);
    return;
  }
  final boolean horizontalGrowth="l".equals(side) || "r".equals(side);
  final int changeSize=(horizontalGrowth ? bounds.width() : bounds.height()) / 2;
  int currentPoint;
switch (side) {
case "l":
    currentPoint=bounds.left;
  break;
case "r":
currentPoint=bounds.right;
break;
case "t":
currentPoint=bounds.top;
break;
case "b":
currentPoint=bounds.bottom;
break;
default :
showError("Unknown growth side: " + side);
return;
}
final int startPoint=currentPoint;
final int minPoint=currentPoint - changeSize;
final int maxPoint=currentPoint + changeSize;
int maxChange;
System.out.println("Shrinking docked stack side=" + side);
while (currentPoint > minPoint) {
maxChange=Math.min(stepSize,currentPoint - minPoint);
currentPoint-=maxChange;
setBoundsSide(bounds,side,currentPoint);
resizeStack(DOCKED_STACK_ID,bounds,delayMs);
}
System.out.println("Growing docked stack side=" + side);
while (currentPoint < maxPoint) {
maxChange=Math.min(stepSize,maxPoint - currentPoint);
currentPoint+=maxChange;
setBoundsSide(bounds,side,currentPoint);
resizeStack(DOCKED_STACK_ID,bounds,delayMs);
}
System.out.println("Back to Original size side=" + side);
while (currentPoint > startPoint) {
maxChange=Math.min(stepSize,currentPoint - startPoint);
currentPoint-=maxChange;
setBoundsSide(bounds,side,currentPoint);
resizeStack(DOCKED_STACK_ID,bounds,delayMs);
}
}
