{
  super.onActivityCreated(savedInstanceState);
  final Context context=getActivity();
  final State state=getDisplayState();
  final RootInfo root=getArguments().getParcelable(EXTRA_ROOT);
  final DocumentInfo doc=getArguments().getParcelable(EXTRA_DOC);
  mAdapter=new DocumentsAdapter(context);
  mRecView.setAdapter(mAdapter);
  mDefaultItemColor=context.getResources().getColor(android.R.color.transparent);
  TypedValue selColor=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.colorAccent,selColor,true);
  mSelectedItemColor=(selColor.data & 0x00ffffff) | 0x16000000;
  GestureDetector.SimpleOnGestureListener listener=new GestureDetector.SimpleOnGestureListener(){
    @Override public boolean onSingleTapUp(    MotionEvent e){
      return DirectoryFragment.this.onSingleTapUp(e);
    }
    @Override public boolean onDoubleTap(    MotionEvent e){
      Log.d(TAG,"Handling double tap.");
      return DirectoryFragment.this.onDoubleTap(e);
    }
  }
;
  final GestureDetector detector=new GestureDetector(this.getContext(),listener);
  detector.setOnDoubleTapListener(listener);
  mRecView.addOnItemTouchListener(new OnItemTouchListener(){
    @Override public boolean onInterceptTouchEvent(    RecyclerView rv,    MotionEvent e){
      detector.onTouchEvent(e);
      return false;
    }
    @Override public void onTouchEvent(    RecyclerView rv,    MotionEvent e){
    }
    @Override public void onRequestDisallowInterceptTouchEvent(    boolean disallowIntercept){
    }
  }
);
  mSelectionManager=new MultiSelectManager(mRecView,state.allowMultiple ? MultiSelectManager.MODE_MULTIPLE : MultiSelectManager.MODE_SINGLE);
  mSelectionManager.addCallback(new SelectionModeListener());
  mModel=new Model(context,mAdapter);
  mModel.addUpdateListener(mModelUpdateListener);
  mType=getArguments().getInt(EXTRA_TYPE);
  mStateKey=buildStateKey(root,doc);
  mTuner=FragmentTuner.pick(state);
  mClipper=new DocumentClipper(context);
  if (mType == TYPE_RECENT_OPEN) {
    mHideGridTitles=MimePredicate.mimeMatches(MimePredicate.VISUAL_MIMES,state.acceptMimes);
  }
 else {
    mHideGridTitles=(doc != null) && doc.isGridTitlesHidden();
  }
  final ActivityManager am=(ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);
  mSvelteRecents=am.isLowRamDevice() && (mType == TYPE_RECENT_OPEN);
  mCallbacks=new LoaderCallbacks<DirectoryResult>(){
    @Override public Loader<DirectoryResult> onCreateLoader(    int id,    Bundle args){
      final String query=getArguments().getString(EXTRA_QUERY);
      Uri contentsUri;
switch (mType) {
case TYPE_NORMAL:
        contentsUri=DocumentsContract.buildChildDocumentsUri(doc.authority,doc.documentId);
      if (state.action == ACTION_MANAGE) {
        contentsUri=DocumentsContract.setManageMode(contentsUri);
      }
    return new DirectoryLoader(context,mType,root,doc,contentsUri,state.userSortOrder);
case TYPE_SEARCH:
  contentsUri=DocumentsContract.buildSearchDocumentsUri(root.authority,root.rootId,query);
if (state.action == ACTION_MANAGE) {
  contentsUri=DocumentsContract.setManageMode(contentsUri);
}
return new DirectoryLoader(context,mType,root,doc,contentsUri,state.userSortOrder);
case TYPE_RECENT_OPEN:
final RootsCache roots=DocumentsApplication.getRootsCache(context);
return new RecentLoader(context,roots,state);
default :
throw new IllegalStateException("Unknown type " + mType);
}
}
@Override public void onLoadFinished(Loader<DirectoryResult> loader,DirectoryResult result){
if (!isAdded()) return;
mModel.update(result);
if (result.mode != MODE_UNKNOWN) {
state.derivedMode=result.mode;
}
state.derivedSortOrder=result.sortOrder;
((BaseActivity)context).onStateChanged();
updateDisplayState();
if (mType == TYPE_RECENT_OPEN && mModel.isEmpty() && !state.stackTouched && context instanceof DocumentsActivity) {
((DocumentsActivity)context).setRootsDrawerOpen(true);
}
final SparseArray<Parcelable> container=state.dirState.remove(mStateKey);
if (container != null && !getArguments().getBoolean(EXTRA_IGNORE_STATE,false)) {
getView().restoreHierarchyState(container);
}
 else if (mLastSortOrder != state.derivedSortOrder) {
mRecView.smoothScrollToPosition(0);
}
mLastSortOrder=state.derivedSortOrder;
}
@Override public void onLoaderReset(Loader<DirectoryResult> loader){
mModel.update(null);
}
}
;
getLoaderManager().restartLoader(LOADER_ID,null,mCallbacks);
updateDisplayState();
}
