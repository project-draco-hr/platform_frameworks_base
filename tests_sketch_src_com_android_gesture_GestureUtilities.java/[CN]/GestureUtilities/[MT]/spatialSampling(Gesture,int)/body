{
  final float targetPatchSize=sampleMatrixDimension - 1;
  float[] sample=new float[sampleMatrixDimension * sampleMatrixDimension];
  Arrays.fill(sample,0);
  RectF rect=gesture.getBoundingBox();
  float sx=targetPatchSize / rect.width();
  float sy=targetPatchSize / rect.height();
  float scale=sx < sy ? sx : sy;
  Matrix trans=new Matrix();
  trans.setScale(scale,scale);
  trans.preTranslate(-rect.centerX(),-rect.centerY());
  trans.postTranslate(targetPatchSize / 2,targetPatchSize / 2);
  final ArrayList<GestureStroke> strokes=gesture.getStrokes();
  final int count=strokes.size();
  int size;
  float xpos;
  float ypos;
  for (int index=0; index < count; index++) {
    final GestureStroke stroke=strokes.get(index);
    size=stroke.points.length;
    final float[] pts=new float[size];
    trans.mapPoints(pts,0,stroke.points,0,size / 2);
    float segmentEndX=-1;
    float segmentEndY=-1;
    for (int i=0; i < size; i+=2) {
      float segmentStartX=pts[i] < 0 ? 0 : pts[i];
      float segmentStartY=pts[i + 1] < 0 ? 0 : pts[i + 1];
      if (segmentStartX > targetPatchSize) {
        segmentStartX=targetPatchSize;
      }
      if (segmentStartY > targetPatchSize) {
        segmentStartY=targetPatchSize;
      }
      plot(segmentStartX,segmentStartY,sample,sampleMatrixDimension);
      if (segmentEndX != -1) {
        if (segmentEndX > segmentStartX) {
          xpos=(float)Math.ceil(segmentStartX);
          float slope=(segmentEndY - segmentStartY) / (segmentEndX - segmentStartX);
          while (xpos < segmentEndX) {
            ypos=slope * (xpos - segmentStartX) + segmentStartY;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            xpos++;
          }
        }
 else         if (segmentEndX < segmentStartX) {
          xpos=(float)Math.ceil(segmentEndX);
          float slope=(segmentEndY - segmentStartY) / (segmentEndX - segmentStartX);
          while (xpos < segmentStartX) {
            ypos=slope * (xpos - segmentStartX) + segmentStartY;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            xpos++;
          }
        }
        if (segmentEndY > segmentStartY) {
          ypos=(float)Math.ceil(segmentStartY);
          float invertSlope=(segmentEndX - segmentStartX) / (segmentEndY - segmentStartY);
          while (ypos < segmentEndY) {
            xpos=invertSlope * (ypos - segmentStartY) + segmentStartX;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            ypos++;
          }
        }
 else         if (segmentEndY < segmentStartY) {
          ypos=(float)Math.ceil(segmentEndY);
          float invertSlope=(segmentEndX - segmentStartX) / (segmentEndY - segmentStartY);
          while (ypos < segmentStartY) {
            xpos=invertSlope * (ypos - segmentStartY) + segmentStartX;
            plot(xpos,ypos,sample,sampleMatrixDimension);
            ypos++;
          }
        }
      }
      segmentEndX=segmentStartX;
      segmentEndY=segmentStartY;
    }
  }
  return sample;
}
