{
  for (int pos=0; pos < MotionEvent.BASE_AVAIL_POINTERS; pos++) {
    final float[] pastX=mPastX[pos];
    final float[] pastY=mPastY[pos];
    final long[] pastTime=mPastTime[pos];
    final int lastTouch=mLastTouch;
    int oldestTouch=lastTouch;
    if (pastTime[lastTouch] > 0) {
      final float acceptableTime=pastTime[lastTouch] - LONGEST_PAST_TIME;
      int nextOldestTouch=(NUM_PAST + oldestTouch - 1) % NUM_PAST;
      while (pastTime[nextOldestTouch] >= acceptableTime && nextOldestTouch != lastTouch) {
        oldestTouch=nextOldestTouch;
        nextOldestTouch=(NUM_PAST + oldestTouch - 1) % NUM_PAST;
      }
    }
    final float oldestX=pastX[oldestTouch];
    final float oldestY=pastY[oldestTouch];
    final long oldestTime=pastTime[oldestTouch];
    float accumX=0;
    float accumY=0;
    float N=(lastTouch - oldestTouch + NUM_PAST) % NUM_PAST + 1;
    if (N > 3)     N--;
    for (int i=1; i < N; i++) {
      final int j=(oldestTouch + i) % NUM_PAST;
      final int dur=(int)(pastTime[j] - oldestTime);
      if (dur == 0)       continue;
      float dist=pastX[j] - oldestX;
      float vel=(dist / dur) * units;
      accumX=(accumX == 0) ? vel : (accumX + vel) * .5f;
      dist=pastY[j] - oldestY;
      vel=(dist / dur) * units;
      accumY=(accumY == 0) ? vel : (accumY + vel) * .5f;
    }
    mXVelocity[pos]=accumX < 0.0f ? Math.max(accumX,-maxVelocity) : Math.min(accumX,maxVelocity);
    mYVelocity[pos]=accumY < 0.0f ? Math.max(accumY,-maxVelocity) : Math.min(accumY,maxVelocity);
    if (localLOGV)     Log.v(TAG,"Y velocity=" + mYVelocity + " X velocity="+ mXVelocity+ " N="+ N);
  }
}
