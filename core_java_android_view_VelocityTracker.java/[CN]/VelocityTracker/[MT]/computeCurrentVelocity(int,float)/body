{
  for (int pos=0; pos < MotionEvent.BASE_AVAIL_POINTERS; pos++) {
    final float[] pastX=mPastX[pos];
    final float[] pastY=mPastY[pos];
    final long[] pastTime=mPastTime[pos];
    final float oldestX=pastX[0];
    final float oldestY=pastY[0];
    final long oldestTime=pastTime[0];
    float accumX=0;
    float accumY=0;
    int N=0;
    while (N < NUM_PAST) {
      if (pastTime[N] == 0) {
        break;
      }
      N++;
    }
    if (N > 3)     N--;
    for (int i=1; i < N; i++) {
      final int dur=(int)(pastTime[i] - oldestTime);
      if (dur == 0)       continue;
      float dist=pastX[i] - oldestX;
      float vel=(dist / dur) * units;
      if (accumX == 0)       accumX=vel;
 else       accumX=(accumX + vel) * .5f;
      dist=pastY[i] - oldestY;
      vel=(dist / dur) * units;
      if (accumY == 0)       accumY=vel;
 else       accumY=(accumY + vel) * .5f;
    }
    mXVelocity[pos]=accumX < 0.0f ? Math.max(accumX,-maxVelocity) : Math.min(accumX,maxVelocity);
    mYVelocity[pos]=accumY < 0.0f ? Math.max(accumY,-maxVelocity) : Math.min(accumY,maxVelocity);
    if (localLOGV)     Log.v(TAG,"Y velocity=" + mYVelocity + " X velocity="+ mXVelocity+ " N="+ N);
  }
}
