{
synchronized (mLock) {
    HashSet<Surface> addSet=new HashSet<Surface>(outputs);
    List<Integer> deleteList=new ArrayList<Integer>();
    for (int i=0; i < mConfiguredOutputs.size(); ++i) {
      int streamId=mConfiguredOutputs.keyAt(i);
      Surface s=mConfiguredOutputs.valueAt(i);
      if (!outputs.contains(s)) {
        deleteList.add(streamId);
      }
 else {
        addSet.remove(s);
      }
    }
    try {
      for (      Integer streamId : deleteList) {
        mRemoteDevice.deleteStream(streamId);
        mConfiguredOutputs.delete(streamId);
      }
      for (      Surface s : addSet) {
        int streamId=mRemoteDevice.createStream(0,0,0,s);
        mConfiguredOutputs.put(streamId,s);
      }
    }
 catch (    CameraRuntimeException e) {
      if (e.getReason() == CAMERA_IN_USE) {
        throw new IllegalStateException("The camera is currently busy." + " You must call waitUntilIdle before trying to reconfigure.");
      }
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return;
    }
  }
}
