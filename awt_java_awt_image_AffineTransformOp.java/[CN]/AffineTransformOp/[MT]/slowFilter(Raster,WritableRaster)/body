{
  Rectangle srcBounds=src.getBounds();
  Rectangle dstBounds=dst.getBounds();
  Rectangle normDstBounds=new Rectangle(0,0,dstBounds.width,dstBounds.height);
  Rectangle bounds=getBounds2D(src).getBounds().intersection(normDstBounds);
  AffineTransform inv=null;
  try {
    inv=at.createInverse();
  }
 catch (  NoninvertibleTransformException e) {
    return -1;
  }
  double[] m=new double[6];
  inv.getMatrix(m);
  int minSrcX=srcBounds.x;
  int minSrcY=srcBounds.y;
  int maxSrcX=srcBounds.x + srcBounds.width;
  int maxSrcY=srcBounds.y + srcBounds.height;
  int minX=bounds.x + dstBounds.x;
  int minY=bounds.y + dstBounds.y;
  int maxX=minX + bounds.width;
  int maxY=minY + bounds.height;
  int hx=(int)(m[0] * 256);
  int hy=(int)(m[1] * 256);
  int vx=(int)(m[2] * 256);
  int vy=(int)(m[3] * 256);
  int sx=(int)(m[4] * 256) + hx * bounds.x + vx * bounds.y + (srcBounds.x) * 256;
  int sy=(int)(m[5] * 256) + hy * bounds.x + vy * bounds.y + (srcBounds.y) * 256;
  vx-=hx * bounds.width;
  vy-=hy * bounds.width;
  if (src.getTransferType() == dst.getTransferType()) {
    for (int y=minY; y < maxY; y++) {
      for (int x=minX; x < maxX; x++) {
        int px=sx >> 8;
        int py=sy >> 8;
        if (px >= minSrcX && py >= minSrcY && px < maxSrcX && py < maxSrcY) {
          Object val=src.getDataElements(px,py,null);
          dst.setDataElements(x,y,val);
        }
        sx+=hx;
        sy+=hy;
      }
      sx+=vx;
      sy+=vy;
    }
  }
 else {
    float pixel[]=null;
    for (int y=minY; y < maxY; y++) {
      for (int x=minX; x < maxX; x++) {
        int px=sx >> 8;
        int py=sy >> 8;
        if (px >= minSrcX && py >= minSrcY && px < maxSrcX && py < maxSrcY) {
          pixel=src.getPixel(px,py,pixel);
          dst.setPixel(x,y,pixel);
        }
        sx+=hx;
        sy+=hy;
      }
      sx+=vx;
      sy+=vy;
    }
  }
  return 0;
}
