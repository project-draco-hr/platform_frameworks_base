{
  if (DBG) {
    Log.d(TAG,"audioAvailable(byte[" + buffer.length + "],"+ offset+ ","+ length+ ")");
  }
  if (length > getMaxBufferSize() || length <= 0) {
    throw new IllegalArgumentException("buffer is too large or of zero length (" + +length + " bytes)");
  }
synchronized (mStateLock) {
    if (mWriteErrorOccured) {
      if (DBG)       Log.d(TAG,"Error writing to audio track, count < 0");
      return TextToSpeech.ERROR;
    }
    if (mStopped) {
      if (DBG)       Log.d(TAG,"Request has been aborted.");
      return TextToSpeech.ERROR;
    }
    if (mAudioTrack == null) {
      Log.e(TAG,"audioAvailable(): Not started");
      return TextToSpeech.ERROR;
    }
    final AudioTrack audioTrack=mAudioTrack;
    final byte[] bufferCopy=new byte[length];
    System.arraycopy(buffer,offset,bufferCopy,0,length);
    mAudioTrackHandler.post(new Runnable(){
      @Override public void run(){
        int playState=audioTrack.getPlayState();
        if (playState == AudioTrack.PLAYSTATE_STOPPED) {
          if (DBG)           Log.d(TAG,"AudioTrack stopped, restarting");
          audioTrack.play();
        }
        if (DBG)         Log.d(TAG,"AudioTrack.write()");
        int count=audioTrack.write(bufferCopy,0,bufferCopy.length);
        if (count < 0) {
          mWriteErrorOccured=true;
        }
      }
    }
);
    return TextToSpeech.SUCCESS;
  }
}
