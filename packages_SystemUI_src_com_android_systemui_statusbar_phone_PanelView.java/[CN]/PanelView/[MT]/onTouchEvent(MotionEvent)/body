{
  if (mInstantExpanding) {
    return false;
  }
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  boolean waitForTouchSlop=hasConflictingGestures();
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mInitialTouchY=y;
  mInitialTouchX=x;
mInitialOffsetOnTouch=mExpandedHeight;
mTouchSlopExceeded=false;
mJustPeeked=false;
if (mVelocityTracker == null) {
initVelocityTracker();
}
trackMovement(event);
if (!waitForTouchSlop || (mHeightAnimator != null && !mHintAnimationRunning)) {
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
mTouchSlopExceeded=(mHeightAnimator != null && !mHintAnimationRunning);
onTrackingStarted();
}
if (mExpandedHeight == 0) {
mJustPeeked=true;
runPeekAnimation();
}
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
float h=y - mInitialTouchY;
if (Math.abs(h) > mTouchSlop && (Math.abs(h) > Math.abs(x - mInitialTouchX) || mInitialOffsetOnTouch == 0f)) {
mTouchSlopExceeded=true;
if (waitForTouchSlop && !mTracking) {
mInitialOffsetOnTouch=mExpandedHeight;
mInitialTouchX=x;
mInitialTouchY=y;
if (mHeightAnimator != null) {
mHeightAnimator.cancel();
}
onTrackingStarted();
h=0;
}
}
final float newHeight=h + mInitialOffsetOnTouch;
if (newHeight > mPeekHeight) {
if (mPeekAnimator != null && mPeekAnimator.isStarted()) {
mPeekAnimator.cancel();
}
mJustPeeked=false;
}
if (!mJustPeeked && (!waitForTouchSlop || mTracking)) {
setExpandedHeightInternal(newHeight);
mBar.panelExpansionChanged(PanelView.this,mExpandedFraction);
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mTrackingPointer=-1;
trackMovement(event);
if ((mTracking && mTouchSlopExceeded) || event.getActionMasked() == MotionEvent.ACTION_CANCEL) {
float vel=0f;
float vectorVel=0f;
if (mVelocityTracker != null) {
mVelocityTracker.computeCurrentVelocity(1000);
vel=mVelocityTracker.getYVelocity();
vectorVel=(float)Math.hypot(mVelocityTracker.getXVelocity(),mVelocityTracker.getYVelocity());
}
boolean expand=flingExpands(vel,vectorVel);
onTrackingStopped(expand);
fling(vel,expand);
}
 else {
boolean expands=onEmptySpaceClick(mInitialTouchX);
onTrackingStopped(expands);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
return !waitForTouchSlop || mTracking;
}
