{
  if (!mTimeAnimator.isStarted()) {
    mTimeAnimator=new TimeAnimator();
    mTimeAnimator.setTimeListener(mAnimationCallback);
    mTimeAnimator.start();
    mRubberbanding=STRETCH_PAST_CONTENTS && mExpandedHeight > getFullHeight();
    if (mRubberbanding) {
      mClosing=true;
    }
 else     if (mVel == 0) {
      mClosing=(mFinalTouchY / getFullHeight()) < 0.5f;
    }
 else {
      mClosing=mExpandedHeight > 0 && mVel < 0;
    }
  }
 else   if (dtms > 0) {
    final float dt=dtms * 0.001f;
    LOG("tick: v=%.2fpx/s dt=%.4fs",mVel,dt);
    LOG("tick: before: h=%d",(int)mExpandedHeight);
    final float fh=getFullHeight();
    boolean braking=false;
    if (BRAKES) {
      if (mClosing) {
        braking=mExpandedHeight <= mCollapseBrakingDistancePx;
        mAccel=braking ? 10 * mCollapseAccelPx : -mCollapseAccelPx;
      }
 else {
        braking=mExpandedHeight >= (fh - mExpandBrakingDistancePx);
        mAccel=braking ? 10 * -mExpandAccelPx : mExpandAccelPx;
      }
    }
 else {
      mAccel=mClosing ? -mCollapseAccelPx : mExpandAccelPx;
    }
    mVel+=mAccel * dt;
    if (braking) {
      if (mClosing && mVel > -mBrakingSpeedPx) {
        mVel=-mBrakingSpeedPx;
      }
 else       if (!mClosing && mVel < mBrakingSpeedPx) {
        mVel=mBrakingSpeedPx;
      }
    }
 else {
      if (mClosing && mVel > -mFlingCollapseMinVelocityPx) {
        mVel=-mFlingCollapseMinVelocityPx;
      }
 else       if (!mClosing && mVel > mFlingGestureMaxOutputVelocityPx) {
        mVel=mFlingGestureMaxOutputVelocityPx;
      }
    }
    float h=mExpandedHeight + mVel * dt;
    if (mRubberbanding && h < fh) {
      h=fh;
    }
    LOG("tick: new h=%d closing=%s",(int)h,mClosing ? "true" : "false");
    setExpandedHeightInternal(h);
    mBar.panelExpansionChanged(PanelView.this,mExpandedFraction);
    if (mVel == 0 || (mClosing && mExpandedHeight == 0) || ((mRubberbanding || !mClosing) && mExpandedHeight == fh)) {
      post(mStopAnimator);
    }
  }
}
