{
switch (msg.what) {
case IDLE_TIMEOUT_MSG:
{
      if (DEBUG_IDLE)       Slog.d(TAG,"handleMessage: IDLE_TIMEOUT_MSG: r=" + msg.obj);
      if (mService.mDidDexOpt) {
        mService.mDidDexOpt=false;
        Message nmsg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
        nmsg.obj=msg.obj;
        mHandler.sendMessageDelayed(nmsg,IDLE_TIMEOUT);
        return;
      }
      activityIdleInternal((ActivityRecord)msg.obj);
    }
  break;
case IDLE_NOW_MSG:
{
  if (DEBUG_IDLE)   Slog.d(TAG,"handleMessage: IDLE_NOW_MSG: r=" + msg.obj);
  activityIdleInternal((ActivityRecord)msg.obj);
}
break;
case RESUME_TOP_ACTIVITY_MSG:
{
synchronized (mService) {
resumeTopActivitiesLocked();
}
}
break;
case SLEEP_TIMEOUT_MSG:
{
synchronized (mService) {
if (mService.isSleepingOrShuttingDown()) {
Slog.w(TAG,"Sleep timeout!  Sleeping now.");
mSleepTimeout=true;
checkReadyForSleepLocked();
}
}
}
break;
case LAUNCH_TIMEOUT_MSG:
{
if (mService.mDidDexOpt) {
mService.mDidDexOpt=false;
mHandler.sendEmptyMessageDelayed(LAUNCH_TIMEOUT_MSG,LAUNCH_TIMEOUT);
return;
}
synchronized (mService) {
if (mLaunchingActivity.isHeld()) {
Slog.w(TAG,"Launch timeout has expired, giving up wake lock!");
if (VALIDATE_WAKE_LOCK_CALLER && Binder.getCallingUid() != Process.myUid()) {
throw new IllegalStateException("Calling must be system uid");
}
mLaunchingActivity.release();
}
}
}
break;
}
}
