{
  if (localLOGV)   Slog.v(TAG,"Activity idle: " + token);
  ArrayList<ActivityRecord> stops=null;
  ArrayList<ActivityRecord> finishes=null;
  ArrayList<UserStartedState> startingUsers=null;
  int NS=0;
  int NF=0;
  IApplicationThread sendThumbnail=null;
  boolean booting=false;
  boolean enableScreen=false;
  boolean activityRemoved=false;
  ActivityRecord r=ActivityRecord.forToken(token);
  if (r != null) {
    if (DEBUG_IDLE)     Slog.d(TAG,"activityIdleInternalLocked: Callers=" + Debug.getCallers(4));
    mHandler.removeMessages(IDLE_TIMEOUT_MSG,r);
    r.finishLaunchTickingLocked();
    if (fromTimeout) {
      reportActivityLaunchedLocked(fromTimeout,r,-1,-1);
    }
    if (config != null) {
      r.configuration=config;
    }
    r.idle=true;
    if (r.thumbnailNeeded && r.app != null && r.app.thread != null) {
      sendThumbnail=r.app.thread;
      r.thumbnailNeeded=false;
    }
    if (!mService.mBooted && isFrontStack(r.task.stack)) {
      mService.mBooted=true;
      enableScreen=true;
    }
  }
  if (allResumedActivitiesIdle()) {
    if (r != null) {
      mService.scheduleAppGcsLocked();
    }
    if (mLaunchingActivity.isHeld()) {
      mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);
      if (VALIDATE_WAKE_LOCK_CALLER && Binder.getCallingUid() != Process.myUid()) {
        throw new IllegalStateException("Calling must be system uid");
      }
      mLaunchingActivity.release();
    }
    ensureActivitiesVisibleLocked(null,0);
  }
  stops=processStoppingActivitiesLocked(true);
  NS=stops != null ? stops.size() : 0;
  if ((NF=mFinishingActivities.size()) > 0) {
    finishes=new ArrayList<ActivityRecord>(mFinishingActivities);
    mFinishingActivities.clear();
  }
  final ArrayList<ActivityRecord> thumbnails;
  final int NT=mCancelledThumbnails.size();
  if (NT > 0) {
    thumbnails=new ArrayList<ActivityRecord>(mCancelledThumbnails);
    mCancelledThumbnails.clear();
  }
 else {
    thumbnails=null;
  }
  if (isFrontStack(mHomeStack)) {
    booting=mService.mBooting;
    mService.mBooting=false;
  }
  if (mStartingUsers.size() > 0) {
    startingUsers=new ArrayList<UserStartedState>(mStartingUsers);
    mStartingUsers.clear();
  }
  final IApplicationThread thumbnailThread=sendThumbnail;
  mHandler.post(new Runnable(){
    @Override public void run(){
      if (thumbnailThread != null) {
        try {
          thumbnailThread.requestThumbnail(token);
        }
 catch (        Exception e) {
          Slog.w(TAG,"Exception thrown when requesting thumbnail",e);
          mService.sendPendingThumbnail(null,token,null,null,true);
        }
      }
      for (int i=0; i < NT; i++) {
        ActivityRecord r=thumbnails.get(i);
        mService.sendPendingThumbnail(r,null,null,null,true);
      }
    }
  }
);
  for (int i=0; i < NS; i++) {
    r=stops.get(i);
    final ActivityStack stack=r.task.stack;
    if (r.finishing) {
      stack.finishCurrentActivityLocked(r,ActivityStack.FINISH_IMMEDIATELY,false);
    }
 else {
      stack.stopActivityLocked(r);
    }
  }
  for (int i=0; i < NF; i++) {
    r=finishes.get(i);
    activityRemoved|=r.task.stack.destroyActivityLocked(r,true,false,"finish-idle");
  }
  if (booting) {
    mService.finishBooting();
  }
 else   if (startingUsers != null) {
    for (int i=0; i < startingUsers.size(); i++) {
      mService.finishUserSwitch(startingUsers.get(i));
    }
  }
  mService.trimApplications();
  if (enableScreen) {
    mService.enableScreenAfterBoot();
  }
  if (activityRemoved) {
    resumeTopActivitiesLocked();
  }
  return r;
}
