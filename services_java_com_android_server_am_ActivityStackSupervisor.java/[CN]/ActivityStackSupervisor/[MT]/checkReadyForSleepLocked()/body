{
  if (!mService.isSleepingOrShuttingDown()) {
    return;
  }
  if (!mSleepTimeout) {
    boolean dontSleep=false;
    for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
      dontSleep|=mStacks.get(stackNdx).checkReadyForSleepLocked();
    }
    if (mStoppingActivities.size() > 0) {
      if (DEBUG_PAUSE)       Slog.v(TAG,"Sleep still need to stop " + mStoppingActivities.size() + " activities");
      scheduleIdleLocked();
      dontSleep=true;
    }
    if (mGoingToSleepActivities.size() > 0) {
      if (DEBUG_PAUSE)       Slog.v(TAG,"Sleep still need to sleep " + mGoingToSleepActivities.size() + " activities");
      dontSleep=true;
    }
    if (dontSleep) {
      return;
    }
  }
  for (int stackNdx=mStacks.size() - 1; stackNdx >= 0; --stackNdx) {
    mStacks.get(stackNdx).goToSleep();
  }
  removeSleepTimeouts();
  if (mGoingToSleep.isHeld()) {
    mGoingToSleep.release();
  }
  if (mService.mShuttingDown) {
    mService.notifyAll();
  }
}
