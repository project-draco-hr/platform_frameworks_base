{
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mBlockDrag=false;
  mGestureStartX=ev.getX();
mGestureStartY=ev.getY();
break;
case MotionEvent.ACTION_CANCEL:
if (mDragging) {
showChallenge(0);
}
resetTouch();
break;
case MotionEvent.ACTION_POINTER_UP:
if (mActivePointerId != ev.getPointerId(ev.getActionIndex())) {
break;
}
case MotionEvent.ACTION_UP:
if (OPEN_ON_CLICK && isInDragHandle(mGestureStartX,mGestureStartY) && Math.abs(ev.getX() - mGestureStartX) <= mTouchSlop && Math.abs(ev.getY() - mGestureStartY) <= mTouchSlop) {
showChallenge(true);
}
 else if (mDragging) {
mVelocityTracker.computeCurrentVelocity(1000,mMaxVelocity);
showChallenge((int)mVelocityTracker.getYVelocity(mActivePointerId));
}
resetTouch();
break;
case MotionEvent.ACTION_MOVE:
if (!mDragging && !mBlockDrag && !mIsBouncing) {
final int count=ev.getPointerCount();
for (int i=0; i < count; i++) {
final float x=ev.getX(i);
final float y=ev.getY(i);
if ((isInDragHandle(x,y) || crossedDragHandle(x,y,mGestureStartY) || (isInChallengeView(x,y) && mScrollState == SCROLL_STATE_SETTLING)) && mActivePointerId == INVALID_POINTER) {
mGestureStartX=x;
mGestureStartY=y;
mActivePointerId=ev.getPointerId(i);
mGestureStartChallengeBottom=getChallengeBottom();
mDragging=true;
break;
}
}
}
if (mDragging) {
setScrollState(SCROLL_STATE_DRAGGING);
final int index=ev.findPointerIndex(mActivePointerId);
if (index < 0) {
resetTouch();
showChallenge(0);
return true;
}
final float y=ev.getY(index);
final float pos=Math.min(y - mGestureStartY,getLayoutBottom() - mChallengeBottomBound);
moveChallengeTo(mGestureStartChallengeBottom + (int)pos);
}
break;
}
return true;
}
