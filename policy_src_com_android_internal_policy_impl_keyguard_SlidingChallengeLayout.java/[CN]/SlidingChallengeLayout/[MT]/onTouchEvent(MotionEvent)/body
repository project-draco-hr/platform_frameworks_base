{
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_CANCEL:
    if (mDragging) {
      showChallenge(0);
    }
  resetTouch();
break;
case MotionEvent.ACTION_POINTER_UP:
if (mActivePointerId != ev.getPointerId(ev.getActionIndex())) {
break;
}
case MotionEvent.ACTION_UP:
if (mDragging) {
mVelocityTracker.computeCurrentVelocity(1000,mMaxVelocity);
showChallenge((int)mVelocityTracker.getYVelocity(mActivePointerId));
}
resetTouch();
break;
case MotionEvent.ACTION_MOVE:
if (!mDragging && !mBlockDrag) {
final int count=ev.getPointerCount();
for (int i=0; i < count; i++) {
final float x=ev.getX(i);
final float y=ev.getY(i);
if ((isInDragHandle(x,y) || crossedDragHandle(x,y,mLastTouchY) || (isInChallengeView(x,y) && mScrollState == SCROLL_STATE_SETTLING)) && mActivePointerId == INVALID_POINTER) {
mActivePointerId=ev.getPointerId(i);
mDragging=true;
break;
}
}
}
if (mDragging) {
setScrollState(SCROLL_STATE_DRAGGING);
final int index=ev.findPointerIndex(mActivePointerId);
if (index < 0) {
resetTouch();
showChallenge(0);
return true;
}
final float y=Math.max(ev.getY(index),getChallengeOpenedTop());
final float delta=y - mLastTouchY;
final int idelta=(int)delta;
mLastTouchY=y + delta - idelta;
moveChallengeBy(idelta);
}
break;
}
return true;
}
