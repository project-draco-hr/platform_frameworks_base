{
  if (mLaunching || mLaunchPending) {
    return false;
  }
  int action=event.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mStartTouch=mHorizontal ? event.getX() : event.getY();
  mDragging=false;
mDraggedFarEnough=false;
mCircle.reset();
break;
case MotionEvent.ACTION_MOVE:
float currentTouch=mHorizontal ? event.getX() : event.getY();
if (getVisibility() == View.VISIBLE && !mDragging && (!mCircle.isAnimationRunning(true) || Math.abs(mStartTouch - currentTouch) > mThreshold)) {
mStartDrag=currentTouch;
mDragging=true;
}
if (mDragging) {
float offset=Math.max(mStartDrag - currentTouch,0.0f);
mCircle.setDragDistance(offset);
mDraggedFarEnough=Math.abs(mStartTouch - currentTouch) > mThreshold;
mCircle.setDraggedFarEnough(mDraggedFarEnough);
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (mDraggedFarEnough) {
if (mCircle.isAnimationRunning(true)) {
mLaunchPending=true;
mCircle.setAnimatingOut(true);
mCircle.performOnAnimationFinished(new Runnable(){
@Override public void run(){
startExitAnimation();
}
}
);
}
 else {
startExitAnimation();
}
}
 else {
startAbortAnimation();
}
break;
}
return true;
}
