{
  int action=event.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mStartTouch=mHorizontal ? event.getX() : event.getY();
  mDragging=false;
mDraggedFarEnough=false;
mStartExitAfterAnimatingIn=false;
break;
case MotionEvent.ACTION_MOVE:
float currentTouch=mHorizontal ? event.getX() : event.getY();
if (getVisibility() == View.VISIBLE && !mDragging && (!mAnimatingIn || Math.abs(mStartTouch - currentTouch) > mThreshold)) {
mStartDrag=currentTouch;
mDragging=true;
}
if (!mDraggedFarEnough && Math.abs(mStartTouch - currentTouch) > mThreshold) {
mDraggedFarEnough=true;
}
if (mDragging) {
if (!mAnimatingIn && !mAnimatingOut) {
if (Math.abs(currentTouch - mStartDrag) > mThreshold) {
startExitAnimation();
}
 else {
if (mHorizontal) {
mCard.setX(getWidth() - mPeekHeight + rubberband(currentTouch - mStartDrag));
}
 else {
mCard.setY(getHeight() - mPeekHeight + rubberband(currentTouch - mStartDrag));
}
}
}
 else if (mAnimatingIn) {
float diff=rubberband(currentTouch - mStartDrag);
PropertyValuesHolder[] values=mEnterAnimator.getValues();
values[0].setFloatValues(mHorizontal ? getWidth() + diff : getHeight() + diff,mHorizontal ? getWidth() - mPeekHeight + diff : getHeight() - mPeekHeight + diff);
mEnterAnimator.setCurrentPlayTime(mEnterAnimator.getCurrentPlayTime());
}
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (mDraggedFarEnough) {
if (mAnimatingIn) {
mStartExitAfterAnimatingIn=true;
}
 else {
startExitAnimation();
}
}
 else {
startAbortAnimation();
}
break;
}
return true;
}
