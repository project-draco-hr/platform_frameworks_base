{
  final SQLiteDatabase database=mDatabase.getSQLiteDatabase();
  database.beginTransaction();
  try {
    final String invalidatedIdQuery=createStateFilter(ROW_STATE_INVALIDATED,Document.COLUMN_DOCUMENT_ID);
    final String pendingIdQuery=createStateFilter(ROW_STATE_PENDING,Document.COLUMN_DOCUMENT_ID);
    final Cursor mergingCursor=database.query(TABLE_DOCUMENTS,new String[]{"group_concat(" + invalidatedIdQuery + ")","group_concat(" + pendingIdQuery + ")"},selection,strings(arg),groupKey,"count(" + invalidatedIdQuery + ") = 1 AND count("+ pendingIdQuery+ ") = 1",null);
    final ContentValues values=new ContentValues();
    while (mergingCursor.moveToNext()) {
      final String invalidatedId=mergingCursor.getString(0);
      final String pendingId=mergingCursor.getString(1);
      getFirstRow(TABLE_DOCUMENTS,SELECTION_DOCUMENT_ID,new String[]{pendingId},values);
      values.remove(Document.COLUMN_DOCUMENT_ID);
      values.put(COLUMN_ROW_STATE,ROW_STATE_VALID);
      database.update(TABLE_DOCUMENTS,values,SELECTION_DOCUMENT_ID,new String[]{invalidatedId});
      getFirstRow(TABLE_ROOT_EXTRA,SELECTION_ROOT_ID,new String[]{pendingId},values);
      if (values.size() > 0) {
        values.remove(Root.COLUMN_ROOT_ID);
        database.update(TABLE_ROOT_EXTRA,values,SELECTION_ROOT_ID,new String[]{invalidatedId});
      }
      mDatabase.deleteDocumentsAndRootsRecursively(SELECTION_DOCUMENT_ID,new String[]{pendingId});
    }
    mergingCursor.close();
    boolean changed=false;
    if (mDatabase.deleteDocumentsAndRootsRecursively(COLUMN_ROW_STATE + " = ? AND " + selection,strings(ROW_STATE_INVALIDATED,arg))) {
      changed=true;
    }
    values.clear();
    values.put(COLUMN_ROW_STATE,ROW_STATE_VALID);
    if (database.update(TABLE_DOCUMENTS,values,COLUMN_ROW_STATE + " = ? AND " + selection,strings(ROW_STATE_PENDING,arg)) != 0) {
      changed=true;
    }
    database.setTransactionSuccessful();
    return changed;
  }
  finally {
    database.endTransaction();
  }
}
