{
  Preconditions.checkState(mMappingMode.containsKey(parentId));
  final String selection;
  final String[] args;
  if (parentId != null) {
    selection=COLUMN_PARENT_DOCUMENT_ID + "=?";
    args=strings(parentId);
  }
 else {
    selection=COLUMN_PARENT_DOCUMENT_ID + " IS NULL";
    args=new String[0];
  }
  final String groupKey;
switch (mMappingMode.get(parentId)) {
case MAP_BY_MTP_IDENTIFIER:
    groupKey=parentId != null ? COLUMN_OBJECT_HANDLE : COLUMN_STORAGE_ID;
  break;
case MAP_BY_NAME:
groupKey=Document.COLUMN_DISPLAY_NAME;
break;
default :
throw new Error("Unexpected mapping state.");
}
mMappingMode.remove(parentId);
final SQLiteDatabase database=mDatabase.getSQLiteDatabase();
database.beginTransaction();
try {
final String invalidatedIdQuery=createStateFilter(ROW_STATE_INVALIDATED,Document.COLUMN_DOCUMENT_ID);
final String pendingIdQuery=createStateFilter(ROW_STATE_PENDING,Document.COLUMN_DOCUMENT_ID);
final Cursor mergingCursor=database.query(TABLE_DOCUMENTS,new String[]{"group_concat(" + invalidatedIdQuery + ")","group_concat(" + pendingIdQuery + ")"},selection,args,groupKey,"count(" + invalidatedIdQuery + ") = 1 AND count("+ pendingIdQuery+ ") = 1",null);
final ContentValues values=new ContentValues();
while (mergingCursor.moveToNext()) {
final String invalidatedId=mergingCursor.getString(0);
final String pendingId=mergingCursor.getString(1);
getFirstRow(TABLE_DOCUMENTS,SELECTION_DOCUMENT_ID,new String[]{pendingId},values);
values.remove(Document.COLUMN_DOCUMENT_ID);
values.put(COLUMN_ROW_STATE,ROW_STATE_VALID);
database.update(TABLE_DOCUMENTS,values,SELECTION_DOCUMENT_ID,new String[]{invalidatedId});
getFirstRow(TABLE_ROOT_EXTRA,SELECTION_ROOT_ID,new String[]{pendingId},values);
if (values.size() > 0) {
values.remove(Root.COLUMN_ROOT_ID);
database.update(TABLE_ROOT_EXTRA,values,SELECTION_ROOT_ID,new String[]{invalidatedId});
}
mDatabase.deleteDocumentsAndRootsRecursively(SELECTION_DOCUMENT_ID,new String[]{pendingId});
}
mergingCursor.close();
boolean changed=false;
if (mDatabase.deleteDocumentsAndRootsRecursively(COLUMN_ROW_STATE + " = ? AND " + selection,DatabaseUtils.appendSelectionArgs(strings(ROW_STATE_INVALIDATED),args))) {
changed=true;
}
values.clear();
values.put(COLUMN_ROW_STATE,ROW_STATE_VALID);
if (database.update(TABLE_DOCUMENTS,values,COLUMN_ROW_STATE + " = ? AND " + selection,DatabaseUtils.appendSelectionArgs(strings(ROW_STATE_PENDING),args)) != 0) {
changed=true;
}
database.setTransactionSuccessful();
return changed;
}
  finally {
database.endTransaction();
}
}
