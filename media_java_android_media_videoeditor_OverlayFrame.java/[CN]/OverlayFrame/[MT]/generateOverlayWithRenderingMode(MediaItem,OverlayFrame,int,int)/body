{
  final MediaItem t=mediaItemsList;
  int renderMode=t.getRenderingMode();
  Bitmap overlayBitmap=((OverlayFrame)overlay).getBitmap();
  int resizedRGBFileHeight=((OverlayFrame)overlay).getResizedRGBSizeHeight();
  int resizedRGBFileWidth=((OverlayFrame)overlay).getResizedRGBSizeWidth();
  if (resizedRGBFileWidth == 0) {
    resizedRGBFileWidth=overlayBitmap.getWidth();
  }
  if (resizedRGBFileHeight == 0) {
    resizedRGBFileHeight=overlayBitmap.getHeight();
  }
  if (resizedRGBFileWidth != width || resizedRGBFileHeight != height || (!(new File(((OverlayFrame)overlay).getFilename()).exists()))) {
    final Bitmap destBitmap=Bitmap.createBitmap((int)width,(int)height,Bitmap.Config.ARGB_8888);
    final Canvas overlayCanvas=new Canvas(destBitmap);
    final Rect destRect;
    final Rect srcRect;
switch (renderMode) {
case MediaItem.RENDERING_MODE_STRETCH:
{
        destRect=new Rect(0,0,overlayCanvas.getWidth(),overlayCanvas.getHeight());
        srcRect=new Rect(0,0,overlayBitmap.getWidth(),overlayBitmap.getHeight());
        break;
      }
case MediaItem.RENDERING_MODE_BLACK_BORDER:
{
      int left, right, top, bottom;
      float aROverlayImage, aRCanvas;
      aROverlayImage=(float)(overlayBitmap.getWidth()) / (float)(overlayBitmap.getHeight());
      aRCanvas=(float)(overlayCanvas.getWidth()) / (float)(overlayCanvas.getHeight());
      if (aROverlayImage > aRCanvas) {
        int newHeight=((overlayCanvas.getWidth() * overlayBitmap.getHeight()) / overlayBitmap.getWidth());
        left=0;
        top=(overlayCanvas.getHeight() - newHeight) / 2;
        right=overlayCanvas.getWidth();
        bottom=top + newHeight;
      }
 else {
        int newWidth=((overlayCanvas.getHeight() * overlayBitmap.getWidth()) / overlayBitmap.getHeight());
        left=(overlayCanvas.getWidth() - newWidth) / 2;
        top=0;
        right=left + newWidth;
        bottom=overlayCanvas.getHeight();
      }
      destRect=new Rect(left,top,right,bottom);
      srcRect=new Rect(0,0,overlayBitmap.getWidth(),overlayBitmap.getHeight());
      break;
    }
case MediaItem.RENDERING_MODE_CROPPING:
{
    int left, right, top, bottom;
    float aROverlayImage, aRCanvas;
    aROverlayImage=(float)(overlayBitmap.getWidth()) / (float)(overlayBitmap.getHeight());
    aRCanvas=(float)(overlayCanvas.getWidth()) / (float)(overlayCanvas.getHeight());
    if (aROverlayImage < aRCanvas) {
      int newHeight=((overlayBitmap.getWidth() * overlayCanvas.getHeight()) / overlayCanvas.getWidth());
      left=0;
      top=(overlayBitmap.getHeight() - newHeight) / 2;
      right=overlayBitmap.getWidth();
      bottom=top + newHeight;
    }
 else {
      int newWidth=((overlayBitmap.getHeight() * overlayCanvas.getWidth()) / overlayCanvas.getHeight());
      left=(overlayBitmap.getWidth() - newWidth) / 2;
      top=0;
      right=left + newWidth;
      bottom=overlayBitmap.getHeight();
    }
    srcRect=new Rect(left,top,right,bottom);
    destRect=new Rect(0,0,overlayCanvas.getWidth(),overlayCanvas.getHeight());
    break;
  }
default :
{
  throw new IllegalStateException("Rendering mode: " + renderMode);
}
}
overlayCanvas.drawBitmap(overlayBitmap,srcRect,destRect,sResizePaint);
overlayCanvas.setBitmap(null);
String outFileName=((OverlayFrame)overlay).getFilename();
if (outFileName != null) {
new File(outFileName).delete();
}
final FileOutputStream fl=new FileOutputStream(outFileName);
final DataOutputStream dos=new DataOutputStream(fl);
final int[] framingBuffer=new int[width];
ByteBuffer byteBuffer=ByteBuffer.allocate(framingBuffer.length * 4);
IntBuffer intBuffer;
byte[] array=byteBuffer.array();
int tmp=0;
while (tmp < height) {
destBitmap.getPixels(framingBuffer,0,width,0,tmp,width,1);
intBuffer=byteBuffer.asIntBuffer();
intBuffer.put(framingBuffer,0,width);
dos.write(array);
tmp+=1;
}
fl.flush();
fl.close();
((OverlayFrame)overlay).setResizedRGBSize(width,height);
}
}
