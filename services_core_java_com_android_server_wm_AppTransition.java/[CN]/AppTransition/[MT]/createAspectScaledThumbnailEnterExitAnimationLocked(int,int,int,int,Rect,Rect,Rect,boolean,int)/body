{
  Animation a;
  final int appWidth=containingFrame.width();
  final int appHeight=containingFrame.height();
  getDefaultNextAppTransitionStartRect(mTmpRect);
  final int thumbWidthI=mTmpRect.width();
  final float thumbWidth=thumbWidthI > 0 ? thumbWidthI : 1;
  final int thumbHeightI=mTmpRect.height();
  final float thumbHeight=thumbHeightI > 0 ? thumbHeightI : 1;
  final int thumbStartX=mTmpRect.left - containingFrame.left;
  final int thumbStartY=mTmpRect.top - containingFrame.top;
switch (thumbTransitState) {
case THUMBNAIL_TRANSITION_ENTER_SCALE_UP:
case THUMBNAIL_TRANSITION_EXIT_SCALE_DOWN:
{
      final boolean scaleUp=thumbTransitState == THUMBNAIL_TRANSITION_ENTER_SCALE_UP;
      if (freeform && scaleUp) {
        a=createAspectScaledThumbnailEnterFreeformAnimationLocked(containingFrame,surfaceInsets,taskId);
      }
 else       if (freeform) {
        a=createAspectScaledThumbnailExitFreeformAnimationLocked(containingFrame,surfaceInsets,taskId);
      }
 else {
        AnimationSet set=new AnimationSet(true);
        mTmpFromClipRect.set(containingFrame);
        mTmpToClipRect.set(containingFrame);
        mTmpFromClipRect.offsetTo(0,0);
        mTmpToClipRect.offsetTo(0,0);
        mTmpFromClipRect.inset(contentInsets);
        mNextAppTransitionInsets.set(contentInsets);
        if (isTvUiMode(uiMode) || orientation == Configuration.ORIENTATION_PORTRAIT) {
          float scale=thumbWidth / (appWidth - contentInsets.left - contentInsets.right);
          int unscaledThumbHeight=(int)(thumbHeight / scale);
          mTmpFromClipRect.bottom=mTmpFromClipRect.top + unscaledThumbHeight;
          mNextAppTransitionInsets.set(contentInsets);
          Animation scaleAnim=new ScaleAnimation(scaleUp ? scale : 1,scaleUp ? 1 : scale,scaleUp ? scale : 1,scaleUp ? 1 : scale,containingFrame.width() / 2f,containingFrame.height() / 2f + contentInsets.top);
          final float targetX=(mTmpRect.left - containingFrame.left);
          final float x=containingFrame.width() / 2f - containingFrame.width() / 2f * scale;
          final float targetY=(mTmpRect.top - containingFrame.top);
          final float y=containingFrame.height() / 2f - containingFrame.height() / 2f * scale;
          final float startX=targetX - x;
          final float startY=targetY - y;
          Animation clipAnim=scaleUp ? new ClipRectAnimation(mTmpFromClipRect,mTmpToClipRect) : new ClipRectAnimation(mTmpToClipRect,mTmpFromClipRect);
          Animation translateAnim=scaleUp ? createCurvedMotion(startX,0,startY - contentInsets.top,0) : createCurvedMotion(0,startX,0,startY - contentInsets.top);
          set.addAnimation(clipAnim);
          set.addAnimation(scaleAnim);
          set.addAnimation(translateAnim);
        }
 else {
          mTmpFromClipRect.bottom=mTmpFromClipRect.top + thumbHeightI;
          mTmpFromClipRect.right=mTmpFromClipRect.left + thumbWidthI;
          Animation clipAnim=scaleUp ? new ClipRectAnimation(mTmpFromClipRect,mTmpToClipRect) : new ClipRectAnimation(mTmpToClipRect,mTmpFromClipRect);
          Animation translateAnim=scaleUp ? createCurvedMotion(thumbStartX,0,thumbStartY - contentInsets.top,0) : createCurvedMotion(0,thumbStartX,0,thumbStartY - contentInsets.top);
          set.addAnimation(clipAnim);
          set.addAnimation(translateAnim);
        }
        a=set;
        a.setZAdjustment(Animation.ZORDER_TOP);
      }
      break;
    }
case THUMBNAIL_TRANSITION_EXIT_SCALE_UP:
{
    if (transit == TRANSIT_WALLPAPER_INTRA_OPEN) {
      a=new AlphaAnimation(1,0);
    }
 else {
      a=new AlphaAnimation(1,1);
    }
    break;
  }
case THUMBNAIL_TRANSITION_ENTER_SCALE_DOWN:
{
  if (transit == TRANSIT_WALLPAPER_INTRA_OPEN) {
    a=new AlphaAnimation(0,1);
  }
 else {
    a=new AlphaAnimation(1,1);
  }
  break;
}
default :
throw new RuntimeException("Invalid thumbnail transition state");
}
return prepareThumbnailAnimationWithDuration(a,appWidth,appHeight,getAspectScaleDuration(),getAspectScaleInterpolator());
}
