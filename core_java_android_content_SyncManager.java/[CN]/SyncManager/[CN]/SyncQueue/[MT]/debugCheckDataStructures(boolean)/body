{
  if (mOpsByKey.size() != mOpsByWhen.size()) {
    throw new IllegalStateException("size mismatch: " + mOpsByKey.size() + " != "+ mOpsByWhen.size());
  }
  for (  SyncOperation operation : mOpsByWhen) {
    if (!mOpsByKey.containsKey(operation.key)) {
      throw new IllegalStateException("operation " + operation + " is in mOpsByWhen but not mOpsByKey");
    }
  }
  for (  Map.Entry<String,SyncOperation> entry : mOpsByKey.entrySet()) {
    final SyncOperation operation=entry.getValue();
    final String key=entry.getKey();
    if (!key.equals(operation.key)) {
      throw new IllegalStateException("operation " + operation + " in mOpsByKey doesn't match key "+ key);
    }
    if (!mOpsByWhen.contains(operation)) {
      throw new IllegalStateException("operation " + operation + " is in mOpsByKey but not mOpsByWhen");
    }
  }
  if (checkDatabase) {
    final int N=mSyncStorageEngine.getPendingOperationCount();
    if (mOpsByKey.size() != N) {
      ArrayList<SyncStorageEngine.PendingOperation> ops=mSyncStorageEngine.getPendingOperations();
      StringBuilder sb=new StringBuilder();
      for (int i=0; i < N; i++) {
        SyncStorageEngine.PendingOperation op=ops.get(i);
        sb.append("#");
        sb.append(i);
        sb.append(": account=");
        sb.append(op.account);
        sb.append(" syncSource=");
        sb.append(op.syncSource);
        sb.append(" authority=");
        sb.append(op.authority);
        sb.append("\n");
      }
      dump(sb);
      throw new IllegalStateException("DB size mismatch: " + mOpsByKey.size() + " != "+ N+ "\n"+ sb.toString());
    }
  }
}
