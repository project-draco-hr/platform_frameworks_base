{
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  long nextBindTimeoutTime=Long.MAX_VALUE;
  try {
    waitUntilReadyToRun();
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    nextBindTimeoutTime=auditRunningSyncsForStuckBindsLocked();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_CANCEL:
{
        Pair<Account,String> payload=(Pair<Account,String>)msg.obj;
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_CANCEL: " + payload.first + ", "+ payload.second);
        }
        cancelActiveSyncLocked(payload.first,payload.second);
        nextPendingSyncTime=maybeStartNextSyncLocked();
        break;
      }
case SyncHandler.MESSAGE_SYNC_FINISHED:
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED");
    }
  SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActive(payload.activeSyncContext)) {
  Log.d(TAG,"handleSyncHandlerMessage: dropping since the " + "sync is no longer active: " + payload.activeSyncContext);
  break;
}
runSyncFinishedOrCanceledLocked(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncLocked();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: " + msgData.activeSyncContext);
}
if (isSyncStillActive(msgData.activeSyncContext)) {
runBoundToSyncAdapter(msgData.activeSyncContext,msgData.syncAdapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: " + currentSyncContext);
}
if (isSyncStillActive(currentSyncContext)) {
if (currentSyncContext.mSyncAdapter != null) {
try {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 catch (RemoteException e) {
}
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledLocked(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncLocked();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_ALARM");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncLocked();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS");
}
nextPendingSyncTime=maybeStartNextSyncLocked();
break;
}
}
  finally {
nextPendingSyncTime=Math.min(nextBindTimeoutTime,nextPendingSyncTime);
manageSyncNotificationLocked();
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}
