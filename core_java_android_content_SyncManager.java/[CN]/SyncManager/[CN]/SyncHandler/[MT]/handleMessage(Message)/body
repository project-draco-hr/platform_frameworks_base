{
  Long earliestFuturePollTime=null;
  try {
    waitUntilReadyToRun();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_SYNC_FINISHED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED");
      }
    SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
  if (mActiveSyncContext != payload.activeSyncContext) {
    Log.d(TAG,"handleSyncHandlerMessage: sync context doesn't match, " + "dropping: mActiveSyncContext " + mActiveSyncContext + " != "+ payload.activeSyncContext);
    return;
  }
runSyncFinishedOrCanceled(payload.syncResult);
runStateIdle();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: " + msgData.activeSyncContext + " active is "+ mActiveSyncContext);
}
if (mActiveSyncContext == msgData.activeSyncContext) {
runBoundToSyncAdapter(msgData.syncAdapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: " + msgData.activeSyncContext + " active is "+ mActiveSyncContext);
}
if (mActiveSyncContext == msgData.activeSyncContext) {
if (mActiveSyncContext.mSyncAdapter != null) {
try {
mActiveSyncContext.mSyncAdapter.cancelSync(mActiveSyncContext);
}
 catch (RemoteException e) {
}
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceled(syncResult);
runStateIdle();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_ALARM");
}
mAlarmScheduleTime=null;
try {
if (mActiveSyncContext != null) {
if (isLoggable) {
Log.v(TAG,"handleSyncHandlerMessage: sync context is active");
}
runStateSyncing();
}
if (mActiveSyncContext == null) {
if (isLoggable) {
Log.v(TAG,"handleSyncHandlerMessage: " + "sync context is not active");
}
runStateIdle();
}
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS");
}
break;
}
}
  finally {
final boolean isSyncInProgress=mActiveSyncContext != null;
if (!isSyncInProgress && mSyncWakeLock != null) {
mSyncWakeLock.release();
mSyncWakeLock=null;
}
manageSyncNotification();
manageErrorNotification();
manageSyncAlarm(earliestFuturePollTime);
mSyncTimeTracker.update();
}
}
