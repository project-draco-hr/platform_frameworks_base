{
  final ActivityRecord next=mStackSupervisor.topRunningActivityLocked();
  if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible) && next != null && !next.nowVisible) {
    if (!mStackSupervisor.mStoppingActivities.contains(r)) {
      addToStopping(r,false);
    }
    if (DEBUG_STATES)     Slog.v(TAG_STATES,"Moving to STOPPING: " + r + " (finish requested)");
    r.state=ActivityState.STOPPING;
    if (oomAdj) {
      mService.updateOomAdjLocked();
    }
    return r;
  }
  mStackSupervisor.mStoppingActivities.remove(r);
  mStackSupervisor.mGoingToSleepActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  final ActivityState prevState=r.state;
  if (DEBUG_STATES)   Slog.v(TAG_STATES,"Moving to FINISHING: " + r);
  r.state=ActivityState.FINISHING;
  if (mode == FINISH_IMMEDIATELY || (mode == FINISH_AFTER_PAUSE && prevState == ActivityState.PAUSED) || prevState == ActivityState.STOPPED || prevState == ActivityState.INITIALIZING) {
    r.makeFinishingLocked();
    boolean activityRemoved=destroyActivityLocked(r,true,"finish-imm");
    if (activityRemoved) {
      mStackSupervisor.resumeFocusedStackTopActivityLocked();
    }
    if (DEBUG_CONTAINERS)     Slog.d(TAG_CONTAINERS,"destroyActivityLocked: finishCurrentActivityLocked r=" + r + " destroy returned removed="+ activityRemoved);
    return activityRemoved ? null : r;
  }
  if (DEBUG_ALL)   Slog.v(TAG,"Enqueueing pending finish: " + r);
  mStackSupervisor.mFinishingActivities.add(r);
  r.resumeKeyDispatchingLocked();
  mStackSupervisor.resumeFocusedStackTopActivityLocked();
  return r;
}
