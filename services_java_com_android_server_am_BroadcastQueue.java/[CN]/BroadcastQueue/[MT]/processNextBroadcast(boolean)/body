{
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG,"processNextBroadcast [" + mQueueName + "]: "+ mParallelBroadcasts.size()+ " broadcasts, "+ mOrderedBroadcasts.size()+ " ordered broadcasts");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,"Processing parallel broadcast [" + mQueueName + "] "+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG,"Delivering non-ordered on [" + mQueueName + "] to registered "+ target+ ": "+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,"Done with parallel broadcast [" + mQueueName + "] "+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT) {
        Slog.v(TAG,"processNextBroadcast [" + mQueueName + "]: waiting for "+ mPendingBroadcast.curApp);
      }
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,"pending app  [" + mQueueName + "]"+ mPendingBroadcast.curApp+ " died before responding to broadcast");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,"Hung broadcast [" + mQueueName + "] discarded after timeout failure:"+ " now="+ now+ " dispatchTime="+ r.dispatchTime+ " startTime="+ r.receiverTime+ " intent="+ r.intent+ " numReceivers="+ numReceivers+ " nextReceiver="+ r.nextReceiver+ " state="+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG,"processNextBroadcast(" + mQueueName + ") called when not idle (state="+ r.state+ ")");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST) {
              int seq=r.intent.getIntExtra("seq",-1);
              Slog.i(TAG,"Finishing broadcast [" + mQueueName + "] "+ r.intent.getAction()+ " seq="+ seq+ " app="+ r.callerApp);
            }
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            Slog.w(TAG,"Failure [" + mQueueName + "] sending broadcast result of "+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG,"Cancelling BROADCAST_TIMEOUT_MSG");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG,"Finished with ordered broadcast " + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG,"Processing ordered broadcast [" + mQueueName + "] "+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Submitting BROADCAST_TIMEOUT_MSG [" + mQueueName + "] for "+ r+ " at "+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Delivering ordered [" + mQueueName + "] to registered "+ filter+ ": "+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG,"Quick finishing [" + mQueueName + "]: ordered="+ r.ordered+ " receiver="+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,"Permission Denial: broadcasting " + r.intent.toString() + " from "+ r.callerPackage+ " (pid="+ r.callingPid+ ", uid="+ r.callingUid+ ")"+ " is not exported from uid "+ info.activityInfo.applicationInfo.uid+ " due to receiver "+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,"Permission Denial: broadcasting " + r.intent.toString() + " from "+ r.callerPackage+ " (pid="+ r.callingPid+ ", uid="+ r.callingUid+ ")"+ " requires "+ info.activityInfo.permission+ " due to receiver "+ component.flattenToShortString());
      }
      skip=true;
    }
    if (info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermission != null) {
      try {
        perm=AppGlobals.getPackageManager().checkPermission(r.requiredPermission,info.activityInfo.applicationInfo.packageName);
      }
 catch (      RemoteException e) {
        perm=PackageManager.PERMISSION_DENIED;
      }
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,"Permission Denial: receiving " + r.intent + " to "+ component.flattenToShortString()+ " requires "+ r.requiredPermission+ " due to sender "+ r.callerPackage+ " (uid "+ r.callingUid+ ")");
        skip=true;
      }
    }
    if (r.appOp != AppOpsManager.OP_NONE) {
      int mode=mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName);
      if (mode != AppOpsManager.MODE_ALLOWED) {
        if (DEBUG_BROADCAST)         Slog.v(TAG,"App op " + r.appOp + " not allowed for broadcast to uid "+ info.activityInfo.applicationInfo.uid+ " pkg "+ info.activityInfo.packageName);
        skip=true;
      }
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,"Permission Denial: Receiver " + component.flattenToShortString() + " requests FLAG_SINGLE_USER, but app does not hold "+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,"Skipping deliver ordered [" + mQueueName + "] "+ r+ " to "+ r.curApp+ ": process crashing");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,"Exception getting recipient info for " + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST) {
          Slog.v(TAG,"Skipping delivery to " + info.activityInfo.packageName + " / "+ info.activityInfo.applicationInfo.uid+ " : package no longer available");
        }
        skip=true;
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG,"Skipping delivery of ordered [" + mQueueName + "] "+ r+ " for whatever reason");
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.state=BroadcastRecord.APP_RECEIVE;
    String targetProcess=info.activityInfo.processName;
    r.curComponent=component;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,"Updated broadcast record activity info for secondary user, " + info.activityInfo + ", callingUid = "+ r.callingUid+ ", uid = "+ info.activityInfo.applicationInfo.uid);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,"Failed trying to unstop package " + r.curComponent.getPackageName() + ": "+ e);
    }
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,"Exception when sending broadcast to " + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Log.wtf(TAG,"Failed sending broadcast to " + r.curComponent + " with "+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG,"Need to start app [" + mQueueName + "] "+ targetProcess+ " for broadcast "+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,"broadcast",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,"Unable to launch app " + info.activityInfo.applicationInfo.packageName + "/"+ info.activityInfo.applicationInfo.uid+ " for broadcast "+ r.intent+ ": process is bad");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}
