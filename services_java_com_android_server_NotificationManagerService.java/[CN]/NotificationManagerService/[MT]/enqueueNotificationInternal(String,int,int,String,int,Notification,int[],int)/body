{
  if (DBG) {
    Slog.v(TAG,"enqueueNotificationInternal: pkg=" + pkg + " id="+ id+ " notification="+ notification);
  }
  checkCallerIsSystemOrSameApp(pkg);
  final boolean isSystemNotification=("android".equals(pkg));
  userId=ActivityManager.handleIncomingUser(callingPid,callingUid,userId,true,false,"enqueueNotification",pkg);
  final UserHandle user=new UserHandle(userId);
  if (!isSystemNotification) {
synchronized (mNotificationList) {
      int count=0;
      final int N=mNotificationList.size();
      for (int i=0; i < N; i++) {
        final NotificationRecord r=mNotificationList.get(i);
        if (r.pkg.equals(pkg) && r.userId == userId) {
          count++;
          if (count >= MAX_PACKAGE_NOTIFICATIONS) {
            Slog.e(TAG,"Package has already posted " + count + " notifications.  Not showing more.  package="+ pkg);
            return;
          }
        }
      }
    }
  }
  if (!pkg.equals("com.android.providers.downloads") || Log.isLoggable("DownloadManager",Log.VERBOSE)) {
    EventLog.writeEvent(EventLogTags.NOTIFICATION_ENQUEUE,pkg,id,tag,userId,notification.toString());
  }
  if (pkg == null || notification == null) {
    throw new IllegalArgumentException("null not allowed: pkg=" + pkg + " id="+ id+ " notification="+ notification);
  }
  if (notification.icon != 0) {
    if (notification.contentView == null) {
      throw new IllegalArgumentException("contentView required: pkg=" + pkg + " id="+ id+ " notification="+ notification);
    }
  }
  notification.priority=clamp(notification.priority,Notification.PRIORITY_MIN,Notification.PRIORITY_MAX);
  if (0 != (notification.flags & Notification.FLAG_HIGH_PRIORITY)) {
    if (notification.priority < Notification.PRIORITY_MAX)     notification.priority=Notification.PRIORITY_MAX;
  }
 else   if (SCORE_ONGOING_HIGHER && 0 != (notification.flags & Notification.FLAG_ONGOING_EVENT)) {
    if (notification.priority < Notification.PRIORITY_HIGH)     notification.priority=Notification.PRIORITY_HIGH;
  }
  int score=notification.priority * NOTIFICATION_PRIORITY_MULTIPLIER;
  if (ENABLE_BLOCKED_NOTIFICATIONS && !noteNotificationOp(pkg,callingUid)) {
    if (!isSystemNotification) {
      score=JUNK_SCORE;
      Slog.e(TAG,"Suppressing notification from package " + pkg + " by user request.");
    }
  }
  if (DBG) {
    Slog.v(TAG,"Assigned score=" + score + " to "+ notification);
  }
  if (score < SCORE_DISPLAY_THRESHOLD) {
    return;
  }
  final boolean canInterrupt=(score >= SCORE_INTERRUPTION_THRESHOLD);
synchronized (mNotificationList) {
    NotificationRecord r=new NotificationRecord(pkg,tag,id,callingUid,callingPid,userId,score,notification);
    NotificationRecord old=null;
    int index=indexOfNotificationLocked(pkg,tag,id,userId);
    if (index < 0) {
      mNotificationList.add(r);
    }
 else {
      old=mNotificationList.remove(index);
      mNotificationList.add(index,r);
      if (old != null) {
        notification.flags|=old.notification.flags & Notification.FLAG_FOREGROUND_SERVICE;
      }
    }
    if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
      notification.flags|=Notification.FLAG_ONGOING_EVENT | Notification.FLAG_NO_CLEAR;
    }
    final int currentUser;
    final long token=Binder.clearCallingIdentity();
    try {
      currentUser=ActivityManager.getCurrentUser();
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
    if (notification.icon != 0) {
      final StatusBarNotification n=new StatusBarNotification(pkg,id,tag,r.uid,r.initialPid,score,notification,user);
      if (old != null && old.statusBarKey != null) {
        r.statusBarKey=old.statusBarKey;
        long identity=Binder.clearCallingIdentity();
        try {
          mStatusBar.updateNotification(r.statusBarKey,n);
        }
  finally {
          Binder.restoreCallingIdentity(identity);
        }
      }
 else {
        long identity=Binder.clearCallingIdentity();
        try {
          r.statusBarKey=mStatusBar.addNotification(n);
          if ((n.notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
            mAttentionLight.pulse();
          }
        }
  finally {
          Binder.restoreCallingIdentity(identity);
        }
      }
      if (currentUser == userId) {
        sendAccessibilityEvent(notification,pkg);
      }
    }
 else {
      Slog.e(TAG,"Ignoring notification with icon==0: " + notification);
      if (old != null && old.statusBarKey != null) {
        long identity=Binder.clearCallingIdentity();
        try {
          mStatusBar.removeNotification(old.statusBarKey);
        }
  finally {
          Binder.restoreCallingIdentity(identity);
        }
      }
    }
    if (((mDisabledNotifications & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) == 0) && (!(old != null && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (r.userId == UserHandle.USER_ALL || (r.userId == userId && r.userId == currentUser))&& canInterrupt&& mSystemReady) {
      final AudioManager audioManager=(AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
      final boolean useDefaultSound=(notification.defaults & Notification.DEFAULT_SOUND) != 0;
      Uri soundUri=null;
      boolean hasValidSound=false;
      if (useDefaultSound) {
        soundUri=Settings.System.DEFAULT_NOTIFICATION_URI;
        ContentResolver resolver=mContext.getContentResolver();
        hasValidSound=Settings.System.getString(resolver,Settings.System.NOTIFICATION_SOUND) != null;
      }
 else       if (notification.sound != null) {
        soundUri=notification.sound;
        hasValidSound=(soundUri != null);
      }
      if (hasValidSound) {
        boolean looping=(notification.flags & Notification.FLAG_INSISTENT) != 0;
        int audioStreamType;
        if (notification.audioStreamType >= 0) {
          audioStreamType=notification.audioStreamType;
        }
 else {
          audioStreamType=DEFAULT_STREAM_TYPE;
        }
        mSoundNotification=r;
        if ((audioManager.getStreamVolume(audioStreamType) != 0) && !audioManager.isSpeechRecognitionActive()) {
          final long identity=Binder.clearCallingIdentity();
          try {
            final IRingtonePlayer player=mAudioService.getRingtonePlayer();
            if (player != null) {
              player.playAsync(soundUri,user,looping,audioStreamType);
            }
          }
 catch (          RemoteException e) {
          }
 finally {
            Binder.restoreCallingIdentity(identity);
          }
        }
      }
      final boolean hasCustomVibrate=notification.vibrate != null;
      final boolean convertSoundToVibration=!hasCustomVibrate && hasValidSound && (audioManager.getRingerMode() == AudioManager.RINGER_MODE_VIBRATE);
      final boolean useDefaultVibrate=(notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
      if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(audioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT)) {
        mVibrateNotification=r;
        if (useDefaultVibrate || convertSoundToVibration) {
          long identity=Binder.clearCallingIdentity();
          try {
            mVibrator.vibrate(useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1);
          }
  finally {
            Binder.restoreCallingIdentity(identity);
          }
        }
 else         if (notification.vibrate.length > 1) {
          mVibrator.vibrate(notification.vibrate,((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1);
        }
      }
    }
    mLights.remove(old);
    if (mLedNotification == old) {
      mLedNotification=null;
    }
    if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterrupt) {
      mLights.add(r);
      updateLightsLocked();
    }
 else {
      if (old != null && ((old.notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0)) {
        updateLightsLocked();
      }
    }
  }
  idOut[0]=id;
}
