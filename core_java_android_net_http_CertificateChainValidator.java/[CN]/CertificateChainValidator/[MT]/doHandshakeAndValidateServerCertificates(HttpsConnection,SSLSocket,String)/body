{
  X509Certificate[] serverCertificates=null;
  try {
    sslSocket.setUseClientMode(true);
    sslSocket.startHandshake();
  }
 catch (  IOException e) {
    closeSocketThrowException(sslSocket,e.getMessage(),"failed to perform SSL handshake");
  }
  Certificate[] peerCertificates=sslSocket.getSession().getPeerCertificates();
  if (peerCertificates == null || peerCertificates.length <= 0) {
    closeSocketThrowException(sslSocket,"failed to retrieve peer certificates");
  }
 else {
    serverCertificates=new X509Certificate[peerCertificates.length];
    for (int i=0; i < peerCertificates.length; ++i) {
      serverCertificates[i]=(X509Certificate)(peerCertificates[i]);
    }
    if (connection != null) {
      if (serverCertificates[0] != null) {
        connection.setCertificate(new SslCertificate(serverCertificates[0]));
      }
    }
  }
  X509Certificate currCertificate=serverCertificates[0];
  if (currCertificate == null) {
    closeSocketThrowException(sslSocket,"certificate for this site is null");
  }
 else {
    if (!DomainNameChecker.match(currCertificate,domain)) {
      String errorMessage="certificate not for this host: " + domain;
      if (HttpLog.LOGV) {
        HttpLog.v(errorMessage);
      }
      sslSocket.getSession().invalidate();
      return new SslError(SslError.SSL_IDMISMATCH,currCertificate);
    }
  }
  try {
    SSLParameters.getDefaultTrustManager().checkServerTrusted(serverCertificates,"RSA");
    return null;
  }
 catch (  CertificateException e) {
    if (HttpLog.LOGV) {
      HttpLog.v("failed to pre-validate the certificate chain, error: " + e.getMessage());
    }
  }
  sslSocket.getSession().invalidate();
  SslError error=null;
  currCertificate=serverCertificates[serverCertificates.length - 1];
  if (currCertificate == null) {
    closeSocketThrowException(sslSocket,"root certificate is null");
  }
  X509Certificate[] rootCertificateChain={currCertificate};
  try {
    SSLParameters.getDefaultTrustManager().checkServerTrusted(rootCertificateChain,"RSA");
  }
 catch (  CertificateExpiredException e) {
    String errorMessage=e.getMessage();
    if (errorMessage == null) {
      errorMessage="root certificate has expired";
    }
    if (HttpLog.LOGV) {
      HttpLog.v(errorMessage);
    }
    error=new SslError(SslError.SSL_EXPIRED,currCertificate);
  }
catch (  CertificateNotYetValidException e) {
    String errorMessage=e.getMessage();
    if (errorMessage == null) {
      errorMessage="root certificate not valid yet";
    }
    if (HttpLog.LOGV) {
      HttpLog.v(errorMessage);
    }
    error=new SslError(SslError.SSL_NOTYETVALID,currCertificate);
  }
catch (  CertificateException e) {
    String errorMessage=e.getMessage();
    if (errorMessage == null) {
      errorMessage="root certificate not trusted";
    }
    if (HttpLog.LOGV) {
      HttpLog.v(errorMessage);
    }
    return new SslError(SslError.SSL_UNTRUSTED,currCertificate);
  }
  X509Certificate prevCertificate=serverCertificates[serverCertificates.length - 1];
  for (int i=serverCertificates.length - 2; i >= 0; --i) {
    currCertificate=serverCertificates[i];
    if (currCertificate == null) {
      closeSocketThrowException(sslSocket,"null certificate in the chain");
    }
    if (!prevCertificate.getSubjectDN().equals(currCertificate.getIssuerDN())) {
      String errorMessage="not trusted by chain";
      if (HttpLog.LOGV) {
        HttpLog.v(errorMessage);
      }
      return new SslError(SslError.SSL_UNTRUSTED,currCertificate);
    }
    try {
      currCertificate.verify(prevCertificate.getPublicKey());
    }
 catch (    GeneralSecurityException e) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="not trusted by chain";
      }
      if (HttpLog.LOGV) {
        HttpLog.v(errorMessage);
      }
      return new SslError(SslError.SSL_UNTRUSTED,currCertificate);
    }
    try {
      currCertificate.checkValidity();
    }
 catch (    CertificateExpiredException e) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="certificate expired";
      }
      if (HttpLog.LOGV) {
        HttpLog.v(errorMessage);
      }
      if (error == null || error.getPrimaryError() < SslError.SSL_EXPIRED) {
        error=new SslError(SslError.SSL_EXPIRED,currCertificate);
      }
    }
catch (    CertificateNotYetValidException e) {
      String errorMessage=e.getMessage();
      if (errorMessage == null) {
        errorMessage="certificate not valid yet";
      }
      if (HttpLog.LOGV) {
        HttpLog.v(errorMessage);
      }
      if (error == null || error.getPrimaryError() < SslError.SSL_NOTYETVALID) {
        error=new SslError(SslError.SSL_NOTYETVALID,currCertificate);
      }
    }
    prevCertificate=currCertificate;
  }
  if (error == null) {
    closeSocketThrowException(sslSocket,"failed to pre-validate the certificate chain due to a non-standard error");
  }
  return error;
}
