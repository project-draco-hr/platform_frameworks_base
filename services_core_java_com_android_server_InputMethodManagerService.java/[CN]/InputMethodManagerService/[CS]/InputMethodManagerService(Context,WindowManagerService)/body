{
  mIPackageManager=AppGlobals.getPackageManager();
  mContext=context;
  mRes=context.getResources();
  mHandler=new Handler(this);
  mIWindowManager=IWindowManager.Stub.asInterface(ServiceManager.getService(Context.WINDOW_SERVICE));
  mCaller=new HandlerCaller(context,null,new HandlerCaller.Callback(){
    @Override public void executeMessage(    Message msg){
      handleMessage(msg);
    }
  }
,true);
  mWindowManagerService=windowManager;
  mAppOpsManager=(AppOpsManager)mContext.getSystemService(Context.APP_OPS_SERVICE);
  mHardKeyboardListener=new HardKeyboardListener();
  mHasFeature=context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_INPUT_METHODS);
  mImeSwitcherNotification=new Notification();
  mImeSwitcherNotification.icon=com.android.internal.R.drawable.ic_notification_ime_default;
  mImeSwitcherNotification.when=0;
  mImeSwitcherNotification.flags=Notification.FLAG_ONGOING_EVENT;
  mImeSwitcherNotification.tickerText=null;
  mImeSwitcherNotification.defaults=0;
  mImeSwitcherNotification.sound=null;
  mImeSwitcherNotification.vibrate=null;
  mImeSwitcherNotification.extras.putBoolean(Notification.EXTRA_ALLOW_DURING_SETUP,true);
  mImeSwitcherNotification.category=Notification.CATEGORY_SYSTEM;
  Intent intent=new Intent(Settings.ACTION_SHOW_INPUT_METHOD_PICKER);
  mImeSwitchPendingIntent=PendingIntent.getBroadcast(mContext,0,intent,0);
  mShowOngoingImeSwitcherForPhones=false;
  final IntentFilter broadcastFilter=new IntentFilter();
  broadcastFilter.addAction(Intent.ACTION_SCREEN_ON);
  broadcastFilter.addAction(Intent.ACTION_SCREEN_OFF);
  broadcastFilter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  broadcastFilter.addAction(Intent.ACTION_USER_ADDED);
  broadcastFilter.addAction(Intent.ACTION_USER_REMOVED);
  broadcastFilter.addAction(Intent.ACTION_SETTING_RESTORED);
  mContext.registerReceiver(new ImmsBroadcastReceiver(),broadcastFilter);
  mNotificationShown=false;
  int userId=0;
  try {
    ActivityManagerNative.getDefault().registerUserSwitchObserver(new IUserSwitchObserver.Stub(){
      @Override public void onUserSwitching(      int newUserId,      IRemoteCallback reply){
synchronized (mMethodMap) {
          switchUserLocked(newUserId);
        }
        if (reply != null) {
          try {
            reply.sendResult(null);
          }
 catch (          RemoteException e) {
          }
        }
      }
      @Override public void onUserSwitchComplete(      int newUserId) throws RemoteException {
      }
    }
);
    userId=ActivityManagerNative.getDefault().getCurrentUser().id;
  }
 catch (  RemoteException e) {
    Slog.w(TAG,"Couldn't get current user ID; guessing it's 0",e);
  }
  mMyPackageMonitor.register(mContext,null,UserHandle.ALL,true);
  mSettings=new InputMethodSettings(mRes,context.getContentResolver(),mMethodMap,mMethodList,userId);
  updateCurrentProfileIds();
  mFileManager=new InputMethodFileManager(mMethodMap,userId);
synchronized (mMethodMap) {
    mSwitchingController=InputMethodSubtypeSwitchingController.createInstanceLocked(mSettings,context);
  }
  final String defaultImiId=mSettings.getSelectedInputMethod();
  if (DEBUG) {
    Slog.d(TAG,"Initial default ime = " + defaultImiId);
  }
  mImeSelectedOnBoot=!TextUtils.isEmpty(defaultImiId);
synchronized (mMethodMap) {
    buildInputMethodListLocked(mMethodList,mMethodMap,!mImeSelectedOnBoot);
  }
  mSettings.enableAllIMEsIfThereIsNoEnabledIME();
  if (!mImeSelectedOnBoot) {
    Slog.w(TAG,"No IME selected. Choose the most applicable IME.");
synchronized (mMethodMap) {
      resetDefaultImeLocked(context);
    }
  }
  mSettingsObserver=new SettingsObserver(mHandler);
synchronized (mMethodMap) {
    updateFromSettingsLocked(true);
  }
  final IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_LOCALE_CHANGED);
  mContext.registerReceiver(new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mMethodMap) {
        resetStateIfCurrentLocaleChangedLocked();
      }
    }
  }
,filter);
}
