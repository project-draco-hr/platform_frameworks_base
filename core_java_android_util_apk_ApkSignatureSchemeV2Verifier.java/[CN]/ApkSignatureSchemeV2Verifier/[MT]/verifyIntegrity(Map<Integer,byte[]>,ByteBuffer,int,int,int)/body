{
  if (expectedDigests.isEmpty()) {
    throw new SecurityException("No digests provided");
  }
  ByteBuffer beforeApkSigningBlock=sliceFromTo(apkContents,0,apkSigningBlockOffset);
  ByteBuffer centralDir=sliceFromTo(apkContents,centralDirOffset,eocdOffset);
  byte[] eocdBytes=new byte[apkContents.capacity() - eocdOffset];
  apkContents.position(eocdOffset);
  apkContents.get(eocdBytes);
  ByteBuffer eocd=ByteBuffer.wrap(eocdBytes);
  eocd.order(apkContents.order());
  ZipUtils.setZipEocdCentralDirectoryOffset(eocd,apkSigningBlockOffset);
  int[] digestAlgorithms=new int[expectedDigests.size()];
  int digestAlgorithmCount=0;
  for (  int digestAlgorithm : expectedDigests.keySet()) {
    digestAlgorithms[digestAlgorithmCount]=digestAlgorithm;
    digestAlgorithmCount++;
  }
  Map<Integer,byte[]> actualDigests;
  try {
    actualDigests=computeContentDigests(digestAlgorithms,new ByteBuffer[]{beforeApkSigningBlock,centralDir,eocd});
  }
 catch (  DigestException e) {
    throw new SecurityException("Failed to compute digest(s) of contents",e);
  }
  for (  Map.Entry<Integer,byte[]> entry : expectedDigests.entrySet()) {
    int digestAlgorithm=entry.getKey();
    byte[] expectedDigest=entry.getValue();
    byte[] actualDigest=actualDigests.get(digestAlgorithm);
    if (!MessageDigest.isEqual(expectedDigest,actualDigest)) {
      throw new SecurityException(getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm) + " digest of contents did not verify");
    }
  }
}
