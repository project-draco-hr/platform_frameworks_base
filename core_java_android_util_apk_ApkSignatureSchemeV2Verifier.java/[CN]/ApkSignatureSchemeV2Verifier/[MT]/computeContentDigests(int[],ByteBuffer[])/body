{
  int totalChunkCount=0;
  for (  ByteBuffer input : contents) {
    totalChunkCount+=getChunkCount(input.remaining());
  }
  Map<Integer,byte[]> digestsOfChunks=new HashMap<>(totalChunkCount);
  for (  int digestAlgorithm : digestAlgorithms) {
    int digestOutputSizeBytes=getContentDigestAlgorithmOutputSizeBytes(digestAlgorithm);
    byte[] concatenationOfChunkCountAndChunkDigests=new byte[5 + totalChunkCount * digestOutputSizeBytes];
    concatenationOfChunkCountAndChunkDigests[0]=0x5a;
    setUnsignedInt32LittleEndian(totalChunkCount,concatenationOfChunkCountAndChunkDigests,1);
    digestsOfChunks.put(digestAlgorithm,concatenationOfChunkCountAndChunkDigests);
  }
  byte[] chunkContentPrefix=new byte[5];
  chunkContentPrefix[0]=(byte)0xa5;
  int chunkIndex=0;
  for (  ByteBuffer input : contents) {
    while (input.hasRemaining()) {
      int chunkSize=Math.min(input.remaining(),CHUNK_SIZE_BYTES);
      ByteBuffer chunk=getByteBuffer(input,chunkSize);
      for (      int digestAlgorithm : digestAlgorithms) {
        String jcaAlgorithmName=getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm);
        MessageDigest md;
        try {
          md=MessageDigest.getInstance(jcaAlgorithmName);
        }
 catch (        NoSuchAlgorithmException e) {
          throw new RuntimeException(jcaAlgorithmName + " digest not supported",e);
        }
        chunk.clear();
        setUnsignedInt32LittleEndian(chunk.remaining(),chunkContentPrefix,1);
        md.update(chunkContentPrefix);
        md.update(chunk);
        byte[] concatenationOfChunkCountAndChunkDigests=digestsOfChunks.get(digestAlgorithm);
        int expectedDigestSizeBytes=getContentDigestAlgorithmOutputSizeBytes(digestAlgorithm);
        int actualDigestSizeBytes=md.digest(concatenationOfChunkCountAndChunkDigests,5 + chunkIndex * expectedDigestSizeBytes,expectedDigestSizeBytes);
        if (actualDigestSizeBytes != expectedDigestSizeBytes) {
          throw new RuntimeException("Unexpected output size of " + md.getAlgorithm() + " digest: "+ actualDigestSizeBytes);
        }
      }
      chunkIndex++;
    }
  }
  Map<Integer,byte[]> result=new HashMap<>(digestAlgorithms.length);
  for (  Map.Entry<Integer,byte[]> entry : digestsOfChunks.entrySet()) {
    int digestAlgorithm=entry.getKey();
    byte[] input=entry.getValue();
    String jcaAlgorithmName=getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm);
    MessageDigest md;
    try {
      md=MessageDigest.getInstance(jcaAlgorithmName);
    }
 catch (    NoSuchAlgorithmException e) {
      throw new RuntimeException(jcaAlgorithmName + " digest not supported",e);
    }
    byte[] output=md.digest(input);
    result.put(digestAlgorithm,output);
  }
  return result;
}
