{
  final WeakReference<WifiNanManager> nanManager=new WeakReference<WifiNanManager>(mgr);
  if (VDBG)   Log.v(TAG,"WifiNanEventCallbackProxy ctor: looper=" + looper);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
      if (DBG) {
        Log.d(TAG,"WifiNanEventCallbackProxy: What=" + msg.what + ", msg="+ msg);
      }
      WifiNanManager mgr=nanManager.get();
      if (mgr == null) {
        Log.w(TAG,"WifiNanEventCallbackProxy: handleMessage post GC");
        return;
      }
switch (msg.what) {
case CALLBACK_CONNECT_SUCCESS:
synchronized (mgr.mLock) {
          if (mgr.mState != STATE_CONNECTING) {
            Log.w(TAG,"onConnectSuccess indication received but not in " + "CONNECTING state. Ignoring.");
            return;
          }
          mgr.mState=STATE_CONNECTED;
        }
      originalCallback.onConnectSuccess();
    break;
case CALLBACK_CONNECT_FAIL:
synchronized (mgr.mLock) {
    if (mgr.mState != STATE_CONNECTING) {
      Log.w(TAG,"onConnectFail indication received but not in " + "CONNECTING state. Ignoring.");
      return;
    }
    mgr.mState=STATE_UNCONNECTED;
    mgr.mBinder=null;
    mgr.mLooper=null;
    mgr.mClientId=0;
  }
nanManager.clear();
originalCallback.onConnectFail(msg.arg1);
break;
case CALLBACK_NAN_DOWN:
synchronized (mgr.mLock) {
mgr.mState=STATE_UNCONNECTED;
mgr.mBinder=null;
mgr.mLooper=null;
mgr.mClientId=0;
}
nanManager.clear();
originalCallback.onNanDown(msg.arg1);
break;
case CALLBACK_IDENTITY_CHANGED:
originalCallback.onIdentityChanged();
break;
}
}
}
;
}
