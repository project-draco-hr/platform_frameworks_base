{
  if (DEBUG_RC)   Log.d(TAG,"onNewPlaybackInfoForRcc(id=" + rccId + ", what="+ key+ ",val="+ value+ ")");
synchronized (mPRStack) {
    try {
      for (int index=mPRStack.size() - 1; index >= 0; index--) {
        final PlayerRecord prse=mPRStack.elementAt(index);
        if (prse.getRccId() == rccId) {
switch (key) {
case RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE:
            prse.mPlaybackType=value;
          postReevaluateRemote();
        break;
case RemoteControlClient.PLAYBACKINFO_VOLUME:
      prse.mPlaybackVolume=value;
synchronized (mMainRemote) {
      if (rccId == mMainRemote.mRccId) {
        mMainRemote.mVolume=value;
        mVolumeController.postHasNewRemotePlaybackInfo();
      }
    }
  break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_MAX:
prse.mPlaybackVolumeMax=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
  mMainRemote.mVolumeMax=value;
  mVolumeController.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING:
prse.mPlaybackVolumeHandling=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemote.mVolumeHandling=value;
mVolumeController.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_USES_STREAM:
prse.mPlaybackStream=value;
break;
default :
Log.e(TAG,"unhandled key " + key + " for RCC "+ rccId);
break;
}
return;
}
}
}
 catch (ArrayIndexOutOfBoundsException e) {
Log.e(TAG,"Wrong index mPRStack on onNewPlaybackInfoForRcc, lock error? ",e);
}
}
}
