{
  if (DEBUG_RC)   Log.d(TAG,"onNewPlaybackInfoForRcc(id=" + rccId + ", what="+ key+ ",val="+ value+ ")");
synchronized (mMCStack) {
    try {
      for (int index=mMCStack.size() - 1; index >= 0; index--) {
        final MediaController mcse=mMCStack.elementAt(index);
        if (mcse.mRccId == rccId) {
switch (key) {
case RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE:
            mcse.mPlaybackType=value;
          postReevaluateRemote();
        break;
case RemoteControlClient.PLAYBACKINFO_VOLUME:
      mcse.mPlaybackVolume=value;
synchronized (mMainRemote) {
      if (rccId == mMainRemote.mRccId) {
        mMainRemote.mVolume=value;
        mVolumeController.postHasNewRemotePlaybackInfo();
      }
    }
  break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_MAX:
mcse.mPlaybackVolumeMax=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
  mMainRemote.mVolumeMax=value;
  mVolumeController.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING:
mcse.mPlaybackVolumeHandling=value;
synchronized (mMainRemote) {
if (rccId == mMainRemote.mRccId) {
mMainRemote.mVolumeHandling=value;
mVolumeController.postHasNewRemotePlaybackInfo();
}
}
break;
case RemoteControlClient.PLAYBACKINFO_USES_STREAM:
mcse.mPlaybackStream=value;
break;
default :
Log.e(TAG,"unhandled key " + key + " for RCC "+ rccId);
break;
}
return;
}
}
}
 catch (ArrayIndexOutOfBoundsException e) {
Log.e(TAG,"Wrong index mMCStack on onNewPlaybackInfoForRcc, lock error? ",e);
}
}
}
