{
  final ArrayList<TaskRecord> tasks=new ArrayList<TaskRecord>();
  ArraySet<Integer> recoveredTaskIds=new ArraySet<Integer>();
  File[] recentFiles=sTasksDir.listFiles();
  if (recentFiles == null) {
    Slog.e(TAG,"Unable to list files from " + sTasksDir);
    return tasks;
  }
  for (int taskNdx=0; taskNdx < recentFiles.length; ++taskNdx) {
    File taskFile=recentFiles[taskNdx];
    if (DEBUG)     Slog.d(TAG,"restoreTasksLocked: taskFile=" + taskFile.getName());
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new FileReader(taskFile));
      final XmlPullParser in=Xml.newPullParser();
      in.setInput(reader);
      int event;
      while (((event=in.next()) != XmlPullParser.END_DOCUMENT) && event != XmlPullParser.END_TAG) {
        final String name=in.getName();
        if (event == XmlPullParser.START_TAG) {
          if (DEBUG)           Slog.d(TAG,"restoreTasksLocked: START_TAG name=" + name);
          if (TAG_TASK.equals(name)) {
            final TaskRecord task=TaskRecord.restoreFromXml(in,mStackSupervisor);
            if (DEBUG)             Slog.d(TAG,"restoreTasksLocked: restored task=" + task);
            if (task != null) {
              tasks.add(task);
              final int taskId=task.taskId;
              recoveredTaskIds.add(taskId);
              mStackSupervisor.setNextTaskId(taskId);
            }
          }
 else {
            Slog.e(TAG,"restoreTasksLocked Unknown xml event=" + event + " name="+ name);
          }
        }
        XmlUtils.skipCurrentTag(in);
      }
    }
 catch (    IOException e) {
      Slog.e(TAG,"Unable to parse " + taskFile + ". Error "+ e);
    }
catch (    XmlPullParserException e) {
      Slog.e(TAG,"Unable to parse " + taskFile + ". Error "+ e);
    }
 finally {
      if (reader != null) {
        try {
          reader.close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  if (!DEBUG) {
    removeObsoleteFiles(recoveredTaskIds);
  }
  TaskRecord[] tasksArray=new TaskRecord[tasks.size()];
  tasks.toArray(tasksArray);
  Arrays.sort(tasksArray,new Comparator<TaskRecord>(){
    @Override public int compare(    TaskRecord lhs,    TaskRecord rhs){
      final long diff=lhs.mLastTimeMoved - rhs.mLastTimeMoved;
      if (diff < 0) {
        return -1;
      }
 else       if (diff > 0) {
        return +1;
      }
 else {
        return 0;
      }
    }
  }
);
  return new ArrayList<TaskRecord>(Arrays.asList(tasksArray));
}
