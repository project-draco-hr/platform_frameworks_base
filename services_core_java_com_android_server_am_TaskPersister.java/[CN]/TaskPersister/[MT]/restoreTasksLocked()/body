{
  final ArrayList<TaskRecord> tasks=new ArrayList<TaskRecord>();
  ArraySet<Integer> recoveredTaskIds=new ArraySet<Integer>();
  File[] recentFiles=sTasksDir.listFiles();
  if (recentFiles == null) {
    Slog.e(TAG,"Unable to list files from " + sTasksDir);
    return tasks;
  }
  for (int taskNdx=0; taskNdx < recentFiles.length; ++taskNdx) {
    File taskFile=recentFiles[taskNdx];
    if (DEBUG)     Slog.d(TAG,"restoreTasksLocked: taskFile=" + taskFile.getName());
    BufferedReader reader=null;
    boolean deleteFile=false;
    try {
      reader=new BufferedReader(new FileReader(taskFile));
      final XmlPullParser in=Xml.newPullParser();
      in.setInput(reader);
      int event;
      while (((event=in.next()) != XmlPullParser.END_DOCUMENT) && event != XmlPullParser.END_TAG) {
        final String name=in.getName();
        if (event == XmlPullParser.START_TAG) {
          if (DEBUG)           Slog.d(TAG,"restoreTasksLocked: START_TAG name=" + name);
          if (TAG_TASK.equals(name)) {
            final TaskRecord task=TaskRecord.restoreFromXml(in,mStackSupervisor);
            if (DEBUG)             Slog.d(TAG,"restoreTasksLocked: restored task=" + task);
            if (task != null) {
              task.isPersistable=true;
              tasks.add(task);
              final int taskId=task.taskId;
              recoveredTaskIds.add(taskId);
              mStackSupervisor.setNextTaskId(taskId);
            }
 else {
              Slog.e(TAG,"Unable to restore taskFile=" + taskFile + ": "+ fileToString(taskFile));
            }
          }
 else {
            Slog.wtf(TAG,"restoreTasksLocked Unknown xml event=" + event + " name="+ name);
          }
        }
        XmlUtils.skipCurrentTag(in);
      }
    }
 catch (    Exception e) {
      Slog.wtf(TAG,"Unable to parse " + taskFile + ". Error ",e);
      Slog.e(TAG,"Failing file: " + fileToString(taskFile));
      deleteFile=true;
    }
 finally {
      IoUtils.closeQuietly(reader);
      if (deleteFile) {
        if (DEBUG)         Slog.d(TAG,"Deleting file=" + taskFile.getName());
        taskFile.delete();
      }
    }
  }
  if (!DEBUG) {
    removeObsoleteFiles(recoveredTaskIds);
  }
  for (int taskNdx=tasks.size() - 1; taskNdx >= 0; --taskNdx) {
    final TaskRecord task=tasks.get(taskNdx);
    task.setPrevAffiliate(taskIdToTask(task.mPrevAffiliateTaskId,tasks));
    task.setNextAffiliate(taskIdToTask(task.mNextAffiliateTaskId,tasks));
  }
  TaskRecord[] tasksArray=new TaskRecord[tasks.size()];
  tasks.toArray(tasksArray);
  Arrays.sort(tasksArray,new Comparator<TaskRecord>(){
    @Override public int compare(    TaskRecord lhs,    TaskRecord rhs){
      final long diff=rhs.mLastTimeMoved - lhs.mLastTimeMoved;
      if (diff < 0) {
        return -1;
      }
 else       if (diff > 0) {
        return +1;
      }
 else {
        return 0;
      }
    }
  }
);
  return new ArrayList<TaskRecord>(Arrays.asList(tasksArray));
}
