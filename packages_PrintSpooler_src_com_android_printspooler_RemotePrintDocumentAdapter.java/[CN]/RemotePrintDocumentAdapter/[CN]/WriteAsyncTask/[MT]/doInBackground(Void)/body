{
  if (DEBUG) {
    Log.i(LOG_TAG,"print()");
  }
synchronized (mLock) {
    mTaskQueue.add(this);
    if (mState != STATE_LAYOUT_COMPLETED && mState != STATE_WRITE_COMPLETED) {
      throw new IllegalStateException("Invalid state: " + mState);
    }
  }
  InputStream in=null;
  OutputStream out=null;
  ParcelFileDescriptor source=null;
  ParcelFileDescriptor sink=null;
synchronized (mLock) {
    mWriteThread=Thread.currentThread();
  }
  try {
    ParcelFileDescriptor[] pipe=ParcelFileDescriptor.createPipe();
    source=pipe[0];
    sink=pipe[1];
    in=new FileInputStream(source.getFileDescriptor());
    out=new FileOutputStream(mFile);
    mRemoteInterface.write(mPages,sink,mIWriteResultCallback);
    sink.close();
    sink=null;
    final byte[] buffer=new byte[8192];
    while (true) {
      if (Thread.currentThread().isInterrupted()) {
        Thread.currentThread().interrupt();
        break;
      }
      final int readByteCount=in.read(buffer);
      if (readByteCount < 0) {
        break;
      }
      out.write(buffer,0,readByteCount);
    }
synchronized (mLock) {
      while (true) {
        if (isCancelled()) {
          mTaskQueue.remove(this);
          break;
        }
        if (mCompleted) {
          mState=STATE_WRITE_COMPLETED;
          mTaskQueue.remove(this);
          break;
        }
        try {
          mLock.wait();
        }
 catch (        InterruptedException ie) {
        }
      }
    }
  }
 catch (  RemoteException re) {
    Slog.e(LOG_TAG,"Error writing print document",re);
    mState=STATE_FAILED;
  }
catch (  IOException ioe) {
    Slog.e(LOG_TAG,"Error writing print document",ioe);
    mState=STATE_FAILED;
  }
 finally {
    IoUtils.closeQuietly(in);
    IoUtils.closeQuietly(out);
    IoUtils.closeQuietly(sink);
    IoUtils.closeQuietly(source);
  }
  return null;
}
