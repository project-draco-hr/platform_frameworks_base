{
  ArrayList<StreamConfiguration> availableStreamConfigs=new ArrayList<>();
  List<Camera.Size> previewSizes=p.getSupportedPreviewSizes();
  appendStreamConfig(availableStreamConfigs,HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED,previewSizes);
  appendStreamConfig(availableStreamConfigs,ImageFormat.YUV_420_888,previewSizes);
  for (  int format : p.getSupportedPreviewFormats()) {
    if (ImageFormat.isPublicFormat(format)) {
      appendStreamConfig(availableStreamConfigs,format,previewSizes);
    }
 else {
      Log.w(TAG,String.format("mapStreamConfigs - Skipping non-public format %x",format));
    }
  }
  List<Camera.Size> jpegSizes=p.getSupportedPictureSizes();
  appendStreamConfig(availableStreamConfigs,HAL_PIXEL_FORMAT_BLOB,p.getSupportedPictureSizes());
  m.set(SCALER_AVAILABLE_STREAM_CONFIGURATIONS,availableStreamConfigs.toArray(new StreamConfiguration[0]));
  m.set(SCALER_AVAILABLE_MIN_FRAME_DURATIONS,new StreamConfigurationDuration[0]);
  StreamConfigurationDuration[] jpegStalls=new StreamConfigurationDuration[jpegSizes.size()];
  int i=0;
  long longestStallDuration=-1;
  for (  Camera.Size s : jpegSizes) {
    long stallDuration=calculateJpegStallDuration(s);
    jpegStalls[i++]=new StreamConfigurationDuration(HAL_PIXEL_FORMAT_BLOB,s.width,s.height,stallDuration);
    if (longestStallDuration < stallDuration) {
      longestStallDuration=stallDuration;
    }
  }
  m.set(SCALER_AVAILABLE_STALL_DURATIONS,jpegStalls);
  m.set(SENSOR_INFO_MAX_FRAME_DURATION,longestStallDuration);
}
