{
  Log.d(TAG,"StartingState.processMessage what=" + message.what);
  boolean retValue=true;
switch (message.what) {
case CMD_TETHER_UNREQUESTED:
    Message m=mTetherMasterSM.obtainMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED);
  m.obj=TetherInterfaceSM.this;
mTetherMasterSM.sendMessage(m);
if (mUsb) {
if (!Tethering.this.configureUsbIface(false)) {
  setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR);
  break;
}
}
transitionTo(mInitialState);
break;
case CMD_TETHER_MODE_ALIVE:
transitionTo(mTetheredState);
break;
case CMD_CELL_DUN_ERROR:
case CMD_IP_FORWARDING_ENABLE_ERROR:
case CMD_IP_FORWARDING_DISABLE_ERROR:
case CMD_START_TETHERING_ERROR:
case CMD_STOP_TETHERING_ERROR:
case CMD_SET_DNS_FORWARDERS_ERROR:
setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_MASTER_ERROR);
break;
case CMD_INTERFACE_DOWN:
m=mTetherMasterSM.obtainMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED);
m.obj=TetherInterfaceSM.this;
mTetherMasterSM.sendMessage(m);
transitionTo(mUnavailableState);
break;
case CMD_TRANSITION_TO_STATE:
HierarchicalState s=(HierarchicalState)(message.obj);
transitionTo(s);
break;
default :
retValue=false;
}
return retValue;
}
