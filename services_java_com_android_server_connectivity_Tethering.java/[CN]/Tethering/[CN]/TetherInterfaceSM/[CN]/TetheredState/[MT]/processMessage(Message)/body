{
  Log.d(TAG,"TetheredState.processMessage what=" + message.what);
  boolean retValue=true;
  boolean error=false;
switch (message.what) {
case CMD_TETHER_UNREQUESTED:
case CMD_INTERFACE_DOWN:
    IBinder b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
  INetworkManagementService service=INetworkManagementService.Stub.asInterface(b);
if (mMyUpstreamIfaceName != null) {
  try {
    service.disableNat(mIfaceName,mMyUpstreamIfaceName);
  }
 catch (  Exception e) {
    try {
      service.untetherInterface(mIfaceName);
    }
 catch (    Exception ee) {
    }
    setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_DISABLE_NAT_ERROR);
    break;
  }
}
try {
service.untetherInterface(mIfaceName);
}
 catch (Exception e) {
setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR);
break;
}
mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED,TetherInterfaceSM.this);
if (message.what == CMD_TETHER_UNREQUESTED) {
if (mUsb) {
if (!Tethering.this.configureUsbIface(false)) {
setLastError(ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR);
}
}
transitionTo(mInitialState);
}
 else if (message.what == CMD_INTERFACE_DOWN) {
transitionTo(mUnavailableState);
}
Log.d(TAG,"Untethered " + mIfaceName);
break;
case CMD_TETHER_CONNECTION_CHANGED:
String newUpstreamIfaceName=(String)(message.obj);
b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
service=INetworkManagementService.Stub.asInterface(b);
if (mMyUpstreamIfaceName != null) {
try {
service.disableNat(mIfaceName,mMyUpstreamIfaceName);
}
 catch (Exception e) {
try {
service.untetherInterface(mIfaceName);
}
 catch (Exception ee) {
}
setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_DISABLE_NAT_ERROR);
break;
}
}
if (newUpstreamIfaceName != null) {
try {
service.enableNat(mIfaceName,newUpstreamIfaceName);
}
 catch (Exception e) {
try {
service.untetherInterface(mIfaceName);
}
 catch (Exception ee) {
}
setLastError(ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR);
transitionTo(mInitialState);
return true;
}
}
mMyUpstreamIfaceName=newUpstreamIfaceName;
break;
case CMD_CELL_DUN_ERROR:
case CMD_IP_FORWARDING_ENABLE_ERROR:
case CMD_IP_FORWARDING_DISABLE_ERROR:
case CMD_START_TETHERING_ERROR:
case CMD_STOP_TETHERING_ERROR:
case CMD_SET_DNS_FORWARDERS_ERROR:
error=true;
case CMD_TETHER_MODE_DEAD:
b=ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
service=INetworkManagementService.Stub.asInterface(b);
if (mMyUpstreamIfaceName != null) {
try {
service.disableNat(mIfaceName,mMyUpstreamIfaceName);
}
 catch (Exception e) {
try {
service.untetherInterface(mIfaceName);
}
 catch (Exception ee) {
}
setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_DISABLE_NAT_ERROR);
break;
}
}
try {
service.untetherInterface(mIfaceName);
}
 catch (Exception e) {
setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR);
break;
}
if (error) {
setLastErrorAndTransitionToInitialState(ConnectivityManager.TETHER_ERROR_MASTER_ERROR);
break;
}
Log.d(TAG,"Tether lost upstream connection " + mIfaceName);
sendTetherStateChangedBroadcast();
if (mUsb) {
if (!Tethering.this.configureUsbIface(false)) {
setLastError(ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR);
}
}
transitionTo(mInitialState);
break;
case CMD_TRANSITION_TO_STATE:
HierarchicalState s=(HierarchicalState)(message.obj);
transitionTo(s);
break;
default :
retValue=false;
break;
}
return retValue;
}
