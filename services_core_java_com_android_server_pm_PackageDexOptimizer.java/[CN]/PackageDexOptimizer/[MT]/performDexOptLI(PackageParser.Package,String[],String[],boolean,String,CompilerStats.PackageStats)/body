{
  final String[] instructionSets=targetInstructionSets != null ? targetInstructionSets : getAppDexInstructionSets(pkg.applicationInfo);
  if (!canOptimizePackage(pkg)) {
    return DEX_OPT_SKIPPED;
  }
  final List<String> paths=pkg.getAllCodePathsExcludingResourceOnly();
  final int sharedGid=UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
  boolean isProfileGuidedFilter=DexFile.isProfileGuidedCompilerFilter(targetCompilerFilter);
  if (isProfileGuidedFilter && isUsedByOtherApps(pkg)) {
    checkProfiles=false;
    targetCompilerFilter=getNonProfileGuidedCompilerFilter(targetCompilerFilter);
    if (DexFile.isProfileGuidedCompilerFilter(targetCompilerFilter)) {
      throw new IllegalStateException(targetCompilerFilter);
    }
    isProfileGuidedFilter=false;
  }
  final boolean vmSafeMode=(pkg.applicationInfo.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0;
  final boolean debuggable=(pkg.applicationInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (vmSafeMode) {
    targetCompilerFilter=getNonProfileGuidedCompilerFilter(targetCompilerFilter);
    isProfileGuidedFilter=false;
  }
  boolean newProfile=false;
  if (checkProfiles && isProfileGuidedFilter) {
    try {
      newProfile=mInstaller.mergeProfiles(sharedGid,pkg.packageName);
    }
 catch (    InstallerException e) {
      Slog.w(TAG,"Failed to merge profiles",e);
    }
  }
  boolean performedDexOpt=false;
  boolean successfulDexOpt=true;
  final String[] dexCodeInstructionSets=getDexCodeInstructionSets(instructionSets);
  for (  String dexCodeInstructionSet : dexCodeInstructionSets) {
    for (    String path : paths) {
      int dexoptNeeded;
      try {
        dexoptNeeded=DexFile.getDexOptNeeded(path,dexCodeInstructionSet,targetCompilerFilter,newProfile);
      }
 catch (      IOException ioe) {
        Slog.w(TAG,"IOException reading apk: " + path,ioe);
        return DEX_OPT_FAILED;
      }
      dexoptNeeded=adjustDexoptNeeded(dexoptNeeded);
      if (PackageManagerService.DEBUG_DEXOPT) {
        Log.i(TAG,"DexoptNeeded for " + path + "@"+ targetCompilerFilter+ " is "+ dexoptNeeded);
      }
      final String dexoptType;
      String oatDir=null;
switch (dexoptNeeded) {
case DexFile.NO_DEXOPT_NEEDED:
        continue;
case DexFile.DEX2OAT_NEEDED:
      dexoptType="dex2oat";
    oatDir=createOatDirIfSupported(pkg,dexCodeInstructionSet);
  break;
case DexFile.PATCHOAT_NEEDED:
dexoptType="patchoat";
break;
case DexFile.SELF_PATCHOAT_NEEDED:
dexoptType="self patchoat";
break;
default :
throw new IllegalStateException("Invalid dexopt:" + dexoptNeeded);
}
String sharedLibrariesPath=null;
if (sharedLibraries != null && sharedLibraries.length != 0) {
StringBuilder sb=new StringBuilder();
for (String lib : sharedLibraries) {
if (sb.length() != 0) {
sb.append(":");
}
sb.append(lib);
}
sharedLibrariesPath=sb.toString();
}
Log.i(TAG,"Running dexopt (" + dexoptType + ") on: "+ path+ " pkg="+ pkg.applicationInfo.packageName+ " isa="+ dexCodeInstructionSet+ " vmSafeMode="+ vmSafeMode+ " debuggable="+ debuggable+ " target-filter="+ targetCompilerFilter+ " oatDir = "+ oatDir+ " sharedLibraries="+ sharedLibrariesPath);
final boolean isPublic=!pkg.isForwardLocked() && !isProfileGuidedFilter;
final int profileFlag=isProfileGuidedFilter ? DEXOPT_PROFILE_GUIDED : 0;
final int dexFlags=adjustDexoptFlags((isPublic ? DEXOPT_PUBLIC : 0) | (vmSafeMode ? DEXOPT_SAFEMODE : 0) | (debuggable ? DEXOPT_DEBUGGABLE : 0)| profileFlag| DEXOPT_BOOTCOMPLETE);
try {
long startTime=System.currentTimeMillis();
mInstaller.dexopt(path,sharedGid,pkg.packageName,dexCodeInstructionSet,dexoptNeeded,oatDir,dexFlags,targetCompilerFilter,pkg.volumeUuid,sharedLibrariesPath);
performedDexOpt=true;
if (packageStats != null) {
long endTime=System.currentTimeMillis();
packageStats.setCompileTime(path,(int)(endTime - startTime));
}
}
 catch (InstallerException e) {
Slog.w(TAG,"Failed to dexopt",e);
successfulDexOpt=false;
}
}
}
if (successfulDexOpt) {
return performedDexOpt ? DEX_OPT_PERFORMED : DEX_OPT_SKIPPED;
}
 else {
return DEX_OPT_FAILED;
}
}
