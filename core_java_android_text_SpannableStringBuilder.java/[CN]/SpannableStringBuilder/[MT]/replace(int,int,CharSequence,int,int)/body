{
  int filtercount=mFilters.length;
  for (int i=0; i < filtercount; i++) {
    CharSequence repl=mFilters[i].filter(tb,tbstart,tbend,this,start,end);
    if (repl != null) {
      tb=repl;
      tbstart=0;
      tbend=repl.length();
    }
  }
  if (end == start && tbstart == tbend) {
    return this;
  }
  if (end == start || tbstart == tbend) {
    change(start,end,tb,tbstart,tbend);
  }
 else {
    int selstart=Selection.getSelectionStart(this);
    int selend=Selection.getSelectionEnd(this);
    checkRange("replace",start,end);
    moveGapTo(end);
    TextWatcher[] recipients;
    recipients=sendTextWillChange(start,end - start,tbend - tbstart);
    int origlen=end - start;
    if (mGapLength < 2)     resizeFor(length() + 1);
    for (int i=mSpanCount - 1; i >= 0; i--) {
      if (mSpanStarts[i] == mGapStart)       mSpanStarts[i]++;
      if (mSpanEnds[i] == mGapStart)       mSpanEnds[i]++;
    }
    mText[mGapStart]=' ';
    mGapStart++;
    mGapLength--;
    if (mGapLength < 1) {
      new Exception("mGapLength < 1").printStackTrace();
    }
    int oldlen=(end + 1) - start;
    int inserted=change(false,start + 1,start + 1,tb,tbstart,tbend);
    change(false,start,start + 1,"",0,0);
    change(false,start + inserted,start + inserted + oldlen - 1,"",0,0);
    if (selstart > start && selstart < end) {
      long off=selstart - start;
      off=off * inserted / (end - start);
      selstart=(int)off + start;
      setSpan(false,Selection.SELECTION_START,selstart,selstart,Spanned.SPAN_POINT_POINT);
    }
    if (selend > start && selend < end) {
      long off=selend - start;
      off=off * inserted / (end - start);
      selend=(int)off + start;
      setSpan(false,Selection.SELECTION_END,selend,selend,Spanned.SPAN_POINT_POINT);
    }
    sendTextChange(recipients,start,origlen,inserted);
    sendTextHasChanged(recipients);
  }
  return this;
}
