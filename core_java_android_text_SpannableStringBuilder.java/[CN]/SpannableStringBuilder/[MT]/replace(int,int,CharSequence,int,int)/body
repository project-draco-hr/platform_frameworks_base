{
  int filtercount=mFilters.length;
  for (int i=0; i < filtercount; i++) {
    CharSequence repl=mFilters[i].filter(tb,tbstart,tbend,this,start,end);
    if (repl != null) {
      tb=repl;
      tbstart=0;
      tbend=repl.length();
    }
  }
  final int origLen=end - start;
  final int newLen=tbend - tbstart;
  if (origLen == 0 && newLen == 0) {
    return this;
  }
  TextWatcher[] textWatchers=getSpans(start,start + origLen,TextWatcher.class);
  sendBeforeTextChanged(textWatchers,start,origLen,newLen);
  if (origLen == 0 || newLen == 0) {
    change(start,end,tb,tbstart,tbend);
  }
 else {
    int selstart=Selection.getSelectionStart(this);
    int selend=Selection.getSelectionEnd(this);
    checkRange("replace",start,end);
    moveGapTo(end);
    if (mGapLength < 2)     resizeFor(length() + 1);
    for (int i=mSpanCount - 1; i >= 0; i--) {
      if (mSpanStarts[i] == mGapStart)       mSpanStarts[i]++;
      if (mSpanEnds[i] == mGapStart)       mSpanEnds[i]++;
    }
    mText[mGapStart]=' ';
    mGapStart++;
    mGapLength--;
    if (mGapLength < 1) {
      new Exception("mGapLength < 1").printStackTrace();
    }
    change(start + 1,start + 1,tb,tbstart,tbend);
    change(start,start + 1,"",0,0);
    change(start + newLen,start + newLen + origLen,"",0,0);
    if (selstart > start && selstart < end) {
      long off=selstart - start;
      off=off * newLen / (end - start);
      selstart=(int)off + start;
      setSpan(false,Selection.SELECTION_START,selstart,selstart,Spanned.SPAN_POINT_POINT);
    }
    if (selend > start && selend < end) {
      long off=selend - start;
      off=off * newLen / (end - start);
      selend=(int)off + start;
      setSpan(false,Selection.SELECTION_END,selend,selend,Spanned.SPAN_POINT_POINT);
    }
  }
  sendTextChanged(textWatchers,start,origLen,newLen);
  sendAfterTextChanged(textWatchers);
  return this;
}
