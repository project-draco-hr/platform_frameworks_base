{
  checkRange("setSpan",start,end);
  int flagsStart=(flags & START_MASK) >> START_SHIFT;
  if (flagsStart == PARAGRAPH) {
    if (start != 0 && start != length()) {
      char c=charAt(start - 1);
      if (c != '\n')       throw new RuntimeException("PARAGRAPH span must start at paragraph boundary");
    }
  }
  int flagsEnd=flags & END_MASK;
  if (flagsEnd == PARAGRAPH) {
    if (end != 0 && end != length()) {
      char c=charAt(end - 1);
      if (c != '\n')       throw new RuntimeException("PARAGRAPH span must end at paragraph boundary");
    }
  }
  if (flagsStart == POINT && flagsEnd == MARK && start == end) {
    if (send) {
      Log.e(TAG,"SPAN_EXCLUSIVE_EXCLUSIVE spans cannot have a zero length");
    }
    return;
  }
  int nstart=start;
  int nend=end;
  if (start > mGapStart) {
    start+=mGapLength;
  }
 else   if (start == mGapStart) {
    if (flagsStart == POINT || (flagsStart == PARAGRAPH && start == length()))     start+=mGapLength;
  }
  if (end > mGapStart) {
    end+=mGapLength;
  }
 else   if (end == mGapStart) {
    if (flagsEnd == POINT || (flagsEnd == PARAGRAPH && end == length()))     end+=mGapLength;
  }
  int count=mSpanCount;
  Object[] spans=mSpans;
  for (int i=0; i < count; i++) {
    if (spans[i] == what) {
      int ostart=mSpanStarts[i];
      int oend=mSpanEnds[i];
      if (ostart > mGapStart)       ostart-=mGapLength;
      if (oend > mGapStart)       oend-=mGapLength;
      mSpanStarts[i]=start;
      mSpanEnds[i]=end;
      mSpanFlags[i]=flags;
      if (send)       sendSpanChanged(what,ostart,oend,nstart,nend);
      return;
    }
  }
  mSpans=GrowingArrayUtils.append(mSpans,mSpanCount,what);
  mSpanStarts=GrowingArrayUtils.append(mSpanStarts,mSpanCount,start);
  mSpanEnds=GrowingArrayUtils.append(mSpanEnds,mSpanCount,end);
  mSpanFlags=GrowingArrayUtils.append(mSpanFlags,mSpanCount,flags);
  mSpanCount++;
  if (send)   sendSpanAdded(what,nstart,nend);
}
