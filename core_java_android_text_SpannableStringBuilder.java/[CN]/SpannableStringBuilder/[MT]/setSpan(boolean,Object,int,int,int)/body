{
  checkRange("setSpan",start,end);
  int flagsStart=(flags & START_MASK) >> START_SHIFT;
  if (isInvalidParagraphStart(start,flagsStart)) {
    throw new RuntimeException("PARAGRAPH span must start at paragraph boundary");
  }
  int flagsEnd=flags & END_MASK;
  if (isInvalidParagraphEnd(end,flagsEnd)) {
    throw new RuntimeException("PARAGRAPH span must end at paragraph boundary");
  }
  if (flagsStart == POINT && flagsEnd == MARK && start == end) {
    if (send) {
      Log.e(TAG,"SPAN_EXCLUSIVE_EXCLUSIVE spans cannot have a zero length");
    }
    return;
  }
  int nstart=start;
  int nend=end;
  if (start > mGapStart) {
    start+=mGapLength;
  }
 else   if (start == mGapStart) {
    if (flagsStart == POINT || (flagsStart == PARAGRAPH && start == length()))     start+=mGapLength;
  }
  if (end > mGapStart) {
    end+=mGapLength;
  }
 else   if (end == mGapStart) {
    if (flagsEnd == POINT || (flagsEnd == PARAGRAPH && end == length()))     end+=mGapLength;
  }
  int count=mSpanCount;
  Object[] spans=mSpans;
  if (mIndexOfSpan != null) {
    Integer index=mIndexOfSpan.get(what);
    if (index != null) {
      int i=index;
      int ostart=mSpanStarts[i];
      int oend=mSpanEnds[i];
      if (ostart > mGapStart)       ostart-=mGapLength;
      if (oend > mGapStart)       oend-=mGapLength;
      mSpanStarts[i]=start;
      mSpanEnds[i]=end;
      mSpanFlags[i]=flags;
      if (send) {
        restoreInvariants();
        sendSpanChanged(what,ostart,oend,nstart,nend);
      }
      return;
    }
  }
  mSpans=GrowingArrayUtils.append(mSpans,mSpanCount,what);
  mSpanStarts=GrowingArrayUtils.append(mSpanStarts,mSpanCount,start);
  mSpanEnds=GrowingArrayUtils.append(mSpanEnds,mSpanCount,end);
  mSpanFlags=GrowingArrayUtils.append(mSpanFlags,mSpanCount,flags);
  invalidateIndex(mSpanCount);
  mSpanCount++;
  int sizeOfMax=2 * treeRoot() + 1;
  if (mSpanMax.length < sizeOfMax) {
    mSpanMax=new int[sizeOfMax];
  }
  if (send) {
    restoreInvariants();
    sendSpanAdded(what,nstart,nend);
  }
}
