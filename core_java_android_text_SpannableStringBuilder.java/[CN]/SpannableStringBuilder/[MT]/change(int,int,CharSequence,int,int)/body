{
  final int nbNewChars=(csEnd - csStart) - (end - start);
  for (int i=mSpanCount - 1; i >= 0; i--) {
    int spanStart=mSpanStarts[i];
    if (spanStart > mGapStart)     spanStart-=mGapLength;
    int spanEnd=mSpanEnds[i];
    if (spanEnd > mGapStart)     spanEnd-=mGapLength;
    if ((mSpanFlags[i] & SPAN_PARAGRAPH) == SPAN_PARAGRAPH) {
      int ost=spanStart;
      int oen=spanEnd;
      int clen=length();
      if (spanStart > start && spanStart <= end) {
        for (spanStart=end; spanStart < clen; spanStart++)         if (spanStart > end && charAt(spanStart - 1) == '\n')         break;
      }
      if (spanEnd > start && spanEnd <= end) {
        for (spanEnd=end; spanEnd < clen; spanEnd++)         if (spanEnd > end && charAt(spanEnd - 1) == '\n')         break;
      }
      if (spanStart != ost || spanEnd != oen)       setSpan(false,mSpans[i],spanStart,spanEnd,mSpanFlags[i]);
    }
    int flags=0;
    if (spanStart == start)     flags|=SPAN_START_AT_START;
 else     if (spanStart == end + nbNewChars)     flags|=SPAN_START_AT_END;
    if (spanEnd == start)     flags|=SPAN_END_AT_START;
 else     if (spanEnd == end + nbNewChars)     flags|=SPAN_END_AT_END;
    mSpanFlags[i]|=flags;
  }
  moveGapTo(end);
  if (nbNewChars >= mGapLength) {
    resizeFor(mText.length + nbNewChars - mGapLength);
  }
  if (end > start) {
    int i=0;
    while (i < mSpanCount) {
      if ((mSpanFlags[i] & Spanned.SPAN_EXCLUSIVE_EXCLUSIVE) == Spanned.SPAN_EXCLUSIVE_EXCLUSIVE && mSpanStarts[i] >= start && mSpanStarts[i] < mGapStart + mGapLength && mSpanEnds[i] >= start && mSpanEnds[i] < mGapStart + mGapLength) {
        removeSpan(i);
      }
 else {
        i++;
      }
    }
  }
  mGapStart+=nbNewChars;
  mGapLength-=nbNewChars;
  if (mGapLength < 1)   new Exception("mGapLength < 1").printStackTrace();
  TextUtils.getChars(cs,csStart,csEnd,mText,start);
  if (end > start) {
    final boolean atEnd=(mGapStart + mGapLength == mText.length);
    for (int i=0; i < mSpanCount; i++) {
      if (mSpanStarts[i] >= start && mSpanStarts[i] < mGapStart + mGapLength) {
        int flag=(mSpanFlags[i] & START_MASK) >> START_SHIFT;
        if (flag == POINT || (flag == PARAGRAPH && atEnd)) {
          mSpanStarts[i]=mGapStart + mGapLength;
        }
 else {
          mSpanStarts[i]=start;
        }
      }
      if (mSpanEnds[i] >= start && mSpanEnds[i] < mGapStart + mGapLength) {
        int flag=(mSpanFlags[i] & END_MASK);
        if (flag == POINT || (flag == PARAGRAPH && atEnd)) {
          mSpanEnds[i]=mGapStart + mGapLength;
        }
 else {
          mSpanEnds[i]=start;
        }
      }
    }
  }
  mSpanCountBeforeAdd=mSpanCount;
  if (cs instanceof Spanned) {
    Spanned sp=(Spanned)cs;
    Object[] spans=sp.getSpans(csStart,csEnd,Object.class);
    for (int i=0; i < spans.length; i++) {
      int st=sp.getSpanStart(spans[i]);
      int en=sp.getSpanEnd(spans[i]);
      if (st < csStart)       st=csStart;
      if (en > csEnd)       en=csEnd;
      if (getSpanStart(spans[i]) < 0) {
        setSpan(false,spans[i],st - csStart + start,en - csStart + start,sp.getSpanFlags(spans[i]));
      }
    }
  }
}
