{
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mMainStack) {
      return mService.startHomeActivityLocked();
    }
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  if ((mService.mSleeping || mService.mShuttingDown) && mLastPausedActivity == next && next.state == ActivityState.PAUSED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    return false;
  }
  mStoppingActivities.remove(next);
  mWaitingVisibleActivities.remove(next);
  if (DEBUG_SWITCH)   Slog.v(TAG,"Resuming " + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,"Skip resume: pausing=" + mPausingActivity);
    return false;
  }
  if (mLastStartedActivity != null) {
    long now=SystemClock.uptimeMillis();
    final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
    final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
    final int nextUid=next.info.applicationInfo.uid;
    if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
      mService.showLaunchWarningLocked(mLastStartedActivity,next);
    }
 else {
      next.startTime=now;
      mLastStartedActivity=next;
    }
  }
 else {
    next.startTime=SystemClock.uptimeMillis();
    mLastStartedActivity=next;
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,"Skip resume: need to start pausing");
    startPausingLocked(userLeaving,false);
    return true;
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,"Resuming top, waiting visible to hide: " + prev);
    }
 else {
      if (prev.finishing) {
        mService.mWindowManager.setAppVisibility(prev,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,"Not waiting for visible to hide: " + prev + ", waitingVisible="+ (prev != null ? prev.waitingVisible : null)+ ", nowVisible="+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,"Previous already visible but still waiting to hide: " + prev + ", waitingVisible="+ (prev != null ? prev.waitingVisible : null)+ ", nowVisible="+ next.nowVisible);
      }
    }
  }
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,"Prepare close transition: prev=" + prev);
      if (mNoAnimActivities.contains(prev)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE : WindowManagerPolicy.TRANSIT_TASK_CLOSE);
      }
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,"Prepare open transition: prev=" + prev);
      if (mNoAnimActivities.contains(next)) {
        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN : WindowManagerPolicy.TRANSIT_TASK_OPEN);
      }
    }
    if (false) {
      mService.mWindowManager.setAppWillBeHidden(prev);
      mService.mWindowManager.setAppVisibility(prev,false);
    }
  }
 else   if (mHistory.size() > 1) {
    if (DEBUG_TRANSITION)     Slog.v(TAG,"Prepare open transition: no previous");
    if (mNoAnimActivities.contains(next)) {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_NONE);
    }
 else {
      mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN);
    }
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,"Resume running: " + next);
    mService.mWindowManager.setAppVisibility(next,true);
    ActivityRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.updateLruProcessLocked(next.app,true,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mMainStack) {
synchronized (mService) {
        Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next : null);
        if (config != null) {
          next.frozenBeforeDestroy=true;
        }
        updated=mService.updateConfigurationLocked(config,next);
      }
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,"Activity config changed during resume: " + next + ", new next: "+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mMainStack) {
        mService.setFocusedActivityLocked(next);
      }
      ensureActivitiesVisibleLocked(null,0);
      mService.mWindowManager.executeAppTransition();
      mNoAnimActivities.clear();
      return true;
    }
    try {
      ArrayList a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,"Delivering results to " + next + ": "+ a);
          next.app.thread.scheduleSendResult(next,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.app.thread.scheduleResumeActivity(next,mService.isNextTransitionForward());
      pauseIfSleepingLocked();
    }
 catch (    Exception e) {
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      Slog.i(TAG,"Restarting because process died: " + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
          mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
        }
      }
      startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,"Exception thrown during resume of " + next,e);
      requestFinishActivityLocked(next,Activity.RESULT_CANCELED,null,"resume-exception");
      return true;
    }
    next.icicle=null;
    next.haveState=false;
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mService.mWindowManager.setAppStartingWindow(next,next.packageName,next.theme,next.nonLocalizedLabel,next.labelRes,next.icon,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,"Restarting: " + next);
    }
    startSpecificActivityLocked(next,true,true);
  }
  return true;
}
