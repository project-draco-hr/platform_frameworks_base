{
  ActivityRecord next=topRunningActivityLocked(null);
  final boolean userLeaving=mUserLeaving;
  mUserLeaving=false;
  if (next == null) {
    if (mStackSupervisor.isMainStack(this)) {
      ActivityOptions.abort(options);
      return mService.startHomeActivityLocked(mCurrentUser);
    }
  }
  next.delayedResume=false;
  if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    return false;
  }
  if ((mService.mSleeping || mService.mShuttingDown) && mLastPausedActivity == next && (next.state == ActivityState.PAUSED || next.state == ActivityState.STOPPED || next.state == ActivityState.STOPPING)) {
    mService.mWindowManager.executeAppTransition();
    mNoAnimActivities.clear();
    ActivityOptions.abort(options);
    return false;
  }
  if (mService.mStartedUsers.get(next.userId) == null) {
    Slog.w(TAG,"Skipping resume of top activity " + next + ": user "+ next.userId+ " is stopped");
    return false;
  }
  mStoppingActivities.remove(next);
  mGoingToSleepActivities.remove(next);
  next.sleeping=false;
  mWaitingVisibleActivities.remove(next);
  next.updateOptionsLocked(options);
  if (DEBUG_SWITCH)   Slog.v(TAG,"Resuming " + next);
  if (mPausingActivity != null) {
    if (DEBUG_SWITCH || DEBUG_PAUSE)     Slog.v(TAG,"Skip resume: pausing=" + mPausingActivity);
    return false;
  }
  if (false) {
    if (mLastStartedActivity != null && !mLastStartedActivity.finishing) {
      long now=SystemClock.uptimeMillis();
      final boolean inTime=mLastStartedActivity.startTime != 0 && (mLastStartedActivity.startTime + START_WARN_TIME) >= now;
      final int lastUid=mLastStartedActivity.info.applicationInfo.uid;
      final int nextUid=next.info.applicationInfo.uid;
      if (inTime && lastUid != nextUid && lastUid != next.launchedFromUid && mService.checkPermission(android.Manifest.permission.STOP_APP_SWITCHES,-1,next.launchedFromUid) != PackageManager.PERMISSION_GRANTED) {
        mService.showLaunchWarningLocked(mLastStartedActivity,next);
      }
 else {
        next.startTime=now;
        mLastStartedActivity=next;
      }
    }
 else {
      next.startTime=SystemClock.uptimeMillis();
      mLastStartedActivity=next;
    }
  }
  if (mResumedActivity != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,"Skip resume: need to start pausing");
    if (next.app != null && next.app.thread != null) {
      mService.updateLruProcessLocked(next.app,false);
    }
    startPausingLocked(userLeaving,false);
    return true;
  }
  final ActivityRecord last=mLastPausedActivity;
  if (mService.mSleeping && last != null && !last.finishing) {
    if ((last.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (last.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
      if (DEBUG_STATES) {
        Slog.d(TAG,"no-history finish of " + last + " on new resume");
      }
      requestFinishActivityLocked(last.appToken,Activity.RESULT_CANCELED,null,"no-history",false);
    }
  }
  if (prev != null && prev != next) {
    if (!prev.waitingVisible && next != null && !next.nowVisible) {
      prev.waitingVisible=true;
      mWaitingVisibleActivities.add(prev);
      if (DEBUG_SWITCH)       Slog.v(TAG,"Resuming top, waiting visible to hide: " + prev);
    }
 else {
      if (prev.finishing) {
        mService.mWindowManager.setAppVisibility(prev.appToken,false);
        if (DEBUG_SWITCH)         Slog.v(TAG,"Not waiting for visible to hide: " + prev + ", waitingVisible="+ (prev != null ? prev.waitingVisible : null)+ ", nowVisible="+ next.nowVisible);
      }
 else {
        if (DEBUG_SWITCH)         Slog.v(TAG,"Previous already visible but still waiting to hide: " + prev + ", waitingVisible="+ (prev != null ? prev.waitingVisible : null)+ ", nowVisible="+ next.nowVisible);
      }
    }
  }
  try {
    AppGlobals.getPackageManager().setPackageStoppedState(next.packageName,false,next.userId);
  }
 catch (  RemoteException e1) {
  }
catch (  IllegalArgumentException e) {
    Slog.w(TAG,"Failed trying to unstop package " + next.packageName + ": "+ e);
  }
  boolean noAnim=false;
  if (prev != null) {
    if (prev.finishing) {
      if (DEBUG_TRANSITION)       Slog.v(TAG,"Prepare close transition: prev=" + prev);
      if (mNoAnimActivities.contains(prev)) {
        mService.mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE,false);
      }
      mService.mWindowManager.setAppWillBeHidden(prev.appToken);
      mService.mWindowManager.setAppVisibility(prev.appToken,false);
    }
 else {
      if (DEBUG_TRANSITION)       Slog.v(TAG,"Prepare open transition: prev=" + prev);
      if (mNoAnimActivities.contains(next)) {
        noAnim=true;
        mService.mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
      }
 else {
        mService.mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : AppTransition.TRANSIT_TASK_OPEN,false);
      }
    }
    if (false) {
      mService.mWindowManager.setAppWillBeHidden(prev.appToken);
      mService.mWindowManager.setAppVisibility(prev.appToken,false);
    }
  }
 else   if (numActivities() > 1) {
    if (DEBUG_TRANSITION)     Slog.v(TAG,"Prepare open transition: no previous");
    if (mNoAnimActivities.contains(next)) {
      noAnim=true;
      mService.mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE,false);
    }
 else {
      mService.mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN,false);
    }
  }
  if (!noAnim) {
    next.applyOptionsLocked();
  }
 else {
    next.clearOptionsLocked();
  }
  if (next.app != null && next.app.thread != null) {
    if (DEBUG_SWITCH)     Slog.v(TAG,"Resume running: " + next);
    mService.mWindowManager.setAppVisibility(next.appToken,true);
    next.startLaunchTickingLocked();
    ActivityRecord lastResumedActivity=mResumedActivity;
    ActivityState lastState=next.state;
    mService.updateCpuStats();
    if (DEBUG_STATES)     Slog.v(TAG,"Moving to RESUMED: " + next + " (in existing)");
    next.state=ActivityState.RESUMED;
    mResumedActivity=next;
    next.task.touchActiveTime();
    mService.addRecentTaskLocked(next.task);
    mService.updateLruProcessLocked(next.app,true);
    updateLRUListLocked(next);
    boolean updated=false;
    if (mStackSupervisor.isMainStack(this)) {
      Configuration config=mService.mWindowManager.updateOrientationFromAppTokens(mService.mConfiguration,next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
      if (config != null) {
        next.frozenBeforeDestroy=true;
      }
      updated=mService.updateConfigurationLocked(config,next,false,false);
    }
    if (!updated) {
      ActivityRecord nextNext=topRunningActivityLocked(null);
      if (DEBUG_SWITCH)       Slog.i(TAG,"Activity config changed during resume: " + next + ", new next: "+ nextNext);
      if (nextNext != next) {
        mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
      }
      if (mStackSupervisor.isMainStack(this)) {
        mService.setFocusedActivityLocked(next);
      }
      ensureActivitiesVisibleLocked(null,0);
      mService.mWindowManager.executeAppTransition();
      mNoAnimActivities.clear();
      return true;
    }
    try {
      ArrayList<ResultInfo> a=next.results;
      if (a != null) {
        final int N=a.size();
        if (!next.finishing && N > 0) {
          if (DEBUG_RESULTS)           Slog.v(TAG,"Delivering results to " + next + ": "+ a);
          next.app.thread.scheduleSendResult(next.appToken,a);
        }
      }
      if (next.newIntents != null) {
        next.app.thread.scheduleNewIntent(next.newIntents,next.appToken);
      }
      EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY,next.userId,System.identityHashCode(next),next.task.taskId,next.shortComponentName);
      next.sleeping=false;
      mService.showAskCompatModeDialogLocked(next);
      next.app.pendingUiClean=true;
      next.app.thread.scheduleResumeActivity(next.appToken,mService.isNextTransitionForward());
      checkReadyForSleepLocked();
    }
 catch (    Exception e) {
      if (DEBUG_STATES)       Slog.v(TAG,"Resume failed; resetting state to " + lastState + ": "+ next);
      next.state=lastState;
      mResumedActivity=lastResumedActivity;
      Slog.i(TAG,"Restarting because process died: " + next);
      if (!next.hasBeenLaunched) {
        next.hasBeenLaunched=true;
      }
 else {
        if (SHOW_APP_STARTING_PREVIEW && mStackSupervisor.isMainStack(this)) {
          mService.mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
        }
      }
      mStackSupervisor.startSpecificActivityLocked(next,true,false);
      return true;
    }
    try {
      next.visible=true;
      completeResumeLocked(next);
    }
 catch (    Exception e) {
      Slog.w(TAG,"Exception thrown during resume of " + next,e);
      requestFinishActivityLocked(next.appToken,Activity.RESULT_CANCELED,null,"resume-exception",true);
      return true;
    }
    next.stopped=false;
  }
 else {
    if (!next.hasBeenLaunched) {
      next.hasBeenLaunched=true;
    }
 else {
      if (SHOW_APP_STARTING_PREVIEW) {
        mService.mWindowManager.setAppStartingWindow(next.appToken,next.packageName,next.theme,mService.compatibilityInfoForPackageLocked(next.info.applicationInfo),next.nonLocalizedLabel,next.labelRes,next.icon,next.windowFlags,null,true);
      }
      if (DEBUG_SWITCH)       Slog.v(TAG,"Restarting: " + next);
    }
    mStackSupervisor.startSpecificActivityLocked(next,true,true);
  }
  return true;
}
