{
  super(infoID);
  payload.get();
  int locLength=payload.get() & BYTE_MASK;
  if (locLength != GEO_LOCATION_LENGTH) {
    throw new ProtocolException("GeoLocation length field value " + locLength + " incorrect, expected 16");
  }
  if (payload.remaining() != GEO_LOCATION_LENGTH) {
    throw new ProtocolException("Bad buffer length " + payload.remaining() + ", expected 16");
  }
  ReverseBitStream reverseBitStream=new ReverseBitStream(payload);
  int rawLatRes=(int)reverseBitStream.sliceOff(RES_WIDTH);
  double latitude=fixToFloat(reverseBitStream.sliceOff(LL_WIDTH),LL_FRACTION_SIZE,LL_WIDTH);
  mLatitude=rawLatRes != 0 ? new RealValue(latitude,bitsToAbsResolution(rawLatRes,LL_WIDTH,LL_FRACTION_SIZE)) : new RealValue(latitude);
  int rawLonRes=(int)reverseBitStream.sliceOff(RES_WIDTH);
  double longitude=fixToFloat(reverseBitStream.sliceOff(LL_WIDTH),LL_FRACTION_SIZE,LL_WIDTH);
  mLongitude=rawLonRes != 0 ? new RealValue(longitude,bitsToAbsResolution(rawLonRes,LL_WIDTH,LL_FRACTION_SIZE)) : new RealValue(longitude);
  int altType=(int)reverseBitStream.sliceOff(ALT_TYPE_WIDTH);
  mAltitudeType=altType < AltitudeType.values().length ? AltitudeType.values()[altType] : AltitudeType.Unknown;
  int rawAltRes=(int)reverseBitStream.sliceOff(RES_WIDTH);
  double altitude=fixToFloat(reverseBitStream.sliceOff(ALT_WIDTH),ALT_FRACTION_SIZE,ALT_WIDTH);
  mAltitude=rawAltRes != 0 ? new RealValue(altitude,bitsToAbsResolution(rawAltRes,ALT_WIDTH,ALT_FRACTION_SIZE)) : new RealValue(altitude);
  int datumValue=(int)reverseBitStream.sliceOff(DATUM_WIDTH);
  mDatum=datumValue < Datum.values().length ? Datum.values()[datumValue] : Datum.Unknown;
}
