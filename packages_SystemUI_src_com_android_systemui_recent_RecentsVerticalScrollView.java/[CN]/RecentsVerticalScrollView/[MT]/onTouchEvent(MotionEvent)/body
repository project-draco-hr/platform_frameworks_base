{
  if (!mDragging) {
    return super.onTouchEvent(ev);
  }
  mVelocityTracker.addMovement(ev);
  final View animView=mCurrentView;
switch (ev.getAction()) {
case MotionEvent.ACTION_MOVE:
    if (animView != null) {
      final float delta=ev.getX() - mLastX;
      final View thumb=animView.findViewById(R.id.app_thumbnail);
      animView.setX(animView.getX() + delta);
      animView.setAlpha(getAlphaForOffset(animView,thumb.getWidth()));
      invalidateGlobalRegion(animView);
    }
  mLastX=ev.getX();
break;
case MotionEvent.ACTION_UP:
final ObjectAnimator anim;
if (animView != null) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,10000);
final float velocityX=velocityTracker.getXVelocity();
final float velocityY=velocityTracker.getYVelocity();
final float curX=animView.getX();
final float newX=(velocityX >= 0.0f ? 1 : -1) * animView.getWidth();
final float maxVelocity=Constants.ESCAPE_VELOCITY * mDensityScale;
if (Math.abs(velocityX) > Math.abs(velocityY) && Math.abs(velocityX) > maxVelocity && (velocityX >= 0.0f) == (animView.getX() >= 0)) {
long duration=(long)(Math.abs(newX - curX) * 1000.0f / Math.abs(velocityX));
duration=Math.min(duration,Constants.MAX_ESCAPE_ANIMATION_DURATION);
anim=animateClosed(animView,duration,"x",curX,newX);
}
 else {
long duration=Math.abs(velocityX) > 0.0f ? (long)(Math.abs(newX - curX) * 1000.0f / Math.abs(velocityX)) : Constants.SNAP_BACK_DURATION;
duration=Math.min(duration,Constants.SNAP_BACK_DURATION);
anim=ObjectAnimator.ofFloat(animView,"x",animView.getX(),0.0f);
anim.setInterpolator(new DecelerateInterpolator(4.0f));
anim.setDuration(duration);
}
final View thumb=animView.findViewById(R.id.app_thumbnail);
anim.addUpdateListener(new AnimatorUpdateListener(){
public void onAnimationUpdate(ValueAnimator animation){
  animView.setAlpha(getAlphaForOffset(animView,thumb.getWidth()));
  invalidateGlobalRegion(animView);
}
}
);
anim.start();
}
mVelocityTracker.recycle();
mVelocityTracker=null;
break;
}
return true;
}
