{
synchronized (mMethodMap) {
    if (DEBUG)     Log.v(TAG,"windowGainedFocus: " + client.asBinder() + " viewHasFocus="+ viewHasFocus+ " softInputMode=#"+ Integer.toHexString(softInputMode)+ " first="+ first+ " flags=#"+ Integer.toHexString(windowFlags));
    if (mCurClient == null || client == null || mCurClient.client.asBinder() != client.asBinder()) {
      try {
        if (!mIWindowManager.inputMethodClientHasFocus(client)) {
          Log.w(TAG,"Ignoring focus gain of: " + client);
          return;
        }
      }
 catch (      RemoteException e) {
      }
    }
switch (softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_STATE) {
case WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED:
      if (!viewHasFocus || (softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE) {
        if ((windowFlags & WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM) == 0) {
          hideCurrentInputLocked();
        }
      }
    break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED:
  break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN:
hideCurrentInputLocked();
break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_FIRST_VISIBLE:
if (first && !viewHasFocus && (windowFlags & WindowManager.LayoutParams.FLAG_RESTORED_STATE) == 0) {
showCurrentInputLocked();
}
break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE:
if (viewHasFocus) {
showCurrentInputLocked();
}
break;
}
}
}
