{
  InputMethodInfo info=mMethodMap.get(id);
  if (info == null) {
    throw new IllegalArgumentException("Unknown id: " + id);
  }
  if (id.equals(mCurMethodId)) {
    InputMethodSubtype subtype=null;
    if (subtypeId >= 0 && subtypeId < info.getSubtypeCount()) {
      subtype=info.getSubtypeAt(subtypeId);
    }
    if (subtype != mCurrentSubtype) {
synchronized (mMethodMap) {
        if (subtype != null) {
          setSelectedInputMethodAndSubtypeLocked(info,subtypeId,true);
        }
        if (mCurMethod != null) {
          try {
            final Configuration conf=mRes.getConfiguration();
            final boolean haveHardKeyboard=conf.keyboard != Configuration.KEYBOARD_NOKEYS;
            final boolean hardKeyShown=haveHardKeyboard && conf.hardKeyboardHidden != Configuration.KEYBOARDHIDDEN_YES;
            mImeWindowVis=(mInputShown || hardKeyShown) ? (InputMethodService.IME_ACTIVE | InputMethodService.IME_VISIBLE) : 0;
            mStatusBar.setImeWindowStatus(mCurToken,mImeWindowVis,mBackDisposition);
            if (subtype == null) {
              subtype=getCurrentInputMethodSubtype();
            }
            mCurMethod.changeInputMethodSubtype(subtype);
          }
 catch (          RemoteException e) {
            return;
          }
        }
      }
    }
    return;
  }
  final long ident=Binder.clearCallingIdentity();
  try {
    setSelectedInputMethodAndSubtypeLocked(info,subtypeId,false);
    mCurMethodId=id;
    if (ActivityManagerNative.isSystemReady()) {
      Intent intent=new Intent(Intent.ACTION_INPUT_METHOD_CHANGED);
      intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
      intent.putExtra("input_method_id",id);
      mContext.sendBroadcast(intent);
    }
    unbindCurrentClientLocked();
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}
