{
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  final Configuration config=mRes.getConfiguration();
  final boolean haveHardKeyboard=config.keyboard == Configuration.KEYBOARD_QWERTY;
  String disabledSysImes=Settings.Secure.getString(mContext.getContentResolver(),Secure.DISABLED_SYSTEM_INPUT_METHODS);
  if (disabledSysImes == null)   disabledSysImes="";
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  final HashMap<String,List<InputMethodSubtype>> additionalSubtypes=mFileManager.getAllAdditionalInputMethodSubtypes();
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Slog.w(TAG,"Skipping input method " + compName + ": it does not require the permission "+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Slog.d(TAG,"Checking " + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri,additionalSubtypes);
      list.add(p);
      final String id=p.getId();
      map.put(id,p);
      if (isSystemIme(p) && (!haveHardKeyboard || disabledSysImes.indexOf(id) < 0)) {
        setInputMethodEnabledLocked(id,true);
      }
      if (DEBUG) {
        Slog.d(TAG,"Found a third-party input method " + p);
      }
    }
 catch (    XmlPullParserException e) {
      Slog.w(TAG,"Unable to load input method " + compName,e);
    }
catch (    IOException e) {
      Slog.w(TAG,"Unable to load input method " + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!TextUtils.isEmpty(defaultIme) && !map.containsKey(defaultIme)) {
    if (chooseNewDefaultIMELocked()) {
      updateFromSettingsLocked();
    }
  }
}
