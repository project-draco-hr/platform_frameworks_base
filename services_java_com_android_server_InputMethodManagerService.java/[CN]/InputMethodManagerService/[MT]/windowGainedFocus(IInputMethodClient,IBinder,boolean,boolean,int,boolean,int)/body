{
  long ident=Binder.clearCallingIdentity();
  try {
synchronized (mMethodMap) {
      if (DEBUG)       Slog.v(TAG,"windowGainedFocus: " + client.asBinder() + " viewHasFocus="+ viewHasFocus+ " isTextEditor="+ isTextEditor+ " softInputMode=#"+ Integer.toHexString(softInputMode)+ " first="+ first+ " flags=#"+ Integer.toHexString(windowFlags));
      if (mCurClient == null || client == null || mCurClient.client.asBinder() != client.asBinder()) {
        try {
          if (!mIWindowManager.inputMethodClientHasFocus(client)) {
            Slog.w(TAG,"Client not active, ignoring focus gain of: " + client);
            return;
          }
        }
 catch (        RemoteException e) {
        }
      }
      if (mCurFocusedWindow == windowToken) {
        Slog.w(TAG,"Window already focused, ignoring focus gain of: " + client);
        return;
      }
      mCurFocusedWindow=windowToken;
      final boolean doAutoShow=(softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE || mRes.getConfiguration().isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_LARGE);
switch (softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_STATE) {
case WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED:
        if (!isTextEditor || !doAutoShow) {
          if (WindowManager.LayoutParams.mayUseInputMethod(windowFlags)) {
            if (DEBUG)             Slog.v(TAG,"Unspecified window will hide input");
            hideCurrentInputLocked(InputMethodManager.HIDE_NOT_ALWAYS,null);
          }
        }
 else         if (isTextEditor && doAutoShow && (softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != 0) {
          if (DEBUG)           Slog.v(TAG,"Unspecified window will show input");
          showCurrentInputLocked(InputMethodManager.SHOW_IMPLICIT,null);
        }
      break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED:
    break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN:
  if ((softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != 0) {
    if (DEBUG)     Slog.v(TAG,"Window asks to hide input going forward");
    hideCurrentInputLocked(0,null);
  }
break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN:
if (DEBUG) Slog.v(TAG,"Window asks to hide input");
hideCurrentInputLocked(0,null);
break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE:
if ((softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != 0) {
if (DEBUG) Slog.v(TAG,"Window asks to show input going forward");
showCurrentInputLocked(InputMethodManager.SHOW_IMPLICIT,null);
}
break;
case WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE:
if (DEBUG) Slog.v(TAG,"Window asks to always show input");
showCurrentInputLocked(InputMethodManager.SHOW_IMPLICIT,null);
break;
}
}
}
  finally {
Binder.restoreCallingIdentity(ident);
}
}
