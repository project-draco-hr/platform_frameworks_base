{
  if (DEBUG)   Slog.v(TAG,"Show switching menu");
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  int lastInputMethodSubtypeId=getSelectedInputMethodSubtypeId(lastInputMethodId);
  if (DEBUG)   Slog.v(TAG,"Current IME: " + lastInputMethodId);
synchronized (mMethodMap) {
    final HashMap<InputMethodInfo,List<InputMethodSubtype>> immis=getExplicitlyOrImplicitlyEnabledInputMethodsAndSubtypeListLocked();
    if (immis == null || immis.size() == 0) {
      return;
    }
    hideInputMethodMenuLocked();
    final TreeMap<InputMethodInfo,List<InputMethodSubtype>> sortedImmis=new TreeMap<InputMethodInfo,List<InputMethodSubtype>>(new Comparator<InputMethodInfo>(){
      @Override public int compare(      InputMethodInfo imi1,      InputMethodInfo imi2){
        if (imi2 == null)         return 0;
        if (imi1 == null)         return 1;
        if (pm == null) {
          return imi1.getId().compareTo(imi2.getId());
        }
        CharSequence imiId1=imi1.loadLabel(pm) + "/" + imi1.getId();
        CharSequence imiId2=imi2.loadLabel(pm) + "/" + imi2.getId();
        return imiId1.toString().compareTo(imiId2.toString());
      }
    }
);
    sortedImmis.putAll(immis);
    final ArrayList<Pair<CharSequence,Pair<InputMethodInfo,Integer>>> imList=new ArrayList<Pair<CharSequence,Pair<InputMethodInfo,Integer>>>();
    for (    InputMethodInfo imi : sortedImmis.keySet()) {
      if (imi == null)       continue;
      List<InputMethodSubtype> explicitlyOrImplicitlyEnabledSubtypeList=immis.get(imi);
      HashSet<String> enabledSubtypeSet=new HashSet<String>();
      for (      InputMethodSubtype subtype : explicitlyOrImplicitlyEnabledSubtypeList) {
        enabledSubtypeSet.add(String.valueOf(subtype.hashCode()));
      }
      ArrayList<InputMethodSubtype> subtypes=getSubtypes(imi);
      final CharSequence label=imi.loadLabel(pm);
      if (showSubtypes && enabledSubtypeSet.size() > 0) {
        final int subtypeCount=imi.getSubtypeCount();
        if (DEBUG) {
          Slog.v(TAG,"Add subtypes: " + subtypeCount + ", "+ imi.getId());
        }
        for (int j=0; j < subtypeCount; ++j) {
          final InputMethodSubtype subtype=imi.getSubtypeAt(j);
          final String subtypeHashCode=String.valueOf(subtype.hashCode());
          if (enabledSubtypeSet.contains(subtypeHashCode) && (mInputShown || !subtype.isAuxiliary())) {
            final CharSequence title;
            final String mode=subtype.getMode();
            title=TextUtils.concat(subtype.getDisplayName(context,imi.getPackageName(),imi.getServiceInfo().applicationInfo),(TextUtils.isEmpty(label) ? "" : " (" + label + ")"));
            imList.add(new Pair<CharSequence,Pair<InputMethodInfo,Integer>>(title,new Pair<InputMethodInfo,Integer>(imi,j)));
            enabledSubtypeSet.remove(subtypeHashCode);
          }
        }
      }
 else {
        imList.add(new Pair<CharSequence,Pair<InputMethodInfo,Integer>>(label,new Pair<InputMethodInfo,Integer>(imi,NOT_A_SUBTYPE_ID)));
      }
    }
    final int N=imList.size();
    mItems=new CharSequence[N];
    for (int i=0; i < N; ++i) {
      mItems[i]=imList.get(i).first;
    }
    mIms=new InputMethodInfo[N];
    mSubtypeIds=new int[N];
    int checkedItem=0;
    for (int i=0; i < N; ++i) {
      Pair<InputMethodInfo,Integer> value=imList.get(i).second;
      mIms[i]=value.first;
      mSubtypeIds[i]=value.second;
      if (mIms[i].getId().equals(lastInputMethodId)) {
        int subtypeId=mSubtypeIds[i];
        if ((subtypeId == NOT_A_SUBTYPE_ID) || (lastInputMethodSubtypeId == NOT_A_SUBTYPE_ID && subtypeId == 0) || (subtypeId == lastInputMethodSubtypeId)) {
          checkedItem=i;
        }
      }
    }
    AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
        hideInputMethodMenu();
      }
    }
;
    TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
    mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
      @Override public void onCancel(      DialogInterface dialog){
        hideInputMethodMenu();
      }
    }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
    a.recycle();
    mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int which){
synchronized (mMethodMap) {
          if (mIms == null || mIms.length <= which || mSubtypeIds == null || mSubtypeIds.length <= which) {
            return;
          }
          InputMethodInfo im=mIms[which];
          int subtypeId=mSubtypeIds[which];
          hideInputMethodMenu();
          if (im != null) {
            if ((subtypeId < 0) || (subtypeId >= im.getSubtypeCount())) {
              subtypeId=NOT_A_SUBTYPE_ID;
            }
            setInputMethodLocked(im.getId(),subtypeId);
          }
        }
      }
    }
);
    if (showSubtypes && !(mKeyguardManager.isKeyguardLocked() && mKeyguardManager.isKeyguardSecure())) {
      mDialogBuilder.setPositiveButton(com.android.internal.R.string.configure_input_methods,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int whichButton){
          showConfigureInputMethods();
        }
      }
);
    }
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.setCanceledOnTouchOutside(true);
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.getWindow().getAttributes().setTitle("Select input method");
    mSwitchingDialog.show();
  }
}
