{
  if (DEBUG)   Slog.v(TAG,"Show switching menu");
  final Context context=mContext;
  final PackageManager pm=context.getPackageManager();
  String lastInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  int lastInputMethodSubtypeId=getSelectedInputMethodSubtypeId(lastInputMethodId);
  if (DEBUG)   Slog.v(TAG,"Current IME: " + lastInputMethodId);
synchronized (mMethodMap) {
    final List<Pair<InputMethodInfo,ArrayList<String>>> immis=mSettings.getEnabledInputMethodAndSubtypeHashCodeListLocked();
    int N=immis.size();
    for (int i=0; i < N; ++i) {
      InputMethodInfo imi=immis.get(i).first;
      ArrayList<String> subtypes=immis.get(i).second;
      if (subtypes != null && subtypes.size() == 0) {
        ArrayList<InputMethodSubtype> applicableSubtypes=getApplicableSubtypesLocked(imi.getSubtypes());
        final int numSubtypes=applicableSubtypes.size();
        for (int j=0; j < numSubtypes; ++j) {
          subtypes.add(String.valueOf(applicableSubtypes.get(j).hashCode()));
        }
      }
    }
    ArrayList<Integer> subtypeIds=new ArrayList<Integer>();
    if (immis == null || immis.size() == 0) {
      return;
    }
    hideInputMethodMenuLocked();
    final Map<CharSequence,Pair<InputMethodInfo,Integer>> imMap=new TreeMap<CharSequence,Pair<InputMethodInfo,Integer>>(Collator.getInstance());
    for (int i=0; i < N; ++i) {
      InputMethodInfo property=immis.get(i).first;
      final ArrayList<String> enabledSubtypeIds=immis.get(i).second;
      HashSet<String> enabledSubtypeSet=new HashSet<String>();
      for (      String s : enabledSubtypeIds) {
        enabledSubtypeSet.add(s);
      }
      if (property == null) {
        continue;
      }
      ArrayList<InputMethodSubtype> subtypes=property.getSubtypes();
      CharSequence label=property.loadLabel(pm);
      if (showSubtypes && enabledSubtypeSet.size() > 0) {
        for (int j=0; j < subtypes.size(); ++j) {
          InputMethodSubtype subtype=subtypes.get(j);
          if (enabledSubtypeSet.contains(String.valueOf(subtype.hashCode()))) {
            CharSequence title;
            int nameResId=subtype.getNameResId();
            String mode=subtype.getMode();
            if (nameResId != 0) {
              title=pm.getText(property.getPackageName(),nameResId,property.getServiceInfo().applicationInfo);
            }
 else {
              CharSequence language=subtype.getLocale();
              title=label + "," + (mode == null ? "" : mode)+ ","+ (language == null ? "" : language);
            }
            imMap.put(title,new Pair<InputMethodInfo,Integer>(property,j));
          }
        }
      }
 else {
        imMap.put(label,new Pair<InputMethodInfo,Integer>(property,NOT_A_SUBTYPE_ID));
        subtypeIds.add(0);
      }
    }
    N=imMap.size();
    mItems=imMap.keySet().toArray(new CharSequence[N]);
    mIms=new InputMethodInfo[N];
    mSubtypeIds=new int[N];
    int checkedItem=0;
    for (int i=0; i < N; ++i) {
      Pair<InputMethodInfo,Integer> value=imMap.get(mItems[i]);
      mIms[i]=value.first;
      mSubtypeIds[i]=value.second;
      if (mIms[i].getId().equals(lastInputMethodId)) {
        int subtypeId=mSubtypeIds[i];
        if ((subtypeId == NOT_A_SUBTYPE_ID) || (lastInputMethodSubtypeId == NOT_A_SUBTYPE_ID && subtypeId == 0) || (subtypeId == lastInputMethodSubtypeId)) {
          checkedItem=i;
        }
      }
    }
    AlertDialog.OnClickListener adocl=new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        hideInputMethodMenu();
      }
    }
;
    TypedArray a=context.obtainStyledAttributes(null,com.android.internal.R.styleable.DialogPreference,com.android.internal.R.attr.alertDialogStyle,0);
    mDialogBuilder=new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.select_input_method).setOnCancelListener(new OnCancelListener(){
      public void onCancel(      DialogInterface dialog){
        hideInputMethodMenu();
      }
    }
).setIcon(a.getDrawable(com.android.internal.R.styleable.DialogPreference_dialogTitle));
    a.recycle();
    mDialogBuilder.setSingleChoiceItems(mItems,checkedItem,new AlertDialog.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
synchronized (mMethodMap) {
          if (mIms == null || mIms.length <= which || mSubtypeIds == null || mSubtypeIds.length <= which) {
            return;
          }
          InputMethodInfo im=mIms[which];
          int subtypeId=mSubtypeIds[which];
          hideInputMethodMenu();
          if (im != null) {
            if ((subtypeId < 0) || (subtypeId >= im.getSubtypes().size())) {
              subtypeId=NOT_A_SUBTYPE_ID;
            }
            setInputMethodLocked(im.getId(),subtypeId);
          }
        }
      }
    }
);
    if (showSubtypes) {
      mDialogBuilder.setPositiveButton(com.android.internal.R.string.more_item_label,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          showConfigureInputMethods();
        }
      }
);
    }
    mDialogBuilder.setNegativeButton(com.android.internal.R.string.cancel,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int whichButton){
        hideInputMethodMenu();
      }
    }
);
    mSwitchingDialog=mDialogBuilder.create();
    mSwitchingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
    mSwitchingDialog.show();
  }
}
