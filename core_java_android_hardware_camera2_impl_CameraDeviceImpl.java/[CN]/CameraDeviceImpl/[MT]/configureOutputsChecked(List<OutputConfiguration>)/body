{
  if (outputs == null) {
    outputs=new ArrayList<OutputConfiguration>();
  }
  boolean success=false;
synchronized (mInterfaceLock) {
    checkIfCameraClosedOrInError();
    HashSet<OutputConfiguration> addSet=new HashSet<OutputConfiguration>(outputs);
    List<Integer> deleteList=new ArrayList<Integer>();
    for (int i=0; i < mConfiguredOutputs.size(); ++i) {
      int streamId=mConfiguredOutputs.keyAt(i);
      OutputConfiguration outConfig=mConfiguredOutputs.valueAt(i);
      if (!outputs.contains(outConfig)) {
        deleteList.add(streamId);
      }
 else {
        addSet.remove(outConfig);
      }
    }
    mDeviceHandler.post(mCallOnBusy);
    stopRepeating();
    try {
      waitUntilIdle();
      mRemoteDevice.beginConfigure();
      for (      Integer streamId : deleteList) {
        mRemoteDevice.deleteStream(streamId);
        mConfiguredOutputs.delete(streamId);
      }
      for (      OutputConfiguration outConfig : outputs) {
        if (addSet.contains(outConfig)) {
          int streamId=mRemoteDevice.createStream(outConfig);
          mConfiguredOutputs.put(streamId,outConfig);
        }
      }
      try {
        mRemoteDevice.endConfigure();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,"Stream configuration failed");
        return false;
      }
      success=true;
    }
 catch (    CameraRuntimeException e) {
      if (e.getReason() == CAMERA_IN_USE) {
        throw new IllegalStateException("The camera is currently busy." + " You must wait until the previous operation completes.");
      }
      throw e.asChecked();
    }
catch (    RemoteException e) {
      return false;
    }
 finally {
      if (success && outputs.size() > 0) {
        mDeviceHandler.post(mCallOnIdle);
      }
 else {
        mDeviceHandler.post(mCallOnUnconfigured);
      }
    }
  }
  return success;
}
