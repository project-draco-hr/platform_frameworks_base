{
  final int requestId=resultExtras.getRequestId();
  final int subsequenceId=resultExtras.getSubsequenceId();
  final long frameNumber=resultExtras.getFrameNumber();
  final CaptureListenerHolder holder=CameraDeviceImpl.this.mCaptureListenerMap.get(requestId);
  final CaptureRequest request=holder.getRequest(subsequenceId);
  if (errorCode == ERROR_CAMERA_BUFFER) {
    Log.e(TAG,String.format("Lost output buffer reported for frame %d",frameNumber));
    return;
  }
  boolean mayHaveBuffers=(errorCode == ERROR_CAMERA_RESULT);
  int reason=(mCurrentSession != null && mCurrentSession.isAborting()) ? CaptureFailure.REASON_FLUSHED : CaptureFailure.REASON_ERROR;
  final CaptureFailure failure=new CaptureFailure(request,reason,mayHaveBuffers,requestId,frameNumber);
  Runnable failureDispatch=new Runnable(){
    @Override public void run(){
      if (!CameraDeviceImpl.this.isClosed()) {
        holder.getListener().onCaptureFailed(CameraDeviceImpl.this,request,failure);
      }
    }
  }
;
  holder.getHandler().post(failureDispatch);
  if (DEBUG) {
    Log.v(TAG,String.format("got error frame %d",frameNumber));
  }
  mFrameNumberTracker.updateTracker(frameNumber,true);
  checkAndFireSequenceComplete();
}
