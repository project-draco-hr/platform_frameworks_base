{
  final int kToken_LineNum=0;
  final int kToken_CardNum=1;
  final int kToken_DeviceNum=2;
  final int kToken_Type0=3;
  final int kToken_Type1=4;
  final int kToken_Type2=5;
  int tokenOffset=0;
  int delimOffset=0;
  int tokenIndex=kToken_LineNum;
  while (true) {
    tokenOffset=mTokenizer.nextToken(line,delimOffset);
    if (tokenOffset == LineTokenizer.kTokenNotFound) {
      break;
    }
    delimOffset=mTokenizer.nextDelimiter(line,tokenOffset);
    if (delimOffset == LineTokenizer.kTokenNotFound) {
      delimOffset=line.length();
    }
    String token=line.substring(tokenOffset,delimOffset);
    try {
switch (tokenIndex) {
case kToken_LineNum:
        break;
case kToken_CardNum:
      mCardNum=Integer.parseInt(token);
    if (line.charAt(delimOffset) != '-') {
      tokenIndex++;
    }
  break;
case kToken_DeviceNum:
mDeviceNum=Integer.parseInt(token);
break;
case kToken_Type0:
if (token.equals("digital")) {
}
 else if (token.equals("control")) {
mDeviceType=kDeviceType_Control;
}
 else if (token.equals("raw")) {
}
break;
case kToken_Type1:
if (token.equals("audio")) {
mDeviceType=kDeviceType_Audio;
}
 else if (token.equals("midi")) {
mDeviceType=kDeviceType_MIDI;
mHasMIDIDevices=true;
}
break;
case kToken_Type2:
if (token.equals("capture")) {
mDeviceDir=kDeviceDir_Capture;
mHasCaptureDevices=true;
}
 else if (token.equals("playback")) {
mDeviceDir=kDeviceDir_Playback;
mHasPlaybackDevices=true;
}
break;
}
}
 catch (NumberFormatException e) {
Slog.e(TAG,"Failed to parse token " + tokenIndex + " of "+ kDevicesFilePath+ " token: "+ token);
return false;
}
tokenIndex++;
}
return true;
}
