{
  mVelocityTracker.addMovement(ev);
  final int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      final float y=ev.getY();
      if (hitThumb(x,y)) {
        mTouchMode=TOUCH_MODE_DOWN;
        mTouchX=x;
        mTouchY=y;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_IDLE:
      break;
case TOUCH_MODE_DOWN:
{
      final float x=ev.getX();
      final float y=ev.getY();
      if (Math.abs(x - mTouchX) > mTouchSlop || Math.abs(y - mTouchY) > mTouchSlop) {
        mTouchMode=TOUCH_MODE_DRAGGING;
        getParent().requestDisallowInterceptTouchEvent(true);
        mTouchX=x;
        mTouchY=y;
        return true;
      }
      break;
    }
case TOUCH_MODE_DRAGGING:
{
    final float x=ev.getX();
    final float dx=x - mTouchX;
    float newPos=Math.max(0,Math.min(mThumbPosition + dx,getThumbScrollRange()));
    if (newPos != mThumbPosition) {
      mThumbPosition=newPos;
      mTouchX=x;
      invalidate();
    }
    return true;
  }
}
break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_MODE_DRAGGING) {
stopDrag(ev);
return true;
}
mTouchMode=TOUCH_MODE_IDLE;
mVelocityTracker.clear();
break;
}
}
return super.onTouchEvent(ev);
}
