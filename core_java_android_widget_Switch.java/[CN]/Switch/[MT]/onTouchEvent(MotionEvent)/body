{
  mVelocityTracker.addMovement(ev);
  final int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
{
      final float x=ev.getX();
      final float y=ev.getY();
      if (isEnabled() && hitThumb(x,y)) {
        mTouchMode=TOUCH_MODE_DOWN;
        mTouchX=x;
        mTouchY=y;
      }
      break;
    }
case MotionEvent.ACTION_MOVE:
{
switch (mTouchMode) {
case TOUCH_MODE_IDLE:
      break;
case TOUCH_MODE_DOWN:
{
      final float x=ev.getX();
      final float y=ev.getY();
      if (Math.abs(x - mTouchX) > mTouchSlop || Math.abs(y - mTouchY) > mTouchSlop) {
        mTouchMode=TOUCH_MODE_DRAGGING;
        getParent().requestDisallowInterceptTouchEvent(true);
        mTouchX=x;
        mTouchY=y;
        return true;
      }
      break;
    }
case TOUCH_MODE_DRAGGING:
{
    final float x=ev.getX();
    final int thumbScrollRange=getThumbScrollRange();
    final float thumbScrollOffset=x - mTouchX;
    float dPos;
    if (thumbScrollRange != 0) {
      dPos=thumbScrollOffset / thumbScrollRange;
    }
 else {
      dPos=thumbScrollOffset > 0 ? 1 : -1;
    }
    if (isLayoutRtl()) {
      dPos=-dPos;
    }
    final float newPos=MathUtils.constrain(mThumbPosition + dPos,0,1);
    if (newPos != mThumbPosition) {
      mTouchX=x;
      setThumbPosition(newPos);
    }
    return true;
  }
}
break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mTouchMode == TOUCH_MODE_DRAGGING) {
stopDrag(ev);
return true;
}
mTouchMode=TOUCH_MODE_IDLE;
mVelocityTracker.clear();
break;
}
}
return super.onTouchEvent(ev);
}
