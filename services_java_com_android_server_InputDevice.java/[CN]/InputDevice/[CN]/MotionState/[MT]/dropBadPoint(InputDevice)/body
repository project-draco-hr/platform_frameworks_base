{
  if (dev.absY == null) {
    return;
  }
  if (mNextNumPointers != mLastNumPointers) {
    return;
  }
  final int maxDy=((dev.absY.maxValue - dev.absY.minValue) * 7) / 16;
  for (int i=mNextNumPointers - 1; i >= 0; i--) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int y=mNextData[ioff + MotionEvent.SAMPLE_Y];
    if (DEBUG_HACKS)     Log.v("InputDevice","Looking at next point #" + i + ": y="+ y);
    boolean dropped=false;
    if (!mDroppedBadPoint[i] && mLastNumPointers > 0) {
      dropped=true;
      int closestDy=-1;
      int closestY=-1;
      for (int j=mLastNumPointers - 1; j >= 0; j--) {
        final int joff=j * MotionEvent.NUM_SAMPLE_DATA;
        int dy=y - mLastData[joff + MotionEvent.SAMPLE_Y];
        if (dy < 0)         dy=-dy;
        if (DEBUG_HACKS)         Log.v("InputDevice","Comparing with last point #" + j + ": y="+ mLastData[joff]+ " dy="+ dy);
        if (dy < maxDy) {
          dropped=false;
          break;
        }
 else         if (closestDy < 0 || dy < closestDy) {
          closestDy=dy;
          closestY=mLastData[joff + MotionEvent.SAMPLE_Y];
        }
      }
      if (dropped) {
        dropped=true;
        Log.i("InputDevice","Dropping bad point #" + i + ": newY="+ y+ " closestDy="+ closestDy+ " maxDy="+ maxDy);
        mNextData[ioff + MotionEvent.SAMPLE_Y]=closestY;
        break;
      }
    }
    mDroppedBadPoint[i]=dropped;
  }
}
