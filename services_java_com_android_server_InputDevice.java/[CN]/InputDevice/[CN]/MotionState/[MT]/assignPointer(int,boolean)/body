{
  final int lastNumPointers=mLastNumPointers;
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  final int[] last2Next=mLast2Next;
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int id=nextIndex * MotionEvent.NUM_SAMPLE_DATA;
  if (DEBUG_POINTERS)   Log.v("InputDevice","assignPointer: nextIndex=" + nextIndex + " dataOff="+ id);
  final int x1=nextData[id + MotionEvent.SAMPLE_X];
  final int y1=nextData[id + MotionEvent.SAMPLE_Y];
  long bestDistance=-1;
  int bestIndex=-1;
  for (int j=0; j < lastNumPointers; j++) {
    if (!allowOverlap && last2Next[j] < 0) {
      continue;
    }
    final int jd=j * MotionEvent.NUM_SAMPLE_DATA;
    final int xd=lastData[jd + MotionEvent.SAMPLE_X] - x1;
    final int yd=lastData[jd + MotionEvent.SAMPLE_Y] - y1;
    final long distance=xd * (long)xd + yd * (long)yd;
    if (j == 0 || distance < bestDistance) {
      bestDistance=distance;
      bestIndex=j;
    }
  }
  if (DEBUG_POINTERS)   Log.v("InputDevice","New index " + nextIndex + " best old index="+ bestIndex+ " (distance="+ bestDistance+ ")");
  next2Last[nextIndex]=bestIndex;
  next2LastDistance[nextIndex]=bestDistance;
  if (bestIndex < 0) {
    return true;
  }
  if (last2Next[bestIndex] == -1) {
    last2Next[bestIndex]=nextIndex;
    return false;
  }
  if (DEBUG_POINTERS)   Log.v("InputDevice","Old index " + bestIndex + " has multiple best new pointers!");
  last2Next[bestIndex]=-2;
  return true;
}
