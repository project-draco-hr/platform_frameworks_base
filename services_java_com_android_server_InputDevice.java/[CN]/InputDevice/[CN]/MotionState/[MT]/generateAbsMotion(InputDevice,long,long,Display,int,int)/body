{
  if (mSkipLastPointers) {
    mSkipLastPointers=false;
    mLastNumPointers=0;
  }
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Slog.w("InputDevice","Number of pointers " + mNextNumPointers + " exceeded maximum of "+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData;
  if (KeyInputQueue.BAD_TOUCH_HACK) {
    rawData=generateAveragedData(upOrDownPointer,lastNumPointers,nextNumPointers);
  }
 else {
    rawData=mLastData;
  }
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Slog.v("InputDevice","Processing " + numPointers + " pointers (going from "+ lastNumPointers+ " to "+ nextNumPointers+ ")");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_INDEX_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_INDEX_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Slog.i("InputDevice","Adding batch x=" + reportData[MotionEvent.SAMPLE_X] + " y="+ reportData[MotionEvent.SAMPLE_Y]+ " to "+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Slog.i("KeyInputQueue","Updating: " + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}
