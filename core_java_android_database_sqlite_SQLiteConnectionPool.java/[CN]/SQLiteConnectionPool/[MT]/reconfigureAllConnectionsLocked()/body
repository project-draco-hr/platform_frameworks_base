{
  boolean wake=false;
  if (mAvailablePrimaryConnection != null) {
    try {
      mAvailablePrimaryConnection.reconfigure(mConfiguration);
    }
 catch (    RuntimeException ex) {
      Log.e(TAG,"Failed to reconfigure available primary connection, closing it: " + mAvailablePrimaryConnection,ex);
      closeConnectionAndLogExceptionsLocked(mAvailablePrimaryConnection);
      mAvailablePrimaryConnection=null;
      wake=true;
    }
  }
  int count=mAvailableNonPrimaryConnections.size();
  for (int i=0; i < count; i++) {
    final SQLiteConnection connection=mAvailableNonPrimaryConnections.get(i);
    try {
      connection.reconfigure(mConfiguration);
    }
 catch (    RuntimeException ex) {
      Log.e(TAG,"Failed to reconfigure available non-primary connection, closing it: " + connection,ex);
      closeConnectionAndLogExceptionsLocked(connection);
      mAvailableNonPrimaryConnections.remove(i--);
      count-=1;
      wake=true;
    }
  }
  if (!mAcquiredConnections.isEmpty()) {
    ArrayList<SQLiteConnection> keysToUpdate=new ArrayList<SQLiteConnection>(mAcquiredConnections.size());
    for (    Map.Entry<SQLiteConnection,Boolean> entry : mAcquiredConnections.entrySet()) {
      if (entry.getValue() != Boolean.TRUE) {
        keysToUpdate.add(entry.getKey());
      }
    }
    final int updateCount=keysToUpdate.size();
    for (int i=0; i < updateCount; i++) {
      mAcquiredConnections.put(keysToUpdate.get(i),Boolean.TRUE);
    }
  }
  if (wake) {
    wakeConnectionWaitersLocked();
  }
}
