{
  if (mCloseGuard != null) {
    if (finalized) {
      mCloseGuard.warnIfOpen();
    }
    mCloseGuard.close();
  }
  if (!finalized) {
synchronized (mLock) {
      throwIfClosedLocked();
      mIsOpen=false;
      final int count=mAvailableNonPrimaryConnections.size();
      for (int i=0; i < count; i++) {
        closeConnectionAndLogExceptionsLocked(mAvailableNonPrimaryConnections.get(i));
      }
      mAvailableNonPrimaryConnections.clear();
      if (mAvailablePrimaryConnection != null) {
        closeConnectionAndLogExceptionsLocked(mAvailablePrimaryConnection);
        mAvailablePrimaryConnection=null;
      }
      final int pendingCount=mAcquiredConnections.size();
      if (pendingCount != 0) {
        Log.i(TAG,"The connection pool for " + mConfiguration.label + " has been closed but there are still "+ pendingCount+ " connections in use.  They will be closed "+ "as they are released back to the pool.");
      }
      wakeConnectionWaitersLocked();
    }
  }
}
