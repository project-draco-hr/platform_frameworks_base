{
  if (!isTextEditable() || !isSuggestionsEnabled() || !getSpellChecker().isSessionActive())   return;
  Editable text=(Editable)mText;
  WordIterator wordIterator=getWordIterator();
  wordIterator.setCharSequence(text);
  int wordStart=wordIterator.preceding(start);
  int wordEnd;
  if (wordStart == BreakIterator.DONE) {
    wordEnd=wordIterator.following(start);
    if (wordEnd != BreakIterator.DONE) {
      wordStart=wordIterator.getBeginning(wordEnd);
    }
  }
 else {
    wordEnd=wordIterator.getEnd(wordStart);
  }
  if (wordEnd == BreakIterator.DONE) {
    return;
  }
  while (wordStart <= end) {
    if (wordEnd >= start) {
      if (wordStart < start && wordEnd > start) {
        removeEditionSpansAt(start,text);
      }
      if (wordStart < end && wordEnd > end) {
        removeEditionSpansAt(end,text);
      }
      boolean createSpellCheckSpan=true;
      if (wordEnd == start) {
        SpellCheckSpan[] spellCheckSpans=text.getSpans(start,start,SpellCheckSpan.class);
        if (spellCheckSpans.length > 0)         createSpellCheckSpan=false;
      }
      if (wordStart == end) {
        SpellCheckSpan[] spellCheckSpans=text.getSpans(end,end,SpellCheckSpan.class);
        if (spellCheckSpans.length > 0)         createSpellCheckSpan=false;
      }
      if (createSpellCheckSpan) {
        text.setSpan(new SpellCheckSpan(),wordStart,wordEnd,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
      }
    }
    wordEnd=wordIterator.following(wordEnd);
    if (wordEnd == BreakIterator.DONE)     return;
    wordStart=wordIterator.getBeginning(wordEnd);
    if (wordStart == BreakIterator.DONE) {
      Log.e(LOG_TAG,"Unable to find word beginning from " + wordEnd + "in "+ mText);
      return;
    }
  }
}
