{
  boolean inDestroying=mDestroyingServices.contains(r);
  if (r != null) {
    if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) {
      r.callStart=true;
switch (res) {
case Service.START_STICKY_COMPATIBILITY:
case Service.START_STICKY:
{
          r.findDeliveredStart(startId,true);
          r.stopIfKilled=false;
          break;
        }
case Service.START_NOT_STICKY:
{
        r.findDeliveredStart(startId,true);
        if (r.getLastStartId() == startId) {
          r.stopIfKilled=true;
        }
        break;
      }
case Service.START_REDELIVER_INTENT:
{
      ServiceRecord.StartItem si=r.findDeliveredStart(startId,false);
      if (si != null) {
        si.deliveryCount=0;
        si.doneExecutingCount++;
        r.stopIfKilled=true;
      }
      break;
    }
case Service.START_TASK_REMOVED_COMPLETE:
{
    r.findDeliveredStart(startId,true);
    break;
  }
default :
throw new IllegalArgumentException("Unknown service start result: " + res);
}
if (res == Service.START_STICKY_COMPATIBILITY) {
r.callStart=false;
}
}
 else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) {
if (!inDestroying) {
Slog.wtfStack(TAG,"Service done with onDestroy, but not inDestroying: " + r);
}
 else if (r.executeNesting != 1) {
Slog.wtfStack(TAG,"Service done with onDestroy, but executeNesting=" + r.executeNesting + ": "+ r);
r.executeNesting=1;
}
}
final long origId=Binder.clearCallingIdentity();
serviceDoneExecutingLocked(r,inDestroying,inDestroying);
Binder.restoreCallingIdentity(origId);
}
 else {
Slog.w(TAG,"Done executing unknown service from pid " + Binder.getCallingPid());
}
}
