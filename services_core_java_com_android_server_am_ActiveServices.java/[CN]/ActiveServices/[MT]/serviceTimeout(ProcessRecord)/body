{
  String anrMessage=null;
synchronized (mAm) {
    if (proc.executingServices.size() == 0 || proc.thread == null) {
      return;
    }
    final long now=SystemClock.uptimeMillis();
    final long maxTime=now - (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
    ServiceRecord timeout=null;
    long nextTime=0;
    for (int i=proc.executingServices.size() - 1; i >= 0; i--) {
      ServiceRecord sr=proc.executingServices.valueAt(i);
      if (sr.executingStart < maxTime) {
        timeout=sr;
        break;
      }
      if (sr.executingStart > nextTime) {
        nextTime=sr.executingStart;
      }
    }
    if (timeout != null && mAm.mLruProcesses.contains(proc)) {
      Slog.w(TAG,"Timeout executing service: " + timeout);
      StringWriter sw=new StringWriter();
      PrintWriter pw=new FastPrintWriter(sw,false,1024);
      pw.println(timeout);
      timeout.dump(pw,"    ");
      pw.close();
      mLastAnrDump=sw.toString();
      mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);
      mAm.mHandler.postDelayed(mLastAnrDumpClearer,LAST_ANR_LIFETIME_DURATION_MSECS);
      anrMessage="executing service " + timeout.shortName;
    }
 else {
      Message msg=mAm.mHandler.obtainMessage(ActivityManagerService.SERVICE_TIMEOUT_MSG);
      msg.obj=proc;
      mAm.mHandler.sendMessageAtTime(msg,proc.execServicesFg ? (nextTime + SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));
    }
  }
  if (anrMessage != null) {
    mAm.mAppErrors.appNotResponding(proc,null,null,false,anrMessage);
  }
}
