{
  if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,"screenshotApplications()")) {
    throw new SecurityException("Requires READ_FRAME_BUFFER permission");
  }
  Bitmap rawss=null;
  int maxLayer=0;
  final Rect frame=new Rect();
  float scale=0;
  int dw, dh;
  int rot=Surface.ROTATION_0;
  boolean screenshotReady;
  int minLayer;
  if (appToken == null) {
    screenshotReady=true;
    minLayer=0;
  }
 else {
    screenshotReady=false;
    minLayer=Integer.MAX_VALUE;
  }
  int retryCount=0;
  WindowState appWin=null;
  do {
    if (retryCount++ > 0) {
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
      }
    }
synchronized (mWindowMap) {
      final DisplayContent displayContent=getDisplayContentLocked(displayId);
      if (displayContent == null) {
        return null;
      }
      final DisplayInfo displayInfo=displayContent.getDisplayInfo();
      dw=displayInfo.logicalWidth;
      dh=displayInfo.logicalHeight;
      int aboveAppLayer=mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
      aboveAppLayer+=TYPE_LAYER_MULTIPLIER;
      boolean isImeTarget=mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
      boolean including=false;
      appWin=null;
      final WindowList windows=displayContent.getWindowList();
      final Rect stackBounds=new Rect();
      for (int i=windows.size() - 1; i >= 0; i--) {
        WindowState ws=windows.get(i);
        if (!ws.mHasSurface) {
          continue;
        }
        if (ws.mLayer >= aboveAppLayer) {
          continue;
        }
        if (!including && appToken != null) {
          if (!ws.mIsImWindow || !isImeTarget) {
            if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
              continue;
            }
            appWin=ws;
            ws.getStackBounds(stackBounds);
          }
        }
        including=!ws.mIsImWindow && !ws.isFullscreen(dw,dh);
        final WindowStateAnimator winAnim=ws.mWinAnimator;
        if (maxLayer < winAnim.mSurfaceLayer) {
          maxLayer=winAnim.mSurfaceLayer;
        }
        if (minLayer > winAnim.mSurfaceLayer) {
          minLayer=winAnim.mSurfaceLayer;
        }
        if (!ws.mIsWallpaper) {
          final Rect wf=ws.mFrame;
          final Rect cr=ws.mContentInsets;
          int left=wf.left + cr.left;
          int top=wf.top + cr.top;
          int right=wf.right - cr.right;
          int bottom=wf.bottom - cr.bottom;
          frame.union(left,top,right,bottom);
          frame.intersect(stackBounds);
        }
        if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
          screenshotReady=true;
        }
      }
      if (appToken != null && appWin == null) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,"Screenshot: Couldn't find a surface matching " + appToken);
        return null;
      }
      if (!screenshotReady) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,"Screenshot: No image ready for " + appToken + ", "+ appWin+ " drawState="+ appWin.mWinAnimator.mDrawState);
        continue;
      }
      frame.intersect(0,0,dw,dh);
      if (frame.isEmpty() || maxLayer == 0) {
        if (DEBUG_SCREENSHOT)         Slog.i(TAG,"Screenshot of " + appToken + ": returning null frame="+ frame.toShortString()+ " maxLayer="+ maxLayer);
        return null;
      }
      rot=getDefaultDisplayContentLocked().getDisplay().getRotation();
      int fw=frame.width();
      int fh=frame.height();
      scale=Math.max(width / (float)fw,height / (float)fh);
      dw=(int)(dw * scale);
      dh=(int)(dh * scale);
      if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
        int tmp=dw;
        dw=dh;
        dh=tmp;
        rot=(rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
      }
      if (DEBUG_SCREENSHOT) {
        Slog.i(TAG,"Screenshot: " + dw + "x"+ dh+ " from "+ minLayer+ " to "+ maxLayer+ " appToken="+ appToken);
        for (int i=0; i < windows.size(); i++) {
          WindowState win=windows.get(i);
          Slog.i(TAG,win + ": " + win.mLayer+ " animLayer="+ win.mWinAnimator.mAnimLayer+ " surfaceLayer="+ win.mWinAnimator.mSurfaceLayer);
        }
      }
      rawss=SurfaceControl.screenshot(dw,dh,minLayer,maxLayer,false);
    }
  }
 while (!screenshotReady && retryCount <= MAX_SCREENSHOT_RETRIES);
  if (retryCount > MAX_SCREENSHOT_RETRIES)   Slog.i(TAG,"Screenshot max retries " + retryCount + " of "+ appToken+ " appWin="+ (appWin == null ? "null" : (appWin + " drawState=" + appWin.mWinAnimator.mDrawState)));
  if (rawss == null) {
    Slog.w(TAG,"Screenshot failure taking screenshot for (" + dw + "x"+ dh+ ") to layer "+ maxLayer);
    return null;
  }
  Bitmap bm=Bitmap.createBitmap(width,height,force565 ? Config.RGB_565 : rawss.getConfig());
  bm.eraseColor(0xFF000000);
  frame.scale(scale);
  Matrix matrix=new Matrix();
  ScreenRotationAnimation.createRotationMatrix(rot,dw,dh,matrix);
  matrix.postTranslate(-FloatMath.ceil(frame.left),-FloatMath.ceil(frame.top));
  Canvas canvas=new Canvas(bm);
  canvas.drawBitmap(rawss,matrix,null);
  canvas.setBitmap(null);
  if (DEBUG_SCREENSHOT) {
    int[] buffer=new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(buffer,0,bm.getWidth(),0,0,bm.getWidth(),bm.getHeight());
    boolean allBlack=true;
    final int firstColor=buffer[0];
    for (int i=0; i < buffer.length; i++) {
      if (buffer[i] != firstColor) {
        allBlack=false;
        break;
      }
    }
    if (allBlack) {
      Slog.i(TAG,"Screenshot " + appWin + " was monochrome("+ Integer.toHexString(firstColor)+ ")! mSurfaceLayer="+ (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : "null")+ " minLayer="+ minLayer+ " maxLayer="+ maxLayer);
    }
  }
  rawss.recycle();
  return bm;
}
