{
  final SurfaceControl surface=winAnimator.mSurfaceControl;
  boolean leakedSurface=false;
  boolean killedApps=false;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,winAnimator.mWin.toString(),winAnimator.mSession.mPid,operation);
  if (mForceRemoves == null) {
    mForceRemoves=new ArrayList<WindowState>();
  }
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    Slog.i(TAG,"Out of memory for surface!  Looking for leaks...");
    final int numDisplays=mDisplayContents.size();
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
      final int numWindows=windows.size();
      for (int winNdx=0; winNdx < numWindows; ++winNdx) {
        final WindowState ws=windows.get(winNdx);
        WindowStateAnimator wsa=ws.mWinAnimator;
        if (wsa.mSurfaceControl != null) {
          if (!mSessions.contains(wsa.mSession)) {
            Slog.w(TAG,"LEAKED SURFACE (session doesn't exist): " + ws + " surface="+ wsa.mSurfaceControl+ " token="+ ws.mToken+ " pid="+ ws.mSession.mPid+ " uid="+ ws.mSession.mUid);
            if (SHOW_TRANSACTIONS)             logSurface(ws,"LEAK DESTROY",null);
            wsa.mSurfaceControl.destroy();
            wsa.mSurfaceShown=false;
            wsa.mSurfaceControl=null;
            ws.mHasSurface=false;
            mForceRemoves.add(ws);
            leakedSurface=true;
          }
 else           if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
            Slog.w(TAG,"LEAKED SURFACE (app token hidden): " + ws + " surface="+ wsa.mSurfaceControl+ " token="+ ws.mAppToken);
            if (SHOW_TRANSACTIONS)             logSurface(ws,"LEAK DESTROY",null);
            wsa.mSurfaceControl.destroy();
            wsa.mSurfaceShown=false;
            wsa.mSurfaceControl=null;
            ws.mHasSurface=false;
            leakedSurface=true;
          }
        }
      }
    }
    if (!leakedSurface) {
      Slog.w(TAG,"No leaked surfaces; killing applicatons!");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
        final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
        final int numWindows=windows.size();
        for (int winNdx=0; winNdx < numWindows; ++winNdx) {
          final WindowState ws=windows.get(winNdx);
          if (mForceRemoves.contains(ws)) {
            continue;
          }
          WindowStateAnimator wsa=ws.mWinAnimator;
          if (wsa.mSurfaceControl != null) {
            pidCandidates.append(wsa.mSession.mPid,wsa.mSession.mPid);
          }
        }
        if (pidCandidates.size() > 0) {
          int[] pids=new int[pidCandidates.size()];
          for (int i=0; i < pids.length; i++) {
            pids[i]=pidCandidates.keyAt(i);
          }
          try {
            if (mActivityManager.killPids(pids,"Free memory",secure)) {
              killedApps=true;
            }
          }
 catch (          RemoteException e) {
          }
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG,"Looks like we have reclaimed some memory, clearing surface for retry.");
      if (surface != null) {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC)         logSurface(winAnimator.mWin,"RECOVER DESTROY",null);
        surface.destroy();
        winAnimator.mSurfaceShown=false;
        winAnimator.mSurfaceControl=null;
        winAnimator.mWin.mHasSurface=false;
        scheduleRemoveStartingWindow(winAnimator.mWin.mAppToken);
      }
      try {
        winAnimator.mWin.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
  return leakedSurface || killedApps;
}
