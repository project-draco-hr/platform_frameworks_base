{
  String methodName=pair ? "pair()" : "acceptPair()";
  int mask=PairReceiver.PAIR_FLAG;
  int pairMask=PairReceiver.PAIR_STATE_BONDING | PairReceiver.PAIR_STATE_BONDED;
  PairReceiver pairReceiver=getPairReceiver(mContext,device,passkey,pin);
  mReceivers.add(pairReceiver);
  if (!adapter.isEnabled()) {
    fail(methodName + " bluetooth not enabled");
  }
  int state=device.getBondState();
switch (state) {
case BluetoothDevice.BOND_BONDED:
    assertTrue(adapter.getBondedDevices().contains(device));
  return;
case BluetoothDevice.BOND_BONDING:
mask=pairMask=0;
break;
case BluetoothDevice.BOND_NONE:
assertFalse(adapter.getBondedDevices().contains(device));
if (pair) {
assertTrue(device.createBond());
}
break;
default :
fail(methodName + " invalide state: state=" + state);
}
long s=System.currentTimeMillis();
while (System.currentTimeMillis() - s < PAIR_TIMEOUT) {
state=device.getBondState();
if (state == BluetoothDevice.BOND_BONDED) {
assertTrue(adapter.getBondedDevices().contains(device));
if ((pairReceiver.getFiredFlags() & mask) == mask && (pairReceiver.getPairFiredFlags() & pairMask) == pairMask) {
writeOutput(String.format("%s completed in %d ms: device=%s",methodName,(System.currentTimeMillis() - s),device));
mReceivers.remove(pairReceiver);
mContext.unregisterReceiver(pairReceiver);
return;
}
}
sleep(POLL_TIME);
}
int firedFlags=pairReceiver.getFiredFlags();
int pairFiredFlags=pairReceiver.getPairFiredFlags();
pairReceiver.resetFiredFlags();
fail(String.format("%s timeout: state=%d (expected %d), flags=0x%x (expected 0x%x), " + "pairFlags=0x%x (expected 0x%x)",methodName,state,BluetoothDevice.BOND_BONDED,firedFlags,mask,pairFiredFlags,pairMask));
}
