{
  mWindowManager.getDefaultDisplay().getRealSize(mTempPoint);
  final int screenWidth=mTempPoint.x;
  final int screenHeight=mTempPoint.y;
  mMagnificationRegion.set(0,0,0,0);
  final Region availableBounds=mTempRegion1;
  availableBounds.set(0,0,screenWidth,screenHeight);
  if (mCircularPath != null) {
    availableBounds.setPath(mCircularPath,availableBounds);
  }
  Region nonMagnifiedBounds=mTempRegion4;
  nonMagnifiedBounds.set(0,0,0,0);
  SparseArray<WindowState> visibleWindows=mTempWindowStates;
  visibleWindows.clear();
  populateWindowsOnScreenLocked(visibleWindows);
  final int visibleWindowCount=visibleWindows.size();
  for (int i=visibleWindowCount - 1; i >= 0; i--) {
    WindowState windowState=visibleWindows.valueAt(i);
    if (windowState.mAttrs.type == WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY) {
      continue;
    }
    Matrix matrix=mTempMatrix;
    populateTransformationMatrixLocked(windowState,matrix);
    Region touchableRegion=mTempRegion3;
    windowState.getTouchableRegion(touchableRegion);
    Rect touchableFrame=mTempRect1;
    touchableRegion.getBounds(touchableFrame);
    RectF windowFrame=mTempRectF;
    windowFrame.set(touchableFrame);
    windowFrame.offset(-windowState.mFrame.left,-windowState.mFrame.top);
    matrix.mapRect(windowFrame);
    Region windowBounds=mTempRegion2;
    windowBounds.set((int)windowFrame.left,(int)windowFrame.top,(int)windowFrame.right,(int)windowFrame.bottom);
    Region portionOfWindowAlreadyAccountedFor=mTempRegion3;
    portionOfWindowAlreadyAccountedFor.set(mMagnificationRegion);
    portionOfWindowAlreadyAccountedFor.op(nonMagnifiedBounds,Region.Op.UNION);
    windowBounds.op(portionOfWindowAlreadyAccountedFor,Region.Op.DIFFERENCE);
    if (mWindowManagerService.mPolicy.canMagnifyWindow(windowState.mAttrs.type)) {
      mMagnificationRegion.op(windowBounds,Region.Op.UNION);
      mMagnificationRegion.op(availableBounds,Region.Op.INTERSECT);
    }
 else {
      nonMagnifiedBounds.op(windowBounds,Region.Op.UNION);
      availableBounds.op(windowBounds,Region.Op.DIFFERENCE);
    }
    Region accountedBounds=mTempRegion2;
    accountedBounds.set(mMagnificationRegion);
    accountedBounds.op(nonMagnifiedBounds,Region.Op.UNION);
    accountedBounds.op(0,0,screenWidth,screenHeight,Region.Op.INTERSECT);
    if (accountedBounds.isRect()) {
      Rect accountedFrame=mTempRect1;
      accountedBounds.getBounds(accountedFrame);
      if (accountedFrame.width() == screenWidth && accountedFrame.height() == screenHeight) {
        break;
      }
    }
  }
  visibleWindows.clear();
  mMagnificationRegion.op(mDrawBorderInset,mDrawBorderInset,screenWidth - mDrawBorderInset,screenHeight - mDrawBorderInset,Region.Op.INTERSECT);
  final boolean magnifiedChanged=!mOldMagnificationRegion.equals(mMagnificationRegion);
  if (magnifiedChanged) {
    mWindow.setBounds(mMagnificationRegion);
    final Rect dirtyRect=mTempRect1;
    if (mFullRedrawNeeded) {
      mFullRedrawNeeded=false;
      dirtyRect.set(mDrawBorderInset,mDrawBorderInset,screenWidth - mDrawBorderInset,screenHeight - mDrawBorderInset);
      mWindow.invalidate(dirtyRect);
    }
 else {
      final Region dirtyRegion=mTempRegion3;
      dirtyRegion.set(mMagnificationRegion);
      dirtyRegion.op(mOldMagnificationRegion,Region.Op.UNION);
      dirtyRegion.op(nonMagnifiedBounds,Region.Op.INTERSECT);
      dirtyRegion.getBounds(dirtyRect);
      mWindow.invalidate(dirtyRect);
    }
    mOldMagnificationRegion.set(mMagnificationRegion);
    final SomeArgs args=SomeArgs.obtain();
    args.arg1=Region.obtain(mMagnificationRegion);
    mHandler.obtainMessage(MyHandler.MESSAGE_NOTIFY_MAGNIFICATION_REGION_CHANGED,args).sendToTarget();
  }
}
