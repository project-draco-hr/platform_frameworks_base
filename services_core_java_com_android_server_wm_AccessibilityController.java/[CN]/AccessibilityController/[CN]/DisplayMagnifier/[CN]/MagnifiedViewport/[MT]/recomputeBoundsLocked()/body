{
  mWindowManager.getDefaultDisplay().getRealSize(mTempPoint);
  final int screenWidth=mTempPoint.x;
  final int screenHeight=mTempPoint.y;
  mMagnifiedBounds.set(0,0,0,0);
  mAvailableBounds.set(0,0,screenWidth,screenHeight);
  if (mCircularPath != null) {
    mAvailableBounds.setPath(mCircularPath,mAvailableBounds);
  }
  Region nonMagnifiedBounds=mTempRegion4;
  nonMagnifiedBounds.set(0,0,0,0);
  SparseArray<WindowState> visibleWindows=mTempWindowStates;
  visibleWindows.clear();
  populateWindowsOnScreenLocked(visibleWindows);
  final int visibleWindowCount=visibleWindows.size();
  for (int i=visibleWindowCount - 1; i >= 0; i--) {
    WindowState windowState=visibleWindows.valueAt(i);
    if (windowState.mAttrs.type == WindowManager.LayoutParams.TYPE_MAGNIFICATION_OVERLAY) {
      continue;
    }
    Matrix matrix=mTempMatrix;
    populateTransformationMatrixLocked(windowState,matrix);
    Region touchableRegion=mTempRegion3;
    windowState.getTouchableRegion(touchableRegion);
    Rect touchableFrame=mTempRect1;
    touchableRegion.getBounds(touchableFrame);
    RectF windowFrame=mTempRectF;
    windowFrame.set(touchableFrame);
    windowFrame.offset(-windowState.mFrame.left,-windowState.mFrame.top);
    matrix.mapRect(windowFrame);
    Region windowBounds=mTempRegion2;
    windowBounds.set((int)windowFrame.left,(int)windowFrame.top,(int)windowFrame.right,(int)windowFrame.bottom);
    Region portionOfWindowAlreadyAccountedFor=mTempRegion3;
    portionOfWindowAlreadyAccountedFor.set(mMagnifiedBounds);
    portionOfWindowAlreadyAccountedFor.op(nonMagnifiedBounds,Region.Op.UNION);
    windowBounds.op(portionOfWindowAlreadyAccountedFor,Region.Op.DIFFERENCE);
    if (mWindowManagerService.mPolicy.canMagnifyWindow(windowState.mAttrs.type)) {
      mMagnifiedBounds.op(windowBounds,Region.Op.UNION);
      mMagnifiedBounds.op(mAvailableBounds,Region.Op.INTERSECT);
    }
 else {
      nonMagnifiedBounds.op(windowBounds,Region.Op.UNION);
      mAvailableBounds.op(windowBounds,Region.Op.DIFFERENCE);
    }
    Region accountedBounds=mTempRegion2;
    accountedBounds.set(mMagnifiedBounds);
    accountedBounds.op(nonMagnifiedBounds,Region.Op.UNION);
    accountedBounds.op(0,0,screenWidth,screenHeight,Region.Op.INTERSECT);
    if (accountedBounds.isRect()) {
      Rect accountedFrame=mTempRect1;
      accountedBounds.getBounds(accountedFrame);
      if (accountedFrame.width() == screenWidth && accountedFrame.height() == screenHeight) {
        break;
      }
    }
  }
  visibleWindows.clear();
  mMagnifiedBounds.op(mDrawBorderInset,mDrawBorderInset,screenWidth - mDrawBorderInset,screenHeight - mDrawBorderInset,Region.Op.INTERSECT);
  final boolean magnifiedChanged=!mOldMagnifiedBounds.equals(mMagnifiedBounds);
  final boolean availableChanged=!mOldAvailableBounds.equals(mAvailableBounds);
  if (magnifiedChanged || availableChanged) {
    if (magnifiedChanged) {
      mWindow.setBounds(mMagnifiedBounds);
      Rect dirtyRect=mTempRect1;
      if (mFullRedrawNeeded) {
        mFullRedrawNeeded=false;
        dirtyRect.set(mDrawBorderInset,mDrawBorderInset,screenWidth - mDrawBorderInset,screenHeight - mDrawBorderInset);
        mWindow.invalidate(dirtyRect);
      }
 else {
        Region dirtyRegion=mTempRegion3;
        dirtyRegion.set(mMagnifiedBounds);
        dirtyRegion.op(mOldMagnifiedBounds,Region.Op.UNION);
        dirtyRegion.op(nonMagnifiedBounds,Region.Op.INTERSECT);
        dirtyRegion.getBounds(dirtyRect);
        mWindow.invalidate(dirtyRect);
      }
      mOldMagnifiedBounds.set(mMagnifiedBounds);
    }
    if (availableChanged) {
      mOldAvailableBounds.set(mAvailableBounds);
    }
    final SomeArgs args=SomeArgs.obtain();
    args.arg1=Region.obtain(mMagnifiedBounds);
    args.arg2=Region.obtain(mAvailableBounds);
    mHandler.obtainMessage(MyHandler.MESSAGE_NOTIFY_MAGNIFIED_BOUNDS_CHANGED,args).sendToTarget();
  }
}
