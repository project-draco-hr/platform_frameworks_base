{
  mRoots.clear();
  mIdToPath.clear();
  mIdToRoot.clear();
  final StorageVolume[] volumes=mStorageManager.getVolumeList();
  for (  StorageVolume volume : volumes) {
    final boolean mounted=Environment.MEDIA_MOUNTED.equals(volume.getState()) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(volume.getState());
    if (!mounted)     continue;
    final String rootId;
    if (volume.isPrimary() && volume.isEmulated()) {
      rootId=ROOT_ID_PRIMARY_EMULATED;
    }
 else     if (volume.getUuid() != null) {
      rootId=volume.getUuid();
    }
 else {
      Log.d(TAG,"Missing UUID for " + volume.getPath() + "; skipping");
      continue;
    }
    if (mIdToPath.containsKey(rootId)) {
      Log.w(TAG,"Duplicate UUID " + rootId + "; skipping");
      continue;
    }
    try {
      final File path=volume.getPathFile();
      mIdToPath.put(rootId,path);
      final RootInfo root=new RootInfo();
      root.rootId=rootId;
      root.flags=Root.FLAG_SUPPORTS_CREATE | Root.FLAG_LOCAL_ONLY | Root.FLAG_ADVANCED| Root.FLAG_SUPPORTS_SEARCH| Root.FLAG_SUPPORTS_IS_CHILD;
      if (ROOT_ID_PRIMARY_EMULATED.equals(rootId)) {
        root.title=getContext().getString(R.string.root_internal_storage);
      }
 else {
        final String userLabel=volume.getUserLabel();
        if (!TextUtils.isEmpty(userLabel)) {
          root.title=userLabel;
        }
 else {
          root.title=volume.getDescription(getContext());
        }
      }
      root.docId=getDocIdForFile(path);
      mRoots.add(root);
      mIdToRoot.put(rootId,root);
    }
 catch (    FileNotFoundException e) {
      throw new IllegalStateException(e);
    }
  }
  Log.d(TAG,"After updating volumes, found " + mRoots.size() + " active roots");
  getContext().getContentResolver().notifyChange(DocumentsContract.buildRootsUri(AUTHORITY),null,false);
}
