{
  mRoots.clear();
  final int userId=UserHandle.myUserId();
  final List<VolumeInfo> volumes=mStorageManager.getVolumes();
  for (  VolumeInfo volume : volumes) {
    if (!volume.isMountedReadable())     continue;
    final String rootId;
    final String title;
    if (volume.getType() == VolumeInfo.TYPE_EMULATED) {
      rootId=ROOT_ID_PRIMARY_EMULATED;
      if (VolumeInfo.ID_EMULATED_INTERNAL.equals(volume.getId())) {
        title=getContext().getString(R.string.root_internal_storage);
      }
 else {
        final VolumeInfo privateVol=mStorageManager.findPrivateForEmulated(volume);
        title=mStorageManager.getBestVolumeDescription(privateVol);
      }
    }
 else     if (volume.getType() == VolumeInfo.TYPE_PUBLIC) {
      rootId=volume.getFsUuid();
      title=mStorageManager.getBestVolumeDescription(volume);
    }
 else {
      continue;
    }
    if (TextUtils.isEmpty(rootId)) {
      Log.d(TAG,"Missing UUID for " + volume.getId() + "; skipping");
      continue;
    }
    if (mRoots.containsKey(rootId)) {
      Log.w(TAG,"Duplicate UUID " + rootId + " for "+ volume.getId()+ "; skipping");
      continue;
    }
    try {
      final RootInfo root=new RootInfo();
      mRoots.put(rootId,root);
      root.rootId=rootId;
      root.flags=Root.FLAG_SUPPORTS_CREATE | Root.FLAG_LOCAL_ONLY | Root.FLAG_ADVANCED| Root.FLAG_SUPPORTS_SEARCH| Root.FLAG_SUPPORTS_IS_CHILD;
      root.title=title;
      if (volume.getType() == VolumeInfo.TYPE_PUBLIC) {
        root.flags|=Root.FLAG_HAS_SETTINGS;
      }
      if (volume.isVisibleForRead(userId)) {
        root.visiblePath=volume.getPathForUser(userId);
      }
 else {
        root.visiblePath=null;
      }
      root.path=volume.getInternalPathForUser(userId);
      root.docId=getDocIdForFile(root.path);
    }
 catch (    FileNotFoundException e) {
      throw new IllegalStateException(e);
    }
  }
  Log.d(TAG,"After updating volumes, found " + mRoots.size() + " active roots");
  getContext().getContentResolver().notifyChange(BASE_URI,null,false);
}
