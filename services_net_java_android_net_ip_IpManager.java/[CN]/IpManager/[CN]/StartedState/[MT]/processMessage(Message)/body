{
switch (msg.what) {
case CMD_STOP:
    transitionTo(mStoppedState);
  break;
case CMD_START:
Log.e(TAG,"ALERT: START received in StartedState. Please fix caller.");
break;
case CMD_CONFIRM:
if (mCallback.usingIpReachabilityMonitor()) {
mIpReachabilityMonitor.probeAll();
}
break;
case CMD_UPDATE_DHCPV4_RESULTS:
{
final DhcpResults dhcpResults=(DhcpResults)msg.obj;
if (dhcpResults != null) {
mDhcpResults=new DhcpResults(dhcpResults);
setLinkProperties(assembleLinkProperties());
mCallback.onIPv4ProvisioningSuccess(dhcpResults);
}
 else {
clearIPv4Address();
mDhcpResults=null;
setLinkProperties(assembleLinkProperties());
mCallback.onIPv4ProvisioningFailure();
}
break;
}
case EVENT_PRE_DHCP_ACTION_COMPLETE:
if (mDhcpStateMachine != null) {
mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_PRE_DHCP_ACTION_COMPLETE);
}
break;
case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
{
final LinkProperties newLp=assembleLinkProperties();
final ProvisioningChange delta=setLinkProperties(newLp);
switch (delta) {
case GAINED_PROVISIONING:
mCallback.onProvisioningSuccess(newLp);
break;
case LOST_PROVISIONING:
mCallback.onProvisioningFailure(newLp);
break;
default :
mCallback.onLinkPropertiesChange(newLp);
break;
}
break;
}
case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
mCallback.onPreDhcpAction();
break;
case DhcpStateMachine.CMD_POST_DHCP_ACTION:
{
mCallback.onPostDhcpAction();
final DhcpResults dhcpResults=(DhcpResults)msg.obj;
switch (msg.arg1) {
case DhcpStateMachine.DHCP_SUCCESS:
mDhcpResults=new DhcpResults(dhcpResults);
setLinkProperties(assembleLinkProperties());
mCallback.onIPv4ProvisioningSuccess(dhcpResults);
break;
case DhcpStateMachine.DHCP_FAILURE:
clearIPv4Address();
mDhcpResults=null;
setLinkProperties(assembleLinkProperties());
mCallback.onIPv4ProvisioningFailure();
break;
default :
Log.e(TAG,"Unknown CMD_POST_DHCP_ACTION status:" + msg.arg1);
}
break;
}
case DhcpStateMachine.CMD_ON_QUIT:
break;
default :
return NOT_HANDLED;
}
return HANDLED;
}
