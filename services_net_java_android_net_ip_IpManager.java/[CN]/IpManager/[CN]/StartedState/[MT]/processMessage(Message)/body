{
switch (msg.what) {
case CMD_STOP:
    transitionTo(mStoppedState);
  break;
case CMD_START:
Log.e(TAG,"ALERT: START received in StartedState. Please fix caller.");
break;
case CMD_CONFIRM:
if (mCallback.usingIpReachabilityMonitor()) {
mIpReachabilityMonitor.probeAll();
}
break;
case EVENT_PRE_DHCP_ACTION_COMPLETE:
if (mDhcpStateMachine != null) {
mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_PRE_DHCP_ACTION_COMPLETE);
}
break;
case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
{
final LinkProperties newLp=assembleLinkProperties();
final ProvisioningChange delta=setLinkProperties(newLp);
switch (delta) {
case GAINED_PROVISIONING:
mCallback.onProvisioningSuccess(newLp);
break;
case LOST_PROVISIONING:
mCallback.onProvisioningFailure(newLp);
break;
default :
mCallback.onLinkPropertiesChange(newLp);
break;
}
break;
}
case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
mCallback.onPreDhcpAction();
break;
case DhcpStateMachine.CMD_POST_DHCP_ACTION:
{
mCallback.onPostDhcpAction();
final DhcpResults dhcpResults=(DhcpResults)msg.obj;
switch (msg.arg1) {
case DhcpStateMachine.DHCP_SUCCESS:
handleIPv4Success(dhcpResults);
break;
case DhcpStateMachine.DHCP_FAILURE:
handleIPv4Failure();
break;
default :
Log.e(TAG,"Unknown CMD_POST_DHCP_ACTION status:" + msg.arg1);
}
break;
}
case DhcpStateMachine.CMD_ON_QUIT:
break;
default :
return NOT_HANDLED;
}
return HANDLED;
}
