{
switch (msg.what) {
case CMD_STOP:
    transitionTo(mStoppedState);
  break;
case CMD_START:
Log.e(mTag,"ALERT: START received in StartedState. Please fix caller.");
break;
case CMD_CONFIRM:
if (mIpReachabilityMonitor != null) {
mIpReachabilityMonitor.probeAll();
}
break;
case EVENT_PRE_DHCP_ACTION_COMPLETE:
if (mDhcpStateMachine != null) {
mDhcpStateMachine.sendMessage(DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE);
}
break;
case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
{
final LinkProperties newLp=assembleLinkProperties();
if (linkPropertiesUnchanged(newLp)) {
break;
}
final ProvisioningChange delta=setLinkProperties(newLp);
dispatchCallback(delta,newLp);
if (delta == ProvisioningChange.LOST_PROVISIONING) {
transitionTo(mStoppedState);
}
break;
}
case DhcpClient.CMD_PRE_DHCP_ACTION:
if (VDBG) {
Log.d(mTag,"onPreDhcpAction()");
}
if (mConfiguration.mRequestedPreDhcpAction) {
mCallback.onPreDhcpAction();
}
 else {
sendMessage(EVENT_PRE_DHCP_ACTION_COMPLETE);
}
break;
case DhcpClient.CMD_POST_DHCP_ACTION:
{
if (VDBG) {
Log.d(mTag,"onPostDhcpAction()");
}
mCallback.onPostDhcpAction();
final DhcpResults dhcpResults=(DhcpResults)msg.obj;
switch (msg.arg1) {
case DhcpClient.DHCP_SUCCESS:
handleIPv4Success(dhcpResults);
break;
case DhcpClient.DHCP_FAILURE:
handleIPv4Failure();
break;
default :
Log.e(mTag,"Unknown CMD_POST_DHCP_ACTION status:" + msg.arg1);
}
break;
}
case DhcpClient.CMD_ON_QUIT:
Log.e(mTag,"Unexpected CMD_ON_QUIT.");
mDhcpStateMachine=null;
break;
default :
return NOT_HANDLED;
}
return HANDLED;
}
