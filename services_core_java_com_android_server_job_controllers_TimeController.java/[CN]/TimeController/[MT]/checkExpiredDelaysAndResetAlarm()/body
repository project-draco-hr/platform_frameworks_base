{
  final long nowElapsedMillis=SystemClock.elapsedRealtime();
  long nextDelayTime=Long.MAX_VALUE;
  boolean ready=false;
  Iterator<JobStatus> it=mTrackedJobs.iterator();
  while (it.hasNext()) {
    final JobStatus job=it.next();
    if (!job.hasTimingDelayConstraint()) {
      continue;
    }
    final long jobDelayTime=job.getEarliestRunTime();
    if (jobDelayTime <= nowElapsedMillis) {
      job.timeDelayConstraintSatisfied.set(true);
      if (canStopTrackingJob(job)) {
        it.remove();
      }
      if (job.isReady()) {
        ready=true;
      }
    }
 else {
      if (nextDelayTime > jobDelayTime) {
        nextDelayTime=jobDelayTime;
      }
    }
  }
  if (ready) {
    mStateChangedListener.onControllerStateChanged();
  }
  setDelayExpiredAlarm(nextDelayTime);
}
