{
synchronized (mLock) {
    if (mAvailability == STATE_INVALID) {
      Slog.w(TAG,"Received message: " + msg.what + " for an invalid detector");
      return;
    }
  }
switch (msg.what) {
case MSG_STATE_CHANGED:
    mExternalCallback.onAvailabilityChanged(msg.arg1);
  break;
case MSG_HOTWORD_DETECTED:
synchronized (mLock) {
  mInternalState&=~FLAG_REQUESTED;
  mInternalState&=~FLAG_STARTED;
}
mExternalCallback.onDetected((byte[])msg.obj);
break;
case MSG_DETECTION_STARTED:
synchronized (mLock) {
mInternalState|=FLAG_STARTED;
}
mExternalCallback.onDetectionStarted();
break;
case MSG_DETECTION_STOPPED:
synchronized (mLock) {
mInternalState&=~FLAG_REQUESTED;
mInternalState&=~FLAG_STARTED;
}
mExternalCallback.onDetectionStopped();
break;
case MSG_DETECTION_ERROR:
synchronized (mLock) {
mInternalState&=~FLAG_REQUESTED;
mInternalState&=~FLAG_STARTED;
}
mExternalCallback.onError();
break;
default :
super.handleMessage(msg);
}
}
