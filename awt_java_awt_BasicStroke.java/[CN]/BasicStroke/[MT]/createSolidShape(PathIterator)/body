{
  double coords[]=new double[6];
  mx=my=cx=cy=0.0;
  isMove=false;
  isFirst=false;
  checkMove=true;
  boolean isClosed=true;
  while (!p.isDone()) {
switch (p.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
      if (!isClosed) {
        closeSolidShape();
      }
    rp.clean();
  mx=cx=coords[0];
my=cy=coords[1];
isMove=true;
isClosed=false;
break;
case PathIterator.SEG_LINETO:
addLine(cx,cy,cx=coords[0],cy=coords[1],true);
break;
case PathIterator.SEG_QUADTO:
addQuad(cx,cy,coords[0],coords[1],cx=coords[2],cy=coords[3]);
break;
case PathIterator.SEG_CUBICTO:
addCubic(cx,cy,coords[0],coords[1],coords[2],coords[3],cx=coords[4],cy=coords[5]);
break;
case PathIterator.SEG_CLOSE:
addLine(cx,cy,mx,my,false);
addJoin(lp,mx,my,lp.xMove,lp.yMove,true);
addJoin(rp,mx,my,rp.xMove,rp.yMove,false);
lp.closePath();
rp.closePath();
lp.appendReverse(rp);
isClosed=true;
break;
}
p.next();
}
if (!isClosed) {
closeSolidShape();
}
dst=lp;
}
