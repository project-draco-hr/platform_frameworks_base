{
  double coords[]=new double[6];
  mx=my=cx=cy=0.0;
  smx=smy=scx=scy=0.0;
  isMove=false;
  checkMove=false;
  boolean isClosed=true;
  while (!p.isDone()) {
switch (p.currentSegment(coords)) {
case PathIterator.SEG_MOVETO:
      if (!isClosed) {
        closeDashedShape();
      }
    dasher=new Dasher(dash,dashPhase);
  lp.clean();
rp.clean();
sp=null;
isFirst=true;
isMove=true;
isClosed=false;
mx=cx=coords[0];
my=cy=coords[1];
break;
case PathIterator.SEG_LINETO:
addDashLine(cx,cy,cx=coords[0],cy=coords[1]);
break;
case PathIterator.SEG_QUADTO:
addDashQuad(cx,cy,coords[0],coords[1],cx=coords[2],cy=coords[3]);
break;
case PathIterator.SEG_CUBICTO:
addDashCubic(cx,cy,coords[0],coords[1],coords[2],coords[3],cx=coords[4],cy=coords[5]);
break;
case PathIterator.SEG_CLOSE:
addDashLine(cx,cy,cx=mx,cy=my);
if (dasher.isConnected()) {
addJoin(lp,fmx,fmy,sp.xMove,sp.yMove,true);
lp.join(sp);
addJoin(lp,fmx,fmy,rp.xLast,rp.yLast,true);
lp.combine(rp);
addCap(lp,smx,smy,lp.xMove,lp.yMove);
lp.closePath();
dst.append(lp);
sp=null;
}
 else {
closeDashedShape();
}
isClosed=true;
break;
}
p.next();
}
if (!isClosed) {
closeDashedShape();
}
}
