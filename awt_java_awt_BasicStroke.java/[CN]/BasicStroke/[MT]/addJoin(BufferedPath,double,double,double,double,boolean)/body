{
  double x1=p.xLast;
  double y1=p.yLast;
  double x10=x1 - x0;
  double y10=y1 - y0;
  double x20=x2 - x0;
  double y20=y2 - y0;
  double sin0=x10 * y20 - y10 * x20;
  if (-cornerDelta < sin0 && sin0 < cornerDelta) {
    double cos0=x10 * x20 + y10 * y20;
    if (cos0 > 0.0) {
      if (-zeroDelta > sin0 || sin0 > zeroDelta) {
        double x3=x0 + w2 * w2 * (y20 - y10) / sin0;
        double y3=y0 + w2 * w2 * (x10 - x20) / sin0;
        p.setLast(x3,y3);
      }
      return;
    }
    if (-zeroDelta < sin0 && sin0 < zeroDelta) {
      p.lineTo(x2,y2);
    }
    return;
  }
  if (isLeft ^ (sin0 < 0.0)) {
    p.lineTo(x0,y0);
    p.lineTo(x2,y2);
  }
 else {
switch (join) {
case JOIN_BEVEL:
      p.lineTo(x2,y2);
    break;
case JOIN_MITER:
  double s1=x1 * x10 + y1 * y10;
double s2=x2 * x20 + y2 * y20;
double x3=(s1 * y20 - s2 * y10) / sin0;
double y3=(s2 * x10 - s1 * x20) / sin0;
double x30=x3 - x0;
double y30=y3 - y0;
double miterLength=Math.sqrt(x30 * x30 + y30 * y30);
if (miterLength < miterLimit * w2) {
p.lineTo(x3,y3);
}
p.lineTo(x2,y2);
break;
case JOIN_ROUND:
addRoundJoin(p,x0,y0,x2,y2,isLeft);
break;
}
}
}
