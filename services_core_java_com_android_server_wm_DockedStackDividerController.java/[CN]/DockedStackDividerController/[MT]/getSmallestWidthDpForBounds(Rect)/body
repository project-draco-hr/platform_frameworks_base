{
  final DisplayInfo di=mDisplayContent.getDisplayInfo();
  if (bounds == null || (bounds.left == 0 && bounds.top == 0 && bounds.right == di.logicalWidth && bounds.bottom == di.logicalHeight)) {
    return mService.mCurConfiguration.smallestScreenWidthDp;
  }
  final int baseDisplayWidth=mDisplayContent.mBaseDisplayWidth;
  final int baseDisplayHeight=mDisplayContent.mBaseDisplayHeight;
  int minWidth=Integer.MAX_VALUE;
  for (int rotation=0; rotation < 4; rotation++) {
    mTmpRect.set(bounds);
    mDisplayContent.rotateBounds(di.rotation,rotation,mTmpRect);
    final boolean rotated=(rotation == ROTATION_90 || rotation == ROTATION_270);
    mTmpRect2.set(0,0,rotated ? baseDisplayHeight : baseDisplayWidth,rotated ? baseDisplayWidth : baseDisplayHeight);
    final int orientation=mTmpRect2.width() <= mTmpRect2.height() ? ORIENTATION_PORTRAIT : ORIENTATION_LANDSCAPE;
    final int dockSide=TaskStack.getDockSideUnchecked(mTmpRect,mTmpRect2,orientation);
    final int position=DockedDividerUtils.calculatePositionForBounds(mTmpRect,dockSide,getContentWidth());
    final int snappedPosition=mSnapAlgorithmForRotation[rotation].calculateNonDismissingSnapTarget(position).position;
    DockedDividerUtils.calculateBoundsForPosition(snappedPosition,dockSide,mTmpRect,mTmpRect2.width(),mTmpRect2.height(),getContentWidth());
    mService.mPolicy.getStableInsetsLw(rotation,mTmpRect2.width(),mTmpRect2.height(),mTmpRect3);
    mService.subtractInsets(mTmpRect2,mTmpRect3,mTmpRect);
    minWidth=Math.min(mTmpRect.width(),minWidth);
  }
  return (int)(minWidth / mDisplayContent.getDisplayMetrics().density);
}
