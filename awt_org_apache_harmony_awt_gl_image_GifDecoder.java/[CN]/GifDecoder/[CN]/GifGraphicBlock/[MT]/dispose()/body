{
  imageComplete(ImageConsumer.SINGLEFRAMEDONE);
  if (delayTime > 0) {
    try {
      Thread.sleep(delayTime);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
 else {
    Thread.yield();
  }
  if (imageLeft > gifDataStream.logicalScreen.logicalScreenWidth || imageTop > gifDataStream.logicalScreen.logicalScreenHeight) {
    disposalMethod=DISPOSAL_NONE;
  }
switch (disposalMethod) {
case DISPOSAL_BACKGROUND:
{
      if (forceRGB) {
        getRgbImageData();
        int data[]=new int[imageWidth * imageHeight];
        if (transparentColor != IMPOSSIBLE_VALUE) {
          Arrays.fill(data,transparentColor);
        }
 else {
          Arrays.fill(data,gifDataStream.logicalScreen.backgroundColor);
        }
        setPixels(imageLeft,imageTop,imageWidth,imageHeight,ColorModel.getRGBdefault(),data,0,imageWidth);
        sendToScreenBuffer(data);
      }
 else {
        byte data[]=new byte[imageWidth * imageHeight];
        if (transparentColor != IMPOSSIBLE_VALUE) {
          Arrays.fill(data,(byte)transparentColor);
        }
 else {
          Arrays.fill(data,(byte)gifDataStream.logicalScreen.backgroundColor);
        }
        setPixels(imageLeft,imageTop,imageWidth,imageHeight,null,data,0,imageWidth);
        sendToScreenBuffer(data);
      }
      break;
    }
case DISPOSAL_RESTORE:
{
    screenBufferToScreen();
    break;
  }
case DISPOSAL_NONE:
case DISPOSAL_NODISPOSAL:
default :
{
  Object data=forceRGB ? (Object)getRgbImageData() : imageData;
  sendToScreenBuffer(data);
  break;
}
}
}
