{
  int type=parser.getEventType();
  if (type == XmlPullParser.START_TAG && parser.getName().equals(TAG_ENTRY)) {
    String key=parser.getAttributeValue(null,ATTR_KEY);
    String valType=parser.getAttributeValue(null,ATTR_VALUE_TYPE);
    String multiple=parser.getAttributeValue(null,ATTR_MULTIPLE);
    if (multiple != null) {
      values.clear();
      int count=Integer.parseInt(multiple);
      while (count > 0 && (type=parser.next()) != XmlPullParser.END_DOCUMENT) {
        if (type == XmlPullParser.START_TAG && parser.getName().equals(TAG_VALUE)) {
          values.add(parser.nextText().trim());
          count--;
        }
      }
      String[] valueStrings=new String[values.size()];
      values.toArray(valueStrings);
      restrictions.putStringArray(key,valueStrings);
    }
 else     if (ATTR_TYPE_BUNDLE.equals(valType)) {
      restrictions.putBundle(key,readBundleEntry(parser,values));
    }
 else     if (ATTR_TYPE_BUNDLE_ARRAY.equals(valType)) {
      final int outerDepth=parser.getDepth();
      ArrayList<Bundle> bundleList=new ArrayList<>();
      while (XmlUtils.nextElementWithin(parser,outerDepth)) {
        Bundle childBundle=readBundleEntry(parser,values);
        bundleList.add(childBundle);
      }
      restrictions.putParcelableArray(key,bundleList.toArray(new Bundle[bundleList.size()]));
    }
 else {
      String value=parser.nextText().trim();
      if (ATTR_TYPE_BOOLEAN.equals(valType)) {
        restrictions.putBoolean(key,Boolean.parseBoolean(value));
      }
 else       if (ATTR_TYPE_INTEGER.equals(valType)) {
        restrictions.putInt(key,Integer.parseInt(value));
      }
 else {
        restrictions.putString(key,value);
      }
    }
  }
}
