{
  checkManageUsersPermission("Only the system can remove users");
  if (getUserRestrictions(UserHandle.getCallingUserId()).getBoolean(UserManager.DISALLOW_REMOVE_USER,false)) {
    Log.w(LOG_TAG,"Cannot remove user. DISALLOW_REMOVE_USER is enabled.");
    return false;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    final UserInfo user;
    int currentUser=ActivityManager.getCurrentUser();
    if (currentUser == userHandle) {
      Log.w(LOG_TAG,"Current user cannot be removed");
      return false;
    }
synchronized (mPackagesLock) {
      user=mUsers.get(userHandle);
      if (userHandle == 0 || user == null || mRemovingUserIds.get(userHandle)) {
        return false;
      }
      mRemovingUserIds.put(userHandle,true);
      try {
        mAppOpsService.removeUser(userHandle);
      }
 catch (      RemoteException e) {
        Log.w(LOG_TAG,"Unable to notify AppOpsService of removing user",e);
      }
      user.partial=true;
      user.flags|=UserInfo.FLAG_DISABLED;
      writeUserLocked(user);
    }
    if (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID && user.isManagedProfile()) {
      sendProfileRemovedBroadcast(user.profileGroupId,user.id);
    }
    if (DBG)     Slog.i(LOG_TAG,"Stopping user " + userHandle);
    int res;
    try {
      res=ActivityManagerNative.getDefault().stopUser(userHandle,new IStopUserCallback.Stub(){
        @Override public void userStopped(        int userId){
          finishRemoveUser(userId);
        }
        @Override public void userStopAborted(        int userId){
        }
      }
);
    }
 catch (    RemoteException e) {
      return false;
    }
    return res == ActivityManager.USER_OP_SUCCESS;
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}
