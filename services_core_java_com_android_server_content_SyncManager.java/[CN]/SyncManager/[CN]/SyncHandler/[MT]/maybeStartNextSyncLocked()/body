{
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  if (isLoggable)   Log.v(TAG,"maybeStartNextSync");
  if (!mDataConnectionIsConnected) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: no data connection, skipping");
    }
    return Long.MAX_VALUE;
  }
  if (mStorageIsLow) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: memory low, skipping");
    }
    return Long.MAX_VALUE;
  }
  AccountAndUser[] accounts=mRunningAccounts;
  if (accounts == INITIAL_ACCOUNTS_ARRAY) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: accounts not known, skipping");
    }
    return Long.MAX_VALUE;
  }
  final boolean backgroundDataUsageAllowed=getConnectivityManager().getBackgroundDataSetting();
  final long now=SystemClock.elapsedRealtime();
  long nextReadyToRunTime=Long.MAX_VALUE;
  ArrayList<SyncOperation> operations=new ArrayList<SyncOperation>();
synchronized (mSyncQueue) {
    if (isLoggable) {
      Log.v(TAG,"build the operation array, syncQueue size is " + mSyncQueue.getOperations().size());
    }
    final Iterator<SyncOperation> operationIterator=mSyncQueue.getOperations().iterator();
    final ActivityManager activityManager=(ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    final Set<Integer> removedUsers=Sets.newHashSet();
    while (operationIterator.hasNext()) {
      final SyncOperation op=operationIterator.next();
      if (!containsAccountAndUser(accounts,op.account,op.userId)) {
        operationIterator.remove();
        mSyncStorageEngine.deleteFromPending(op.pendingOperation);
        if (isLoggable) {
          Log.v(TAG,"    Dropping sync operation: account doesn't exist.");
        }
        continue;
      }
      int syncableState=getIsSyncable(op.account,op.userId,op.authority);
      if (syncableState == 0) {
        operationIterator.remove();
        mSyncStorageEngine.deleteFromPending(op.pendingOperation);
        if (isLoggable) {
          Log.v(TAG,"    Dropping sync operation: isSyncable == 0.");
        }
        continue;
      }
      if (!activityManager.isUserRunning(op.userId)) {
        final UserInfo userInfo=mUserManager.getUserInfo(op.userId);
        if (userInfo == null) {
          removedUsers.add(op.userId);
        }
        if (isLoggable) {
          Log.v(TAG,"    Dropping sync operation: user not running.");
        }
        continue;
      }
      if (op.effectiveRunTime - op.flexTime > now) {
        if (nextReadyToRunTime > op.effectiveRunTime) {
          nextReadyToRunTime=op.effectiveRunTime;
        }
        if (isLoggable) {
          Log.v(TAG,"    Dropping sync operation: Sync too far in future.");
        }
        continue;
      }
      if (getConnectivityManager().isActiveNetworkMetered() && op.isMeteredDisallowed()) {
        operationIterator.remove();
        mSyncStorageEngine.deleteFromPending(op.pendingOperation);
        continue;
      }
      final RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterInfo;
      syncAdapterInfo=mSyncAdapters.getServiceInfo(SyncAdapterType.newKey(op.authority,op.account.type),op.userId);
      final boolean uidNetworkConnected;
      if (syncAdapterInfo != null) {
        final NetworkInfo networkInfo=getConnectivityManager().getActiveNetworkInfoForUid(syncAdapterInfo.uid);
        uidNetworkConnected=networkInfo != null && networkInfo.isConnected();
      }
 else {
        uidNetworkConnected=false;
      }
      if (!op.extras.getBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS,false) && (syncableState > 0) && (!mSyncStorageEngine.getMasterSyncAutomatically(op.userId) || !backgroundDataUsageAllowed || !uidNetworkConnected|| !mSyncStorageEngine.getSyncAutomatically(op.account,op.userId,op.authority))) {
        operationIterator.remove();
        mSyncStorageEngine.deleteFromPending(op.pendingOperation);
        continue;
      }
      operations.add(op);
    }
    for (    Integer user : removedUsers) {
      if (mUserManager.getUserInfo(user) == null) {
        onUserRemoved(user);
      }
    }
  }
  if (isLoggable)   Log.v(TAG,"sort the candidate operations, size " + operations.size());
  Collections.sort(operations);
  if (isLoggable)   Log.v(TAG,"dispatch all ready sync operations");
  for (int i=0, N=operations.size(); i < N; i++) {
    final SyncOperation candidate=operations.get(i);
    final boolean candidateIsInitialization=candidate.isInitialization();
    int numInit=0;
    int numRegular=0;
    ActiveSyncContext conflict=null;
    ActiveSyncContext longRunning=null;
    ActiveSyncContext toReschedule=null;
    ActiveSyncContext oldestNonExpeditedRegular=null;
    for (    ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
      final SyncOperation activeOp=activeSyncContext.mSyncOperation;
      if (activeOp.isInitialization()) {
        numInit++;
      }
 else {
        numRegular++;
        if (!activeOp.isExpedited()) {
          if (oldestNonExpeditedRegular == null || (oldestNonExpeditedRegular.mStartTime > activeSyncContext.mStartTime)) {
            oldestNonExpeditedRegular=activeSyncContext;
          }
        }
      }
      if (activeOp.account.type.equals(candidate.account.type) && activeOp.authority.equals(candidate.authority) && activeOp.userId == candidate.userId && (!activeOp.allowParallelSyncs || activeOp.account.name.equals(candidate.account.name))) {
        conflict=activeSyncContext;
      }
 else {
        if (candidateIsInitialization == activeOp.isInitialization() && activeSyncContext.mStartTime + MAX_TIME_PER_SYNC < now) {
          longRunning=activeSyncContext;
        }
      }
    }
    if (isLoggable) {
      Log.v(TAG,"candidate " + (i + 1) + " of "+ N+ ": "+ candidate);
      Log.v(TAG,"  numActiveInit=" + numInit + ", numActiveRegular="+ numRegular);
      Log.v(TAG,"  longRunning: " + longRunning);
      Log.v(TAG,"  conflict: " + conflict);
      Log.v(TAG,"  oldestNonExpeditedRegular: " + oldestNonExpeditedRegular);
    }
    final boolean roomAvailable=candidateIsInitialization ? numInit < MAX_SIMULTANEOUS_INITIALIZATION_SYNCS : numRegular < MAX_SIMULTANEOUS_REGULAR_SYNCS;
    if (conflict != null) {
      if (candidateIsInitialization && !conflict.mSyncOperation.isInitialization() && numInit < MAX_SIMULTANEOUS_INITIALIZATION_SYNCS) {
        toReschedule=conflict;
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Log.v(TAG,"canceling and rescheduling sync since an initialization " + "takes higher priority, " + conflict);
        }
      }
 else       if (candidate.isExpedited() && !conflict.mSyncOperation.isExpedited() && (candidateIsInitialization == conflict.mSyncOperation.isInitialization())) {
        toReschedule=conflict;
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Log.v(TAG,"canceling and rescheduling sync since an expedited " + "takes higher priority, " + conflict);
        }
      }
 else {
        continue;
      }
    }
 else     if (roomAvailable) {
    }
 else     if (candidate.isExpedited() && oldestNonExpeditedRegular != null && !candidateIsInitialization) {
      toReschedule=oldestNonExpeditedRegular;
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,"canceling and rescheduling sync since an expedited is ready to run, " + oldestNonExpeditedRegular);
      }
    }
 else     if (longRunning != null && (candidateIsInitialization == longRunning.mSyncOperation.isInitialization())) {
      toReschedule=longRunning;
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,"canceling and rescheduling sync since it ran roo long, " + longRunning);
      }
    }
 else {
      continue;
    }
    if (toReschedule != null) {
      runSyncFinishedOrCanceledLocked(null,toReschedule);
      scheduleSyncOperation(toReschedule.mSyncOperation);
    }
synchronized (mSyncQueue) {
      mSyncQueue.remove(candidate);
    }
    dispatchSyncOperation(candidate);
  }
  return nextReadyToRunTime;
}
