{
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_SYNC_EXPIRED:
      ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
    if (Log.isLoggable(TAG,Log.DEBUG)) {
      Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_EXPIRED: expiring " + expiredContext);
    }
  cancelActiveSync(expiredContext.mSyncOperation.target,expiredContext.mSyncOperation.extras);
nextPendingSyncTime=maybeStartNextSyncLocked();
break;
case SyncHandler.MESSAGE_CANCEL:
{
SyncStorageEngine.EndPoint payload=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_CANCEL: " + payload + " bundle: "+ extras);
}
cancelActiveSyncLocked(payload,extras);
nextPendingSyncTime=maybeStartNextSyncLocked();
break;
}
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_FINISHED");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActive(payload.activeSyncContext)) {
Log.d(TAG,"handleSyncHandlerMessage: dropping since the " + "sync is no longer active: " + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledLocked(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncLocked();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_CONNECTED: " + msgData.activeSyncContext);
}
if (isSyncStillActive(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,"handleSyncHandlerMessage: MESSAGE_SERVICE_DISCONNECTED: " + currentSyncContext);
}
if (isSyncStillActive(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledLocked(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncLocked();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_SYNC_ALARM");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncLocked();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,"handleSyncHandlerMessage: MESSAGE_CHECK_ALARMS");
}
nextPendingSyncTime=maybeStartNextSyncLocked();
break;
}
}
  finally {
manageSyncNotificationLocked();
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}
