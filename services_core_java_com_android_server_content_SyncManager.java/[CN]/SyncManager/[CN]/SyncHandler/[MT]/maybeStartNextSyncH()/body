{
  final boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
  if (isLoggable)   Log.v(TAG,"maybeStartNextSync");
  if (!mDataConnectionIsConnected) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: no data connection, skipping");
    }
    return Long.MAX_VALUE;
  }
  if (mStorageIsLow) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: memory low, skipping");
    }
    return Long.MAX_VALUE;
  }
  if (mDeviceIsIdle) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: device idle, skipping");
    }
    return Long.MAX_VALUE;
  }
  if (mRunningAccounts == INITIAL_ACCOUNTS_ARRAY) {
    if (isLoggable) {
      Log.v(TAG,"maybeStartNextSync: accounts not known, skipping");
    }
    return Long.MAX_VALUE;
  }
  final long now=SystemClock.elapsedRealtime();
  long nextReadyToRunTime=Long.MAX_VALUE;
  ArrayList<SyncOperation> operations=new ArrayList<SyncOperation>();
synchronized (mSyncQueue) {
    if (isLoggable) {
      Log.v(TAG,"build the operation array, syncQueue size is " + mSyncQueue.getOperations().size());
    }
    final Iterator<SyncOperation> operationIterator=mSyncQueue.getOperations().iterator();
    final ActivityManager activityManager=(ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    final Set<Integer> removedUsers=Sets.newHashSet();
    while (operationIterator.hasNext()) {
      final SyncOperation op=operationIterator.next();
      if (!activityManager.isUserRunning(op.target.userId)) {
        final UserInfo userInfo=mUserManager.getUserInfo(op.target.userId);
        if (userInfo == null) {
          removedUsers.add(op.target.userId);
        }
        if (isLoggable) {
          Log.v(TAG,"    Dropping all sync operations for + " + op.target.userId + ": user not running.");
        }
        continue;
      }
      String packageName=getPackageName(op.target);
      ApplicationInfo ai=null;
      if (packageName != null) {
        try {
          ai=mContext.getPackageManager().getApplicationInfo(packageName,PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_DISABLED_COMPONENTS);
        }
 catch (        NameNotFoundException e) {
          operationIterator.remove();
          mSyncStorageEngine.deleteFromPending(op.pendingOperation);
          continue;
        }
      }
      if (ai != null && mAppIdleMonitor.isAppIdle(packageName,ai.uid,op.target.userId)) {
        increaseBackoffSetting(op);
        op.appIdle=true;
        if (isLoggable) {
          Log.v(TAG,"Sync backing off idle app " + packageName);
        }
        continue;
      }
 else {
        op.appIdle=false;
      }
      if (!isOperationValidLocked(op)) {
        operationIterator.remove();
        mSyncStorageEngine.deleteFromPending(op.pendingOperation);
        continue;
      }
      if (op.effectiveRunTime - op.flexTime > now) {
        if (nextReadyToRunTime > op.effectiveRunTime) {
          nextReadyToRunTime=op.effectiveRunTime;
        }
        if (isLoggable) {
          Log.v(TAG,"    Not running sync operation: Sync too far in future." + "effective: " + op.effectiveRunTime + " flex: "+ op.flexTime+ " now: "+ now);
        }
        continue;
      }
      operations.add(op);
    }
    for (    Integer user : removedUsers) {
      if (mUserManager.getUserInfo(user) == null) {
        onUserRemoved(user);
      }
    }
  }
  if (isLoggable)   Log.v(TAG,"sort the candidate operations, size " + operations.size());
  Collections.sort(operations);
  if (isLoggable)   Log.v(TAG,"dispatch all ready sync operations");
  for (int i=0, N=operations.size(); i < N; i++) {
    final SyncOperation candidate=operations.get(i);
    final boolean candidateIsInitialization=candidate.isInitialization();
    int numInit=0;
    int numRegular=0;
    ActiveSyncContext conflict=null;
    ActiveSyncContext longRunning=null;
    ActiveSyncContext toReschedule=null;
    ActiveSyncContext oldestNonExpeditedRegular=null;
    for (    ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
      final SyncOperation activeOp=activeSyncContext.mSyncOperation;
      if (activeOp.isInitialization()) {
        numInit++;
      }
 else {
        numRegular++;
        if (!activeOp.isExpedited()) {
          if (oldestNonExpeditedRegular == null || (oldestNonExpeditedRegular.mStartTime > activeSyncContext.mStartTime)) {
            oldestNonExpeditedRegular=activeSyncContext;
          }
        }
      }
      if (activeOp.isConflict(candidate)) {
        conflict=activeSyncContext;
      }
 else {
        if (candidateIsInitialization == activeOp.isInitialization() && activeSyncContext.mStartTime + MAX_TIME_PER_SYNC < now) {
          longRunning=activeSyncContext;
        }
      }
    }
    if (isLoggable) {
      Log.v(TAG,"candidate " + (i + 1) + " of "+ N+ ": "+ candidate);
      Log.v(TAG,"  numActiveInit=" + numInit + ", numActiveRegular="+ numRegular);
      Log.v(TAG,"  longRunning: " + longRunning);
      Log.v(TAG,"  conflict: " + conflict);
      Log.v(TAG,"  oldestNonExpeditedRegular: " + oldestNonExpeditedRegular);
    }
    final boolean roomAvailable=candidateIsInitialization ? numInit < MAX_SIMULTANEOUS_INITIALIZATION_SYNCS : numRegular < MAX_SIMULTANEOUS_REGULAR_SYNCS;
    if (conflict != null) {
      if (candidateIsInitialization && !conflict.mSyncOperation.isInitialization() && numInit < MAX_SIMULTANEOUS_INITIALIZATION_SYNCS) {
        toReschedule=conflict;
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Log.v(TAG,"canceling and rescheduling sync since an initialization " + "takes higher priority, " + conflict);
        }
      }
 else       if (candidate.isExpedited() && !conflict.mSyncOperation.isExpedited() && (candidateIsInitialization == conflict.mSyncOperation.isInitialization())) {
        toReschedule=conflict;
        if (Log.isLoggable(TAG,Log.VERBOSE)) {
          Log.v(TAG,"canceling and rescheduling sync since an expedited " + "takes higher priority, " + conflict);
        }
      }
 else {
        continue;
      }
    }
 else     if (roomAvailable) {
    }
 else     if (candidate.isExpedited() && oldestNonExpeditedRegular != null && !candidateIsInitialization) {
      toReschedule=oldestNonExpeditedRegular;
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,"canceling and rescheduling sync since an expedited is ready to" + " run, " + oldestNonExpeditedRegular);
      }
    }
 else     if (longRunning != null && (candidateIsInitialization == longRunning.mSyncOperation.isInitialization())) {
      toReschedule=longRunning;
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,"canceling and rescheduling sync since it ran roo long, " + longRunning);
      }
    }
 else {
      continue;
    }
    if (toReschedule != null) {
      runSyncFinishedOrCanceledH(null,toReschedule);
      scheduleSyncOperation(toReschedule.mSyncOperation);
    }
synchronized (mSyncQueue) {
      mSyncQueue.remove(candidate);
    }
    dispatchSyncOperation(candidate);
  }
  return nextReadyToRunTime;
}
