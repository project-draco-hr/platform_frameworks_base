{
  pw.print("data connected: ");
  pw.println(mDataConnectionIsConnected);
  pw.print("auto sync: ");
  List<UserInfo> users=getAllUsers();
  if (users != null) {
    for (    UserInfo user : users) {
      pw.print("u" + user.id + "="+ mSyncStorageEngine.getMasterSyncAutomatically(user.id)+ " ");
    }
    pw.println();
  }
  pw.print("memory low: ");
  pw.println(mStorageIsLow);
  pw.print("device idle: ");
  pw.println(mDeviceIsIdle);
  final AccountAndUser[] accounts=AccountManagerService.getSingleton().getAllAccounts();
  pw.print("accounts: ");
  if (accounts != INITIAL_ACCOUNTS_ARRAY) {
    pw.println(accounts.length);
  }
 else {
    pw.println("not known yet");
  }
  final long now=SystemClock.elapsedRealtime();
  pw.print("now: ");
  pw.print(now);
  pw.println(" (" + formatTime(System.currentTimeMillis()) + ")");
  pw.print("offset: ");
  pw.print(DateUtils.formatElapsedTime(mSyncRandomOffsetMillis / 1000));
  pw.println(" (HH:MM:SS)");
  pw.print("uptime: ");
  pw.print(DateUtils.formatElapsedTime(now / 1000));
  pw.println(" (HH:MM:SS)");
  pw.print("time spent syncing: ");
  pw.print(DateUtils.formatElapsedTime(mSyncHandler.mSyncTimeTracker.timeSpentSyncing() / 1000));
  pw.print(" (HH:MM:SS), sync ");
  pw.print(mSyncHandler.mSyncTimeTracker.mLastWasSyncing ? "" : "not ");
  pw.println("in progress");
  if (mSyncHandler.mAlarmScheduleTime != null) {
    pw.print("next alarm time: ");
    pw.print(mSyncHandler.mAlarmScheduleTime);
    pw.print(" (");
    pw.print(DateUtils.formatElapsedTime((mSyncHandler.mAlarmScheduleTime - now) / 1000));
    pw.println(" (HH:MM:SS) from now)");
  }
 else {
    pw.println("no alarm is scheduled (there had better not be any pending syncs)");
  }
  pw.print("notification info: ");
  final StringBuilder sb=new StringBuilder();
  mSyncHandler.mSyncNotificationInfo.toString(sb);
  pw.println(sb.toString());
  pw.println();
  pw.println("Active Syncs: " + mActiveSyncContexts.size());
  final PackageManager pm=mContext.getPackageManager();
  for (  SyncManager.ActiveSyncContext activeSyncContext : mActiveSyncContexts) {
    final long durationInSeconds=(now - activeSyncContext.mStartTime) / 1000;
    pw.print("  ");
    pw.print(DateUtils.formatElapsedTime(durationInSeconds));
    pw.print(" - ");
    pw.print(activeSyncContext.mSyncOperation.dump(pm,false));
    pw.println();
  }
synchronized (mSyncQueue) {
    sb.setLength(0);
    mSyncQueue.dump(sb);
    getSyncStorageEngine().dumpPendingOperations(sb);
  }
  pw.println();
  pw.print(sb.toString());
  pw.println();
  pw.println("Sync Status");
  for (  AccountAndUser account : accounts) {
    pw.printf("Account %s u%d %s\n",account.account.name,account.userId,account.account.type);
    pw.println("=======================================================================");
    final PrintTable table=new PrintTable(13);
    table.set(0,0,"Authority","Syncable","Enabled","Delay","Loc","Poll","Per","Serv","User","Tot","Time","Last Sync","Periodic");
    final List<RegisteredServicesCache.ServiceInfo<SyncAdapterType>> sorted=Lists.newArrayList();
    sorted.addAll(mSyncAdapters.getAllServices(account.userId));
    Collections.sort(sorted,new Comparator<RegisteredServicesCache.ServiceInfo<SyncAdapterType>>(){
      @Override public int compare(      RegisteredServicesCache.ServiceInfo<SyncAdapterType> lhs,      RegisteredServicesCache.ServiceInfo<SyncAdapterType> rhs){
        return lhs.type.authority.compareTo(rhs.type.authority);
      }
    }
);
    for (    RegisteredServicesCache.ServiceInfo<SyncAdapterType> syncAdapterType : sorted) {
      if (!syncAdapterType.type.accountType.equals(account.account.type)) {
        continue;
      }
      int row=table.getNumRows();
      Pair<AuthorityInfo,SyncStatusInfo> syncAuthoritySyncStatus=mSyncStorageEngine.getCopyOfAuthorityWithSyncStatus(new SyncStorageEngine.EndPoint(account.account,syncAdapterType.type.authority,account.userId));
      SyncStorageEngine.AuthorityInfo settings=syncAuthoritySyncStatus.first;
      SyncStatusInfo status=syncAuthoritySyncStatus.second;
      String authority=settings.target.provider;
      if (authority.length() > 50) {
        authority=authority.substring(authority.length() - 50);
      }
      table.set(row,0,authority,settings.syncable,settings.enabled);
      table.set(row,4,status.numSourceLocal,status.numSourcePoll,status.numSourcePeriodic,status.numSourceServer,status.numSourceUser,status.numSyncs,DateUtils.formatElapsedTime(status.totalElapsedTime / 1000));
      for (int i=0; i < settings.periodicSyncs.size(); i++) {
        final PeriodicSync sync=settings.periodicSyncs.get(i);
        final String period=String.format("[p:%d s, f: %d s]",sync.period,sync.flexTime);
        final String extras=sync.extras.size() > 0 ? sync.extras.toString() : "Bundle[]";
        final String next="Next sync: " + formatTime(status.getPeriodicSyncTime(i) + sync.period * 1000);
        table.set(row + i * 2,12,period + " " + extras);
        table.set(row + i * 2 + 1,12,next);
      }
      int row1=row;
      if (settings.delayUntil > now) {
        table.set(row1++,12,"D: " + (settings.delayUntil - now) / 1000);
        if (settings.backoffTime > now) {
          table.set(row1++,12,"B: " + (settings.backoffTime - now) / 1000);
          table.set(row1++,12,settings.backoffDelay / 1000);
        }
      }
      if (status.lastSuccessTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastSuccessSource] + " " + "SUCCESS");
        table.set(row1++,11,formatTime(status.lastSuccessTime));
      }
      if (status.lastFailureTime != 0) {
        table.set(row1++,11,SyncStorageEngine.SOURCES[status.lastFailureSource] + " " + "FAILURE");
        table.set(row1++,11,formatTime(status.lastFailureTime));
        table.set(row1++,11,status.lastFailureMesg);
      }
    }
    table.writeTo(pw);
  }
}
