{
  fraction=MathUtils.constrain(fraction,0,1);
  int numPoints=mKeyframeData.length / 3;
  if (fraction == 0) {
    return pointForIndex(0);
  }
 else   if (fraction == 1) {
    return pointForIndex(numPoints - 1);
  }
 else {
    int low=0;
    int high=numPoints - 1;
    while (low <= high) {
      int mid=(low + high) / 2;
      float midFraction=mKeyframeData[(mid * NUM_COMPONENTS) + FRACTION_OFFSET];
      if (fraction < midFraction) {
        high=mid - 1;
      }
 else       if (fraction > midFraction) {
        low=mid + 1;
      }
 else {
        return pointForIndex(mid);
      }
    }
    int startBase=(high * NUM_COMPONENTS);
    int endBase=(low * NUM_COMPONENTS);
    float startFraction=mKeyframeData[startBase + FRACTION_OFFSET];
    float endFraction=mKeyframeData[endBase + FRACTION_OFFSET];
    float intervalFraction=(fraction - startFraction) / (endFraction - startFraction);
    float startX=mKeyframeData[startBase + X_OFFSET];
    float endX=mKeyframeData[endBase + X_OFFSET];
    float startY=mKeyframeData[startBase + Y_OFFSET];
    float endY=mKeyframeData[endBase + Y_OFFSET];
    float x=interpolate(intervalFraction,startX,endX);
    float y=interpolate(intervalFraction,startY,endY);
    mTempPointF.set(x,y);
    return mTempPointF;
  }
}
