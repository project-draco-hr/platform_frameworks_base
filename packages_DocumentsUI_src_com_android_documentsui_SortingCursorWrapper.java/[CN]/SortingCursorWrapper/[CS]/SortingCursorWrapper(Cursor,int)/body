{
  mCursor=cursor;
  final int count=cursor.getCount();
  mPosition=new int[count];
switch (sortOrder) {
case SORT_ORDER_DISPLAY_NAME:
    mValueString=new String[count];
  mValueLong=null;
break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
mValueString=null;
mValueLong=new long[count];
break;
default :
throw new IllegalArgumentException();
}
final int mimeTypeIndex=cursor.getColumnIndex(Document.COLUMN_MIME_TYPE);
final int displayNameIndex=cursor.getColumnIndex(Document.COLUMN_DISPLAY_NAME);
final int lastModifiedIndex=cursor.getColumnIndex(Document.COLUMN_LAST_MODIFIED);
final int sizeIndex=cursor.getColumnIndex(Document.COLUMN_SIZE);
cursor.moveToPosition(-1);
for (int i=0; i < count; i++) {
cursor.moveToNext();
mPosition[i]=i;
switch (sortOrder) {
case SORT_ORDER_DISPLAY_NAME:
final String mimeType=cursor.getString(mimeTypeIndex);
final String displayName=cursor.getString(displayNameIndex);
if (Document.MIME_TYPE_DIR.equals(mimeType)) {
mValueString[i]='\001' + displayName;
}
 else {
mValueString[i]=displayName;
}
break;
case SORT_ORDER_LAST_MODIFIED:
mValueLong[i]=cursor.getLong(lastModifiedIndex);
break;
case SORT_ORDER_SIZE:
mValueLong[i]=cursor.getLong(sizeIndex);
break;
}
}
switch (sortOrder) {
case SORT_ORDER_DISPLAY_NAME:
synchronized (SortingCursorWrapper.class) {
binarySort(mPosition,mValueString);
}
break;
case SORT_ORDER_LAST_MODIFIED:
case SORT_ORDER_SIZE:
binarySort(mPosition,mValueLong);
break;
}
}
