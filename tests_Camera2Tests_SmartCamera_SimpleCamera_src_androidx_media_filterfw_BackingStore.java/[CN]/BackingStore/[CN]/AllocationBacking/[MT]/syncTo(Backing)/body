{
  int access=backing.readAccess();
  if ((access & ACCESS_TEXTURE) != 0) {
    RenderTarget target=(RenderTarget)backing.lock(ACCESS_RENDERTARGET);
    ByteBuffer pixels=ByteBuffer.allocateDirect(getSize());
    GLToolbox.readTarget(target,pixels,mDimensions[0],mDimensions[1]);
    mAllocation.copyFrom(pixels.array());
  }
 else   if ((access & ACCESS_BITMAP) != 0) {
    Bitmap bitmap=(Bitmap)backing.lock(ACCESS_BITMAP);
    mAllocation.copyFrom(bitmap);
  }
 else   if ((access & ACCESS_BYTES) != 0) {
    ByteBuffer buffer=(ByteBuffer)backing.lock(ACCESS_BYTES);
    if (buffer.order() != ByteOrder.nativeOrder()) {
      throw new RuntimeException("Trying to sync to the ByteBufferBacking with non-native byte order!");
    }
    byte[] bytes;
    if (buffer.hasArray()) {
      bytes=buffer.array();
    }
 else {
      bytes=new byte[getSize()];
      buffer.get(bytes);
      buffer.rewind();
    }
    mAllocation.copyFromUnchecked(bytes);
  }
 else {
    throw new RuntimeException("Cannot sync allocation backing!");
  }
  backing.unlock();
  mIsDirty=false;
}
