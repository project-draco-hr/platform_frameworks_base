{
synchronized (mLock) {
    if (mCacheImpl.size() <= 0) {
      return;
    }
    AccessibilityNodeInfo root=mCacheImpl.valueAt(0);
    AccessibilityNodeInfo parent=root;
    while (parent != null) {
      root=parent;
      parent=mCacheImpl.get(parent.getParentNodeId());
    }
    final int windowId=root.getWindowId();
    AccessibilityNodeInfo accessFocus=null;
    AccessibilityNodeInfo inputFocus=null;
    HashSet<AccessibilityNodeInfo> seen=new HashSet<AccessibilityNodeInfo>();
    Queue<AccessibilityNodeInfo> fringe=new LinkedList<AccessibilityNodeInfo>();
    fringe.add(root);
    while (!fringe.isEmpty()) {
      AccessibilityNodeInfo current=fringe.poll();
      if (!seen.add(current)) {
        Log.e(LOG_TAG,"Duplicate node: " + current);
        return;
      }
      if (current.isAccessibilityFocused()) {
        if (accessFocus != null) {
          Log.e(LOG_TAG,"Duplicate accessibility focus:" + current);
        }
 else {
          accessFocus=current;
        }
      }
      if (current.isFocused()) {
        if (inputFocus != null) {
          Log.e(LOG_TAG,"Duplicate input focus: " + current);
        }
 else {
          inputFocus=current;
        }
      }
      SparseLongArray childIds=current.getChildNodeIds();
      final int childCount=childIds.size();
      for (int i=0; i < childCount; i++) {
        final long childId=childIds.valueAt(i);
        AccessibilityNodeInfo child=mCacheImpl.get(childId);
        if (child != null) {
          fringe.add(child);
        }
      }
    }
    final int cacheSize=mCacheImpl.size();
    for (int i=0; i < cacheSize; i++) {
      AccessibilityNodeInfo info=mCacheImpl.valueAt(i);
      if (!seen.contains(info)) {
        if (info.getWindowId() == windowId) {
          Log.e(LOG_TAG,"Disconneced node: ");
        }
 else {
          Log.e(LOG_TAG,"Node from: " + info.getWindowId() + " not from:"+ windowId+ " "+ info);
        }
      }
    }
  }
}
