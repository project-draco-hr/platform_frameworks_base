{
  if (mDatabaseHelper == null) {
    return;
  }
synchronized (this.getClass()) {
    SQLiteDatabase db=mDatabaseHelper.getWritableDatabase();
    if (mExternalCache.size() == MAX_CACHE_SIZE) {
      Cursor byTime=mDatabaseHelper.getReadableDatabase().query(SSL_CACHE_TABLE,PROJECTION,null,null,null,null,SSL_CACHE_TIME_SEC);
      if (byTime.moveToFirst()) {
        String hostPort=byTime.getString(SSL_CACHE_HOSTPORT_COL);
        db.delete(SSL_CACHE_TABLE,SSL_CACHE_HOSTPORT + "= ?",new String[]{hostPort});
        mExternalCache.remove(hostPort);
      }
 else {
        Log.w(TAG,"No rows found");
        clear();
      }
    }
    long t0=System.currentTimeMillis();
    String b64=new String(Base64.encodeBase64(der));
    String key=session.getPeerHost() + ":" + session.getPeerPort();
    ContentValues values=new ContentValues();
    values.put(SSL_CACHE_HOSTPORT,key);
    values.put(SSL_CACHE_SESSION,b64);
    values.put(SSL_CACHE_TIME_SEC,System.currentTimeMillis() / 1000);
    mExternalCache.put(key,der);
    try {
      db.insert(SSL_CACHE_TABLE,null,values);
    }
 catch (    SQLException ex) {
      Log.w(TAG,"Ignoring SQL exception when caching session",ex);
    }
    if (Log.isLoggable(TAG,Log.DEBUG)) {
      long t1=System.currentTimeMillis();
      Log.d(TAG,"New SSL session " + session.getPeerHost() + " DER len: "+ der.length+ " "+ (t1 - t0));
    }
  }
}
