{
  if (value != null && sTagSetForCompatibility.contains(tag)) {
    if (tag.equals(TAG_GPS_TIMESTAMP)) {
      Matcher m=sGpsTimestampPattern.matcher(value);
      if (!m.find()) {
        Log.w(TAG,"Invalid value for " + tag + " : "+ value);
        return;
      }
      value=Integer.parseInt(m.group(1)) + "/1," + Integer.parseInt(m.group(2))+ "/1,"+ Integer.parseInt(m.group(3))+ "/1";
    }
 else {
      try {
        double doubleValue=Double.parseDouble(value);
        value=(long)(doubleValue * 10000L) + "/10000";
      }
 catch (      NumberFormatException e) {
        Log.w(TAG,"Invalid value for " + tag + " : "+ value);
        return;
      }
    }
  }
  for (int i=0; i < EXIF_TAGS.length; ++i) {
    if (i == IFD_THUMBNAIL_HINT && !mHasThumbnail) {
      continue;
    }
    final Object obj=sExifTagMapsForWriting[i].get(tag);
    if (obj != null) {
      if (value == null) {
        mAttributes[i].remove(tag);
        continue;
      }
      final ExifTag exifTag=(ExifTag)obj;
      Pair<Integer,Integer> guess=guessDataFormat(value);
      int dataFormat;
      if (exifTag.primaryFormat == guess.first || exifTag.primaryFormat == guess.second) {
        dataFormat=exifTag.primaryFormat;
      }
 else       if (exifTag.secondaryFormat != -1 && (exifTag.secondaryFormat == guess.first || exifTag.secondaryFormat == guess.second)) {
        dataFormat=exifTag.secondaryFormat;
      }
 else       if (exifTag.primaryFormat == IFD_FORMAT_BYTE || exifTag.primaryFormat == IFD_FORMAT_UNDEFINED || exifTag.primaryFormat == IFD_FORMAT_STRING) {
        dataFormat=exifTag.primaryFormat;
      }
 else {
        Log.w(TAG,"Given tag (" + tag + ") value didn't match with one of expected "+ "formats: "+ IFD_FORMAT_NAMES[exifTag.primaryFormat]+ (exifTag.secondaryFormat == -1 ? "" : ", " + IFD_FORMAT_NAMES[exifTag.secondaryFormat])+ " (guess: "+ IFD_FORMAT_NAMES[guess.first]+ (guess.second == -1 ? "" : ", " + IFD_FORMAT_NAMES[guess.second])+ ")");
        continue;
      }
switch (dataFormat) {
case IFD_FORMAT_BYTE:
{
          mAttributes[i].put(tag,ExifAttribute.createByte(value));
          break;
        }
case IFD_FORMAT_UNDEFINED:
case IFD_FORMAT_STRING:
{
        mAttributes[i].put(tag,ExifAttribute.createString(value));
        break;
      }
case IFD_FORMAT_USHORT:
{
      final String[] values=value.split(",");
      final int[] intArray=new int[values.length];
      for (int j=0; j < values.length; ++j) {
        intArray[j]=Integer.parseInt(values[j]);
      }
      mAttributes[i].put(tag,ExifAttribute.createUShort(intArray,mExifByteOrder));
      break;
    }
case IFD_FORMAT_SLONG:
{
    final String[] values=value.split(",");
    final int[] intArray=new int[values.length];
    for (int j=0; j < values.length; ++j) {
      intArray[j]=Integer.parseInt(values[j]);
    }
    mAttributes[i].put(tag,ExifAttribute.createSLong(intArray,mExifByteOrder));
    break;
  }
case IFD_FORMAT_ULONG:
{
  final String[] values=value.split(",");
  final long[] longArray=new long[values.length];
  for (int j=0; j < values.length; ++j) {
    longArray[j]=Long.parseLong(values[j]);
  }
  mAttributes[i].put(tag,ExifAttribute.createULong(longArray,mExifByteOrder));
  break;
}
case IFD_FORMAT_URATIONAL:
{
final String[] values=value.split(",");
final Rational[] rationalArray=new Rational[values.length];
for (int j=0; j < values.length; ++j) {
  final String[] numbers=values[j].split("/");
  rationalArray[j]=new Rational(Long.parseLong(numbers[0]),Long.parseLong(numbers[1]));
}
mAttributes[i].put(tag,ExifAttribute.createURational(rationalArray,mExifByteOrder));
break;
}
case IFD_FORMAT_SRATIONAL:
{
final String[] values=value.split(",");
final Rational[] rationalArray=new Rational[values.length];
for (int j=0; j < values.length; ++j) {
final String[] numbers=values[j].split("/");
rationalArray[j]=new Rational(Long.parseLong(numbers[0]),Long.parseLong(numbers[1]));
}
mAttributes[i].put(tag,ExifAttribute.createSRational(rationalArray,mExifByteOrder));
break;
}
case IFD_FORMAT_DOUBLE:
{
final String[] values=value.split(",");
final double[] doubleArray=new double[values.length];
for (int j=0; j < values.length; ++j) {
doubleArray[j]=Double.parseDouble(values[j]);
}
mAttributes[i].put(tag,ExifAttribute.createDouble(doubleArray,mExifByteOrder));
break;
}
default :
Log.w(TAG,"Data format isn't one of expected formats: " + dataFormat);
continue;
}
}
}
}
