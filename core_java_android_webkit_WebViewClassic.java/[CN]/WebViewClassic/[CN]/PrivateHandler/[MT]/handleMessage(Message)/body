{
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    if (msg.what >= FIRST_PRIVATE_MSG_ID && msg.what <= LAST_PRIVATE_MSG_ID) {
      Log.v(LOGTAG,HandlerPrivateDebugString[msg.what - FIRST_PRIVATE_MSG_ID]);
    }
 else     if (msg.what >= FIRST_PACKAGE_MSG_ID && msg.what <= LAST_PACKAGE_MSG_ID) {
      Log.v(LOGTAG,HandlerPackageDebugString[msg.what - FIRST_PACKAGE_MSG_ID]);
    }
 else {
      Log.v(LOGTAG,Integer.toString(msg.what));
    }
  }
  if (mWebViewCore == null) {
    return;
  }
  if (mBlockWebkitViewMessages && msg.what != WEBCORE_INITIALIZED_MSG_ID) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString("host"),msg.getData().getString("username"),msg.getData().getString("password"));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString("host"),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SCROLL_SELECT_TEXT:
{
  if (mAutoScrollX == 0 && mAutoScrollY == 0) {
    mSentAutoScrollMessage=false;
    break;
  }
  if (mCurrentScrollingLayerId == 0) {
    pinScrollBy(mAutoScrollX,mAutoScrollY,true,0);
  }
 else {
    scrollLayerTo(mScrollingLayerRect.left + mAutoScrollX,mScrollingLayerRect.top + mAutoScrollY);
  }
  sendEmptyMessageDelayed(SCROLL_SELECT_TEXT,SELECT_SCROLL_INTERVAL);
  break;
}
case SCROLL_TO_MSG_ID:
{
if (msg.arg2 == 1) {
  InputMethodManager imm=InputMethodManager.peekInstance();
  if (imm == null || !imm.isAcceptingText() || !imm.isActive(mWebView)) {
    break;
  }
}
final Point p=(Point)msg.obj;
contentScrollTo(p.x,p.y,msg.arg1 == 1);
break;
}
case UPDATE_ZOOM_RANGE:
{
WebViewCore.ViewState viewState=(WebViewCore.ViewState)msg.obj;
mZoomManager.updateZoomRange(viewState,getViewWidth(),viewState.mScrollX);
break;
}
case UPDATE_ZOOM_DENSITY:
{
final float density=(Float)msg.obj;
mZoomManager.updateDefaultZoomDensity(density);
break;
}
case NEW_PICTURE_MSG_ID:
{
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
setNewPicture(draw,true);
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
String drawableDir=BrowserFrame.getRawResFilename(BrowserFrame.DRAWABLEDIR,mContext);
WindowManager windowManager=(WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
Display display=windowManager.getDefaultDisplay();
nativeCreate(msg.arg1,drawableDir,ActivityManager.isHighEndGfx(display));
if (mDelaySetPicture != null) {
setNewPicture(mDelaySetPicture,true);
mDelaySetPicture=null;
}
if (mIsPaused) {
nativeSetPauseDrawing(mNativeClass,true);
}
mInputDispatcher=new WebViewInputDispatcher(this,mWebViewCore.getInputDispatcherCallbacks());
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (msg.arg2 == mTextGeneration) {
String text=(String)msg.obj;
if (null == text) {
text="";
}
if (mInputConnection != null && mFieldPointer == msg.arg1) {
mInputConnection.setTextAndKeepSelection(text);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
updateTextSelectionFromMessage(msg.arg1,msg.arg2,(WebViewCore.TextSelectionData)msg.obj);
break;
case TAKE_FOCUS:
int direction=msg.arg1;
View focusSearch=mWebView.focusSearch(direction);
if (focusSearch != null && focusSearch != mWebView) {
focusSearch.requestFocus();
}
break;
case CLEAR_TEXT_ENTRY:
hideSoftKeyboard();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
if (mFieldPointer == msg.arg1) {
ArrayAdapter<String> adapter=(ArrayAdapter<String>)msg.obj;
mAutoCompletePopup.setAdapter(adapter);
}
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
performLongClick();
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mInputDispatcher.setWebKitWantsTouchEvents(msg.arg1 != 0);
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
mWebViewPrivate.awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case SCREEN_ON:
mWebView.setKeepScreenOn(msg.arg1 == 1);
break;
case ENTER_FULLSCREEN_VIDEO:
int layerId=msg.arg1;
String url=(String)msg.obj;
if (mHTML5VideoViewProxy != null) {
mHTML5VideoViewProxy.enterFullScreenVideo(layerId,url);
}
break;
case EXIT_FULLSCREEN_VIDEO:
if (mHTML5VideoViewProxy != null) {
mHTML5VideoViewProxy.exitFullScreenVideo();
}
break;
case SHOW_FULLSCREEN:
{
View view=(View)msg.obj;
int orientation=msg.arg1;
int npp=msg.arg2;
if (inFullScreenMode()) {
Log.w(LOGTAG,"Should not have another full screen.");
dismissFullScreenMode();
}
mFullScreenHolder=new PluginFullScreenHolder(WebViewClassic.this,orientation,npp);
mFullScreenHolder.setContentView(view);
mFullScreenHolder.show();
invalidate();
break;
}
case HIDE_FULLSCREEN:
dismissFullScreenMode();
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int left=contentToViewX(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
int x=(int)(left + data.mXPercentInDoc * width - data.mXPercentInView * viewWidth);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"showRectMsg=(left=" + left + ",width="+ width+ ",maxWidth="+ maxWidth+ ",viewWidth="+ viewWidth+ ",x="+ x+ ",xPercentInDoc="+ data.mXPercentInDoc+ ",xPercentInView="+ data.mXPercentInView+ ")");
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int top=contentToViewY(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
int y=(int)(top + data.mYPercentInDoc * height - data.mYPercentInView * viewHeight);
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,"showRectMsg=(top=" + top + ",height="+ height+ ",maxHeight="+ maxHeight+ ",viewHeight="+ viewHeight+ ",y="+ y+ ",yPercentInDoc="+ data.mYPercentInDoc+ ",yPercentInView="+ data.mYPercentInView+ ")");
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
y=Math.max(0,y - getVisibleTitleHeightImpl());
mWebView.scrollTo(x,y);
}
break;
case CENTER_FIT_RECT:
centerFitRect((Rect)msg.obj);
break;
case SET_SCROLLBAR_MODES:
mHorizontalScrollBarMode=msg.arg1;
mVerticalScrollBarMode=msg.arg2;
break;
case SELECTION_STRING_CHANGED:
if (isAccessibilityEnabled()) {
getAccessibilityInjector().handleSelectionChangedIfNecessary((String)msg.obj);
}
break;
case FOCUS_NODE_CHANGED:
mIsEditingText=(msg.arg1 == mFieldPointer);
if (mAutoCompletePopup != null && !mIsEditingText) {
mAutoCompletePopup.clearAdapter();
}
case HIT_TEST_RESULT:
WebKitHitTest hit=(WebKitHitTest)msg.obj;
mFocusedNode=hit;
setTouchHighlightRects(hit);
setHitTestResult(hit);
break;
case SAVE_WEBARCHIVE_FINISHED:
SaveWebArchiveMessage saveMessage=(SaveWebArchiveMessage)msg.obj;
if (saveMessage.mCallback != null) {
saveMessage.mCallback.onReceiveValue(saveMessage.mResultFile);
}
break;
case SET_AUTOFILLABLE:
mAutoFillData=(WebViewCore.AutoFillData)msg.obj;
if (mInputConnection != null) {
mInputConnection.setAutoFillable(mAutoFillData.getQueryId());
mAutoCompletePopup.setAutoFillQueryId(mAutoFillData.getQueryId());
}
break;
case AUTOFILL_COMPLETE:
if (mAutoCompletePopup != null) {
ArrayList<String> pastEntries=new ArrayList<String>();
mAutoCompletePopup.setAdapter(new ArrayAdapter<String>(mContext,com.android.internal.R.layout.web_text_view_dropdown,pastEntries));
}
break;
case COPY_TO_CLIPBOARD:
copyToClipboard((String)msg.obj);
break;
case INIT_EDIT_FIELD:
if (mInputConnection != null) {
TextFieldInitData initData=(TextFieldInitData)msg.obj;
mTextGeneration=0;
mFieldPointer=initData.mFieldPointer;
mInputConnection.initEditorInfo(initData);
mInputConnection.setTextAndKeepSelection(initData.mText);
mEditTextContentBounds.set(initData.mContentBounds);
mEditTextLayerId=initData.mNodeLayerId;
nativeMapLayerRect(mNativeClass,mEditTextLayerId,mEditTextContentBounds);
mEditTextContent.set(initData.mContentRect);
relocateAutoCompletePopup();
}
break;
case REPLACE_TEXT:
{
String text=(String)msg.obj;
int start=msg.arg1;
int end=msg.arg2;
int cursorPosition=start + text.length();
replaceTextfieldText(start,end,text,cursorPosition,cursorPosition);
break;
}
case UPDATE_MATCH_COUNT:
{
WebViewCore.FindAllRequest request=(WebViewCore.FindAllRequest)msg.obj;
if (request == null) {
if (mFindCallback != null) {
mFindCallback.updateMatchCount(0,0,true);
}
}
 else if (request == mFindRequest) {
int matchCount, matchIndex;
synchronized (mFindRequest) {
matchCount=request.mMatchCount;
matchIndex=request.mMatchIndex;
}
if (mFindCallback != null) {
mFindCallback.updateMatchCount(matchIndex,matchCount,false);
}
if (mFindListener != null) {
mFindListener.onFindResultReceived(matchIndex,matchCount,true);
}
}
break;
}
case CLEAR_CARET_HANDLE:
selectionDone();
break;
case KEY_PRESS:
sendBatchableInputMessage(EventHub.KEY_PRESS,msg.arg1,0,null);
break;
case RELOCATE_AUTO_COMPLETE_POPUP:
relocateAutoCompletePopup();
break;
case AUTOFILL_FORM:
mWebViewCore.sendMessage(EventHub.AUTOFILL_FORM,msg.arg1,0);
break;
case EDIT_TEXT_SIZE_CHANGED:
if (msg.arg1 == mFieldPointer) {
mEditTextContent.set((Rect)msg.obj);
}
break;
case SHOW_CARET_HANDLE:
if (!mSelectingText && mIsEditingText && mIsCaretSelection) {
setupWebkitSelect();
resetCaretTimer();
showPasteWindow();
}
break;
case UPDATE_CONTENT_BOUNDS:
mEditTextContentBounds.set((Rect)msg.obj);
nativeMapLayerRect(mNativeClass,mEditTextLayerId,mEditTextContentBounds);
break;
case SCROLL_EDIT_TEXT:
scrollEditWithCursor();
break;
default :
super.handleMessage(msg);
break;
}
}
