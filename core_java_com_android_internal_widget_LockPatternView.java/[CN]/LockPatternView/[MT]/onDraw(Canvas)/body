{
  final ArrayList<Cell> pattern=mPattern;
  final int count=pattern.size();
  final boolean[][] drawLookup=mPatternDrawLookup;
  if (mPatternDisplayMode == DisplayMode.Animate) {
    final int oneCycle=(count + 1) * MILLIS_PER_CIRCLE_ANIMATING;
    final int spotInCycle=(int)(SystemClock.elapsedRealtime() - mAnimatingPeriodStart) % oneCycle;
    final int numCircles=spotInCycle / MILLIS_PER_CIRCLE_ANIMATING;
    clearPatternDrawLookup();
    for (int i=0; i < numCircles; i++) {
      final Cell cell=pattern.get(i);
      drawLookup[cell.getRow()][cell.getColumn()]=true;
    }
    final boolean needToUpdateInProgressPoint=numCircles > 0 && numCircles < count;
    if (needToUpdateInProgressPoint) {
      final float percentageOfNextCircle=((float)(spotInCycle % MILLIS_PER_CIRCLE_ANIMATING)) / MILLIS_PER_CIRCLE_ANIMATING;
      final Cell currentCell=pattern.get(numCircles - 1);
      final float centerX=getCenterXForColumn(currentCell.column);
      final float centerY=getCenterYForRow(currentCell.row);
      final Cell nextCell=pattern.get(numCircles);
      final float dx=percentageOfNextCircle * (getCenterXForColumn(nextCell.column) - centerX);
      final float dy=percentageOfNextCircle * (getCenterYForRow(nextCell.row) - centerY);
      mInProgressX=centerX + dx;
      mInProgressY=centerY + dy;
    }
    invalidate();
  }
  final float squareWidth=mSquareWidth;
  final float squareHeight=mSquareHeight;
  float radius=(squareWidth * mDiameterFactor * 0.5f);
  mPathPaint.setStrokeWidth(radius);
  final Path currentPath=mCurrentPath;
  currentPath.rewind();
  final int paddingTop=mPaddingTop;
  final int paddingLeft=mPaddingLeft;
  for (int i=0; i < 3; i++) {
    float topY=paddingTop + i * squareHeight;
    for (int j=0; j < 3; j++) {
      float leftX=paddingLeft + j * squareWidth;
      float scale=mCellStates[i][j].scale;
      mPaint.setAlpha((int)(mCellStates[i][j].alpha * 255));
      float translationY=mCellStates[i][j].translateY;
      drawCircle(canvas,(int)leftX,(int)topY + translationY,scale,drawLookup[i][j]);
    }
  }
  mPaint.setAlpha(255);
  final boolean drawPath=!mInStealthMode;
  if (drawPath) {
    for (int i=0; i < count - 1; i++) {
      Cell cell=pattern.get(i);
      Cell next=pattern.get(i + 1);
      if (!drawLookup[next.row][next.column]) {
        break;
      }
      float leftX=paddingLeft + cell.column * squareWidth;
      float topY=paddingTop + cell.row * squareHeight + mCellStates[cell.row][cell.column].translateY;
      drawArrow(canvas,leftX,topY,cell,next);
    }
  }
  if (drawPath) {
    boolean anyCircles=false;
    for (int i=0; i < count; i++) {
      Cell cell=pattern.get(i);
      if (!drawLookup[cell.row][cell.column]) {
        break;
      }
      anyCircles=true;
      float centerX=getCenterXForColumn(cell.column);
      float centerY=getCenterYForRow(cell.row);
      centerY+=mCellStates[cell.row][cell.column].translateY;
      if (i == 0) {
        currentPath.moveTo(centerX,centerY);
      }
 else {
        currentPath.lineTo(centerX,centerY);
      }
    }
    if ((mPatternInProgress || mPatternDisplayMode == DisplayMode.Animate) && anyCircles) {
      currentPath.lineTo(mInProgressX,mInProgressY);
    }
    canvas.drawPath(currentPath,mPathPaint);
  }
}
