{
  Bitmap outerCircle;
  Bitmap innerCircle;
  ColorFilter outerFilter;
  if (!partOfPattern || mInStealthMode) {
    outerCircle=mBitmapCircleDefault;
    innerCircle=mBitmapBtnDefault;
    outerFilter=mRegularColorFilter;
  }
 else   if (mPatternInProgress) {
    outerCircle=mBitmapCircleAlpha;
    innerCircle=mBitmapBtnTouched;
    outerFilter=mRegularColorFilter;
  }
 else   if (mPatternDisplayMode == DisplayMode.Wrong) {
    outerCircle=mBitmapCircleAlpha;
    innerCircle=mBitmapBtnDefault;
    outerFilter=mErrorColorFilter;
  }
 else   if (mPatternDisplayMode == DisplayMode.Correct || mPatternDisplayMode == DisplayMode.Animate) {
    outerCircle=mBitmapCircleAlpha;
    innerCircle=mBitmapBtnDefault;
    outerFilter=mSuccessColorFilter;
  }
 else {
    throw new IllegalStateException("unknown display mode " + mPatternDisplayMode);
  }
  final int width=mBitmapWidth;
  final int height=mBitmapHeight;
  final float squareWidth=mSquareWidth;
  final float squareHeight=mSquareHeight;
  int offsetX=(int)((squareWidth - width) / 2f);
  int offsetY=(int)((squareHeight - height) / 2f);
  float sx=Math.min(mSquareWidth / mBitmapWidth,1.0f);
  float sy=Math.min(mSquareHeight / mBitmapHeight,1.0f);
  mCircleMatrix.setTranslate(leftX + offsetX,topY + offsetY);
  mCircleMatrix.preTranslate(mBitmapWidth / 2,mBitmapHeight / 2);
  mCircleMatrix.preScale(sx * scale,sy * scale);
  mCircleMatrix.preTranslate(-mBitmapWidth / 2,-mBitmapHeight / 2);
  mPaint.setColorFilter(outerFilter);
  canvas.drawBitmap(outerCircle,mCircleMatrix,mPaint);
  mPaint.setColorFilter(mRegularColorFilter);
  canvas.drawBitmap(innerCircle,mCircleMatrix,mPaint);
}
