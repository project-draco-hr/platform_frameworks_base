{
  copyBounds(mTmpBounds);
  if (mTmpBounds.width() <= 0 || mTmpBounds.height() <= 0) {
    return;
  }
  final ColorFilter colorFilter=(mColorFilter == null ? mTintFilter : mColorFilter);
  canvas.getMatrix(mTmpMatrix);
  mTmpMatrix.getValues(mTmpFloats);
  float canvasScaleX=Math.abs(mTmpFloats[Matrix.MSCALE_X]);
  float canvasScaleY=Math.abs(mTmpFloats[Matrix.MSCALE_Y]);
  int scaledWidth=(int)(mTmpBounds.width() * canvasScaleX);
  int scaledHeight=(int)(mTmpBounds.height() * canvasScaleY);
  scaledWidth=Math.min(MAX_CACHED_BITMAP_SIZE,scaledWidth);
  scaledHeight=Math.min(MAX_CACHED_BITMAP_SIZE,scaledHeight);
  if (scaledWidth <= 0 || scaledHeight <= 0) {
    return;
  }
  final int saveCount=canvas.save();
  canvas.translate(mTmpBounds.left,mTmpBounds.top);
  final boolean needMirroring=needMirroring();
  if (needMirroring) {
    canvas.translate(mTmpBounds.width(),0);
    canvas.scale(-1.0f,1.0f);
  }
  mTmpBounds.offsetTo(0,0);
  mVectorState.createCachedBitmapIfNeeded(scaledWidth,scaledHeight);
  if (!mAllowCaching) {
    mVectorState.updateCachedBitmap(scaledWidth,scaledHeight);
  }
 else {
    if (!mVectorState.canReuseCache()) {
      mVectorState.updateCachedBitmap(scaledWidth,scaledHeight);
      mVectorState.updateCacheStates();
    }
  }
  mVectorState.drawCachedBitmapWithRootAlpha(canvas,colorFilter,mTmpBounds);
  canvas.restoreToCount(saveCount);
}
