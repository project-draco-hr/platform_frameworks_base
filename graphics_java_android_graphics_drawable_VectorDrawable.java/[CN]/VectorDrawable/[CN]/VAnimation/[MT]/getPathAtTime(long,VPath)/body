{
  if (mPaths.length == 1) {
    dest.copyFrom(mPaths[0]);
    return dest;
  }
  long point=milliseconds - mStartOffset;
  if (point < 0) {
    point=0;
  }
  float time=0;
  long sum=mDuration[0];
  for (int i=1; i < mDuration.length; i++) {
    sum+=mDuration[i];
  }
  if (mRepeat > 1) {
    time=point / (float)(sum * mRepeat);
    time=mAnimInterpolator.getInterpolation(time);
    if (mMode == DIRECTION_IN_AND_OUT) {
      point=((long)(time * sum * 2* mRepeat)) % (sum * 2);
      if (point > sum) {
        point=sum * 2 - point;
      }
    }
 else {
      point=((long)(time * sum * mRepeat)) % sum;
    }
  }
 else   if (mRepeat == 1) {
    time=point / (float)(sum * mRepeat);
    time=mAnimInterpolator.getInterpolation(time);
    if (mMode == DIRECTION_IN_AND_OUT) {
      point=((long)(time * sum * 2* mRepeat));
      if (point > sum) {
        point=sum * 2 - point;
      }
    }
 else {
      point=Math.min(((long)(time * sum * mRepeat)),sum);
    }
  }
 else {
    if (mMode == DIRECTION_IN_AND_OUT) {
      point=point % (sum * 2);
      if (point > sum) {
        point=sum * 2 - point;
      }
      time=point / (float)sum;
    }
 else {
      point=point % sum;
      time=point / (float)sum;
    }
  }
  int transition=0;
  while (point > mDuration[transition]) {
    point-=mDuration[transition++];
  }
  if (mPaths.length > (transition + 1)) {
    if (mPaths[transition].getID() != dest.getID()) {
      dest.copyFrom(mPaths[transition]);
    }
    interpolate(mPaths[transition],mPaths[transition + 1],point / (float)mDuration[transition],dest);
  }
 else {
    interpolate(mPaths[transition],mPaths[transition],0,dest);
  }
  return dest;
}
