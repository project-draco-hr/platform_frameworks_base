{
  float scale=w / mViewportWidth;
  scale=Math.min(h / mViewportHeight,scale);
  vPath.toPath(mPath);
  Path path=mPath;
  if (vPath.mTrimPathStart != 0.0f || vPath.mTrimPathEnd != 1.0f) {
    float start=(vPath.mTrimPathStart + vPath.mTrimPathOffset) % 1.0f;
    float end=(vPath.mTrimPathEnd + vPath.mTrimPathOffset) % 1.0f;
    if (mPathMeasure == null) {
      mPathMeasure=new PathMeasure();
    }
    mPathMeasure.setPath(mPath,false);
    float len=mPathMeasure.getLength();
    start=start * len;
    end=end * len;
    path.reset();
    if (start > end) {
      mPathMeasure.getSegment(start,len,path,true);
      mPathMeasure.getSegment(0f,end,path,true);
    }
 else {
      mPathMeasure.getSegment(start,end,path,true);
    }
    path.rLineTo(0,0);
  }
  mRenderPath.reset();
  mMatrix.reset();
  mMatrix.postRotate(vPath.mRotate,vPath.mPivotX,vPath.mPivotY);
  mMatrix.postScale(scale,scale,mViewportWidth / 2f,mViewportHeight / 2f);
  mMatrix.postTranslate(w / 2f - mViewportWidth / 2f,h / 2f - mViewportHeight / 2f);
  mRenderPath.addPath(path,mMatrix);
  if (vPath.mClip) {
    canvas.clipPath(mRenderPath,Region.Op.REPLACE);
  }
  if (vPath.mFillColor != 0) {
    mFillPaint.setColor(vPath.mFillColor);
    int alpha=0xFF & (vPath.mFillColor >> 24);
    mFillPaint.setAlpha(alpha);
    canvas.drawPath(mRenderPath,mFillPaint);
  }
  if (vPath.mStrokeColor != 0) {
    if (vPath.mStrokelineJoin != null) {
      mStrokePaint.setStrokeJoin(vPath.mStrokelineJoin);
    }
    if (vPath.mStrokelineCap != null) {
      mStrokePaint.setStrokeCap(vPath.mStrokelineCap);
    }
    mStrokePaint.setStrokeMiter(vPath.mStrokeMiterlimit * scale);
    mStrokePaint.setColor(vPath.mStrokeColor);
    mStrokePaint.setAlpha(0xFF & (vPath.mStrokeColor >> 24));
    mStrokePaint.setStrokeWidth(vPath.mStrokeWidth * scale);
    canvas.drawPath(mRenderPath,mStrokePaint);
  }
}
