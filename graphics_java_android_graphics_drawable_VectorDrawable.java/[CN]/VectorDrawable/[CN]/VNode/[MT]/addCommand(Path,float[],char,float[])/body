{
  int incr=2;
  float currentX=current[0];
  float currentY=current[1];
  float ctrlPointX=current[2];
  float ctrlPointY=current[3];
switch (cmd) {
case 'z':
case 'Z':
    path.close();
  return;
case 'm':
case 'M':
case 'l':
case 'L':
case 't':
case 'T':
incr=2;
break;
case 'h':
case 'H':
case 'v':
case 'V':
incr=1;
break;
case 'c':
case 'C':
incr=6;
break;
case 's':
case 'S':
case 'q':
case 'Q':
incr=4;
break;
case 'a':
case 'A':
incr=7;
break;
}
for (int k=0; k < val.length; k+=incr) {
switch (cmd) {
case 'm':
path.rMoveTo(val[k + 0],val[k + 1]);
currentX+=val[k + 0];
currentY+=val[k + 1];
break;
case 'M':
path.moveTo(val[k + 0],val[k + 1]);
currentX=val[k + 0];
currentY=val[k + 1];
break;
case 'l':
path.rLineTo(val[k + 0],val[k + 1]);
currentX+=val[k + 0];
currentY+=val[k + 1];
break;
case 'L':
path.lineTo(val[k + 0],val[k + 1]);
currentX=val[k + 0];
currentY=val[k + 1];
break;
case 'z':
case 'Z':
path.close();
break;
case 'h':
path.rLineTo(val[k + 0],0);
currentX+=val[k + 0];
break;
case 'H':
path.lineTo(val[k + 0],currentY);
currentX=val[k + 0];
break;
case 'v':
path.rLineTo(0,val[k + 0]);
currentY+=val[k + 0];
break;
case 'V':
path.lineTo(currentX,val[k + 0]);
currentY=val[k + 0];
break;
case 'c':
path.rCubicTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3],val[k + 4],val[k + 5]);
ctrlPointX=currentX + val[k + 2];
ctrlPointY=currentY + val[k + 3];
currentX+=val[k + 4];
currentY+=val[k + 5];
break;
case 'C':
path.cubicTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3],val[k + 4],val[k + 5]);
currentX=val[k + 4];
currentY=val[k + 5];
ctrlPointX=val[k + 2];
ctrlPointY=val[k + 3];
break;
case 's':
path.rCubicTo(currentX - ctrlPointX,currentY - ctrlPointY,val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
ctrlPointX=currentX + val[k + 0];
ctrlPointY=currentY + val[k + 1];
currentX+=val[k + 2];
currentY+=val[k + 3];
break;
case 'S':
path.cubicTo(2 * currentX - ctrlPointX,2 * currentY - ctrlPointY,val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
currentX=val[k + 2];
currentY=val[k + 3];
ctrlPointX=val[k + 0];
ctrlPointY=val[k + 1];
break;
case 'q':
path.rQuadTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
currentX+=val[k + 2];
currentY+=val[k + 3];
ctrlPointX=val[k + 0];
ctrlPointY=val[k + 1];
break;
case 'Q':
path.quadTo(val[k + 0],val[k + 1],val[k + 2],val[k + 3]);
currentX=val[k + 2];
currentY=val[k + 3];
ctrlPointX=val[k + 0];
ctrlPointY=val[k + 1];
break;
case 't':
path.rQuadTo(currentX - ctrlPointX,currentY - ctrlPointY,val[k + 0],val[k + 1]);
ctrlPointX=ctrlPointX + currentX;
ctrlPointY=ctrlPointY + currentY;
currentX+=val[k + 0];
currentY+=val[k + 1];
break;
case 'T':
path.quadTo(currentX * 2 - ctrlPointX,currentY * 2 - ctrlPointY,val[k + 0],val[k + 1]);
currentX=val[k + 0];
currentY=val[k + 1];
ctrlPointX=-(val[k + 0] - currentX);
ctrlPointY=-(val[k + 1] - currentY);
break;
case 'a':
drawArc(path,currentX,currentY,val[k + 5] + currentX,val[k + 6] + currentY,val[k + 0],val[k + 1],val[k + 2],val[k + 3] != 0,val[k + 4] != 0);
currentX+=val[k + 5];
currentY+=val[k + 6];
ctrlPointX=currentX;
ctrlPointY=currentY;
break;
case 'A':
drawArc(path,currentX,currentY,val[k + 5],val[k + 6],val[k + 0],val[k + 1],val[k + 2],val[k + 3] != 0,val[k + 4] != 0);
currentX=val[k + 5];
currentY=val[k + 6];
ctrlPointX=currentX;
ctrlPointY=currentY;
break;
}
}
current[0]=currentX;
current[1]=currentY;
current[2]=ctrlPointX;
current[3]=ctrlPointY;
}
