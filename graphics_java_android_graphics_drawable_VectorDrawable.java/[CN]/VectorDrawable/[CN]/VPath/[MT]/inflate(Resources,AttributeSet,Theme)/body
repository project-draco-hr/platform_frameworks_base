{
  final TypedArray a=obtainAttributes(r,theme,attrs,R.styleable.VectorDrawablePath);
  final int[] themeAttrs=a.extractThemeAttrs();
  mThemeAttrs=themeAttrs;
  mClip=a.getBoolean(R.styleable.VectorDrawablePath_clipToPath,false);
  mId=a.getString(R.styleable.VectorDrawablePath_name);
  mNode=parsePath(a.getString(R.styleable.VectorDrawablePath_pathData));
  if (themeAttrs == null || themeAttrs[R.styleable.VectorDrawablePath_fill] == 0) {
    mFillColor=a.getColor(R.styleable.VectorDrawablePath_fill,0);
  }
  if (themeAttrs == null || themeAttrs[R.styleable.VectorDrawablePath_fillOpacity] == 0) {
    mFillOpacity=a.getFloat(R.styleable.VectorDrawablePath_fillOpacity,Float.NaN);
  }
  mRotate=a.getFloat(R.styleable.VectorDrawablePath_rotation,0);
  mPivotX=a.getFloat(R.styleable.VectorDrawablePath_pivotX,0);
  mPivotY=a.getFloat(R.styleable.VectorDrawablePath_pivotY,0);
  final int lineCap=a.getInt(R.styleable.VectorDrawablePath_strokeLineCap,0);
switch (lineCap) {
case LINECAP_BUTT:
    mStrokelineCap=Paint.Cap.BUTT;
  break;
case LINECAP_ROUND:
mStrokelineCap=Paint.Cap.ROUND;
break;
case LINECAP_SQUARE:
mStrokelineCap=Paint.Cap.SQUARE;
break;
}
final int lineJoin=a.getInt(R.styleable.VectorDrawablePath_strokeLineJoin,0);
switch (lineJoin) {
case LINEJOIN_MITER:
mStrokelineJoin=Paint.Join.MITER;
break;
case LINEJOIN_ROUND:
mStrokelineJoin=Paint.Join.ROUND;
break;
case LINEJOIN_BEVEL:
mStrokelineJoin=Paint.Join.BEVEL;
break;
}
mStrokeMiterlimit=a.getFloat(R.styleable.VectorDrawablePath_strokeMiterLimit,mStrokeMiterlimit);
if (themeAttrs == null || themeAttrs[R.styleable.VectorDrawablePath_stroke] == 0) {
mStrokeColor=a.getColor(R.styleable.VectorDrawablePath_stroke,mStrokeColor);
}
if (themeAttrs == null || themeAttrs[R.styleable.VectorDrawablePath_strokeOpacity] == 0) {
mStrokeOpacity=a.getFloat(R.styleable.VectorDrawablePath_strokeOpacity,Float.NaN);
}
mStrokeWidth=a.getFloat(R.styleable.VectorDrawablePath_strokeWidth,0);
mTrimPathEnd=a.getFloat(R.styleable.VectorDrawablePath_trimPathEnd,1);
mTrimPathOffset=a.getFloat(R.styleable.VectorDrawablePath_trimPathOffset,0);
mTrimPathStart=a.getFloat(R.styleable.VectorDrawablePath_trimPathStart,0);
final int[] states={R.styleable.VectorDrawablePath_state_activated,R.styleable.VectorDrawablePath_state_checkable,R.styleable.VectorDrawablePath_state_checked,R.styleable.VectorDrawablePath_state_enabled,R.styleable.VectorDrawablePath_state_focused,R.styleable.VectorDrawablePath_state_hovered,R.styleable.VectorDrawablePath_state_pressed,R.styleable.VectorDrawablePath_state_selected,R.styleable.VectorDrawablePath_state_window_focused};
final int N=states.length;
for (int i=0; i < N; i++) {
final int state=states[i];
if (a.hasValue(state)) {
addStateFilter(state,a.getBoolean(state,false));
}
}
updateColorAlphas();
a.recycle();
}
