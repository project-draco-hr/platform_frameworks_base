{
  if (limit == LIMIT_ALL || limit == LIMIT_PATH) {
    if (returnPath.mNode == null || returnPath.mNode.length != p1.mNode.length) {
      returnPath.mNode=new VNode[p1.mNode.length];
    }
    for (int i=0; i < returnPath.mNode.length; i++) {
      if (returnPath.mNode[i] == null) {
        returnPath.mNode[i]=new VNode(p1.mNode[i],p2.mNode[i],t);
      }
 else {
        returnPath.mNode[i].interpolate(p1.mNode[i],p2.mNode[i],t);
      }
    }
  }
  float t1=1 - t;
switch (limit) {
case LIMIT_ALL:
    returnPath.mRotate=t1 * p1.mRotate + t * p2.mRotate;
  returnPath.mPivotX=t1 * p1.mPivotX + t * p2.mPivotX;
returnPath.mPivotY=t1 * p1.mPivotY + t * p2.mPivotY;
returnPath.mClip=p1.mClip | p2.mClip;
returnPath.mTrimPathStart=t1 * p1.mTrimPathStart + t * p2.mTrimPathStart;
returnPath.mTrimPathEnd=t1 * p1.mTrimPathEnd + t * p2.mTrimPathEnd;
returnPath.mTrimPathOffset=t1 * p1.mTrimPathOffset + t * p2.mTrimPathOffset;
returnPath.mStrokeMiterlimit=t1 * p1.mStrokeMiterlimit + t * p2.mStrokeMiterlimit;
returnPath.mStrokeLineCap=p1.mStrokeLineCap;
if (returnPath.mStrokeLineCap == null) {
returnPath.mStrokeLineCap=p2.mStrokeLineCap;
}
returnPath.mStrokeLineJoin=p1.mStrokeLineJoin;
if (returnPath.mStrokeLineJoin == null) {
returnPath.mStrokeLineJoin=p2.mStrokeLineJoin;
}
returnPath.mFillRule=p1.mFillRule;
returnPath.mStrokeColor=rgbInterpolate(t,p1.mStrokeColor,p2.mStrokeColor);
returnPath.mFillColor=rgbInterpolate(t,p1.mFillColor,p2.mFillColor);
returnPath.mStrokeWidth=t1 * p1.mStrokeWidth + t * p2.mStrokeWidth;
returnPath.mNumberOfStates=p1.mNumberOfStates;
for (int i=0; i < returnPath.mNumberOfStates; i++) {
returnPath.mCheckState[i]=p1.mCheckState[i];
returnPath.mCheckValue[i]=p1.mCheckValue[i];
}
for (int i=0; i < p2.mNumberOfStates; i++) {
returnPath.addStateFilter(p2.mCheckState[i],p2.mCheckValue[i]);
}
int count=0;
for (int i=0; i < returnPath.mNumberOfStates; i++) {
if (returnPath.mCheckValue[i]) {
count++;
}
}
returnPath.mNumberOfTrue=count;
break;
case LIMIT_ROTATE:
returnPath.mRotate=t1 * p1.mRotate + t * p2.mRotate;
break;
case LIMIT_TRIM_PATH_END:
returnPath.mTrimPathEnd=t1 * p1.mTrimPathEnd + t * p2.mTrimPathEnd;
break;
case LIMIT_TRIM_PATH_OFFSET:
returnPath.mTrimPathOffset=t1 * p1.mTrimPathOffset + t * p2.mTrimPathOffset;
break;
case LIMIT_TRIM_PATH_START:
returnPath.mTrimPathStart=t1 * p1.mTrimPathStart + t * p2.mTrimPathStart;
break;
}
return returnPath;
}
