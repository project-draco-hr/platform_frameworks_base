{
  resetAll();
  boolean success=false;
  try {
    if ((params == null) || (!(params instanceof KeyGenParameterSpec))) {
      throw new InvalidAlgorithmParameterException("Cannot initialize without a " + KeyGenParameterSpec.class.getName() + " parameter");
    }
    KeyGenParameterSpec spec=(KeyGenParameterSpec)params;
    if (spec.getKeystoreAlias() == null) {
      throw new InvalidAlgorithmParameterException("KeyStore entry alias not provided");
    }
    mRng=random;
    mSpec=spec;
    mKeySizeBits=(spec.getKeySize() != -1) ? spec.getKeySize() : mDefaultKeySizeBits;
    if (mKeySizeBits <= 0) {
      throw new InvalidAlgorithmParameterException("Key size must be positive: " + mKeySizeBits);
    }
 else     if ((mKeySizeBits % 8) != 0) {
      throw new InvalidAlgorithmParameterException("Key size in must be a multiple of 8: " + mKeySizeBits);
    }
    try {
      mKeymasterPurposes=KeyProperties.Purpose.allToKeymaster(spec.getPurposes());
      mKeymasterPaddings=KeyProperties.EncryptionPadding.allToKeymaster(spec.getEncryptionPaddings());
      if (spec.getSignaturePaddings().length > 0) {
        throw new InvalidAlgorithmParameterException("Signature paddings not supported for symmetric key algorithms");
      }
      mKeymasterBlockModes=KeyProperties.BlockMode.allToKeymaster(spec.getBlockModes());
      if (((spec.getPurposes() & KeyProperties.PURPOSE_ENCRYPT) != 0) && (spec.isRandomizedEncryptionRequired())) {
        for (        int keymasterBlockMode : mKeymasterBlockModes) {
          if (!KeymasterUtils.isKeymasterBlockModeIndCpaCompatibleWithSymmetricCrypto(keymasterBlockMode)) {
            throw new InvalidAlgorithmParameterException("Randomized encryption (IND-CPA) required but may be violated" + " by block mode: " + KeyProperties.BlockMode.fromKeymaster(keymasterBlockMode) + ". See "+ KeyGenParameterSpec.class.getName()+ " documentation.");
          }
        }
      }
      if (mKeymasterAlgorithm == KeymasterDefs.KM_ALGORITHM_HMAC) {
        mKeymasterDigests=new int[]{mKeymasterDigest};
        if (spec.isDigestsSpecified()) {
          int[] keymasterDigestsFromSpec=KeyProperties.Digest.allToKeymaster(spec.getDigests());
          if ((keymasterDigestsFromSpec.length != 1) || (keymasterDigestsFromSpec[0] != mKeymasterDigest)) {
            throw new InvalidAlgorithmParameterException("Unsupported digests specification: " + Arrays.asList(spec.getDigests()) + ". Only "+ KeyProperties.Digest.fromKeymaster(mKeymasterDigest)+ " supported for this HMAC key algorithm");
          }
        }
      }
 else {
        if (spec.isDigestsSpecified()) {
          mKeymasterDigests=KeyProperties.Digest.allToKeymaster(spec.getDigests());
        }
 else {
          mKeymasterDigests=EmptyArray.INT;
        }
      }
      KeymasterUtils.addUserAuthArgs(new KeymasterArguments(),spec.isUserAuthenticationRequired(),spec.getUserAuthenticationValidityDurationSeconds());
    }
 catch (    IllegalStateException|IllegalArgumentException e) {
      throw new InvalidAlgorithmParameterException(e);
    }
    success=true;
  }
  finally {
    if (!success) {
      resetAll();
    }
  }
}
