{
  resetAll();
  boolean success=false;
  try {
    if ((params == null) || (!(params instanceof KeyGenParameterSpec))) {
      throw new InvalidAlgorithmParameterException("Cannot initialize without a " + KeyGenParameterSpec.class.getName() + " parameter");
    }
    KeyGenParameterSpec spec=(KeyGenParameterSpec)params;
    if (spec.getKeystoreAlias() == null) {
      throw new InvalidAlgorithmParameterException("KeyStore entry alias not provided");
    }
    mRng=random;
    mSpec=spec;
    mKeySizeBits=(spec.getKeySize() != -1) ? spec.getKeySize() : mDefaultKeySizeBits;
    if (mKeySizeBits <= 0) {
      throw new InvalidAlgorithmParameterException("Key size must be positive: " + mKeySizeBits);
    }
 else     if ((mKeySizeBits % 8) != 0) {
      throw new InvalidAlgorithmParameterException("Key size in must be a multiple of 8: " + mKeySizeBits);
    }
    try {
      mKeymasterPurposes=KeyProperties.Purpose.allToKeymaster(spec.getPurposes());
      mKeymasterPaddings=KeyProperties.EncryptionPadding.allToKeymaster(spec.getEncryptionPaddings());
      if (spec.getSignaturePaddings().length > 0) {
        throw new InvalidAlgorithmParameterException("Signature paddings not supported for symmetric key algorithms");
      }
      mKeymasterBlockModes=KeyProperties.BlockMode.allToKeymaster(spec.getBlockModes());
      if (((spec.getPurposes() & KeyProperties.PURPOSE_ENCRYPT) != 0) && (spec.isRandomizedEncryptionRequired())) {
        for (        int keymasterBlockMode : mKeymasterBlockModes) {
          if (!KeymasterUtils.isKeymasterBlockModeIndCpaCompatibleWithSymmetricCrypto(keymasterBlockMode)) {
            throw new InvalidAlgorithmParameterException("Randomized encryption (IND-CPA) required but may be violated" + " by block mode: " + KeyProperties.BlockMode.fromKeymaster(keymasterBlockMode) + ". See "+ KeyGenParameterSpec.class.getName()+ " documentation.");
          }
        }
      }
      if (spec.isDigestsSpecified()) {
        mKeymasterDigests=KeyProperties.Digest.allToKeymaster(spec.getDigests());
        if (mKeymasterDigest != -1) {
          if (!com.android.internal.util.ArrayUtils.contains(mKeymasterDigests,mKeymasterDigest)) {
            throw new InvalidAlgorithmParameterException("Digests specified in algorithm parameters (" + Arrays.asList(spec.getDigests()) + ") must include "+ " the digest "+ KeyProperties.Digest.fromKeymaster(mKeymasterDigest)+ " implied by key algorithm");
          }
          if (mKeymasterDigests[0] != mKeymasterDigest) {
            for (int i=0; i < mKeymasterDigests.length; i++) {
              if (mKeymasterDigests[i] == mKeymasterDigest) {
                mKeymasterDigests[i]=mKeymasterDigests[0];
                mKeymasterDigests[0]=mKeymasterDigest;
                break;
              }
            }
          }
        }
      }
 else {
        if (mKeymasterDigest != -1) {
          mKeymasterDigests=new int[]{mKeymasterDigest};
        }
 else {
          mKeymasterDigests=EmptyArray.INT;
        }
      }
      if (mKeymasterAlgorithm == KeymasterDefs.KM_ALGORITHM_HMAC) {
        if (mKeymasterDigests.length == 0) {
          throw new InvalidAlgorithmParameterException("At least one digest algorithm must be specified");
        }
      }
      KeymasterUtils.addUserAuthArgs(new KeymasterArguments(),spec.isUserAuthenticationRequired(),spec.getUserAuthenticationValidityDurationSeconds());
    }
 catch (    IllegalStateException|IllegalArgumentException e) {
      throw new InvalidAlgorithmParameterException(e);
    }
    success=true;
  }
  finally {
    if (!success) {
      resetAll();
    }
  }
}
