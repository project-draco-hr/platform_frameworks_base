{
  KeyGenParameterSpec spec=mSpec;
  if (spec == null) {
    throw new IllegalStateException("Not initialized");
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE,mKeySizeBits);
  args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM,mKeymasterAlgorithm);
  args.addEnums(KeymasterDefs.KM_TAG_PURPOSE,mKeymasterPurposes);
  args.addEnums(KeymasterDefs.KM_TAG_BLOCK_MODE,mKeymasterBlockModes);
  args.addEnums(KeymasterDefs.KM_TAG_PADDING,mKeymasterPaddings);
  args.addEnums(KeymasterDefs.KM_TAG_DIGEST,mKeymasterDigests);
  KeymasterUtils.addUserAuthArgs(args,spec.isUserAuthenticationRequired(),spec.getUserAuthenticationValidityDurationSeconds());
  KeymasterUtils.addMinMacLengthAuthorizationIfNecessary(args,mKeymasterAlgorithm,mKeymasterBlockModes,mKeymasterDigests);
  args.addDateIfNotNull(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,spec.getKeyValidityStart());
  args.addDateIfNotNull(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,spec.getKeyValidityForOriginationEnd());
  args.addDateIfNotNull(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,spec.getKeyValidityForConsumptionEnd());
  if (((spec.getPurposes() & KeyProperties.PURPOSE_ENCRYPT) != 0) && (!spec.isRandomizedEncryptionRequired())) {
    args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
  }
  byte[] additionalEntropy=KeyStoreCryptoOperationUtils.getRandomBytesToMixIntoKeystoreRng(mRng,(mKeySizeBits + 7) / 8);
  int flags=0;
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + spec.getKeystoreAlias();
  KeyCharacteristics resultingKeyCharacteristics=new KeyCharacteristics();
  boolean success=false;
  try {
    Credentials.deleteAllTypesForAlias(mKeyStore,spec.getKeystoreAlias());
    int errorCode=mKeyStore.generateKey(keyAliasInKeystore,args,additionalEntropy,flags,resultingKeyCharacteristics);
    if (errorCode != KeyStore.NO_ERROR) {
      throw new ProviderException("Keystore operation failed",KeyStore.getKeyStoreException(errorCode));
    }
    @KeyProperties.KeyAlgorithmEnum String keyAlgorithmJCA;
    try {
      keyAlgorithmJCA=KeyProperties.KeyAlgorithm.fromKeymasterSecretKeyAlgorithm(mKeymasterAlgorithm,mKeymasterDigest);
    }
 catch (    IllegalArgumentException e) {
      throw new ProviderException("Failed to obtain JCA secret key algorithm name",e);
    }
    SecretKey result=new AndroidKeyStoreSecretKey(keyAliasInKeystore,keyAlgorithmJCA);
    success=true;
    return result;
  }
  finally {
    if (!success) {
      Credentials.deleteAllTypesForAlias(mKeyStore,spec.getKeystoreAlias());
    }
  }
}
