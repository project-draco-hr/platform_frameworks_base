{
  KeyGenParameterSpec spec=mSpec;
  if (spec == null) {
    throw new IllegalStateException("Not initialized");
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addInt(KeymasterDefs.KM_TAG_KEY_SIZE,mKeySizeBits);
  args.addInt(KeymasterDefs.KM_TAG_ALGORITHM,mKeymasterAlgorithm);
  args.addInts(KeymasterDefs.KM_TAG_PURPOSE,mKeymasterPurposes);
  args.addInts(KeymasterDefs.KM_TAG_BLOCK_MODE,mKeymasterBlockModes);
  args.addInts(KeymasterDefs.KM_TAG_PADDING,mKeymasterPaddings);
  args.addInts(KeymasterDefs.KM_TAG_DIGEST,mKeymasterDigests);
  KeymasterUtils.addUserAuthArgs(args,spec.isUserAuthenticationRequired(),spec.getUserAuthenticationValidityDurationSeconds());
  args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,(spec.getKeyValidityStart() != null) ? spec.getKeyValidityStart() : new Date(0));
  args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,(spec.getKeyValidityForOriginationEnd() != null) ? spec.getKeyValidityForOriginationEnd() : new Date(Long.MAX_VALUE));
  args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,(spec.getKeyValidityForConsumptionEnd() != null) ? spec.getKeyValidityForConsumptionEnd() : new Date(Long.MAX_VALUE));
  if (((spec.getPurposes() & KeyProperties.PURPOSE_ENCRYPT) != 0) && (!spec.isRandomizedEncryptionRequired())) {
    args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
  }
  byte[] additionalEntropy=KeyStoreCryptoOperationUtils.getRandomBytesToMixIntoKeystoreRng(mRng,(mKeySizeBits + 7) / 8);
  int flags=0;
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + spec.getKeystoreAlias();
  KeyCharacteristics resultingKeyCharacteristics=new KeyCharacteristics();
  boolean success=false;
  try {
    Credentials.deleteAllTypesForAlias(mKeyStore,spec.getKeystoreAlias());
    int errorCode=mKeyStore.generateKey(keyAliasInKeystore,args,additionalEntropy,flags,resultingKeyCharacteristics);
    if (errorCode != KeyStore.NO_ERROR) {
      throw new ProviderException("Keystore operation failed",KeyStore.getKeyStoreException(errorCode));
    }
    @KeyProperties.KeyAlgorithmEnum String keyAlgorithmJCA;
    try {
      keyAlgorithmJCA=KeyProperties.KeyAlgorithm.fromKeymasterSecretKeyAlgorithm(mKeymasterAlgorithm,mKeymasterDigest);
    }
 catch (    IllegalArgumentException e) {
      throw new ProviderException("Failed to obtain JCA secret key algorithm name",e);
    }
    SecretKey result=new AndroidKeyStoreSecretKey(keyAliasInKeystore,keyAlgorithmJCA);
    success=true;
    return result;
  }
  finally {
    if (!success) {
      Credentials.deleteAllTypesForAlias(mKeyStore,spec.getKeystoreAlias());
    }
  }
}
