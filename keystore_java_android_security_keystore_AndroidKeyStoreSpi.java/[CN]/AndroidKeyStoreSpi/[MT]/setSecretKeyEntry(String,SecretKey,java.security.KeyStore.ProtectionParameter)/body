{
  if ((param != null) && (!(param instanceof KeyProtection))) {
    throw new KeyStoreException("Unsupported protection parameter class: " + param.getClass().getName() + ". Supported: "+ KeyProtection.class.getName());
  }
  KeyProtection params=(KeyProtection)param;
  if (key instanceof AndroidKeyStoreSecretKey) {
    String keyAliasInKeystore=((AndroidKeyStoreSecretKey)key).getAlias();
    if (keyAliasInKeystore == null) {
      throw new KeyStoreException("KeyStore-backed secret key does not have an alias");
    }
    if (!keyAliasInKeystore.startsWith(Credentials.USER_SECRET_KEY)) {
      throw new KeyStoreException("KeyStore-backed secret key has invalid alias: " + keyAliasInKeystore);
    }
    String keyEntryAlias=keyAliasInKeystore.substring(Credentials.USER_SECRET_KEY.length());
    if (!entryAlias.equals(keyEntryAlias)) {
      throw new KeyStoreException("Can only replace KeyStore-backed keys with same" + " alias: " + entryAlias + " != "+ keyEntryAlias);
    }
    if (params != null) {
      throw new KeyStoreException("Modifying KeyStore-backed key using protection" + " parameters not supported");
    }
    return;
  }
  if (params == null) {
    throw new KeyStoreException("Protection parameters must be specified when importing a symmetric key");
  }
  String keyExportFormat=key.getFormat();
  if (keyExportFormat == null) {
    throw new KeyStoreException("Only secret keys that export their key material are supported");
  }
 else   if (!"RAW".equals(keyExportFormat)) {
    throw new KeyStoreException("Unsupported secret key material export format: " + keyExportFormat);
  }
  byte[] keyMaterial=key.getEncoded();
  if (keyMaterial == null) {
    throw new KeyStoreException("Key did not export its key material despite supporting" + " RAW format export");
  }
  KeymasterArguments args=new KeymasterArguments();
  try {
    int keymasterAlgorithm=KeyProperties.KeyAlgorithm.toKeymasterSecretKeyAlgorithm(key.getAlgorithm());
    args.addEnum(KeymasterDefs.KM_TAG_ALGORITHM,keymasterAlgorithm);
    int[] keymasterDigests;
    int keymasterDigest=KeyProperties.KeyAlgorithm.toKeymasterDigest(key.getAlgorithm());
    if (params.isDigestsSpecified()) {
      keymasterDigests=KeyProperties.Digest.allToKeymaster(params.getDigests());
      if (keymasterDigest != -1) {
        if (!com.android.internal.util.ArrayUtils.contains(keymasterDigests,keymasterDigest)) {
          throw new KeyStoreException("Digest specified in key algorithm " + key.getAlgorithm() + " not specified in protection parameters: "+ Arrays.asList(params.getDigests()));
        }
        if (keymasterDigests[0] != keymasterDigest) {
          for (int i=0; i < keymasterDigests.length; i++) {
            if (keymasterDigests[i] == keymasterDigest) {
              keymasterDigests[i]=keymasterDigests[0];
              keymasterDigests[0]=keymasterDigest;
              break;
            }
          }
        }
      }
    }
 else {
      if (keymasterDigest != -1) {
        keymasterDigests=new int[]{keymasterDigest};
      }
 else {
        keymasterDigests=EmptyArray.INT;
      }
    }
    args.addEnums(KeymasterDefs.KM_TAG_DIGEST,keymasterDigests);
    if (keymasterAlgorithm == KeymasterDefs.KM_ALGORITHM_HMAC) {
      if (keymasterDigests.length == 0) {
        throw new KeyStoreException("At least one digest algorithm must be specified" + " for key algorithm " + key.getAlgorithm());
      }
    }
    @KeyProperties.PurposeEnum int purposes=params.getPurposes();
    int[] keymasterBlockModes=KeyProperties.BlockMode.allToKeymaster(params.getBlockModes());
    if (((purposes & KeyProperties.PURPOSE_ENCRYPT) != 0) && (params.isRandomizedEncryptionRequired())) {
      for (      int keymasterBlockMode : keymasterBlockModes) {
        if (!KeymasterUtils.isKeymasterBlockModeIndCpaCompatibleWithSymmetricCrypto(keymasterBlockMode)) {
          throw new KeyStoreException("Randomized encryption (IND-CPA) required but may be violated by" + " block mode: " + KeyProperties.BlockMode.fromKeymaster(keymasterBlockMode) + ". See KeyProtection documentation.");
        }
      }
    }
    args.addEnums(KeymasterDefs.KM_TAG_PURPOSE,KeyProperties.Purpose.allToKeymaster(purposes));
    args.addEnums(KeymasterDefs.KM_TAG_BLOCK_MODE,keymasterBlockModes);
    if (params.getSignaturePaddings().length > 0) {
      throw new KeyStoreException("Signature paddings not supported for symmetric keys");
    }
    int[] keymasterPaddings=KeyProperties.EncryptionPadding.allToKeymaster(params.getEncryptionPaddings());
    args.addEnums(KeymasterDefs.KM_TAG_PADDING,keymasterPaddings);
    KeymasterUtils.addUserAuthArgs(args,params.isUserAuthenticationRequired(),params.getUserAuthenticationValidityDurationSeconds());
    args.addDateIfNotNull(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,params.getKeyValidityStart());
    args.addDateIfNotNull(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,params.getKeyValidityForOriginationEnd());
    args.addDateIfNotNull(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,params.getKeyValidityForConsumptionEnd());
    if (((purposes & KeyProperties.PURPOSE_ENCRYPT) != 0) && (!params.isRandomizedEncryptionRequired())) {
      args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
    }
  }
 catch (  IllegalArgumentException|IllegalStateException e) {
    throw new KeyStoreException(e);
  }
  Credentials.deleteAllTypesForAlias(mKeyStore,entryAlias);
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + entryAlias;
  int errorCode=mKeyStore.importKey(keyAliasInKeystore,args,KeymasterDefs.KM_KEY_FORMAT_RAW,keyMaterial,0,new KeyCharacteristics());
  if (errorCode != KeyStore.NO_ERROR) {
    throw new KeyStoreException("Failed to import secret key. Keystore error code: " + errorCode);
  }
}
