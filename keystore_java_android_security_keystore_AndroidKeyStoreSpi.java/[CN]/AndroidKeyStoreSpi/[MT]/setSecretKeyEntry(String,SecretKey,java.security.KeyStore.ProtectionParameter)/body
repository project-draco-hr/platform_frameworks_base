{
  if ((param != null) && (!(param instanceof KeyProtection))) {
    throw new KeyStoreException("Unsupported protection parameter class: " + param.getClass().getName() + ". Supported: "+ KeyProtection.class.getName());
  }
  KeyProtection params=(KeyProtection)param;
  if (key instanceof AndroidKeyStoreSecretKey) {
    String keyAliasInKeystore=((AndroidKeyStoreSecretKey)key).getAlias();
    if (keyAliasInKeystore == null) {
      throw new KeyStoreException("KeyStore-backed secret key does not have an alias");
    }
    if (!keyAliasInKeystore.startsWith(Credentials.USER_SECRET_KEY)) {
      throw new KeyStoreException("KeyStore-backed secret key has invalid alias: " + keyAliasInKeystore);
    }
    String keyEntryAlias=keyAliasInKeystore.substring(Credentials.USER_SECRET_KEY.length());
    if (!entryAlias.equals(keyEntryAlias)) {
      throw new KeyStoreException("Can only replace KeyStore-backed keys with same" + " alias: " + entryAlias + " != "+ keyEntryAlias);
    }
    if (params != null) {
      throw new KeyStoreException("Modifying KeyStore-backed key using protection" + " parameters not supported");
    }
    return;
  }
  if (params == null) {
    throw new KeyStoreException("Protection parameters must be specified when importing a symmetric key");
  }
  String keyExportFormat=key.getFormat();
  if (keyExportFormat == null) {
    throw new KeyStoreException("Only secret keys that export their key material are supported");
  }
 else   if (!"RAW".equals(keyExportFormat)) {
    throw new KeyStoreException("Unsupported secret key material export format: " + keyExportFormat);
  }
  byte[] keyMaterial=key.getEncoded();
  if (keyMaterial == null) {
    throw new KeyStoreException("Key did not export its key material despite supporting" + " RAW format export");
  }
  String keyAlgorithmString=key.getAlgorithm();
  int keymasterAlgorithm;
  int keymasterDigest;
  try {
    keymasterAlgorithm=KeyProperties.KeyAlgorithm.toKeymasterSecretKeyAlgorithm(keyAlgorithmString);
    keymasterDigest=KeyProperties.KeyAlgorithm.toKeymasterDigest(keyAlgorithmString);
  }
 catch (  IllegalArgumentException e) {
    throw new KeyStoreException("Unsupported secret key algorithm: " + keyAlgorithmString);
  }
  KeymasterArguments args=new KeymasterArguments();
  args.addInt(KeymasterDefs.KM_TAG_ALGORITHM,keymasterAlgorithm);
  int[] keymasterDigests;
  if (params.isDigestsSpecified()) {
    keymasterDigests=KeyProperties.Digest.allToKeymaster(params.getDigests());
    if (keymasterDigest != -1) {
      if (!com.android.internal.util.ArrayUtils.contains(keymasterDigests,keymasterDigest)) {
        throw new KeyStoreException("Key digest mismatch" + ". Key: " + keyAlgorithmString + ", parameter spec: "+ Arrays.asList(params.getDigests()));
      }
      if (keymasterDigests[0] != keymasterDigest) {
        for (int i=0; i < keymasterDigests.length; i++) {
          if (keymasterDigests[i] == keymasterDigest) {
            keymasterDigests[i]=keymasterDigests[0];
            keymasterDigests[0]=keymasterDigest;
            break;
          }
        }
      }
    }
  }
 else {
    if (keymasterDigest != -1) {
      keymasterDigests=new int[]{keymasterDigest};
    }
 else {
      keymasterDigests=EmptyArray.INT;
    }
  }
  args.addInts(KeymasterDefs.KM_TAG_DIGEST,keymasterDigests);
  if (keymasterAlgorithm == KeymasterDefs.KM_ALGORITHM_HMAC) {
    if (keymasterDigests.length == 0) {
      throw new KeyStoreException("At least one digest algorithm must be specified" + " for key algorithm " + keyAlgorithmString);
    }
  }
  @KeyProperties.PurposeEnum int purposes=params.getPurposes();
  int[] keymasterBlockModes=KeyProperties.BlockMode.allToKeymaster(params.getBlockModes());
  if (((purposes & KeyProperties.PURPOSE_ENCRYPT) != 0) && (params.isRandomizedEncryptionRequired())) {
    for (    int keymasterBlockMode : keymasterBlockModes) {
      if (!KeymasterUtils.isKeymasterBlockModeIndCpaCompatible(keymasterBlockMode)) {
        throw new KeyStoreException("Randomized encryption (IND-CPA) required but may be violated by block" + " mode: " + KeyProperties.BlockMode.fromKeymaster(keymasterBlockMode) + ". See KeyProtection documentation.");
      }
    }
  }
  for (  int keymasterPurpose : KeyProperties.Purpose.allToKeymaster(purposes)) {
    args.addInt(KeymasterDefs.KM_TAG_PURPOSE,keymasterPurpose);
  }
  args.addInts(KeymasterDefs.KM_TAG_BLOCK_MODE,keymasterBlockModes);
  if (params.getSignaturePaddings().length > 0) {
    throw new KeyStoreException("Signature paddings not supported for symmetric keys");
  }
  int[] keymasterPaddings=KeyProperties.EncryptionPadding.allToKeymaster(params.getEncryptionPaddings());
  args.addInts(KeymasterDefs.KM_TAG_PADDING,keymasterPaddings);
  KeymasterUtils.addUserAuthArgs(args,params.isUserAuthenticationRequired(),params.getUserAuthenticationValidityDurationSeconds());
  args.addDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME,(params.getKeyValidityStart() != null) ? params.getKeyValidityStart() : new Date(0));
  args.addDate(KeymasterDefs.KM_TAG_ORIGINATION_EXPIRE_DATETIME,(params.getKeyValidityForOriginationEnd() != null) ? params.getKeyValidityForOriginationEnd() : new Date(Long.MAX_VALUE));
  args.addDate(KeymasterDefs.KM_TAG_USAGE_EXPIRE_DATETIME,(params.getKeyValidityForConsumptionEnd() != null) ? params.getKeyValidityForConsumptionEnd() : new Date(Long.MAX_VALUE));
  if (((purposes & KeyProperties.PURPOSE_ENCRYPT) != 0) && (!params.isRandomizedEncryptionRequired())) {
    args.addBoolean(KeymasterDefs.KM_TAG_CALLER_NONCE);
  }
  Credentials.deleteAllTypesForAlias(mKeyStore,entryAlias);
  String keyAliasInKeystore=Credentials.USER_SECRET_KEY + entryAlias;
  int errorCode=mKeyStore.importKey(keyAliasInKeystore,args,KeymasterDefs.KM_KEY_FORMAT_RAW,keyMaterial,0,new KeyCharacteristics());
  if (errorCode != android.security.KeyStore.NO_ERROR) {
    throw new KeyStoreException("Failed to import secret key. Keystore error code: " + errorCode);
  }
}
