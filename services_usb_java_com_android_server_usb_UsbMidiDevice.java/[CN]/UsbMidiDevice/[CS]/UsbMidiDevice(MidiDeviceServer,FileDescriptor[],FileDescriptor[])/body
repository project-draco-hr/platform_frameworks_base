{
  mServer=server;
  int inputCount=inputFiles.length;
  int outputCount=outputFiles.length;
  mPollFDs=new StructPollfd[inputCount];
  mInputStreams=new FileInputStream[inputCount];
  for (int i=0; i < inputCount; i++) {
    FileDescriptor fd=inputFiles[i];
    StructPollfd pollfd=new StructPollfd();
    pollfd.fd=fd;
    pollfd.events=(short)OsConstants.POLLIN;
    mPollFDs[i]=pollfd;
    mInputStreams[i]=new FileInputStream(fd);
  }
  mOutputStreams=new FileOutputStream[outputCount];
  for (int i=0; i < outputCount; i++) {
    mOutputStreams[i]=new FileOutputStream(outputFiles[i]);
  }
  mOutputPortReceivers=new MidiReceiver[outputCount];
  for (int port=0; port < outputCount; port++) {
    mOutputPortReceivers[port]=server.openOutputPortReceiver(port);
  }
  for (int port=0; port < inputCount; port++) {
    final int portNumberF=port;
    MidiReceiver receiver=new MidiReceiver(){
      @Override public void onPost(      byte[] data,      int offset,      int count,      long timestamp) throws IOException {
        mOutputStreams[portNumberF].write(data,offset,count);
      }
    }
;
    MidiSender sender=server.openInputPortSender(port);
    sender.connect(receiver);
  }
  new Thread(){
    @Override public void run(){
      byte[] buffer=new byte[3];
      try {
        while (true) {
          for (int index=0; index < mPollFDs.length; index++) {
            StructPollfd pfd=mPollFDs[index];
            if ((pfd.revents & OsConstants.POLLIN) != 0) {
              pfd.revents=0;
              int count=readMessage(buffer,index);
              mOutputPortReceivers[index].onPost(buffer,0,count,System.nanoTime());
            }
          }
          Os.poll(mPollFDs,-1);
        }
      }
 catch (      IOException e) {
        Log.d(TAG,"reader thread exiting");
      }
catch (      ErrnoException e) {
        Log.d(TAG,"reader thread exiting");
      }
    }
  }
.start();
}
