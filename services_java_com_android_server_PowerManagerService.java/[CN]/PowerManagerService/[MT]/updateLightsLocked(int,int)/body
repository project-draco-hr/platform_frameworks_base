{
  int oldState=mPowerState;
  int difference=(newState ^ oldState) | forceState;
  if (difference == 0) {
    return;
  }
  int offMask=0;
  int dimMask=0;
  int onMask=0;
  int preferredBrightness=getPreferredBrightness();
  boolean startAnimation=false;
  if ((difference & KEYBOARD_BRIGHT_BIT) != 0) {
    if (ANIMATE_KEYBOARD_LIGHTS) {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        mKeyboardBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,preferredBrightness);
      }
 else {
        mKeyboardBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        offMask|=KEYBOARD_BRIGHT_BIT;
      }
 else {
        onMask|=KEYBOARD_BRIGHT_BIT;
      }
    }
  }
  if ((difference & BUTTON_BRIGHT_BIT) != 0) {
    if (ANIMATE_BUTTON_LIGHTS) {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        mButtonBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,preferredBrightness);
      }
 else {
        mButtonBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        offMask|=BUTTON_BRIGHT_BIT;
      }
 else {
        onMask|=BUTTON_BRIGHT_BIT;
      }
    }
  }
  if ((difference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
    if (ANIMATE_SCREEN_LIGHTS) {
      int nominalCurrentValue;
switch (oldState & (SCREEN_BRIGHT_BIT | SCREEN_ON_BIT)) {
case SCREEN_BRIGHT_BIT | SCREEN_ON_BIT:
        nominalCurrentValue=preferredBrightness;
      break;
case SCREEN_ON_BIT:
    nominalCurrentValue=Power.BRIGHTNESS_DIM;
  break;
case 0:
nominalCurrentValue=Power.BRIGHTNESS_OFF;
break;
case SCREEN_BRIGHT_BIT:
default :
nominalCurrentValue=(int)mScreenBrightness.curValue;
break;
}
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
final float scale=1.5f;
float ratio=(((float)Power.BRIGHTNESS_DIM) / preferredBrightness);
if (ratio > 1.0f) ratio=1.0f;
if ((newState & SCREEN_ON_BIT) == 0) {
int steps;
if ((oldState & SCREEN_BRIGHT_BIT) != 0) {
steps=ANIM_STEPS;
}
 else {
steps=(int)(ANIM_STEPS * ratio * scale);
}
mScreenBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,steps,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue);
}
 else {
int steps;
if ((oldState & SCREEN_ON_BIT) != 0) {
steps=(int)(ANIM_STEPS * (1.0f - ratio) * scale);
}
 else {
steps=(int)(ANIM_STEPS * ratio);
}
if (mStayOnConditions != 0 && mBatteryService.isPowered(mStayOnConditions)) {
mScreenOffTime=SystemClock.elapsedRealtime();
}
mScreenBrightness.setTargetLocked(Power.BRIGHTNESS_DIM,steps,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue);
}
}
 else {
mScreenBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue);
}
startAnimation=true;
}
 else {
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
if ((newState & SCREEN_ON_BIT) == 0) {
offMask|=SCREEN_BRIGHT_BIT;
}
 else {
dimMask|=SCREEN_BRIGHT_BIT;
}
}
 else {
onMask|=SCREEN_BRIGHT_BIT;
}
}
}
if (startAnimation) {
if (mSpew) {
Log.i(TAG,"Scheduling light animator!");
}
mHandler.removeCallbacks(mLightAnimator);
mHandler.post(mLightAnimator);
}
if (offMask != 0) {
setLightBrightness(offMask,Power.BRIGHTNESS_OFF);
}
if (dimMask != 0) {
int brightness=Power.BRIGHTNESS_DIM;
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(dimMask,brightness);
}
if (onMask != 0) {
int brightness=getPreferredBrightness();
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(onMask,brightness);
}
}
