{
  if (mBootCompleted) {
synchronized (mLocks) {
      mHandler.removeCallbacks(mTimeoutTask);
      mTimeoutTask.nextState=nextState;
      long when=0;
      if (timeoutOverride <= 0) {
switch (nextState) {
case SCREEN_BRIGHT:
          when=now + mKeylightDelay;
        break;
case SCREEN_DIM:
      if (mDimDelay >= 0) {
        when=now + mDimDelay;
      }
 else {
        Slog.w(TAG,"mDimDelay=" + mDimDelay + " while trying to dim");
      }
case SCREEN_OFF:
synchronized (mLocks) {
      when=now + mScreenOffDelay;
    }
  break;
}
}
 else {
override: {
if (timeoutOverride <= mScreenOffDelay) {
  when=now + timeoutOverride;
  nextState=SCREEN_OFF;
  break override;
}
timeoutOverride-=mScreenOffDelay;
if (mDimDelay >= 0) {
  if (timeoutOverride <= mDimDelay) {
    when=now + timeoutOverride;
    nextState=SCREEN_DIM;
    break override;
  }
  timeoutOverride-=mDimDelay;
}
when=now + timeoutOverride;
nextState=SCREEN_BRIGHT;
}
}
if (mSpew) {
Slog.d(TAG,"setTimeoutLocked now=" + now + " timeoutOverride="+ timeoutOverride+ " nextState="+ nextState+ " when="+ when);
}
mHandler.postAtTime(mTimeoutTask,when);
mNextTimeout=when;
}
}
}
