{
  mBandwidthControlEnabled=false;
  final boolean hasKernelSupport=new File("/proc/net/xt_qtaguid/ctrl").exists();
  if (hasKernelSupport) {
    Slog.d(TAG,"enabling bandwidth control");
    try {
      mConnector.execute("bandwidth","enable");
      mBandwidthControlEnabled=true;
    }
 catch (    NativeDaemonConnectorException e) {
      Log.wtf(TAG,"problem enabling bandwidth controls",e);
    }
  }
 else {
    Slog.d(TAG,"not enabling bandwidth control");
  }
  SystemProperties.set(PROP_QTAGUID_ENABLED,mBandwidthControlEnabled ? "1" : "0");
synchronized (mQuotaLock) {
    int size=mActiveQuotas.size();
    if (size > 0) {
      Slog.d(TAG,"pushing " + size + " active quota rules");
      final HashMap<String,Long> activeQuotas=mActiveQuotas;
      mActiveQuotas=Maps.newHashMap();
      for (      Map.Entry<String,Long> entry : activeQuotas.entrySet()) {
        setInterfaceQuota(entry.getKey(),entry.getValue());
      }
    }
    size=mActiveAlerts.size();
    if (size > 0) {
      Slog.d(TAG,"pushing " + size + " active alert rules");
      final HashMap<String,Long> activeAlerts=mActiveAlerts;
      mActiveAlerts=Maps.newHashMap();
      for (      Map.Entry<String,Long> entry : activeAlerts.entrySet()) {
        setInterfaceAlert(entry.getKey(),entry.getValue());
      }
    }
    size=mUidRejectOnQuota.size();
    if (size > 0) {
      Slog.d(TAG,"pushing " + size + " active uid rules");
      final SparseBooleanArray uidRejectOnQuota=mUidRejectOnQuota;
      mUidRejectOnQuota=new SparseBooleanArray();
      for (int i=0; i < uidRejectOnQuota.size(); i++) {
        setUidNetworkRules(uidRejectOnQuota.keyAt(i),uidRejectOnQuota.valueAt(i));
      }
    }
  }
}
