{
  long currentTime=AnimationUtils.currentAnimationTimeMillis();
  while (mPendingAnimations.size() > 0) {
    ArrayList<ValueAnimator> pendingCopy=(ArrayList<ValueAnimator>)mPendingAnimations.clone();
    mPendingAnimations.clear();
    int count=pendingCopy.size();
    for (int i=0; i < count; ++i) {
      ValueAnimator anim=pendingCopy.get(i);
      if (anim.mStartDelay == 0) {
        anim.startAnimation(this);
      }
 else {
        mDelayedAnims.add(anim);
      }
    }
  }
  int numDelayedAnims=mDelayedAnims.size();
  for (int i=0; i < numDelayedAnims; ++i) {
    ValueAnimator anim=mDelayedAnims.get(i);
    if (anim.delayedAnimationFrame(currentTime)) {
      mReadyAnims.add(anim);
    }
  }
  int numReadyAnims=mReadyAnims.size();
  if (numReadyAnims > 0) {
    for (int i=0; i < numReadyAnims; ++i) {
      ValueAnimator anim=mReadyAnims.get(i);
      anim.startAnimation(this);
      anim.mRunning=true;
      mDelayedAnims.remove(anim);
    }
    mReadyAnims.clear();
  }
  int numAnims=mAnimations.size();
  int i=0;
  while (i < numAnims) {
    ValueAnimator anim=mAnimations.get(i);
    if (anim.animationFrame(currentTime)) {
      mEndingAnims.add(anim);
    }
    if (mAnimations.size() == numAnims) {
      ++i;
    }
 else {
      --numAnims;
      mEndingAnims.remove(anim);
    }
  }
  if (mEndingAnims.size() > 0) {
    for (i=0; i < mEndingAnims.size(); ++i) {
      mEndingAnims.get(i).endAnimation(this);
    }
    mEndingAnims.clear();
  }
  if (!mAnimationScheduled && (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty())) {
    mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION,this,null);
    mAnimationScheduled=true;
  }
}
