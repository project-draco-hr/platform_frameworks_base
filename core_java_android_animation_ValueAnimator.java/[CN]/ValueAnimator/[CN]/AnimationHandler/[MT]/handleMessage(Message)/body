{
  boolean callAgain=true;
switch (msg.what) {
case ANIMATION_START:
    if (sAnimations.size() > 0 || sDelayedAnims.size() > 0) {
      callAgain=false;
    }
  while (sPendingAnimations.size() > 0) {
    ArrayList<ValueAnimator> pendingCopy=(ArrayList<ValueAnimator>)sPendingAnimations.clone();
    sPendingAnimations.clear();
    int count=pendingCopy.size();
    for (int i=0; i < count; ++i) {
      ValueAnimator anim=pendingCopy.get(i);
      if (anim.mStartDelay == 0 || anim.mPlayingState == ENDED || anim.mPlayingState == CANCELED) {
        anim.startAnimation();
      }
 else {
        sDelayedAnims.add(anim);
      }
    }
  }
case ANIMATION_FRAME:
long currentTime=AnimationUtils.currentAnimationTimeMillis();
int numDelayedAnims=sDelayedAnims.size();
for (int i=0; i < numDelayedAnims; ++i) {
ValueAnimator anim=sDelayedAnims.get(i);
if (anim.delayedAnimationFrame(currentTime)) {
sReadyAnims.add(anim);
}
}
int numReadyAnims=sReadyAnims.size();
if (numReadyAnims > 0) {
for (int i=0; i < numReadyAnims; ++i) {
ValueAnimator anim=sReadyAnims.get(i);
anim.startAnimation();
sDelayedAnims.remove(anim);
}
sReadyAnims.clear();
}
int numAnims=sAnimations.size();
for (int i=0; i < numAnims; ++i) {
ValueAnimator anim=sAnimations.get(i);
if (anim.animationFrame(currentTime)) {
sEndingAnims.add(anim);
}
}
if (sEndingAnims.size() > 0) {
for (int i=0; i < sEndingAnims.size(); ++i) {
sEndingAnims.get(i).endAnimation();
}
sEndingAnims.clear();
}
if (callAgain && (!sAnimations.isEmpty() || !sDelayedAnims.isEmpty())) {
sendEmptyMessageDelayed(ANIMATION_FRAME,Math.max(0,sFrameDelay - (AnimationUtils.currentAnimationTimeMillis() - currentTime)));
}
break;
}
}
