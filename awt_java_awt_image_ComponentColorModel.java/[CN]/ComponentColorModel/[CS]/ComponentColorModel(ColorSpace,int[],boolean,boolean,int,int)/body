{
  super(createPixelBits(colorSpace,hasAlpha,transferType),validateBits(bits,colorSpace,hasAlpha,transferType),colorSpace,hasAlpha,isAlphaPremultiplied,transparency,transferType);
  needScale=false;
switch (transferType) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_INT:
    signed=false;
  integral=true;
donotSupportUnnormalized=false;
scaleFactors=new float[numComponents];
for (int i=0; i < numColorComponents; i++) {
scaleFactors[i]=1.0f / maxValues[i];
if (cs.getMinValue(i) != 0.0f || cs.getMaxValue(i) != 1.0f) {
donotSupportUnnormalized=true;
}
}
if (hasAlpha) {
maxValues[numColorComponents]=(1 << bits[numColorComponents]) - 1;
scaleFactors[numColorComponents]=1.0f / maxValues[numColorComponents];
}
break;
case DataBuffer.TYPE_SHORT:
signed=true;
integral=true;
donotSupportUnnormalized=true;
scaleFactors=new float[numComponents];
for (int i=0; i < numComponents; i++) {
maxValues[i]=Short.MAX_VALUE;
scaleFactors[i]=1.0f / maxValues[i];
if (cs.getMinValue(i) != 0.0f || cs.getMaxValue(i) != 1.0f) {
needScale=true;
}
}
if (needScale) {
minVals=new float[numColorComponents];
ranges=new float[numColorComponents];
for (int i=0; i < numColorComponents; i++) {
minVals[i]=cs.getMinValue(i);
ranges[i]=cs.getMaxValue(i) - minVals[i];
}
}
break;
case DataBuffer.TYPE_FLOAT:
case DataBuffer.TYPE_DOUBLE:
signed=true;
integral=false;
donotSupportUnnormalized=true;
break;
default :
throw new IllegalArgumentException(Messages.getString("awt.215"));
}
needAlphaDivide=hasAlpha && isAlphaPremultiplied;
initLUTs();
}
