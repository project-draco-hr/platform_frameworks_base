{
  if (!hasAlpha || this.isAlphaPremultiplied == isAlphaPremultiplied) {
    return this;
  }
  int minX=raster.getMinX();
  int minY=raster.getMinY();
  int w=raster.getWidth();
  int h=raster.getHeight();
  if (isAlphaPremultiplied) {
switch (transferType) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_INT:
      float alphaFactor=maxValues[numColorComponents];
    int iComponents[]=null;
  int iTransparentComponents[]=new int[numComponents];
for (int i=0; i < h; i++, minY++) {
  for (int j=0, x=minX; j < w; j++, x++) {
    iComponents=raster.getPixel(x,minY,iComponents);
    if (iComponents[numColorComponents] == 0) {
      raster.setPixel(x,minY,iTransparentComponents);
    }
 else {
      float alpha=iComponents[numColorComponents] / alphaFactor;
      for (int n=0; n < numColorComponents; n++) {
        iComponents[n]=(int)(alpha * iComponents[n] + 0.5f);
      }
      raster.setPixel(x,minY,iComponents);
    }
  }
}
break;
case DataBuffer.TYPE_SHORT:
float sAlphaFactor=maxValues[numColorComponents];
short sComponents[]=null;
short sTransparentComponents[]=new short[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
sComponents=(short[])raster.getDataElements(x,minY,sComponents);
if (sComponents[numColorComponents] == 0) {
raster.setDataElements(x,minY,sTransparentComponents);
}
 else {
float alpha=sComponents[numColorComponents] / sAlphaFactor;
for (int n=0; n < numColorComponents; n++) {
sComponents[n]=(byte)(alpha * sComponents[n] + 0.5f);
}
raster.setDataElements(x,minY,sComponents);
}
}
}
break;
case DataBuffer.TYPE_FLOAT:
float fComponents[]=null;
float fTransparentComponents[]=new float[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
fComponents=raster.getPixel(x,minY,fComponents);
if (fComponents[numColorComponents] == 0.0f) {
raster.setDataElements(x,minY,fTransparentComponents);
}
 else {
float alpha=fComponents[numColorComponents];
for (int n=0; n < numColorComponents; n++) {
fComponents[n]=fComponents[n] * alpha;
}
raster.setPixel(x,minY,fComponents);
}
}
}
break;
case DataBuffer.TYPE_DOUBLE:
double dComponents[]=null;
double dTransparentComponents[]=new double[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
dComponents=raster.getPixel(x,minY,dComponents);
if (dComponents[numColorComponents] == 0.0) {
raster.setPixel(x,minY,dTransparentComponents);
}
 else {
double alpha=dComponents[numColorComponents];
for (int n=0; n < numColorComponents; n++) {
dComponents[n]=dComponents[n] * alpha;
}
raster.setPixel(x,minY,dComponents);
}
}
}
break;
default :
throw new UnsupportedOperationException(Messages.getString("awt.219"));
}
}
 else {
switch (transferType) {
case DataBuffer.TYPE_BYTE:
case DataBuffer.TYPE_USHORT:
case DataBuffer.TYPE_INT:
float alphaFactor=maxValues[numColorComponents];
int iComponents[]=null;
int iTransparentComponents[]=new int[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
iComponents=raster.getPixel(x,minY,iComponents);
if (iComponents[numColorComponents] == 0) {
raster.setPixel(x,minY,iTransparentComponents);
}
 else {
float alpha=iComponents[numColorComponents] / alphaFactor;
for (int n=0; n < numColorComponents; n++) {
iComponents[n]=(int)(iComponents[n] / alpha + 0.5f);
}
raster.setPixel(x,minY,iComponents);
}
}
}
break;
case DataBuffer.TYPE_SHORT:
float sAlphaFactor=maxValues[numColorComponents];
short sComponents[]=null;
short sTransparentComponents[]=new short[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
sComponents=(short[])raster.getDataElements(x,minY,sComponents);
if (sComponents[numColorComponents] == 0) {
raster.setDataElements(x,minY,sTransparentComponents);
}
 else {
float alpha=sComponents[numColorComponents] / sAlphaFactor;
for (int n=0; n < numColorComponents; n++) {
sComponents[n]=(byte)(sComponents[n] / alpha + 0.5f);
}
raster.setDataElements(x,minY,sComponents);
}
}
}
break;
case DataBuffer.TYPE_FLOAT:
float fComponents[]=null;
float fTransparentComponents[]=new float[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
fComponents=raster.getPixel(x,minY,fComponents);
if (fComponents[numColorComponents] == 0.0f) {
raster.setDataElements(x,minY,fTransparentComponents);
}
 else {
float alpha=fComponents[numColorComponents];
for (int n=0; n < numColorComponents; n++) {
fComponents[n]=fComponents[n] / alpha;
}
raster.setPixel(x,minY,fComponents);
}
}
}
break;
case DataBuffer.TYPE_DOUBLE:
double dComponents[]=null;
double dTransparentComponents[]=new double[numComponents];
for (int i=0; i < h; i++, minY++) {
for (int j=0, x=minX; j < w; j++, x++) {
dComponents=raster.getPixel(x,minY,dComponents);
if (dComponents[numColorComponents] == 0.0) {
raster.setPixel(x,minY,dTransparentComponents);
}
 else {
double alpha=dComponents[numColorComponents];
for (int n=0; n < numColorComponents; n++) {
dComponents[n]=dComponents[n] / alpha;
}
raster.setPixel(x,minY,dComponents);
}
}
}
break;
default :
throw new UnsupportedOperationException(Messages.getString("awt.219"));
}
}
if (!signed) {
return new ComponentColorModel(cs,bits,hasAlpha,isAlphaPremultiplied,transparency,transferType);
}
return new ComponentColorModel(cs,null,hasAlpha,isAlphaPremultiplied,transparency,transferType);
}
