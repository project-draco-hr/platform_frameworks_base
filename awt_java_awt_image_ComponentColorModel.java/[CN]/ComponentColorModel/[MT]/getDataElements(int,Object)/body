{
  float normComp[];
  float comp[];
  int red=(rgb >> 16) & 0xff;
  int green=(rgb >> 8) & 0xff;
  int blue=rgb & 0xff;
  int alpha=(rgb >> 24) & 0xff;
  comp=new float[3];
  if (is_sRGB || is_LINEAR_RGB) {
    if (is_LINEAR_RGB) {
      if (LINEAR_RGB_Length == 8) {
        red=to_LINEAR_8RGB_LUT[red] & 0xff;
        green=to_LINEAR_8RGB_LUT[green] & 0xff;
        blue=to_LINEAR_8RGB_LUT[blue] & 0xff;
      }
 else {
        red=to_LINEAR_16RGB_LUT[red] & 0xffff;
        green=to_LINEAR_16RGB_LUT[green] & 0xffff;
        blue=to_LINEAR_16RGB_LUT[blue] & 0xffff;
      }
    }
    comp[0]=red / fFactor;
    comp[1]=green / fFactor;
    comp[2]=blue / fFactor;
    if (!hasAlpha) {
      normComp=comp;
    }
 else {
      float normAlpha=alpha / 255.0f;
      normComp=new float[numComponents];
      for (int i=0; i < numColorComponents; i++) {
        normComp[i]=comp[i];
      }
      normComp[numColorComponents]=normAlpha;
    }
  }
 else {
    comp[0]=red / fFactor;
    comp[1]=green / fFactor;
    comp[2]=blue / fFactor;
    float[] defComp=cs.fromRGB(comp);
    if (!hasAlpha) {
      normComp=defComp;
    }
 else {
      float normAlpha=alpha / 255.0f;
      normComp=new float[numComponents];
      for (int i=0; i < numColorComponents; i++) {
        normComp[i]=defComp[i];
      }
      normComp[numColorComponents]=normAlpha;
    }
  }
  if (hasAlpha && isAlphaPremultiplied) {
    normComp[0]*=normComp[numColorComponents];
    normComp[1]*=normComp[numColorComponents];
    normComp[2]*=normComp[numColorComponents];
  }
  return getDataElements(normComp,0,pixel);
}
