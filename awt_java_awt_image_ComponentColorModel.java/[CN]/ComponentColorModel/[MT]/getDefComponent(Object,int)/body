{
  int comp=0;
  calcValue=false;
switch (transferType) {
case DataBuffer.TYPE_BYTE:
    byte ba[]=(byte[])pixel;
  comp=ba[idx] & 0xff;
if (needAlphaDivide) {
  int alpha=ba[numColorComponents] & 0xff;
  if (alpha == 0) {
    comp=0;
  }
 else {
    float normAlpha=scaleFactors[numColorComponents] * alpha;
    comp=(int)(comp * fFactor / normAlpha + 0.5f);
  }
  calcValue=true;
}
return comp;
case DataBuffer.TYPE_USHORT:
short usa[]=(short[])pixel;
comp=usa[idx] & 0xffff;
if (needAlphaDivide) {
int alpha=usa[numColorComponents] & 0xffff;
if (alpha == 0) {
comp=0;
}
 else {
float normAlpha=scaleFactors[numColorComponents] * alpha;
comp=(int)(comp * fFactor / normAlpha + 0.5f);
}
calcValue=true;
}
return comp;
case DataBuffer.TYPE_INT:
int ia[]=(int[])pixel;
comp=ia[idx];
if (needAlphaDivide) {
int alpha=ia[numColorComponents];
if (alpha == 0) {
comp=0;
}
 else {
float normAlpha=scaleFactors[numColorComponents] * alpha;
comp=(int)(comp * fFactor / normAlpha + 0.5f);
}
calcValue=true;
}
return comp;
case DataBuffer.TYPE_SHORT:
short sa[]=(short[])pixel;
comp=sa[idx];
if (needAlphaDivide) {
int alpha=sa[numColorComponents];
if (alpha == 0) {
comp=0;
}
 else {
float normAlpha=scaleFactors[numColorComponents] * alpha;
comp=(int)(comp * fFactor / normAlpha + 0.5f);
}
calcValue=true;
}
return comp;
case DataBuffer.TYPE_FLOAT:
float fa[]=(float[])pixel;
if (needAlphaDivide) {
float alpha=fa[numColorComponents];
if (fa[numColorComponents] == 0.0f) {
comp=0;
}
 else {
comp=(int)(fa[idx] * fFactor / alpha + 0.5f);
}
}
 else {
comp=(int)(fa[idx] * fFactor + 0.5f);
}
calcValue=true;
return comp;
case DataBuffer.TYPE_DOUBLE:
double da[]=(double[])pixel;
if (needAlphaDivide) {
if (da[numColorComponents] == 0.0) {
comp=0;
}
 else {
comp=(int)(da[idx] * fFactor / da[numColorComponents] + 0.5);
}
}
 else {
comp=(int)(da[idx] * fFactor + 0.5);
}
calcValue=true;
return comp;
default :
throw new UnsupportedOperationException(Messages.getString("awt.214"));
}
}
