{
  if (needScale) {
    for (int i=0, idx=0; i < numColorComponents; i++, idx++) {
      normComponents[idx]=(normComponents[idx] - minVals[i]) / ranges[i];
    }
  }
switch (transferType) {
case DataBuffer.TYPE_BYTE:
    byte ba[];
  if (obj == null) {
    ba=new byte[numComponents];
  }
 else {
    ba=(byte[])obj;
  }
if (needAlphaDivide) {
  float alpha=normComponents[normOffset + numColorComponents];
  for (int i=0, idx=normOffset; i < numColorComponents; i++, idx++) {
    ba[i]=(byte)(normComponents[idx] * alpha * maxValues[i] + 0.5f);
  }
  ba[numColorComponents]=(byte)(normComponents[normOffset + numColorComponents] * maxValues[numColorComponents] + 0.5f);
}
 else {
  for (int i=0, idx=normOffset; i < numComponents; i++, idx++) {
    ba[idx]=(byte)(normComponents[idx] * maxValues[i] + 0.5f);
  }
}
return ba;
case DataBuffer.TYPE_USHORT:
short usa[];
if (obj == null) {
usa=new short[numComponents];
}
 else {
usa=(short[])obj;
}
if (needAlphaDivide) {
float alpha=normComponents[normOffset + numColorComponents];
for (int i=0, idx=0; i < numColorComponents; i++, idx++) {
usa[i]=(short)(normComponents[idx] * alpha * maxValues[i] + 0.5f);
}
usa[numColorComponents]=(short)(alpha * maxValues[numColorComponents] + 0.5f);
}
 else {
for (int i=0, idx=normOffset; i < numComponents; i++, idx++) {
usa[i]=(short)(normComponents[idx] * maxValues[i] + 0.5f);
}
}
return usa;
case DataBuffer.TYPE_INT:
int ia[];
if (obj == null) {
ia=new int[numComponents];
}
 else {
ia=(int[])obj;
}
if (needAlphaDivide) {
float alpha=normComponents[normOffset + numColorComponents];
for (int i=0, idx=0; i < numColorComponents; i++, idx++) {
ia[i]=(int)(normComponents[idx] * alpha * maxValues[i] + 0.5f);
}
ia[numColorComponents]=(int)(alpha * maxValues[numColorComponents] + 0.5f);
}
 else {
for (int i=0, idx=normOffset; i < numComponents; i++, idx++) {
ia[i]=(int)(normComponents[idx] * maxValues[i] + 0.5f);
}
}
return ia;
case DataBuffer.TYPE_SHORT:
short sa[];
if (obj == null) {
sa=new short[numComponents];
}
 else {
sa=(short[])obj;
}
if (needAlphaDivide) {
float alpha=normComponents[normOffset + numColorComponents];
for (int i=0, idx=0; i < numColorComponents; i++, idx++) {
sa[i]=(short)(normComponents[idx] * alpha * maxValues[i] + 0.5f);
}
sa[numColorComponents]=(short)(alpha * maxValues[numColorComponents] + 0.5f);
}
 else {
for (int i=0, idx=normOffset; i < numComponents; i++, idx++) {
sa[i]=(short)(normComponents[idx] * maxValues[i] + 0.5f);
}
}
return sa;
case DataBuffer.TYPE_FLOAT:
float fa[];
if (obj == null) {
fa=new float[numComponents];
}
 else {
fa=(float[])obj;
}
if (needAlphaDivide) {
float alpha=normComponents[normOffset + numColorComponents];
for (int i=0, idx=0; i < numColorComponents; i++, idx++) {
fa[i]=normComponents[idx] * alpha;
}
fa[numColorComponents]=alpha;
}
 else {
for (int i=0, idx=normOffset; i < numComponents; i++, idx++) {
fa[i]=normComponents[idx];
}
}
return fa;
case DataBuffer.TYPE_DOUBLE:
double da[];
if (obj == null) {
da=new double[numComponents];
}
 else {
da=(double[])obj;
}
if (needAlphaDivide) {
double alpha=normComponents[normOffset + numColorComponents];
for (int i=0, idx=0; i < numColorComponents; i++, idx++) {
da[i]=normComponents[idx] * alpha;
}
da[numColorComponents]=alpha;
}
 else {
for (int i=0, idx=normOffset; i < numComponents; i++, idx++) {
da[i]=normComponents[idx];
}
}
return da;
default :
throw new IllegalArgumentException(Messages.getString("awt.213"));
}
}
