{
  int[] breakOpp=null;
  final String localeLanguageTag=paint.getTextLocale().toLanguageTag();
  mLineCount=0;
  int v=0;
  boolean needMultiply=(spacingmult != 1 || spacingadd != 0);
  Paint.FontMetricsInt fm=mFontMetricsInt;
  int[] chooseHtv=null;
  MeasuredText measured=mMeasured;
  Spanned spanned=null;
  if (source instanceof Spanned)   spanned=(Spanned)source;
  int paraEnd;
  for (int paraStart=bufStart; paraStart <= bufEnd; paraStart=paraEnd) {
    paraEnd=TextUtils.indexOf(source,CHAR_NEW_LINE,paraStart,bufEnd);
    if (paraEnd < 0)     paraEnd=bufEnd;
 else     paraEnd++;
    int firstWidthLineLimit=mLineCount + 1;
    int firstWidth=outerWidth;
    int restWidth=outerWidth;
    LineHeightSpan[] chooseHt=null;
    if (spanned != null) {
      LeadingMarginSpan[] sp=getParagraphSpans(spanned,paraStart,paraEnd,LeadingMarginSpan.class);
      for (int i=0; i < sp.length; i++) {
        LeadingMarginSpan lms=sp[i];
        firstWidth-=sp[i].getLeadingMargin(true);
        restWidth-=sp[i].getLeadingMargin(false);
        if (lms instanceof LeadingMarginSpan2) {
          LeadingMarginSpan2 lms2=(LeadingMarginSpan2)lms;
          int lmsFirstLine=getLineForOffset(spanned.getSpanStart(lms2));
          firstWidthLineLimit=lmsFirstLine + lms2.getLeadingMarginLineCount();
        }
      }
      chooseHt=getParagraphSpans(spanned,paraStart,paraEnd,LineHeightSpan.class);
      if (chooseHt.length != 0) {
        if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
          chooseHtv=ArrayUtils.newUnpaddedIntArray(chooseHt.length);
        }
        for (int i=0; i < chooseHt.length; i++) {
          int o=spanned.getSpanStart(chooseHt[i]);
          if (o < paraStart) {
            chooseHtv[i]=getLineTop(getLineForOffset(o));
          }
 else {
            chooseHtv[i]=v;
          }
        }
      }
    }
    measured.setPara(source,paraStart,paraEnd,textDir);
    char[] chs=measured.mChars;
    float[] widths=measured.mWidths;
    byte[] chdirs=measured.mLevels;
    int dir=measured.mDir;
    boolean easy=measured.mEasy;
    breakOpp=nLineBreakOpportunities(localeLanguageTag,chs,paraEnd - paraStart,breakOpp);
    int breakOppIndex=0;
    int width=firstWidth;
    float w=0;
    int here=paraStart;
    int ok=paraStart;
    float okWidth=w;
    int okAscent=0, okDescent=0, okTop=0, okBottom=0;
    int fit=paraStart;
    float fitWidth=w;
    int fitAscent=0, fitDescent=0, fitTop=0, fitBottom=0;
    boolean hasTabOrEmoji=false;
    boolean hasTab=false;
    TabStops tabStops=null;
    for (int spanStart=paraStart, spanEnd; spanStart < paraEnd; spanStart=spanEnd) {
      if (spanned == null) {
        spanEnd=paraEnd;
        int spanLen=spanEnd - spanStart;
        measured.addStyleRun(paint,spanLen,fm);
      }
 else {
        spanEnd=spanned.nextSpanTransition(spanStart,paraEnd,MetricAffectingSpan.class);
        int spanLen=spanEnd - spanStart;
        MetricAffectingSpan[] spans=spanned.getSpans(spanStart,spanEnd,MetricAffectingSpan.class);
        spans=TextUtils.removeEmptySpans(spans,spanned,MetricAffectingSpan.class);
        measured.addStyleRun(paint,spans,spanLen,fm);
      }
      int fmTop=fm.top;
      int fmBottom=fm.bottom;
      int fmAscent=fm.ascent;
      int fmDescent=fm.descent;
      for (int j=spanStart; j < spanEnd; j++) {
        char c=chs[j - paraStart];
        if (c == CHAR_NEW_LINE) {
        }
 else         if (c == CHAR_TAB) {
          if (hasTab == false) {
            hasTab=true;
            hasTabOrEmoji=true;
            if (spanned != null) {
              TabStopSpan[] spans=getParagraphSpans(spanned,paraStart,paraEnd,TabStopSpan.class);
              if (spans.length > 0) {
                tabStops=new TabStops(TAB_INCREMENT,spans);
              }
            }
          }
          if (tabStops != null) {
            w=tabStops.nextTab(w);
          }
 else {
            w=TabStops.nextDefaultStop(w,TAB_INCREMENT);
          }
        }
 else         if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
          int emoji=Character.codePointAt(chs,j - paraStart);
          if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
            Bitmap bm=EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
            if (bm != null) {
              Paint whichPaint;
              if (spanned == null) {
                whichPaint=paint;
              }
 else {
                whichPaint=mWorkPaint;
              }
              float wid=bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
              w+=wid;
              hasTabOrEmoji=true;
              j++;
            }
 else {
              w+=widths[j - paraStart];
            }
          }
 else {
            w+=widths[j - paraStart];
          }
        }
 else {
          w+=widths[j - paraStart];
        }
        boolean isSpaceOrTab=c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
        if (w <= width || isSpaceOrTab) {
          fitWidth=w;
          fit=j + 1;
          if (fmTop < fitTop)           fitTop=fmTop;
          if (fmAscent < fitAscent)           fitAscent=fmAscent;
          if (fmDescent > fitDescent)           fitDescent=fmDescent;
          if (fmBottom > fitBottom)           fitBottom=fmBottom;
          while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
            breakOppIndex++;
          }
          boolean isLineBreak=breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
          if (isLineBreak) {
            okWidth=w;
            ok=j + 1;
            if (fitTop < okTop)             okTop=fitTop;
            if (fitAscent < okAscent)             okAscent=fitAscent;
            if (fitDescent > okDescent)             okDescent=fitDescent;
            if (fitBottom > okBottom)             okBottom=fitBottom;
          }
        }
 else {
          final boolean moreChars;
          int endPos;
          int above, below, top, bottom;
          float currentTextWidth;
          if (ok != here) {
            endPos=ok;
            above=okAscent;
            below=okDescent;
            top=okTop;
            bottom=okBottom;
            currentTextWidth=okWidth;
            moreChars=(j + 1 < spanEnd);
          }
 else           if (fit != here) {
            endPos=fit;
            above=fitAscent;
            below=fitDescent;
            top=fitTop;
            bottom=fitBottom;
            currentTextWidth=fitWidth;
            moreChars=(j + 1 < spanEnd);
          }
 else {
            endPos=here + 1;
            while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
              endPos++;
            }
            above=fmAscent;
            below=fmDescent;
            top=fmTop;
            bottom=fmBottom;
            currentTextWidth=widths[here - paraStart];
            moreChars=(endPos < spanEnd);
          }
          v=out(source,here,endPos,above,below,top,bottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,currentTextWidth,paint,moreChars);
          here=endPos;
          j=here - 1;
          ok=fit=here;
          w=0;
          fitAscent=fitDescent=fitTop=fitBottom=0;
          okAscent=okDescent=okTop=okBottom=0;
          if (--firstWidthLineLimit <= 0) {
            width=restWidth;
          }
          if (here < spanStart) {
            measured.setPos(here);
            spanEnd=here;
            break;
          }
          if (mLineCount >= mMaximumVisibleLineCount) {
            return;
          }
        }
      }
    }
    if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
      if ((fitTop | fitBottom | fitDescent| fitAscent) == 0) {
        paint.getFontMetricsInt(fm);
        fitTop=fm.top;
        fitBottom=fm.bottom;
        fitAscent=fm.ascent;
        fitDescent=fm.descent;
      }
      v=out(source,here,paraEnd,fitAscent,fitDescent,fitTop,fitBottom,v,spacingmult,spacingadd,chooseHt,chooseHtv,fm,hasTabOrEmoji,needMultiply,chdirs,dir,easy,bufEnd,includepad,trackpad,chs,widths,paraStart,ellipsize,ellipsizedWidth,w,paint,paraEnd != bufEnd);
    }
    paraStart=paraEnd;
    if (paraEnd == bufEnd)     break;
  }
  if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
    measured.setPara(source,bufStart,bufEnd,textDir);
    paint.getFontMetricsInt(fm);
    v=out(source,bufEnd,bufEnd,fm.ascent,fm.descent,fm.top,fm.bottom,v,spacingmult,spacingadd,null,null,fm,false,needMultiply,measured.mLevels,measured.mDir,measured.mEasy,bufEnd,includepad,trackpad,null,null,bufStart,ellipsize,ellipsizedWidth,0,paint,false);
  }
}
