{
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseht != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseht.length; i++) {
      chooseht[i].chooseHeight(text,start,end,choosehtv[i],v,fm);
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackpad) {
      mTopPadding=top - above;
    }
    if (includepad) {
      above=top;
    }
  }
  if (last) {
    if (trackpad) {
      mBottomPadding=bottom - below;
    }
    if (includepad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    extra=(int)((below - above) * (spacingmult - 1) + spacingadd + 0.5);
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (tab)   lines[off + TAB]|=TAB_MASK;
{
    lines[off + DIR]|=dir << DIR_SHIFT;
    int cur=Character.DIRECTIONALITY_LEFT_TO_RIGHT;
    int count=0;
    if (!easy) {
      for (int k=start; k < end; k++) {
        if (chdirs[k - pstart] != cur) {
          count++;
          cur=chdirs[k - pstart];
        }
      }
    }
    Directions linedirs;
    if (count == 0) {
      linedirs=DIRS_ALL_LEFT_TO_RIGHT;
    }
 else {
      short[] ld=new short[count + 1];
      cur=Character.DIRECTIONALITY_LEFT_TO_RIGHT;
      count=0;
      int here=start;
      for (int k=start; k < end; k++) {
        if (chdirs[k - pstart] != cur) {
          ld[count++]=(short)(k - here);
          cur=chdirs[k - pstart];
          here=k;
        }
      }
      ld[count]=(short)(end - here);
      if (count == 1 && ld[0] == 0) {
        linedirs=DIRS_ALL_RIGHT_TO_LEFT;
      }
 else {
        linedirs=new Directions(ld);
      }
    }
    mLineDirections[j]=linedirs;
    if (ellipsize != null && (ellipsize != TextUtils.TruncateAt.MARQUEE || j != 0)) {
      calculateEllipsis(start,end,widths,widstart,widoff,ellipsiswidth,ellipsize,j,textwidth,paint);
    }
  }
  mLineCount++;
  return v;
}
