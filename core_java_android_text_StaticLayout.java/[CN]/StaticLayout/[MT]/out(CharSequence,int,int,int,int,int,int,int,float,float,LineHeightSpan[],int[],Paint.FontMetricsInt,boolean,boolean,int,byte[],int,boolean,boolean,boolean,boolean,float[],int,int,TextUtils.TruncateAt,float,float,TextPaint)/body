{
  int j=mLineCount;
  int off=j * mColumns;
  int want=off + mColumns + TOP;
  int[] lines=mLines;
  if (want >= lines.length) {
    int nlen=ArrayUtils.idealIntArraySize(want + 1);
    int[] grow=new int[nlen];
    System.arraycopy(lines,0,grow,0,lines.length);
    mLines=grow;
    lines=grow;
    Directions[] grow2=new Directions[nlen];
    System.arraycopy(mLineDirections,0,grow2,0,mLineDirections.length);
    mLineDirections=grow2;
  }
  if (chooseht != null) {
    fm.ascent=above;
    fm.descent=below;
    fm.top=top;
    fm.bottom=bottom;
    for (int i=0; i < chooseht.length; i++) {
      if (chooseht[i] instanceof LineHeightSpan.WithDensity) {
        ((LineHeightSpan.WithDensity)chooseht[i]).chooseHeight(text,start,end,choosehtv[i],v,fm,paint);
      }
 else {
        chooseht[i].chooseHeight(text,start,end,choosehtv[i],v,fm);
      }
    }
    above=fm.ascent;
    below=fm.descent;
    top=fm.top;
    bottom=fm.bottom;
  }
  if (j == 0) {
    if (trackpad) {
      mTopPadding=top - above;
    }
    if (includepad) {
      above=top;
    }
  }
  if (last) {
    if (trackpad) {
      mBottomPadding=bottom - below;
    }
    if (includepad) {
      below=bottom;
    }
  }
  int extra;
  if (needMultiply) {
    double ex=(below - above) * (spacingmult - 1) + spacingadd;
    if (ex >= 0) {
      extra=(int)(ex + 0.5);
    }
 else {
      extra=-(int)(-ex + 0.5);
    }
  }
 else {
    extra=0;
  }
  lines[off + START]=start;
  lines[off + TOP]=v;
  lines[off + DESCENT]=below + extra;
  v+=(below - above) + extra;
  lines[off + mColumns + START]=end;
  lines[off + mColumns + TOP]=v;
  if (tab)   lines[off + TAB]|=TAB_MASK;
  lines[off + DIR]|=dir << DIR_SHIFT;
  Directions linedirs=DIRS_ALL_LEFT_TO_RIGHT;
  if (easy) {
    mLineDirections[j]=linedirs;
  }
 else {
    int startOff=start - pstart;
    int baseLevel=dir == DIR_LEFT_TO_RIGHT ? 0 : 1;
    int curLevel=chdirs[startOff];
    int minLevel=curLevel;
    int runCount=1;
    for (int i=start + 1; i < end; ++i) {
      int level=chdirs[i - pstart];
      if (level != curLevel) {
        curLevel=level;
        ++runCount;
      }
    }
    int visEnd=end;
    if ((curLevel & 1) != (baseLevel & 1)) {
      while (--visEnd >= start) {
        char ch=text.charAt(visEnd);
        if (ch == '\n') {
          --visEnd;
          break;
        }
        if (ch != ' ' && ch != '\t') {
          break;
        }
      }
      ++visEnd;
      if (visEnd != end) {
        ++runCount;
      }
    }
    if (runCount == 1 && minLevel == baseLevel) {
      if ((minLevel & 1) != 0) {
        linedirs=DIRS_ALL_RIGHT_TO_LEFT;
      }
    }
 else {
      int[] ld=new int[runCount * 2];
      int maxLevel=minLevel;
      int levelBits=minLevel << RUN_LEVEL_SHIFT;
{
        int n=1;
        int prev=start;
        curLevel=minLevel;
        for (int i=start; i < visEnd; ++i) {
          int level=chdirs[i - pstart];
          if (level != curLevel) {
            curLevel=level;
            if (level > maxLevel) {
              maxLevel=level;
            }
 else             if (level < minLevel) {
              minLevel=level;
            }
            ld[n++]=(i - prev) | levelBits;
            ld[n++]=i - start;
            levelBits=curLevel << RUN_LEVEL_SHIFT;
            prev=i;
          }
        }
        ld[n]=(visEnd - prev) | levelBits;
        if (visEnd < end) {
          ld[++n]=visEnd - start;
          ld[++n]=(end - visEnd) | (baseLevel << RUN_LEVEL_SHIFT);
        }
      }
      boolean swap;
      if ((minLevel & 1) == baseLevel) {
        minLevel+=1;
        swap=maxLevel > minLevel;
      }
 else {
        swap=runCount > 1;
      }
      if (swap) {
        for (int level=maxLevel - 1; level >= minLevel; --level) {
          for (int i=0; i < ld.length; i+=2) {
            if (chdirs[startOff + ld[i]] >= level) {
              int e=i + 2;
              while (e < ld.length && chdirs[startOff + ld[e]] >= level) {
                e+=2;
              }
              for (int low=i, hi=e - 2; low < hi; low+=2, hi-=2) {
                int x=ld[low];
                ld[low]=ld[hi];
                ld[hi]=x;
                x=ld[low + 1];
                ld[low + 1]=ld[hi + 1];
                ld[hi + 1]=x;
              }
              i=e + 2;
            }
          }
        }
      }
      linedirs=new Directions(ld);
    }
    mLineDirections[j]=linedirs;
    if (ellipsize != null && (ellipsize != TextUtils.TruncateAt.MARQUEE || j != 0)) {
      calculateEllipsis(start,end,widths,widstart,widoff,ellipsiswidth,ellipsize,j,textwidth,paint);
    }
  }
  mLineCount++;
  return v;
}
