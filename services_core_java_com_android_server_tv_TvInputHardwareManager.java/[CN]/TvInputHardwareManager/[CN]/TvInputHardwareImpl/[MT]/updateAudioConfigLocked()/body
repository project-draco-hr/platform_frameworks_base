{
  boolean sinkUpdated=updateAudioSinkLocked();
  boolean sourceUpdated=updateAudioSourceLocked();
  if (mAudioSource == null || mAudioSink == null || mActiveConfig == null) {
    if (mAudioPatch != null) {
      mAudioManager.releaseAudioPatch(mAudioPatch);
      mAudioPatch=null;
    }
    return;
  }
  updateVolume();
  float volume=mSourceVolume * getMediaStreamVolume();
  AudioGainConfig sourceGainConfig=null;
  if (mAudioSource.gains().length > 0 && volume != mCommittedVolume) {
    AudioGain sourceGain=null;
    for (    AudioGain gain : mAudioSource.gains()) {
      if ((gain.mode() & AudioGain.MODE_JOINT) != 0) {
        sourceGain=gain;
        break;
      }
    }
    if (sourceGain != null) {
      int steps=(sourceGain.maxValue() - sourceGain.minValue()) / sourceGain.stepValue();
      int gainValue=sourceGain.minValue();
      if (volume < 1.0f) {
        gainValue+=sourceGain.stepValue() * (int)(volume * steps + 0.5);
      }
 else {
        gainValue=sourceGain.maxValue();
      }
      int[] gainValues=new int[]{gainValue};
      sourceGainConfig=sourceGain.buildConfig(AudioGain.MODE_JOINT,sourceGain.channelMask(),gainValues,0);
    }
 else {
      Slog.w(TAG,"No audio source gain with MODE_JOINT support exists.");
    }
  }
  AudioPortConfig sourceConfig=mAudioSource.activeConfig();
  AudioPortConfig sinkConfig=mAudioSink.activeConfig();
  AudioPatch[] audioPatchArray=new AudioPatch[]{mAudioPatch};
  boolean shouldRecreateAudioPatch=sourceUpdated || sinkUpdated;
  int sinkSamplingRate=mDesiredSamplingRate;
  int sinkChannelMask=mDesiredChannelMask;
  int sinkFormat=mDesiredFormat;
  if (sinkConfig != null) {
    if (sinkSamplingRate == 0) {
      sinkSamplingRate=sinkConfig.samplingRate();
    }
    if (sinkChannelMask == AudioFormat.CHANNEL_OUT_DEFAULT) {
      sinkChannelMask=sinkConfig.channelMask();
    }
    if (sinkFormat == AudioFormat.ENCODING_DEFAULT) {
      sinkChannelMask=sinkConfig.format();
    }
  }
  if (sinkConfig == null || sinkConfig.samplingRate() != sinkSamplingRate || sinkConfig.channelMask() != sinkChannelMask || sinkConfig.format() != sinkFormat) {
    if (!intArrayContains(mAudioSink.samplingRates(),sinkSamplingRate) && mAudioSink.samplingRates().length > 0) {
      sinkSamplingRate=mAudioSink.samplingRates()[0];
    }
    if (!intArrayContains(mAudioSink.channelMasks(),sinkChannelMask)) {
      sinkChannelMask=AudioFormat.CHANNEL_OUT_DEFAULT;
    }
    if (!intArrayContains(mAudioSink.formats(),sinkFormat)) {
      sinkFormat=AudioFormat.ENCODING_DEFAULT;
    }
    sinkConfig=mAudioSink.buildConfig(sinkSamplingRate,sinkChannelMask,sinkFormat,null);
    shouldRecreateAudioPatch=true;
  }
  if (sourceConfig == null || sourceGainConfig != null) {
    int sourceSamplingRate=0;
    if (intArrayContains(mAudioSource.samplingRates(),sinkConfig.samplingRate())) {
      sourceSamplingRate=sinkConfig.samplingRate();
    }
 else     if (mAudioSource.samplingRates().length > 0) {
      sourceSamplingRate=mAudioSource.samplingRates()[0];
    }
    int sourceChannelMask=AudioFormat.CHANNEL_IN_DEFAULT;
    for (    int inChannelMask : mAudioSource.channelMasks()) {
      if (AudioFormat.channelCountFromOutChannelMask(sinkConfig.channelMask()) == AudioFormat.channelCountFromInChannelMask(inChannelMask)) {
        sourceChannelMask=inChannelMask;
        break;
      }
    }
    int sourceFormat=AudioFormat.ENCODING_DEFAULT;
    if (intArrayContains(mAudioSource.formats(),sinkConfig.format())) {
      sourceFormat=sinkConfig.format();
    }
    sourceConfig=mAudioSource.buildConfig(sourceSamplingRate,sourceChannelMask,sourceFormat,sourceGainConfig);
    shouldRecreateAudioPatch=true;
  }
  if (shouldRecreateAudioPatch) {
    mCommittedVolume=volume;
    mAudioManager.createAudioPatch(audioPatchArray,new AudioPortConfig[]{sourceConfig},new AudioPortConfig[]{sinkConfig});
    mAudioPatch=audioPatchArray[0];
    if (sourceGainConfig != null) {
      mAudioManager.setAudioPortGain(mAudioSource,sourceGainConfig);
    }
  }
}
