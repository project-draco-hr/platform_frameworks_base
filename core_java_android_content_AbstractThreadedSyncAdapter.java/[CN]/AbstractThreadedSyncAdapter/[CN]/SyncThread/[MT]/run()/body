{
  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  if (isCanceled()) {
    return;
  }
  SyncResult syncResult=new SyncResult();
  int uid=Process.myUid();
  mInitialTxBytes=TrafficStats.getUidTxBytes(uid);
  mInitialRxBytes=TrafficStats.getUidRxBytes(uid);
  ContentProviderClient provider=null;
  try {
    provider=mContext.getContentResolver().acquireContentProviderClient(mAuthority);
    if (provider != null) {
      AbstractThreadedSyncAdapter.this.onPerformSync(mAccount,mExtras,mAuthority,provider,syncResult);
    }
 else {
      syncResult.databaseError=true;
    }
  }
  finally {
    if (provider != null) {
      provider.release();
    }
    if (!isCanceled()) {
      mSyncContext.onFinished(syncResult);
    }
    onLogSyncDetails(TrafficStats.getUidTxBytes(uid) - mInitialTxBytes,TrafficStats.getUidRxBytes(uid) - mInitialRxBytes,syncResult);
synchronized (mSyncThreadLock) {
      mSyncThread=null;
    }
  }
}
