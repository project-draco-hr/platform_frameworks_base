{
  int callerUid=UserHandle.getCallingUserId();
  int myUid=UserHandle.myUserId();
  if (VDBG) {
    log("listen sl: E pkg=" + pkgForDebug + " events=0x"+ Integer.toHexString(events)+ " myUid="+ myUid+ " callerUid="+ callerUid+ " callback="+ callback+ " callback.asBinder="+ callback.asBinder());
  }
  if (events != 0) {
    checkSubscriptionListenerPermission(events);
    Record r=null;
synchronized (mRecords) {
      find_and_add: {
        IBinder b=callback.asBinder();
        final int N=mRecords.size();
        for (int i=0; i < N; i++) {
          r=mRecords.get(i);
          if (b == r.binder) {
            break find_and_add;
          }
        }
        r=new Record();
        r.binder=b;
        mRecords.add(r);
        if (DBG)         log("listen sl: add new record");
      }
      r.subscriptionListenerCallback=callback;
      r.pkgForDebug=pkgForDebug;
      r.callerUid=callerUid;
      r.events=events;
      if (DBG) {
        log("listen sl:  Register r=" + r);
      }
    }
    if (r.matchSubscriptionListenerEvent(SubscriptionListener.LISTEN_SUBSCRIPTION_INFO_LIST_CHANGED)) {
      try {
        if (VDBG)         log("listen sl: send to r=" + r);
        r.subscriptionListenerCallback.onSubscriptionInfoChanged();
        if (VDBG)         log("listen sl: sent to r=" + r);
      }
 catch (      RemoteException e) {
        if (VDBG)         log("listen sl: remote exception sending to r=" + r + " e="+ e);
        remove(r.binder);
      }
    }
  }
 else {
    if (DBG)     log("listen sl: Unregister as event is LISTEN_NONE");
    unregisterSubscriptionListener(pkgForDebug,callback);
  }
}
