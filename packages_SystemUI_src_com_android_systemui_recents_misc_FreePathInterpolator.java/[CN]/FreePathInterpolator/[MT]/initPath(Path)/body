{
  float[] pointComponents=path.approximate(PRECISION);
  int numPoints=pointComponents.length / 3;
  mX=new float[numPoints];
  mY=new float[numPoints];
  mArcLength=0;
  float prevX=0;
  float prevY=0;
  float prevFraction=0;
  int componentIndex=0;
  for (int i=0; i < numPoints; i++) {
    float fraction=pointComponents[componentIndex++];
    float x=pointComponents[componentIndex++];
    float y=pointComponents[componentIndex++];
    if (fraction == prevFraction && x != prevX) {
      throw new IllegalArgumentException("The Path cannot have discontinuity in the X axis.");
    }
    if (x < prevX) {
      throw new IllegalArgumentException("The Path cannot loop back on itself.");
    }
    mX[i]=x;
    mY[i]=y;
    mArcLength+=Math.hypot(x - prevX,y - prevY);
    prevX=x;
    prevY=y;
    prevFraction=fraction;
  }
}
