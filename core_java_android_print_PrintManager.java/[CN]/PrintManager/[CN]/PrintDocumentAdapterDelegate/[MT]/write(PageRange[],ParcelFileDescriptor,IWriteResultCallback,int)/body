{
  final boolean destroyed;
synchronized (mLock) {
    destroyed=mDestroyed;
    if (mStartReqeusted && !mFinishRequested && !mDestroyed) {
      if (mLastWriteSpec != null) {
        IoUtils.closeQuietly(mLastWriteSpec.fd);
        mLastWriteSpec=null;
      }
      mLastWriteSpec=new WriteSpec();
      mLastWriteSpec.callback=callback;
      mLastWriteSpec.pages=pages;
      mLastWriteSpec.fd=fd;
      mLastWriteSpec.sequence=sequence;
      if (cancelPreviousCancellableOperationLocked()) {
        return;
      }
      doPendingWorkLocked();
    }
  }
  if (destroyed) {
    try {
      callback.onWriteFailed(null,sequence);
    }
 catch (    RemoteException re) {
      Log.i(LOG_TAG,"Error notifying for cancelled write",re);
    }
  }
}
