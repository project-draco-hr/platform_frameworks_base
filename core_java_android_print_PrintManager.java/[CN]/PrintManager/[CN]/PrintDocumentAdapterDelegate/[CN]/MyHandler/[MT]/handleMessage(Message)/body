{
  if (isFinished()) {
    return;
  }
switch (message.what) {
case MSG_START:
{
      mDocumentAdapter.onStart();
    }
  break;
case MSG_LAYOUT:
{
  SomeArgs args=(SomeArgs)message.obj;
  final PrintAttributes oldAttributes=(PrintAttributes)args.arg1;
  final PrintAttributes newAttributes=(PrintAttributes)args.arg2;
  final ILayoutResultCallback callback=(ILayoutResultCallback)args.arg3;
  final Bundle metadata=(Bundle)args.arg4;
  final int sequence=args.argi1;
  args.recycle();
  CancellationSignal cancellation=new CancellationSignal();
synchronized (mLock) {
    mLayoutOrWriteCancellation=cancellation;
  }
  mDocumentAdapter.onLayout(oldAttributes,newAttributes,cancellation,new LayoutResultCallback(){
    @Override public void onLayoutFinished(    PrintDocumentInfo info,    boolean changed){
      if (info == null) {
        throw new IllegalArgumentException("info cannot be null");
      }
synchronized (mLock) {
        mLayoutOrWriteCancellation=null;
      }
      try {
        callback.onLayoutFinished(info,changed,sequence);
      }
 catch (      RemoteException re) {
        Log.e(LOG_TAG,"Error calling onLayoutFinished",re);
      }
    }
    @Override public void onLayoutFailed(    CharSequence error){
synchronized (mLock) {
        mLayoutOrWriteCancellation=null;
      }
      try {
        callback.onLayoutFailed(error,sequence);
      }
 catch (      RemoteException re) {
        Log.e(LOG_TAG,"Error calling onLayoutFailed",re);
      }
    }
    @Override public void onLayoutCancelled(){
synchronized (mLock) {
        mLayoutOrWriteCancellation=null;
      }
    }
  }
,metadata);
}
break;
case MSG_WRITE:
{
SomeArgs args=(SomeArgs)message.obj;
final PageRange[] pages=(PageRange[])args.arg1;
final FileDescriptor fd=(FileDescriptor)args.arg2;
final IWriteResultCallback callback=(IWriteResultCallback)args.arg3;
final int sequence=args.argi1;
args.recycle();
CancellationSignal cancellation=new CancellationSignal();
synchronized (mLock) {
mLayoutOrWriteCancellation=cancellation;
}
mDocumentAdapter.onWrite(pages,fd,cancellation,new WriteResultCallback(){
@Override public void onWriteFinished(PageRange[] pages){
  if (pages == null) {
    throw new IllegalArgumentException("pages cannot be null");
  }
  if (pages.length == 0) {
    throw new IllegalArgumentException("pages cannot be empty");
  }
synchronized (mLock) {
    mLayoutOrWriteCancellation=null;
  }
  IoUtils.closeQuietly(fd);
  try {
    callback.onWriteFinished(pages,sequence);
  }
 catch (  RemoteException re) {
    Log.e(LOG_TAG,"Error calling onWriteFinished",re);
  }
}
@Override public void onWriteFailed(CharSequence error){
synchronized (mLock) {
    mLayoutOrWriteCancellation=null;
  }
  IoUtils.closeQuietly(fd);
  try {
    callback.onWriteFailed(error,sequence);
  }
 catch (  RemoteException re) {
    Log.e(LOG_TAG,"Error calling onWriteFailed",re);
  }
}
@Override public void onWriteCancelled(){
synchronized (mLock) {
    mLayoutOrWriteCancellation=null;
  }
  IoUtils.closeQuietly(fd);
}
}
);
}
break;
case MSG_FINISH:
{
mDocumentAdapter.onFinish();
doFinish();
}
break;
default :
{
throw new IllegalArgumentException("Unknown message: " + message.what);
}
}
}
