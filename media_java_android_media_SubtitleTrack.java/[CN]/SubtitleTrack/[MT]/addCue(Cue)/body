{
  mCues.add(cue);
  if (cue.mRunID != 0) {
    Run run=mRunsByID.get(cue.mRunID);
    if (run == null) {
      run=new Run();
      mRunsByID.put(cue.mRunID,run);
      run.mEndTimeMs=cue.mEndTimeMs;
    }
 else     if (run.mEndTimeMs < cue.mEndTimeMs) {
      run.mEndTimeMs=cue.mEndTimeMs;
    }
    cue.mNextInRun=run.mFirstCue;
    run.mFirstCue=cue;
  }
  long nowMs=-1;
  if (mTimeProvider != null) {
    try {
      nowMs=mTimeProvider.getCurrentTimeUs(false,true) / 1000;
    }
 catch (    IllegalStateException e) {
    }
  }
  if (DEBUG)   Log.v(TAG,"mVisible=" + mVisible + ", "+ cue.mStartTimeMs+ " <= "+ nowMs+ ", "+ cue.mEndTimeMs+ " >= "+ mLastTimeMs);
  if (mVisible && cue.mStartTimeMs <= nowMs && cue.mEndTimeMs >= mLastTimeMs) {
    if (mRunnable != null) {
      mHandler.removeCallbacks(mRunnable);
    }
    final SubtitleTrack track=this;
    final long thenMs=nowMs;
    mRunnable=new Runnable(){
      @Override public void run(){
synchronized (track) {
          mRunnable=null;
          updateActiveCues(true,thenMs);
          updateView(mActiveCues);
        }
      }
    }
;
    if (mHandler.postDelayed(mRunnable,10)) {
      if (DEBUG)       Log.v(TAG,"scheduling update");
    }
 else {
      if (DEBUG)       Log.w(TAG,"failed to schedule subtitle view update");
    }
    return true;
  }
  if (mVisible && cue.mEndTimeMs >= mLastTimeMs && (cue.mStartTimeMs < mNextScheduledTimeMs || mNextScheduledTimeMs < 0)) {
    scheduleTimedEvents();
  }
  return false;
}
