{
  final boolean isAffiliated=task.mAffiliatedTaskId != task.taskId || task.mNextAffiliateTaskId != -1 || task.mPrevAffiliateTaskId != -1;
  int N=mRecentTasks.size();
  if (!isAffiliated && N > 0 && mRecentTasks.get(0) == task) {
    if (DEBUG_RECENTS)     Slog.d(TAG,"addRecent: already at top: " + task);
    return;
  }
  if (isAffiliated && N > 0 && task.inRecents && task.mAffiliatedTaskId == mRecentTasks.get(0).mAffiliatedTaskId) {
    if (DEBUG_RECENTS)     Slog.d(TAG,"addRecent: affiliated " + mRecentTasks.get(0) + " at top when adding "+ task);
    return;
  }
  if (task.voiceSession != null) {
    if (DEBUG_RECENTS)     Slog.d(TAG,"addRecent: not adding voice interaction " + task);
    return;
  }
  boolean needAffiliationFix=false;
  if (task.inRecents) {
    int taskIndex=mRecentTasks.indexOf(task);
    if (taskIndex >= 0) {
      if (!isAffiliated) {
        mRecentTasks.remove(taskIndex);
        mRecentTasks.add(0,task);
        notifyTaskPersisterLocked(task,false);
        if (DEBUG_RECENTS)         Slog.d(TAG,"addRecent: moving to top " + task + " from "+ taskIndex);
        return;
      }
 else {
        if (moveAffiliatedTasksToFront(task,taskIndex)) {
          return;
        }
        needAffiliationFix=true;
      }
    }
 else {
      Slog.wtf(TAG,"Task with inRecent not in recents: " + task);
      needAffiliationFix=true;
    }
  }
  if (DEBUG_RECENTS)   Slog.d(TAG,"addRecent: trimming tasks for " + task);
  trimRecentsForTaskLocked(task,true);
  N=mRecentTasks.size();
  while (N >= ActivityManager.getMaxRecentTasksStatic()) {
    final TaskRecord tr=mRecentTasks.remove(N - 1);
    tr.removedFromRecents();
    N--;
  }
  task.inRecents=true;
  if (!isAffiliated || needAffiliationFix) {
    mRecentTasks.add(0,task);
  }
 else   if (isAffiliated) {
    TaskRecord other=task.mNextAffiliate;
    if (other == null) {
      other=task.mPrevAffiliate;
    }
    if (other != null) {
      int otherIndex=mRecentTasks.indexOf(other);
      if (otherIndex >= 0) {
        int taskIndex;
        if (other == task.mNextAffiliate) {
          taskIndex=otherIndex + 1;
        }
 else {
          taskIndex=otherIndex;
        }
        if (DEBUG_RECENTS)         Slog.d(TAG,"addRecent: new affiliated task added at " + taskIndex + ": "+ task);
        mRecentTasks.add(taskIndex,task);
        if (moveAffiliatedTasksToFront(task,taskIndex)) {
          return;
        }
        needAffiliationFix=true;
      }
 else {
        if (DEBUG_RECENTS)         Slog.d(TAG,"addRecent: couldn't find other affiliation " + other);
        needAffiliationFix=true;
      }
    }
 else {
      if (DEBUG_RECENTS)       Slog.d(TAG,"addRecent: adding affiliated task without next/prev:" + task);
      needAffiliationFix=true;
    }
  }
  if (DEBUG_RECENTS)   Slog.d(TAG,"addRecent: adding " + task);
  if (needAffiliationFix) {
    if (DEBUG_RECENTS)     Slog.d(TAG,"addRecent: regrouping affiliations");
    cleanupRecentTasksLocked(task.userId);
  }
}
