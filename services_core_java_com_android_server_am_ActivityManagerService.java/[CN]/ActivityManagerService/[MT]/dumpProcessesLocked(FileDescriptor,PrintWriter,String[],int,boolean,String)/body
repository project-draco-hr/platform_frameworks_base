{
  boolean needSep=false;
  boolean printedAnything=false;
  int numPers=0;
  pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
  if (dumpAll) {
    final int NP=mProcessNames.getMap().size();
    for (int ip=0; ip < NP; ip++) {
      SparseArray<ProcessRecord> procs=mProcessNames.getMap().valueAt(ip);
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        ProcessRecord r=procs.valueAt(ia);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!needSep) {
          pw.println("  All known processes:");
          needSep=true;
          printedAnything=true;
        }
        pw.print(r.persistent ? "  *PERS*" : "  *APP*");
        pw.print(" UID ");
        pw.print(procs.keyAt(ia));
        pw.print(" ");
        pw.println(r);
        r.dump(pw,"    ");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mIsolatedProcesses.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mIsolatedProcesses.size(); i++) {
      ProcessRecord r=mIsolatedProcesses.valueAt(i);
      if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
        continue;
      }
      if (!printed) {
        if (needSep) {
          pw.println();
        }
        pw.println("  Isolated process list (sorted by uid):");
        printedAnything=true;
        printed=true;
        needSep=true;
      }
      pw.println(String.format("%sIsolated #%2d: %s","    ",i,r.toString()));
    }
  }
  if (mActiveUids.size() > 0) {
    if (needSep) {
      pw.println();
    }
    pw.println("  UID states:");
    for (int i=0; i < mActiveUids.size(); i++) {
      UidRecord uidRec=mActiveUids.valueAt(i);
      pw.print("    UID ");
      UserHandle.formatUid(pw,uidRec.uid);
      pw.print(": ");
      pw.println(uidRec);
    }
    needSep=true;
    printedAnything=true;
  }
  if (mLruProcesses.size() > 0) {
    if (needSep) {
      pw.println();
    }
    pw.print("  Process LRU list (sorted by oom_adj, ");
    pw.print(mLruProcesses.size());
    pw.print(" total, non-act at ");
    pw.print(mLruProcesses.size() - mLruProcessActivityStart);
    pw.print(", non-svc at ");
    pw.print(mLruProcesses.size() - mLruProcessServiceStart);
    pw.println("):");
    dumpProcessOomList(pw,this,mLruProcesses,"    ","Proc","PERS",false,dumpPackage);
    needSep=true;
    printedAnything=true;
  }
  if (dumpAll || dumpPackage != null) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.valueAt(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println("  PID mappings:");
          printed=true;
          printedAnything=true;
        }
        pw.print("    PID #");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(": ");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mForegroundProcesses.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println("  Foreground Processes:");
          printed=true;
          printedAnything=true;
        }
        pw.print("    PID #");
        pw.print(mForegroundProcesses.keyAt(i));
        pw.print(": ");
        pw.println(mForegroundProcesses.valueAt(i));
      }
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println("  Persisent processes that are starting:");
    dumpProcessList(pw,this,mPersistentStartingProcesses,"    ","Starting Norm","Restarting PERS",dumpPackage);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println("  Processes that are being removed:");
    dumpProcessList(pw,this,mRemovedProcesses,"    ","Removed Norm","Removed PERS",dumpPackage);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println("  Processes that are on old until the system is ready:");
    dumpProcessList(pw,this,mProcessesOnHold,"    ","OnHold Norm","OnHold PERS",dumpPackage);
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll,dumpPackage);
  if (mProcessCrashTimes.getMap().size() > 0) {
    boolean printed=false;
    long now=SystemClock.uptimeMillis();
    final ArrayMap<String,SparseArray<Long>> pmap=mProcessCrashTimes.getMap();
    final int NP=pmap.size();
    for (int ip=0; ip < NP; ip++) {
      String pname=pmap.keyAt(ip);
      SparseArray<Long> uids=pmap.valueAt(ip);
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        int puid=uids.keyAt(i);
        ProcessRecord r=mProcessNames.get(pname,puid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println("  Time since processes crashed:");
          printed=true;
          printedAnything=true;
        }
        pw.print("    Process ");
        pw.print(pname);
        pw.print(" uid ");
        pw.print(puid);
        pw.print(": last crashed ");
        TimeUtils.formatDuration(now - uids.valueAt(i),pw);
        pw.println(" ago");
      }
    }
  }
  if (mBadProcesses.getMap().size() > 0) {
    boolean printed=false;
    final ArrayMap<String,SparseArray<BadProcessInfo>> pmap=mBadProcesses.getMap();
    final int NP=pmap.size();
    for (int ip=0; ip < NP; ip++) {
      String pname=pmap.keyAt(ip);
      SparseArray<BadProcessInfo> uids=pmap.valueAt(ip);
      final int N=uids.size();
      for (int i=0; i < N; i++) {
        int puid=uids.keyAt(i);
        ProcessRecord r=mProcessNames.get(pname,puid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println("  Bad processes:");
          printedAnything=true;
        }
        BadProcessInfo info=uids.valueAt(i);
        pw.print("    Bad process ");
        pw.print(pname);
        pw.print(" uid ");
        pw.print(puid);
        pw.print(": crashed at time ");
        pw.println(info.time);
        if (info.shortMsg != null) {
          pw.print("      Short msg: ");
          pw.println(info.shortMsg);
        }
        if (info.longMsg != null) {
          pw.print("      Long msg: ");
          pw.println(info.longMsg);
        }
        if (info.stack != null) {
          pw.println("      Stack:");
          int lastPos=0;
          for (int pos=0; pos < info.stack.length(); pos++) {
            if (info.stack.charAt(pos) == '\n') {
              pw.print("        ");
              pw.write(info.stack,lastPos,pos - lastPos);
              pw.println();
              lastPos=pos + 1;
            }
          }
          if (lastPos < info.stack.length()) {
            pw.print("        ");
            pw.write(info.stack,lastPos,info.stack.length() - lastPos);
            pw.println();
          }
        }
      }
    }
  }
  if (dumpPackage == null) {
    pw.println();
    needSep=false;
    mUserController.dump(pw,dumpAll);
  }
  if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println("  mHomeProcess: " + mHomeProcess);
  }
  if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println("  mPreviousProcess: " + mPreviousProcess);
  }
  if (dumpAll) {
    StringBuilder sb=new StringBuilder(128);
    sb.append("  mPreviousProcessVisibleTime: ");
    TimeUtils.formatDuration(mPreviousProcessVisibleTime,sb);
    pw.println(sb);
  }
  if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
  }
  if (dumpPackage == null) {
    pw.println("  mConfiguration: " + mConfiguration);
  }
  if (dumpAll) {
    pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
    if (mCompatModePackages.getPackages().size() > 0) {
      boolean printed=false;
      for (      Map.Entry<String,Integer> entry : mCompatModePackages.getPackages().entrySet()) {
        String pkg=entry.getKey();
        int mode=entry.getValue();
        if (dumpPackage != null && !dumpPackage.equals(pkg)) {
          continue;
        }
        if (!printed) {
          pw.println("  mScreenCompatPackages:");
          printed=true;
        }
        pw.print("    ");
        pw.print(pkg);
        pw.print(": ");
        pw.print(mode);
        pw.println();
      }
    }
  }
  if (dumpPackage == null) {
    pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness));
    pw.println("  mSleepTokens=" + mSleepTokens);
    pw.println("  mSleeping=" + mSleeping + " mLockScreenShown="+ lockScreenShownToString());
    pw.println("  mShuttingDown=" + mShuttingDown + " mTestPssMode="+ mTestPssMode);
    if (mRunningVoice != null) {
      pw.println("  mRunningVoice=" + mRunningVoice);
      pw.println("  mVoiceWakeLock" + mVoiceWakeLock);
    }
  }
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println("  mDebugApp=" + mDebugApp + "/orig="+ mOrigDebugApp+ " mDebugTransient="+ mDebugTransient+ " mOrigWaitForDebugger="+ mOrigWaitForDebugger);
    }
  }
  if (mCurAppTimeTracker != null) {
    mCurAppTimeTracker.dumpWithHeader(pw,"  ",true);
  }
  if (mMemWatchProcesses.getMap().size() > 0) {
    pw.println("  Mem watch processes:");
    final ArrayMap<String,SparseArray<Pair<Long,String>>> procs=mMemWatchProcesses.getMap();
    for (int i=0; i < procs.size(); i++) {
      final String proc=procs.keyAt(i);
      final SparseArray<Pair<Long,String>> uids=procs.valueAt(i);
      for (int j=0; j < uids.size(); j++) {
        if (needSep) {
          pw.println();
          needSep=false;
        }
        StringBuilder sb=new StringBuilder();
        sb.append("    ").append(proc).append('/');
        UserHandle.formatUid(sb,uids.keyAt(j));
        Pair<Long,String> val=uids.valueAt(j);
        sb.append(": ");
        DebugUtils.sizeValueToString(val.first,sb);
        if (val.second != null) {
          sb.append(", report to ").append(val.second);
        }
        pw.println(sb.toString());
      }
    }
    pw.print("  mMemWatchDumpProcName=");
    pw.println(mMemWatchDumpProcName);
    pw.print("  mMemWatchDumpFile=");
    pw.println(mMemWatchDumpFile);
    pw.print("  mMemWatchDumpPid=");
    pw.print(mMemWatchDumpPid);
    pw.print(" mMemWatchDumpUid=");
    pw.println(mMemWatchDumpUid);
  }
  if (mTrackAllocationApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println("  mTrackAllocationApp=" + mTrackAllocationApp);
    }
  }
  if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
    if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println("  mProfileApp=" + mProfileApp + " mProfileProc="+ mProfileProc);
      pw.println("  mProfileFile=" + mProfileFile + " mProfileFd="+ mProfileFd);
      pw.println("  mSamplingInterval=" + mSamplingInterval + " mAutoStopProfiler="+ mAutoStopProfiler);
      pw.println("  mProfileType=" + mProfileType);
    }
  }
  if (dumpPackage == null) {
    if (mAlwaysFinishActivities || mController != null) {
      pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mController="+ mController);
    }
    if (dumpAll) {
      pw.println("  Total persistent processes: " + numPers);
      pw.println("  mProcessesReady=" + mProcessesReady + " mSystemReady="+ mSystemReady+ " mBooted="+ mBooted+ " mFactoryTest="+ mFactoryTest);
      pw.println("  mBooting=" + mBooting + " mCallFinishBooting="+ mCallFinishBooting+ " mBootAnimationComplete="+ mBootAnimationComplete);
      pw.print("  mLastPowerCheckRealtime=");
      TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
      pw.println("");
      pw.print("  mLastPowerCheckUptime=");
      TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
      pw.println("");
      pw.println("  mGoingToSleep=" + mStackSupervisor.mGoingToSleep);
      pw.println("  mLaunchingActivity=" + mStackSupervisor.mLaunchingActivity);
      pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq="+ mLruSeq);
      pw.println("  mNumNonCachedProcs=" + mNumNonCachedProcs + " ("+ mLruProcesses.size()+ " total)"+ " mNumCachedHiddenProcs="+ mNumCachedHiddenProcs+ " mNumServiceProcs="+ mNumServiceProcs+ " mNewNumServiceProcs="+ mNewNumServiceProcs);
      pw.println("  mAllowLowerMemLevel=" + mAllowLowerMemLevel + " mLastMemoryLevel"+ mLastMemoryLevel+ " mLastNumProcesses"+ mLastNumProcesses);
      long now=SystemClock.uptimeMillis();
      pw.print("  mLastIdleTime=");
      TimeUtils.formatDuration(now,mLastIdleTime,pw);
      pw.print(" mLowRamSinceLastIdle=");
      TimeUtils.formatDuration(getLowRamTimeSinceIdle(now),pw);
      pw.println();
    }
  }
  if (!printedAnything) {
    pw.println("  (nothing)");
  }
}
