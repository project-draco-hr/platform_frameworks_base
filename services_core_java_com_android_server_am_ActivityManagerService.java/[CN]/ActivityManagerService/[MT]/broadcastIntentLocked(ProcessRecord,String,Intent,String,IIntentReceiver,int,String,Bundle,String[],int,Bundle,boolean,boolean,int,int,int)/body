{
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered="+ ordered+ " userid="+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,"Broadcast " + intent + " not ordered but result callback requested!");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,"broadcast",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,"Skipping broadcast of " + intent + ": user "+ userId+ " is stopped");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg="Permission Denial: " + intent.getAction() + " broadcast from "+ callerPackage+ " (pid="+ callingPid+ ", uid="+ callingUid+ ")"+ " requires "+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,"Remote exception",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action)|| Intent.ACTION_MEDIA_BUTTON.equals(action)|| Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)|| TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action)|| SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
}
 else {
if (callerApp != null) {
Log.wtf(TAG,"Sending non-protected broadcast " + action + " from system "+ callerApp.toShortString()+ " pkg "+ callerPackage,new Throwable());
}
 else {
Log.wtf(TAG,"Sending non-protected broadcast " + action + " from system uid "+ UserHandle.formatUid(callingUid)+ " pkg "+ callerPackage,new Throwable());
}
}
}
 else {
if (isProtectedBroadcast) {
String msg="Permission Denial: not allowed to send broadcast " + action + " from pid="+ callingPid+ ", uid="+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg="Permission Denial: not allowed to send broadcast " + action + " from unknown caller.";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg="Permission Denial: not allowed to send broadcast " + action + " to "+ intent.getComponent().getPackageName()+ " from "+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg="Permission Denial: " + intent.getAction() + " broadcast from "+ callerPackage+ " (pid="+ callingPid+ ", uid="+ callingUid+ ")"+ " requires "+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,"storage unmount");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (removed) {
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? "pkg removed" : "pkg changed");
}
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
if (killProcess) {
killPackageProcessesLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),userId,ProcessList.INVALID_ADJ,false,true,true,false,"change " + ssp);
}
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + " no longer allowed; dropping from " + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg="Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid="+ callingUid+ " requires "+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,"Can't broadcast sticky intent " + intent + " and enforce permissions "+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException("Sticky broadcasts can't target a specific component");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException("Sticky broadcast " + intent + " for user "+ userId+ " conflicts with existing global broadcast");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,"Enqueing broadcast: " + intent.getAction() + " replacePending="+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,"Enqueueing parallel broadcast " + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,"Enqueueing ordered broadcast " + r + ": prev had "+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,"Enqueueing broadcast " + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
