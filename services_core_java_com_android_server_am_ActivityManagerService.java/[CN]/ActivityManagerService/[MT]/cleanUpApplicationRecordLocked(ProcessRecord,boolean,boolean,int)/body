{
  if (index >= 0) {
    removeLruProcessLocked(app);
    ProcessList.remove(app.pid);
  }
  mProcessesToGc.remove(app);
  mPendingPssProcesses.remove(app);
  if (app.crashDialog != null && !app.forceCrashReport) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList(mProcessStats);
  app.unlinkDeathRecipient();
  app.makeInactive(mProcessStats);
  app.waitingToKill=null;
  app.forcingToForeground=null;
  updateProcessForegroundLocked(app,false,false);
  app.foregroundActivities=false;
  app.hasShownUi=false;
  app.treatLikeActivity=false;
  app.hasAboveClient=false;
  app.hasClientActivities=false;
  mServices.killServicesLocked(app,allowRestart);
  boolean restart=false;
  for (int i=app.pubProviders.size() - 1; i >= 0; i--) {
    ContentProviderRecord cpr=app.pubProviders.valueAt(i);
    final boolean always=app.bad || !allowRestart;
    boolean inLaunching=removeDyingProviderLocked(app,cpr,always);
    if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {
      restart=true;
    }
    cpr.provider=null;
    cpr.proc=null;
  }
  app.pubProviders.clear();
  if (cleanupAppInLaunchingProvidersLocked(app,false)) {
    restart=true;
  }
  if (!app.conProviders.isEmpty()) {
    for (int i=app.conProviders.size() - 1; i >= 0; i--) {
      ContentProviderConnection conn=app.conProviders.get(i);
      conn.provider.connections.remove(conn);
      stopAssociationLocked(app.uid,app.processName,conn.provider.uid,conn.provider.name);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=mLaunchingProviders.size() - 1; i >= 0; i--) {
      ContentProviderRecord cpr=mLaunchingProviders.get(i);
      if (cpr.connections.size() <= 0 && !cpr.hasExternalProcessHandles()) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  for (int i=app.receivers.size() - 1; i >= 0; i--) {
    removeReceiverLocked(app.receivers.valueAt(i));
  }
  app.receivers.clear();
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP || DEBUG_CLEANUP)     Slog.d(TAG_CLEANUP,"App " + mBackupTarget.appInfo + " died during backup");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  for (int i=mPendingProcessChanges.size() - 1; i >= 0; i--) {
    ProcessChangeItem item=mPendingProcessChanges.get(i);
    if (item.pid == app.pid) {
      mPendingProcessChanges.remove(i);
      mAvailProcessChanges.add(item);
    }
  }
  mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED,app.pid,app.info.uid,null).sendToTarget();
  if (restarting) {
    return false;
  }
  if (!app.persistent || app.isolated) {
    if (DEBUG_PROCESSES || DEBUG_CLEANUP)     Slog.v(TAG_CLEANUP,"Removing non-persistent process during cleanup: " + app);
    removeProcessNameLocked(app.processName,app.uid);
    if (mHeavyWeightProcess == app) {
      mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,mHeavyWeightProcess.userId,0));
      mHeavyWeightProcess=null;
    }
  }
 else   if (!app.removed) {
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app))   Slog.v(TAG_CLEANUP,"Clean-up removing on hold: " + app);
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (app == mPreviousProcess) {
    mPreviousProcess=null;
  }
  if (restart && !app.isolated) {
    if (index < 0) {
      ProcessList.remove(app.pid);
    }
    addProcessNameLocked(app);
    startProcessLocked(app,"restart",app.processName);
    return true;
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
    boolean removed;
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    mBatteryStatsService.noteProcessFinish(app.processName,app.info.uid);
    if (app.isolated) {
      mBatteryStatsService.removeIsolatedUid(app.uid,app.info.uid);
    }
    app.setPid(0);
  }
  return false;
}
