{
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered="+ ordered+ " userid="+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,"Broadcast " + intent + " not ordered but result callback requested!");
  }
  userId=handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,"broadcast",callerPackage);
  if (userId != UserHandle.USER_ALL && !isUserRunningLocked(userId,false)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,"Skipping broadcast of " + intent + ": user "+ userId+ " is stopped");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  int callingAppId=UserHandle.getAppId(callingUid);
  if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingAppId == Process.NFC_UID || callingUid == 0) {
  }
 else   if (callerApp == null || !callerApp.persistent) {
    try {
      if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
        String msg="Permission Denial: not allowed to send broadcast " + intent.getAction() + " from pid="+ callingPid+ ", uid="+ callingUid;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
 else       if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
        if (callerApp == null) {
          String msg="Permission Denial: not allowed to send broadcast " + intent.getAction() + " from unknown caller.";
          Slog.w(TAG,msg);
          throw new SecurityException(msg);
        }
 else         if (intent.getComponent() != null) {
          if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
            String msg="Permission Denial: not allowed to send broadcast " + intent.getAction() + " to "+ intent.getComponent().getPackageName()+ " from "+ callerApp.info.packageName;
            Slog.w(TAG,msg);
            throw new SecurityException(msg);
          }
        }
 else {
          intent.setPackage(callerApp.info.packageName);
        }
      }
    }
 catch (    RemoteException e) {
      Slog.w(TAG,"Remote exception",e);
      return ActivityManager.BROADCAST_SUCCESS;
    }
  }
  final String action=intent.getAction();
  if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
      if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg="Permission Denial: " + intent.getAction() + " broadcast from "+ callerPackage+ " (pid="+ callingPid+ ", uid="+ callingUid+ ")"+ " requires "+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
switch (action) {
case Intent.ACTION_UID_REMOVED:
      final Bundle intentExtras=intent.getExtras();
    final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
  if (uid >= 0) {
    BatteryStatsImpl bs=mBatteryStatsService.getActiveStatistics();
synchronized (bs) {
      bs.removeUidStatsLocked(uid);
    }
    mAppOpsService.uidRemoved(uid);
  }
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,"storage unmount");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
boolean fullUninstall=removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
if (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false)) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? "pkg removed" : "pkg changed");
}
if (removed) {
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
if (userId == UserHandle.USER_OWNER) {
mTaskPersister.removeFromPackageCache(ssp);
}
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
if (userId == UserHandle.USER_OWNER) {
mTaskPersister.addOtherDeviceTasksToRecentsLocked(ssp);
}
}
}
break;
}
break;
case Intent.ACTION_PACKAGE_ADDED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
if (userId == UserHandle.USER_OWNER) {
mTaskPersister.addOtherDeviceTasksToRecentsLocked(ssp);
}
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg="Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid="+ callingUid+ " requires "+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermission != null) {
Slog.w(TAG,"Can't broadcast sticky intent " + intent + " and enforce permission "+ requiredPermission);
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException("Sticky broadcasts can't target a specific component");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException("Sticky broadcast " + intent + " for user "+ userId+ " conflicts with existing global broadcast");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mStartedUserArray;
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
UserManagerService ums=getUserManagerLocked();
for (int i=0; i < users.length; i++) {
if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,"Enqueing broadcast: " + intent.getAction() + " replacePending="+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,registeredReceivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,"Enqueueing parallel broadcast " + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermission,appOp,receivers,resultTo,resultCode,resultData,map,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,"Enqueueing ordered broadcast " + r + ": prev had "+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,"Enqueueing broadcast " + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}
