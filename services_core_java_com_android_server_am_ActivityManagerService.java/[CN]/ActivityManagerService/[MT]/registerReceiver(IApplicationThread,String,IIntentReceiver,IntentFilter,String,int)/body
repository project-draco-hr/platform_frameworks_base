{
  enforceNotIsolatedCaller("registerReceiver");
  ArrayList<Intent> stickyIntents=null;
  ProcessRecord callerApp=null;
  int callingUid;
  int callingPid;
synchronized (this) {
    if (caller != null) {
      callerApp=getRecordForAppLocked(caller);
      if (callerApp == null) {
        throw new SecurityException("Unable to find app for caller " + caller + " (pid="+ Binder.getCallingPid()+ ") when registering receiver "+ receiver);
      }
      if (callerApp.info.uid != Process.SYSTEM_UID && !callerApp.pkgList.containsKey(callerPackage) && !"android".equals(callerPackage)) {
        throw new SecurityException("Given caller package " + callerPackage + " is not running in process "+ callerApp);
      }
      callingUid=callerApp.info.uid;
      callingPid=callerApp.pid;
    }
 else {
      callerPackage=null;
      callingUid=Binder.getCallingUid();
      callingPid=Binder.getCallingPid();
    }
    userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_FULL_ONLY,"registerReceiver",callerPackage);
    Iterator<String> actions=filter.actionsIterator();
    if (actions == null) {
      ArrayList<String> noAction=new ArrayList<String>(1);
      noAction.add(null);
      actions=noAction.iterator();
    }
    int[] userIds={UserHandle.USER_ALL,UserHandle.getUserId(callingUid)};
    while (actions.hasNext()) {
      String action=actions.next();
      for (      int id : userIds) {
        ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(id);
        if (stickies != null) {
          ArrayList<Intent> intents=stickies.get(action);
          if (intents != null) {
            if (stickyIntents == null) {
              stickyIntents=new ArrayList<Intent>();
            }
            stickyIntents.addAll(intents);
          }
        }
      }
    }
  }
  ArrayList<Intent> allSticky=null;
  if (stickyIntents != null) {
    final ContentResolver resolver=mContext.getContentResolver();
    for (int i=0, N=stickyIntents.size(); i < N; i++) {
      Intent intent=stickyIntents.get(i);
      if (filter.match(resolver,intent,true,TAG) >= 0) {
        if (allSticky == null) {
          allSticky=new ArrayList<Intent>();
        }
        allSticky.add(intent);
      }
    }
  }
  Intent sticky=allSticky != null ? allSticky.get(0) : null;
  if (DEBUG_BROADCAST)   Slog.v(TAG_BROADCAST,"Register receiver " + filter + ": "+ sticky);
  if (receiver == null) {
    return sticky;
  }
synchronized (this) {
    if (callerApp != null && (callerApp.thread == null || callerApp.thread.asBinder() != caller.asBinder())) {
      return null;
    }
    ReceiverList rl=mRegisteredReceivers.get(receiver.asBinder());
    if (rl == null) {
      rl=new ReceiverList(this,callerApp,callingPid,callingUid,userId,receiver);
      if (rl.app != null) {
        rl.app.receivers.add(rl);
      }
 else {
        try {
          receiver.asBinder().linkToDeath(rl,0);
        }
 catch (        RemoteException e) {
          return sticky;
        }
        rl.linkedToDeath=true;
      }
      mRegisteredReceivers.put(receiver.asBinder(),rl);
    }
 else     if (rl.uid != callingUid) {
      throw new IllegalArgumentException("Receiver requested to register for uid " + callingUid + " was previously registered for uid "+ rl.uid);
    }
 else     if (rl.pid != callingPid) {
      throw new IllegalArgumentException("Receiver requested to register for pid " + callingPid + " was previously registered for pid "+ rl.pid);
    }
 else     if (rl.userId != userId) {
      throw new IllegalArgumentException("Receiver requested to register for user " + userId + " was previously registered for user "+ rl.userId);
    }
    BroadcastFilter bf=new BroadcastFilter(filter,rl,callerPackage,permission,callingUid,userId);
    rl.add(bf);
    if (!bf.debugCheck()) {
      Slog.w(TAG,"==> For Dynamic broadcast");
    }
    mReceiverResolver.addFilter(bf);
    if (allSticky != null) {
      ArrayList receivers=new ArrayList();
      receivers.add(bf);
      final int stickyCount=allSticky.size();
      for (int i=0; i < stickyCount; i++) {
        Intent intent=allSticky.get(i);
        BroadcastQueue queue=broadcastQueueForIntent(intent);
        BroadcastRecord r=new BroadcastRecord(queue,intent,null,null,-1,-1,null,null,AppOpsManager.OP_NONE,null,receivers,null,0,null,null,false,true,true,-1);
        queue.enqueueParallelBroadcastLocked(r);
        queue.scheduleBroadcastsLocked();
      }
    }
    return sticky;
  }
}
