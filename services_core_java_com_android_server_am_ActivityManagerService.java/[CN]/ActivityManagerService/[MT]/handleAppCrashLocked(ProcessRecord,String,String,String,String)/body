{
  long now=SystemClock.uptimeMillis();
  Long crashTime;
  if (!app.isolated) {
    crashTime=mProcessCrashTimes.get(app.info.processName,app.uid);
  }
 else {
    crashTime=null;
  }
  if (crashTime != null && now < crashTime + ProcessList.MIN_CRASH_INTERVAL) {
    Slog.w(TAG,"Process " + app.info.processName + " has crashed too many times: killing!");
    EventLog.writeEvent(EventLogTags.AM_PROCESS_CRASHED_TOO_MUCH,app.userId,app.info.processName,app.uid);
    mStackSupervisor.handleAppCrashLocked(app);
    if (!app.persistent) {
      EventLog.writeEvent(EventLogTags.AM_PROC_BAD,app.userId,app.uid,app.info.processName);
      if (!app.isolated) {
        mBadProcesses.put(app.info.processName,app.uid,new BadProcessInfo(now,shortMsg,longMsg,stackTrace));
        mProcessCrashTimes.remove(app.info.processName,app.uid);
      }
      app.bad=true;
      app.removed=true;
      removeProcessLocked(app,false,false,"crash");
      mStackSupervisor.resumeTopActivitiesLocked();
      return false;
    }
    mStackSupervisor.resumeTopActivitiesLocked();
  }
 else {
    mStackSupervisor.finishTopRunningActivityLocked(app,reason);
  }
  for (int i=app.services.size() - 1; i >= 0; i--) {
    ServiceRecord sr=app.services.valueAt(i);
    sr.crashCount++;
  }
  final ArrayList<ActivityRecord> activities=app.activities;
  if (app == mHomeProcess && activities.size() > 0 && (mHomeProcess.info.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
    for (int activityNdx=activities.size() - 1; activityNdx >= 0; --activityNdx) {
      final ActivityRecord r=activities.get(activityNdx);
      if (r.isHomeActivity()) {
        Log.i(TAG,"Clearing package preferred activities from " + r.packageName);
        try {
          ActivityThread.getPackageManager().clearPackagePreferredActivities(r.packageName);
        }
 catch (        RemoteException c) {
        }
      }
    }
  }
  if (!app.isolated) {
    mProcessCrashTimes.put(app.info.processName,app.uid,now);
  }
  if (app.crashHandler != null)   mHandler.post(app.crashHandler);
  return true;
}
