{
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,"Set " + app.pid + " "+ app.processName+ " adj "+ app.curAdj+ ": "+ app.adjType);
    app.setAdj=app.curAdj;
    app.verifiedAdj=ProcessList.INVALID_ADJ;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG_OOM_ADJ,"Setting sched group of " + app.processName + " to "+ app.curSchedGroup);
    if (app.waitingToKill != null && app.curReceivers.isEmpty() && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
      app.kill(app.waitingToKill,true);
      success=false;
    }
 else {
      int processGroup;
switch (app.curSchedGroup) {
case ProcessList.SCHED_GROUP_BACKGROUND:
        processGroup=Process.THREAD_GROUP_BG_NONINTERACTIVE;
      break;
case ProcessList.SCHED_GROUP_TOP_APP:
    processGroup=Process.THREAD_GROUP_TOP_APP;
  break;
default :
processGroup=Process.THREAD_GROUP_DEFAULT;
break;
}
if (true) {
long oldId=Binder.clearCallingIdentity();
try {
Process.setProcessGroup(app.pid,processGroup);
}
 catch (Exception e) {
Slog.w(TAG,"Failed setting process group of " + app.pid + " to "+ app.curSchedGroup);
e.printStackTrace();
}
 finally {
Binder.restoreCallingIdentity(oldId);
}
}
 else {
if (app.thread != null) {
try {
app.thread.setSchedulingGroup(processGroup);
}
 catch (RemoteException e) {
}
}
}
}
}
if (app.repForegroundActivities != app.foregroundActivities) {
app.repForegroundActivities=app.foregroundActivities;
changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
}
if (app.repProcState != app.curProcState) {
app.repProcState=app.curProcState;
changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
if (app.thread != null) {
try {
if (false) {
Slog.i(TAG,"Sending new process state " + app.repProcState + " to "+ app);
}
app.thread.setProcessState(app.repProcState);
}
 catch (RemoteException e) {
}
}
}
if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
long start=SystemClock.uptimeMillis();
long pss=Debug.getPss(app.pid,mTmpLong,null);
recordPssSampleLocked(app,app.curProcState,pss,mTmpLong[0],mTmpLong[1],now);
mPendingPssProcesses.remove(app);
Slog.i(TAG,"Recorded pss for " + app + " state "+ app.setProcState+ " to "+ app.curProcState+ ": "+ (SystemClock.uptimeMillis() - start)+ "ms");
}
app.lastStateTime=now;
app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,mTestPssMode,isSleepingLocked(),now);
if (DEBUG_PSS) Slog.d(TAG_PSS,"Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to "+ ProcessList.makeProcStateString(app.curProcState)+ " next pss in "+ (app.nextPssTime - now)+ ": "+ app);
}
 else {
if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
requestPssLocked(app,app.setProcState);
app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,mTestPssMode,isSleepingLocked(),now);
}
 else if (false && DEBUG_PSS) Slog.d(TAG_PSS,"Not requesting PSS of " + app + ": next="+ (app.nextPssTime - now));
}
if (app.setProcState != app.curProcState) {
if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,"Proc state change of " + app.processName + " to "+ app.curProcState);
boolean setImportant=app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
boolean curImportant=app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
if (setImportant && !curImportant) {
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,nowElapsed);
}
app.lastCpuTime=app.curCpuTime;
}
maybeUpdateUsageStatsLocked(app,nowElapsed);
app.setProcState=app.curProcState;
if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
app.notCachedSinceIdle=false;
}
if (!doingAll) {
setProcessTrackerStateLocked(app,mProcessStats.getMemFactorLocked(),now);
}
 else {
app.procStateChanged=true;
}
}
 else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > USAGE_STATS_INTERACTION_INTERVAL) {
maybeUpdateUsageStatsLocked(app,nowElapsed);
}
if (changes != 0) {
if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,"Changes in " + app + ": "+ changes);
int i=mPendingProcessChanges.size() - 1;
ProcessChangeItem item=null;
while (i >= 0) {
item=mPendingProcessChanges.get(i);
if (item.pid == app.pid) {
if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,"Re-using existing item: " + item);
break;
}
i--;
}
if (i < 0) {
final int NA=mAvailProcessChanges.size();
if (NA > 0) {
item=mAvailProcessChanges.remove(NA - 1);
if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,"Retrieving available item: " + item);
}
 else {
item=new ProcessChangeItem();
if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,"Allocating new item: " + item);
}
item.changes=0;
item.pid=app.pid;
item.uid=app.info.uid;
if (mPendingProcessChanges.size() == 0) {
if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,"*** Enqueueing dispatch processes changed!");
mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
}
mPendingProcessChanges.add(item);
}
item.changes|=changes;
item.processState=app.repProcState;
item.foregroundActivities=app.repForegroundActivities;
if (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,"Item " + Integer.toHexString(System.identityHashCode(item)) + " "+ app.toShortString()+ ": changes="+ item.changes+ " procState="+ item.processState+ " foreground="+ item.foregroundActivities+ " type="+ app.adjType+ " source="+ app.adjSource+ " target="+ app.adjTarget);
}
return success;
}
