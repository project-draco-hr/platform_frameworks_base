{
  boolean success=true;
  if (app.curRawAdj != app.setRawAdj) {
    if (wasKeeping && !app.keeping) {
      BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
        app.lastWakeTime=stats.getProcessWakeTime(app.info.uid,app.pid,SystemClock.elapsedRealtime());
      }
      app.lastCpuTime=app.curCpuTime;
    }
    app.setRawAdj=app.curRawAdj;
  }
  int changes=0;
  if (app.curAdj != app.setAdj) {
    ProcessList.setOomAdj(app.pid,app.info.uid,app.curAdj);
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG,"Set " + app.pid + " "+ app.processName+ " adj "+ app.curAdj+ ": "+ app.adjType);
    app.setAdj=app.curAdj;
  }
  if (app.setSchedGroup != app.curSchedGroup) {
    app.setSchedGroup=app.curSchedGroup;
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG,"Setting process group of " + app.processName + " to "+ app.curSchedGroup);
    if (app.waitingToKill != null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
      killUnneededProcessLocked(app,app.waitingToKill);
      success=false;
    }
 else {
      if (true) {
        long oldId=Binder.clearCallingIdentity();
        try {
          Process.setProcessGroup(app.pid,app.curSchedGroup);
        }
 catch (        Exception e) {
          Slog.w(TAG,"Failed setting process group of " + app.pid + " to "+ app.curSchedGroup);
          e.printStackTrace();
        }
 finally {
          Binder.restoreCallingIdentity(oldId);
        }
      }
 else {
        if (app.thread != null) {
          try {
            app.thread.setSchedulingGroup(app.curSchedGroup);
          }
 catch (          RemoteException e) {
          }
        }
      }
      Process.setSwappiness(app.pid,app.curSchedGroup <= Process.THREAD_GROUP_BG_NONINTERACTIVE);
    }
  }
  if (app.repForegroundActivities != app.foregroundActivities) {
    app.repForegroundActivities=app.foregroundActivities;
    changes|=ProcessChangeItem.CHANGE_ACTIVITIES;
  }
  if (app.repProcState != app.curProcState) {
    app.repProcState=app.curProcState;
    changes|=ProcessChangeItem.CHANGE_PROCESS_STATE;
    if (app.thread != null) {
      try {
        if (false) {
          Slog.i(TAG,"Sending new process state " + app.repProcState + " to "+ app);
        }
        app.thread.setProcessState(app.repProcState);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (app.setProcState < 0 || ProcessList.procStatesDifferForMem(app.curProcState,app.setProcState)) {
    app.lastStateTime=now;
    app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,true,isSleeping(),now);
    if (DEBUG_PSS)     Slog.d(TAG,"Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to "+ ProcessList.makeProcStateString(app.curProcState)+ " next pss in "+ (app.nextPssTime - now)+ ": "+ app);
  }
 else {
    if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.PSS_MIN_TIME_FROM_STATE_CHANGE))) {
      requestPssLocked(app,app.setProcState);
      app.nextPssTime=ProcessList.computeNextPssTime(app.curProcState,false,isSleeping(),now);
    }
 else     if (false && DEBUG_PSS) {
      Slog.d(TAG,"Not requesting PSS of " + app + ": next="+ (app.nextPssTime - now));
    }
  }
  if (app.setProcState != app.curProcState) {
    if (DEBUG_SWITCH || DEBUG_OOM_ADJ)     Slog.v(TAG,"Proc state change of " + app.processName + " to "+ app.curProcState);
    app.setProcState=app.curProcState;
    if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
      app.notCachedSinceIdle=false;
    }
    if (!doingAll) {
      setProcessTrackerState(app,mProcessStats.getMemFactorLocked(),now);
    }
 else {
      app.procStateChanged=true;
    }
  }
  if (changes != 0) {
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,"Changes in " + app + ": "+ changes);
    int i=mPendingProcessChanges.size() - 1;
    ProcessChangeItem item=null;
    while (i >= 0) {
      item=mPendingProcessChanges.get(i);
      if (item.pid == app.pid) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,"Re-using existing item: " + item);
        break;
      }
      i--;
    }
    if (i < 0) {
      final int NA=mAvailProcessChanges.size();
      if (NA > 0) {
        item=mAvailProcessChanges.remove(NA - 1);
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,"Retreiving available item: " + item);
      }
 else {
        item=new ProcessChangeItem();
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,"Allocating new item: " + item);
      }
      item.changes=0;
      item.pid=app.pid;
      item.uid=app.info.uid;
      if (mPendingProcessChanges.size() == 0) {
        if (DEBUG_PROCESS_OBSERVERS)         Slog.i(TAG,"*** Enqueueing dispatch processes changed!");
        mHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
      }
      mPendingProcessChanges.add(item);
    }
    item.changes|=changes;
    item.processState=app.repProcState;
    item.foregroundActivities=app.repForegroundActivities;
    if (DEBUG_PROCESS_OBSERVERS)     Slog.i(TAG,"Item " + Integer.toHexString(System.identityHashCode(item)) + " "+ app.toShortString()+ ": changes="+ item.changes+ " procState="+ item.processState+ " foreground="+ item.foregroundActivities+ " type="+ app.adjType+ " source="+ app.adjSource+ " target="+ app.adjTarget);
  }
  return success;
}
