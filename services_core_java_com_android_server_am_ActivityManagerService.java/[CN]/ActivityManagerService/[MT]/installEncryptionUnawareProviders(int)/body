{
  final int matchFlags=GET_PROVIDERS | MATCH_DIRECT_BOOT_UNAWARE;
synchronized (this) {
    final int NP=mProcessNames.getMap().size();
    for (int ip=0; ip < NP; ip++) {
      final SparseArray<ProcessRecord> apps=mProcessNames.getMap().valueAt(ip);
      final int NA=apps.size();
      for (int ia=0; ia < NA; ia++) {
        final ProcessRecord app=apps.valueAt(ia);
        if (app.userId != userId || app.thread == null || app.unlocked)         continue;
        final int NG=app.pkgList.size();
        for (int ig=0; ig < NG; ig++) {
          try {
            final String pkgName=app.pkgList.keyAt(ig);
            final PackageInfo pkgInfo=AppGlobals.getPackageManager().getPackageInfo(pkgName,matchFlags,userId);
            if (pkgInfo != null && !ArrayUtils.isEmpty(pkgInfo.providers)) {
              for (              ProviderInfo provInfo : pkgInfo.providers) {
                if (Objects.equals(provInfo.processName,app.processName)) {
                  Log.v(TAG,"Installing " + provInfo);
                  app.thread.scheduleInstallProvider(provInfo);
                }
 else {
                  Log.v(TAG,"Skipping " + provInfo);
                }
              }
            }
          }
 catch (          RemoteException ignored) {
          }
        }
      }
    }
  }
}
