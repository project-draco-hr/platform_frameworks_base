{
switch (msg.what) {
case SHOW_ERROR_MSG:
{
      HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
      boolean showBackground=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ANR_SHOW_BACKGROUND,0) != 0;
synchronized (ActivityManagerService.this) {
        ProcessRecord proc=(ProcessRecord)data.get("app");
        AppErrorResult res=(AppErrorResult)data.get("result");
        if (proc != null && proc.crashDialog != null) {
          Slog.e(TAG,"App already has crash dialog: " + proc);
          if (res != null) {
            res.set(0);
          }
          return;
        }
        boolean isBackground=(UserHandle.getAppId(proc.uid) >= Process.FIRST_APPLICATION_UID && proc.pid != MY_PID);
        for (        int userId : mCurrentProfileIds) {
          isBackground&=(proc.userId != userId);
        }
        if (isBackground && !showBackground) {
          Slog.w(TAG,"Skipping crash dialog of " + proc + ": background");
          if (res != null) {
            res.set(0);
          }
          return;
        }
        if (mShowDialogs && !mSleeping && !mShuttingDown) {
          Dialog d=new AppErrorDialog(mContext,ActivityManagerService.this,res,proc);
          d.show();
          proc.crashDialog=d;
        }
 else {
          if (res != null) {
            res.set(0);
          }
        }
      }
      ensureBootCompleted();
    }
  break;
case SHOW_NOT_RESPONDING_MSG:
{
synchronized (ActivityManagerService.this) {
    HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
    ProcessRecord proc=(ProcessRecord)data.get("app");
    if (proc != null && proc.anrDialog != null) {
      Slog.e(TAG,"App already has anr dialog: " + proc);
      return;
    }
    Intent intent=new Intent("android.intent.action.ANR");
    if (!mProcessesReady) {
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
    }
    broadcastIntentLocked(null,null,intent,null,null,0,null,null,null,AppOpsManager.OP_NONE,false,false,MY_PID,Process.SYSTEM_UID,0);
    if (mShowDialogs) {
      Dialog d=new AppNotRespondingDialog(ActivityManagerService.this,mContext,proc,(ActivityRecord)data.get("activity"),msg.arg1 != 0);
      d.show();
      proc.anrDialog=d;
    }
 else {
      killAppAtUsersRequest(proc,null);
    }
  }
  ensureBootCompleted();
}
break;
case SHOW_STRICT_MODE_VIOLATION_MSG:
{
HashMap<String,Object> data=(HashMap<String,Object>)msg.obj;
synchronized (ActivityManagerService.this) {
ProcessRecord proc=(ProcessRecord)data.get("app");
if (proc == null) {
  Slog.e(TAG,"App not found when showing strict mode dialog.");
  break;
}
if (proc.crashDialog != null) {
  Slog.e(TAG,"App already has strict mode dialog: " + proc);
  return;
}
AppErrorResult res=(AppErrorResult)data.get("result");
if (mShowDialogs && !mSleeping && !mShuttingDown) {
  Dialog d=new StrictModeViolationDialog(mContext,ActivityManagerService.this,res,proc);
  d.show();
  proc.crashDialog=d;
}
 else {
  res.set(0);
}
}
ensureBootCompleted();
}
break;
case SHOW_FACTORY_ERROR_MSG:
{
Dialog d=new FactoryErrorDialog(mContext,msg.getData().getCharSequence("msg"));
d.show();
ensureBootCompleted();
}
break;
case UPDATE_CONFIGURATION_MSG:
{
final ContentResolver resolver=mContext.getContentResolver();
Settings.System.putConfiguration(resolver,(Configuration)msg.obj);
}
break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
performAppGcsIfAppropriateLocked();
}
}
break;
case WAIT_FOR_DEBUGGER_MSG:
{
synchronized (ActivityManagerService.this) {
ProcessRecord app=(ProcessRecord)msg.obj;
if (msg.arg1 != 0) {
if (!app.waitedForDebugger) {
Dialog d=new AppWaitingForDebuggerDialog(ActivityManagerService.this,mContext,app);
app.waitDialog=d;
app.waitedForDebugger=true;
d.show();
}
}
 else {
if (app.waitDialog != null) {
app.waitDialog.dismiss();
app.waitDialog=null;
}
}
}
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,ActiveServices.SERVICE_TIMEOUT);
return;
}
mServices.serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to update time zone for: " + r.info.processName);
}
}
}
}
}
break;
case CLEAR_DNS_CACHE_MSG:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.clearDnsCache();
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to clear dns cache for: " + r.info.processName);
}
}
}
}
}
break;
case UPDATE_HTTP_PROXY_MSG:
{
ProxyInfo proxy=(ProxyInfo)msg.obj;
String host="";
String port="";
String exclList="";
Uri pacFileUrl=Uri.EMPTY;
if (proxy != null) {
host=proxy.getHost();
port=Integer.toString(proxy.getPort());
exclList=proxy.getExclusionListAsString();
pacFileUrl=proxy.getPacFileUrl();
}
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.setHttpProxy(host,port,exclList,pacFileUrl);
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to update http proxy for: " + r.info.processName);
}
}
}
}
}
break;
case SHOW_UID_ERROR_MSG:
{
String title="System UIDs Inconsistent";
String text="UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.";
Log.e(TAG,title + ": " + text);
if (mShowDialogs) {
AlertDialog d=new BaseErrorDialog(mContext);
d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
d.setCancelable(false);
d.setTitle(title);
d.setMessage(text);
d.setButton(DialogInterface.BUTTON_POSITIVE,"I'm Feeling Lucky",mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
mUidAlert=d;
d.show();
}
}
break;
case IM_FEELING_LUCKY_MSG:
{
if (mUidAlert != null) {
mUidAlert.dismiss();
mUidAlert=null;
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
mStackSupervisor.doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int appid=msg.arg1;
boolean restart=(msg.arg2 == 1);
Bundle bundle=(Bundle)msg.obj;
String pkg=bundle.getString("pkg");
String reason=bundle.getString("reason");
forceStopPackageLocked(pkg,appid,restart,false,true,false,false,UserHandle.USER_ALL,reason);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification();
notification.icon=com.android.internal.R.drawable.stat_sys_adb;
notification.when=0;
notification.flags=Notification.FLAG_ONGOING_EVENT;
notification.tickerText=text;
notification.defaults=0;
notification.sound=null;
notification.vibrate=null;
notification.color=mContext.getResources().getColor(com.android.internal.R.color.system_notification_accent_color);
notification.setLatestEventInfo(context,text,mContext.getText(R.string.heavy_weight_notification_detail),PendingIntent.getActivityAsUser(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT,null,new UserHandle(root.userId)));
try {
int[] outId=new int[1];
inm.enqueueNotificationWithTag("android","android",null,R.string.heavy_weight_notification,notification,outId,root.userId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Error showing notification for heavy-weight app",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,"Unable to create context for heavy notification",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotificationWithTag("android",null,R.string.heavy_weight_notification,msg.arg1);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Error canceling notification for service",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessivePowerUsageLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
}
}
break;
case SHOW_COMPAT_MODE_DIALOG_MSG:
{
synchronized (ActivityManagerService.this) {
ActivityRecord ar=(ActivityRecord)msg.obj;
if (mCompatModeDialog != null) {
if (mCompatModeDialog.mAppInfo.packageName.equals(ar.info.applicationInfo.packageName)) {
return;
}
mCompatModeDialog.dismiss();
mCompatModeDialog=null;
}
if (ar != null && false) {
if (mCompatModePackages.getPackageAskCompatModeLocked(ar.packageName)) {
int mode=mCompatModePackages.computeCompatModeLocked(ar.info.applicationInfo);
if (mode == ActivityManager.COMPAT_MODE_DISABLED || mode == ActivityManager.COMPAT_MODE_ENABLED) {
mCompatModeDialog=new CompatModeDialog(ActivityManagerService.this,mContext,ar.info.applicationInfo);
mCompatModeDialog.show();
}
}
}
}
break;
}
case DISPATCH_PROCESSES_CHANGED:
{
dispatchProcessesChanged();
break;
}
case DISPATCH_PROCESS_DIED:
{
final int pid=msg.arg1;
final int uid=msg.arg2;
dispatchProcessDied(pid,uid);
break;
}
case REPORT_MEM_USAGE_MSG:
{
final ArrayList<ProcessMemInfo> memInfos=(ArrayList<ProcessMemInfo>)msg.obj;
Thread thread=new Thread(){
@Override public void run(){
final SparseArray<ProcessMemInfo> infoMap=new SparseArray<ProcessMemInfo>(memInfos.size());
for (int i=0, N=memInfos.size(); i < N; i++) {
ProcessMemInfo mi=memInfos.get(i);
infoMap.put(mi.pid,mi);
}
updateCpuStatsNow();
synchronized (mProcessCpuTracker) {
final int N=mProcessCpuTracker.countStats();
for (int i=0; i < N; i++) {
ProcessCpuTracker.Stats st=mProcessCpuTracker.getStats(i);
if (st.vsize > 0) {
long pss=Debug.getPss(st.pid,null);
if (pss > 0) {
if (infoMap.indexOfKey(st.pid) < 0) {
ProcessMemInfo mi=new ProcessMemInfo(st.name,st.pid,ProcessList.NATIVE_ADJ,-1,"native",null);
mi.pss=pss;
memInfos.add(mi);
}
}
}
}
}
long totalPss=0;
for (int i=0, N=memInfos.size(); i < N; i++) {
ProcessMemInfo mi=memInfos.get(i);
if (mi.pss == 0) {
mi.pss=Debug.getPss(mi.pid,null);
}
totalPss+=mi.pss;
}
Collections.sort(memInfos,new Comparator<ProcessMemInfo>(){
@Override public int compare(ProcessMemInfo lhs,ProcessMemInfo rhs){
if (lhs.oomAdj != rhs.oomAdj) {
return lhs.oomAdj < rhs.oomAdj ? -1 : 1;
}
if (lhs.pss != rhs.pss) {
return lhs.pss < rhs.pss ? 1 : -1;
}
return 0;
}
}
);
StringBuilder tag=new StringBuilder(128);
StringBuilder stack=new StringBuilder(128);
tag.append("Low on memory -- ");
appendMemBucket(tag,totalPss,"total",false);
appendMemBucket(stack,totalPss,"total",true);
StringBuilder logBuilder=new StringBuilder(1024);
logBuilder.append("Low on memory:\n");
boolean firstLine=true;
int lastOomAdj=Integer.MIN_VALUE;
for (int i=0, N=memInfos.size(); i < N; i++) {
ProcessMemInfo mi=memInfos.get(i);
if (mi.oomAdj != ProcessList.NATIVE_ADJ && (mi.oomAdj < ProcessList.SERVICE_ADJ || mi.oomAdj == ProcessList.HOME_APP_ADJ || mi.oomAdj == ProcessList.PREVIOUS_APP_ADJ)) {
if (lastOomAdj != mi.oomAdj) {
lastOomAdj=mi.oomAdj;
if (mi.oomAdj <= ProcessList.FOREGROUND_APP_ADJ) {
tag.append(" / ");
}
if (mi.oomAdj >= ProcessList.FOREGROUND_APP_ADJ) {
if (firstLine) {
stack.append(":");
firstLine=false;
}
stack.append("\n\t at ");
}
 else {
stack.append("$");
}
}
 else {
tag.append(" ");
stack.append("$");
}
if (mi.oomAdj <= ProcessList.FOREGROUND_APP_ADJ) {
appendMemBucket(tag,mi.pss,mi.name,false);
}
appendMemBucket(stack,mi.pss,mi.name,true);
if (mi.oomAdj >= ProcessList.FOREGROUND_APP_ADJ && ((i + 1) >= N || memInfos.get(i + 1).oomAdj != lastOomAdj)) {
stack.append("(");
for (int k=0; k < DUMP_MEM_OOM_ADJ.length; k++) {
if (DUMP_MEM_OOM_ADJ[k] == mi.oomAdj) {
stack.append(DUMP_MEM_OOM_LABEL[k]);
stack.append(":");
stack.append(DUMP_MEM_OOM_ADJ[k]);
}
}
stack.append(")");
}
}
logBuilder.append("  ");
logBuilder.append(ProcessList.makeOomAdjString(mi.oomAdj));
logBuilder.append(' ');
logBuilder.append(ProcessList.makeProcStateString(mi.procState));
logBuilder.append(' ');
ProcessList.appendRamKb(logBuilder,mi.pss);
logBuilder.append(" kB: ");
logBuilder.append(mi.name);
logBuilder.append(" (");
logBuilder.append(mi.pid);
logBuilder.append(") ");
logBuilder.append(mi.adjType);
logBuilder.append('\n');
if (mi.adjReason != null) {
logBuilder.append("                      ");
logBuilder.append(mi.adjReason);
logBuilder.append('\n');
}
}
logBuilder.append("           ");
ProcessList.appendRamKb(logBuilder,totalPss);
logBuilder.append(" kB: TOTAL\n");
long[] infos=new long[Debug.MEMINFO_COUNT];
Debug.getMemInfo(infos);
logBuilder.append("  MemInfo: ");
logBuilder.append(infos[Debug.MEMINFO_SLAB]).append(" kB slab, ");
logBuilder.append(infos[Debug.MEMINFO_SHMEM]).append(" kB shmem, ");
logBuilder.append(infos[Debug.MEMINFO_BUFFERS]).append(" kB buffers, ");
logBuilder.append(infos[Debug.MEMINFO_CACHED]).append(" kB cached, ");
logBuilder.append(infos[Debug.MEMINFO_FREE]).append(" kB free\n");
if (infos[Debug.MEMINFO_ZRAM_TOTAL] != 0) {
logBuilder.append("  ZRAM: ");
logBuilder.append(infos[Debug.MEMINFO_ZRAM_TOTAL]);
logBuilder.append(" kB RAM, ");
logBuilder.append(infos[Debug.MEMINFO_SWAP_TOTAL]);
logBuilder.append(" kB swap total, ");
logBuilder.append(infos[Debug.MEMINFO_SWAP_FREE]);
logBuilder.append(" kB swap free\n");
}
Slog.i(TAG,logBuilder.toString());
StringBuilder dropBuilder=new StringBuilder(1024);
dropBuilder.append(stack);
dropBuilder.append('\n');
dropBuilder.append('\n');
dropBuilder.append(logBuilder);
dropBuilder.append('\n');
StringWriter catSw=new StringWriter();
synchronized (ActivityManagerService.this) {
PrintWriter catPw=new FastPrintWriter(catSw,false,256);
String[] emptyArgs=new String[]{};
catPw.println();
dumpProcessesLocked(null,catPw,emptyArgs,0,false,null);
catPw.println();
mServices.dumpServicesLocked(null,catPw,emptyArgs,0,false,false,null);
catPw.println();
dumpActivitiesLocked(null,catPw,emptyArgs,0,false,false,null);
catPw.flush();
}
dropBuilder.append(catSw.toString());
addErrorToDropBox("lowmem",null,"system_server",null,null,tag.toString(),dropBuilder.toString(),null,null);
synchronized (ActivityManagerService.this) {
long now=SystemClock.uptimeMillis();
if (mLastMemUsageReportTime < now) {
mLastMemUsageReportTime=now;
}
}
}
}
;
thread.start();
break;
}
case START_USER_SWITCH_MSG:
{
showUserSwitchDialog(msg.arg1,(String)msg.obj);
break;
}
case REPORT_USER_SWITCH_MSG:
{
dispatchUserSwitch((UserStartedState)msg.obj,msg.arg1,msg.arg2);
break;
}
case CONTINUE_USER_SWITCH_MSG:
{
continueUserSwitch((UserStartedState)msg.obj,msg.arg1,msg.arg2);
break;
}
case USER_SWITCH_TIMEOUT_MSG:
{
timeoutUserSwitch((UserStartedState)msg.obj,msg.arg1,msg.arg2);
break;
}
case IMMERSIVE_MODE_LOCK_MSG:
{
final boolean nextState=(msg.arg1 != 0);
if (mUpdateLock.isHeld() != nextState) {
if (DEBUG_IMMERSIVE) {
final ActivityRecord r=(ActivityRecord)msg.obj;
Slog.d(TAG,"Applying new update lock state '" + nextState + "' for "+ r);
}
if (nextState) {
mUpdateLock.acquire();
}
 else {
mUpdateLock.release();
}
}
break;
}
case PERSIST_URI_GRANTS_MSG:
{
writeGrantedUriPermissions();
break;
}
case REQUEST_ALL_PSS_MSG:
{
requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
break;
}
case START_PROFILES_MSG:
{
synchronized (ActivityManagerService.this) {
startProfilesLocked();
}
break;
}
case UPDATE_TIME:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimePrefs(msg.arg1 == 0 ? false : true);
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to update preferences for: " + r.info.processName);
}
}
}
}
break;
}
case SYSTEM_USER_START_MSG:
{
mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START,Integer.toString(msg.arg1),msg.arg1);
mSystemServiceManager.startUser(msg.arg1);
break;
}
case SYSTEM_USER_CURRENT_MSG:
{
mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH,Integer.toString(msg.arg2),msg.arg2);
mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START,Integer.toString(msg.arg1),msg.arg1);
mSystemServiceManager.switchUser(msg.arg1);
mLockToAppRequest.clearPrompt();
break;
}
case ENTER_ANIMATION_COMPLETE_MSG:
{
synchronized (ActivityManagerService.this) {
ActivityRecord r=ActivityRecord.forToken((IBinder)msg.obj);
if (r != null && r.app != null && r.app.thread != null) {
try {
r.app.thread.scheduleEnterAnimationComplete(r.appToken);
}
 catch (RemoteException e) {
}
}
}
break;
}
case ENABLE_SCREEN_AFTER_BOOT_MSG:
{
enableScreenAfterBoot();
break;
}
}
}
