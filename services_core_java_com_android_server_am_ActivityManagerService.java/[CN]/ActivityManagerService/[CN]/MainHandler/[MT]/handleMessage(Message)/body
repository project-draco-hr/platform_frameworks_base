{
switch (msg.what) {
case UPDATE_CONFIGURATION_MSG:
{
      final ContentResolver resolver=mContext.getContentResolver();
      Settings.System.putConfigurationForUser(resolver,(Configuration)msg.obj,msg.arg1);
    }
  break;
case GC_BACKGROUND_PROCESSES_MSG:
{
synchronized (ActivityManagerService.this) {
    performAppGcsIfAppropriateLocked();
  }
}
break;
case SERVICE_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,ActiveServices.SERVICE_TIMEOUT);
return;
}
mServices.serviceTimeout((ProcessRecord)msg.obj);
}
break;
case UPDATE_TIME_ZONE:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
  r.thread.updateTimeZone();
}
 catch (RemoteException ex) {
  Slog.w(TAG,"Failed to update time zone for: " + r.info.processName);
}
}
}
}
}
break;
case CLEAR_DNS_CACHE_MSG:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.clearDnsCache();
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to clear dns cache for: " + r.info.processName);
}
}
}
}
}
break;
case UPDATE_HTTP_PROXY_MSG:
{
ProxyInfo proxy=(ProxyInfo)msg.obj;
String host="";
String port="";
String exclList="";
Uri pacFileUrl=Uri.EMPTY;
if (proxy != null) {
host=proxy.getHost();
port=Integer.toString(proxy.getPort());
exclList=proxy.getExclusionListAsString();
pacFileUrl=proxy.getPacFileUrl();
}
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.setHttpProxy(host,port,exclList,pacFileUrl);
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to update http proxy for: " + r.info.processName);
}
}
}
}
}
break;
case PROC_START_TIMEOUT_MSG:
{
if (mDidDexOpt) {
mDidDexOpt=false;
Message nmsg=mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
nmsg.obj=msg.obj;
mHandler.sendMessageDelayed(nmsg,PROC_START_TIMEOUT);
return;
}
ProcessRecord app=(ProcessRecord)msg.obj;
synchronized (ActivityManagerService.this) {
processStartTimedOutLocked(app);
}
}
break;
case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
{
synchronized (ActivityManagerService.this) {
mStackSupervisor.doPendingActivityLaunchesLocked(true);
}
}
break;
case KILL_APPLICATION_MSG:
{
synchronized (ActivityManagerService.this) {
int appid=msg.arg1;
boolean restart=(msg.arg2 == 1);
Bundle bundle=(Bundle)msg.obj;
String pkg=bundle.getString("pkg");
String reason=bundle.getString("reason");
forceStopPackageLocked(pkg,appid,restart,false,true,false,false,UserHandle.USER_ALL,reason);
}
}
break;
case FINALIZE_PENDING_INTENT_MSG:
{
((PendingIntentRecord)msg.obj).completeFinalize();
}
break;
case POST_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
ActivityRecord root=(ActivityRecord)msg.obj;
ProcessRecord process=root.app;
if (process == null) {
return;
}
try {
Context context=mContext.createPackageContext(process.info.packageName,0);
String text=mContext.getString(R.string.heavy_weight_notification,context.getApplicationInfo().loadLabel(context.getPackageManager()));
Notification notification=new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext,0,root.intent,PendingIntent.FLAG_CANCEL_CURRENT,null,new UserHandle(root.userId))).build();
try {
int[] outId=new int[1];
inm.enqueueNotificationWithTag("android","android",null,R.string.heavy_weight_notification,notification,outId,root.userId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Error showing notification for heavy-weight app",e);
}
catch (RemoteException e) {
}
}
 catch (NameNotFoundException e) {
Slog.w(TAG,"Unable to create context for heavy notification",e);
}
}
break;
case CANCEL_HEAVY_NOTIFICATION_MSG:
{
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
try {
inm.cancelNotificationWithTag("android",null,R.string.heavy_weight_notification,msg.arg1);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Error canceling notification for service",e);
}
catch (RemoteException e) {
}
}
break;
case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
{
synchronized (ActivityManagerService.this) {
checkExcessivePowerUsageLocked(true);
removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
Message nmsg=obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
sendMessageDelayed(nmsg,POWER_CHECK_DELAY);
}
}
break;
case REPORT_MEM_USAGE_MSG:
{
final ArrayList<ProcessMemInfo> memInfos=(ArrayList<ProcessMemInfo>)msg.obj;
Thread thread=new Thread(){
@Override public void run(){
reportMemUsage(memInfos);
}
}
;
thread.start();
break;
}
case REPORT_USER_SWITCH_MSG:
{
dispatchUserSwitch((UserState)msg.obj,msg.arg1,msg.arg2);
break;
}
case CONTINUE_USER_SWITCH_MSG:
{
continueUserSwitch((UserState)msg.obj,msg.arg1,msg.arg2);
break;
}
case USER_SWITCH_TIMEOUT_MSG:
{
timeoutUserSwitch((UserState)msg.obj,msg.arg1,msg.arg2);
break;
}
case IMMERSIVE_MODE_LOCK_MSG:
{
final boolean nextState=(msg.arg1 != 0);
if (mUpdateLock.isHeld() != nextState) {
if (DEBUG_IMMERSIVE) Slog.d(TAG_IMMERSIVE,"Applying new update lock state '" + nextState + "' for "+ (ActivityRecord)msg.obj);
if (nextState) {
mUpdateLock.acquire();
}
 else {
mUpdateLock.release();
}
}
break;
}
case PERSIST_URI_GRANTS_MSG:
{
writeGrantedUriPermissions();
break;
}
case REQUEST_ALL_PSS_MSG:
{
synchronized (ActivityManagerService.this) {
requestPssAllProcsLocked(SystemClock.uptimeMillis(),true,false);
}
break;
}
case START_PROFILES_MSG:
{
synchronized (ActivityManagerService.this) {
startProfilesLocked();
}
break;
}
case UPDATE_TIME:
{
synchronized (ActivityManagerService.this) {
for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
ProcessRecord r=mLruProcesses.get(i);
if (r.thread != null) {
try {
r.thread.updateTimePrefs(msg.arg1 == 0 ? false : true);
}
 catch (RemoteException ex) {
Slog.w(TAG,"Failed to update preferences for: " + r.info.processName);
}
}
}
}
break;
}
case SYSTEM_USER_START_MSG:
{
mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START,Integer.toString(msg.arg1),msg.arg1);
mSystemServiceManager.startUser(msg.arg1);
break;
}
case SYSTEM_USER_CURRENT_MSG:
{
mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH,Integer.toString(msg.arg2),msg.arg2);
mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START,Integer.toString(msg.arg1),msg.arg1);
mSystemServiceManager.switchUser(msg.arg1);
break;
}
case ENTER_ANIMATION_COMPLETE_MSG:
{
synchronized (ActivityManagerService.this) {
ActivityRecord r=ActivityRecord.forTokenLocked((IBinder)msg.obj);
if (r != null && r.app != null && r.app.thread != null) {
try {
r.app.thread.scheduleEnterAnimationComplete(r.appToken);
}
 catch (RemoteException e) {
}
}
}
break;
}
case FINISH_BOOTING_MSG:
{
if (msg.arg1 != 0) {
Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,"FinishBooting");
finishBooting();
Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}
if (msg.arg2 != 0) {
enableScreenAfterBoot();
}
break;
}
case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
{
try {
Locale l=(Locale)msg.obj;
IBinder service=ServiceManager.getService("mount");
IMountService mountService=IMountService.Stub.asInterface(service);
Log.d(TAG,"Storing locale " + l.toLanguageTag() + " for decryption UI");
mountService.setField(StorageManager.SYSTEM_LOCALE_KEY,l.toLanguageTag());
}
 catch (RemoteException e) {
Log.e(TAG,"Error storing locale for decryption UI",e);
}
break;
}
case NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG:
{
synchronized (ActivityManagerService.this) {
int i=mTaskStackListeners.beginBroadcast();
while (i > 0) {
i--;
try {
mTaskStackListeners.getBroadcastItem(i).onTaskStackChanged();
}
 catch (RemoteException e) {
}
}
mTaskStackListeners.finishBroadcast();
}
break;
}
case NOTIFY_CLEARTEXT_NETWORK_MSG:
{
final int uid=msg.arg1;
final byte[] firstPacket=(byte[])msg.obj;
synchronized (mPidsSelfLocked) {
for (int i=0; i < mPidsSelfLocked.size(); i++) {
final ProcessRecord p=mPidsSelfLocked.valueAt(i);
if (p.uid == uid) {
try {
p.thread.notifyCleartextNetwork(firstPacket);
}
 catch (RemoteException ignored) {
}
}
}
}
break;
}
case POST_DUMP_HEAP_NOTIFICATION_MSG:
{
final String procName;
final int uid;
final long memLimit;
final String reportPackage;
synchronized (ActivityManagerService.this) {
procName=mMemWatchDumpProcName;
uid=mMemWatchDumpUid;
Pair<Long,String> val=mMemWatchProcesses.get(procName,uid);
if (val == null) {
val=mMemWatchProcesses.get(procName,0);
}
if (val != null) {
memLimit=val.first;
reportPackage=val.second;
}
 else {
memLimit=0;
reportPackage=null;
}
}
if (procName == null) {
return;
}
if (DEBUG_PSS) Slog.d(TAG_PSS,"Showing dump heap notification from " + procName + "/"+ uid);
INotificationManager inm=NotificationManager.getService();
if (inm == null) {
return;
}
String text=mContext.getString(R.string.dump_heap_notification,procName);
Intent deleteIntent=new Intent();
deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
Intent intent=new Intent();
intent.setClassName("android",DumpHeapActivity.class.getName());
intent.putExtra(DumpHeapActivity.KEY_PROCESS,procName);
intent.putExtra(DumpHeapActivity.KEY_SIZE,memLimit);
if (reportPackage != null) {
intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH,reportPackage);
}
int userId=UserHandle.getUserId(uid);
Notification notification=new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext,0,intent,PendingIntent.FLAG_CANCEL_CURRENT,null,new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext,0,deleteIntent,0,UserHandle.OWNER)).build();
try {
int[] outId=new int[1];
inm.enqueueNotificationWithTag("android","android",null,R.string.dump_heap_notification,notification,outId,userId);
}
 catch (RuntimeException e) {
Slog.w(ActivityManagerService.TAG,"Error showing notification for dump heap",e);
}
catch (RemoteException e) {
}
}
break;
case DELETE_DUMPHEAP_MSG:
{
revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(),DumpHeapActivity.JAVA_URI,Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION,UserHandle.myUserId());
synchronized (ActivityManagerService.this) {
mMemWatchDumpFile=null;
mMemWatchDumpProcName=null;
mMemWatchDumpPid=-1;
mMemWatchDumpUid=-1;
}
}
break;
case FOREGROUND_PROFILE_CHANGED_MSG:
{
dispatchForegroundProfileChanged(msg.arg1);
}
break;
case REPORT_TIME_TRACKER_MSG:
{
AppTimeTracker tracker=(AppTimeTracker)msg.obj;
tracker.deliverResult(mContext);
}
break;
case REPORT_USER_SWITCH_COMPLETE_MSG:
{
dispatchUserSwitchComplete(msg.arg1);
}
break;
case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
{
IUiAutomationConnection connection=(IUiAutomationConnection)msg.obj;
try {
connection.shutdown();
}
 catch (RemoteException e) {
Slog.w(TAG,"Error shutting down UiAutomationConnection");
}
mUserIsMonkey=false;
}
break;
}
}
