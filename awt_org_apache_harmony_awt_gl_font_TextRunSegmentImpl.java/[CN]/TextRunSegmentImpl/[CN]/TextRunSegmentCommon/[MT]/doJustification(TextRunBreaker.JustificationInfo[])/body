{
  int lastPriority=jInfos[jInfos.length - 1] == null ? -1 : jInfos[jInfos.length - 1].priority;
  int highestPriority=0;
  for (; highestPriority < jInfos.length; highestPriority++) {
    if (jInfos[highestPriority] != null) {
      break;
    }
  }
  if (highestPriority == jInfos.length) {
    return 0;
  }
  TextRunBreaker.JustificationInfo firstInfo=jInfos[highestPriority];
  TextRunBreaker.JustificationInfo lastInfo=lastPriority > 0 ? jInfos[lastPriority] : null;
  boolean haveFirst=info.start <= firstInfo.firstIdx;
  boolean haveLast=info.end >= (firstInfo.lastIdx + 1);
  int firstGlyph=haveFirst ? getChar2Glyph()[firstInfo.firstIdx - info.start] : getChar2Glyph()[0];
  int lastGlyph=haveLast ? getChar2Glyph()[firstInfo.lastIdx - info.start] : getChar2Glyph()[info.length - 1];
  if (haveLast) {
    lastGlyph--;
  }
  TextRunBreaker.JustificationInfo currInfo;
  float glyphOffset=0;
  float positionIncrement=0;
  float sideIncrement=0;
  if (haveFirst) {
    GlyphJustificationInfo gji=getGlyphJustificationInfos()[firstGlyph];
    currInfo=jInfos[gji.growPriority];
    if (currInfo != null) {
      if (currInfo.useLimits) {
        if (currInfo.absorb) {
          glyphOffset+=gji.weight * currInfo.absorbedGapPerUnit;
        }
 else         if (lastInfo != null && lastInfo.priority == currInfo.priority) {
          glyphOffset+=gji.weight * lastInfo.absorbedGapPerUnit;
        }
        glyphOffset+=firstInfo.grow ? gji.growRightLimit : -gji.shrinkRightLimit;
      }
 else {
        glyphOffset+=gji.weight * currInfo.gapPerUnit;
      }
    }
    firstGlyph++;
  }
  if (firstInfo.grow) {
    for (int i=firstGlyph; i <= lastGlyph; i++) {
      GlyphJustificationInfo gji=getGlyphJustificationInfos()[i];
      currInfo=jInfos[gji.growPriority];
      if (currInfo == null) {
        Point2D glyphPos=getGlyphVector().getGlyphPosition(i);
        glyphPos.setLocation(glyphPos.getX() + glyphOffset,glyphPos.getY());
        getGlyphVector().setGlyphPosition(i,glyphPos);
        continue;
      }
      if (currInfo.useLimits) {
        glyphOffset+=gji.growLeftLimit;
        if (currInfo.absorb) {
          sideIncrement=gji.weight * currInfo.absorbedGapPerUnit;
          glyphOffset+=sideIncrement;
          positionIncrement=glyphOffset;
          glyphOffset+=sideIncrement;
        }
 else         if (lastInfo != null && lastInfo.priority == currInfo.priority) {
          sideIncrement=gji.weight * lastInfo.absorbedGapPerUnit;
          glyphOffset+=sideIncrement;
          positionIncrement=glyphOffset;
          glyphOffset+=sideIncrement;
        }
 else {
          positionIncrement=glyphOffset;
        }
        glyphOffset+=gji.growRightLimit;
      }
 else {
        sideIncrement=gji.weight * currInfo.gapPerUnit;
        glyphOffset+=sideIncrement;
        positionIncrement=glyphOffset;
        glyphOffset+=sideIncrement;
      }
      Point2D glyphPos=getGlyphVector().getGlyphPosition(i);
      glyphPos.setLocation(glyphPos.getX() + positionIncrement,glyphPos.getY());
      getGlyphVector().setGlyphPosition(i,glyphPos);
    }
  }
 else {
    for (int i=firstGlyph; i <= lastGlyph; i++) {
      GlyphJustificationInfo gji=getGlyphJustificationInfos()[i];
      currInfo=jInfos[gji.shrinkPriority];
      if (currInfo == null) {
        Point2D glyphPos=getGlyphVector().getGlyphPosition(i);
        glyphPos.setLocation(glyphPos.getX() + glyphOffset,glyphPos.getY());
        getGlyphVector().setGlyphPosition(i,glyphPos);
        continue;
      }
      if (currInfo.useLimits) {
        glyphOffset-=gji.shrinkLeftLimit;
        if (currInfo.absorb) {
          sideIncrement=gji.weight * currInfo.absorbedGapPerUnit;
          glyphOffset+=sideIncrement;
          positionIncrement=glyphOffset;
          glyphOffset+=sideIncrement;
        }
 else         if (lastInfo != null && lastInfo.priority == currInfo.priority) {
          sideIncrement=gji.weight * lastInfo.absorbedGapPerUnit;
          glyphOffset+=sideIncrement;
          positionIncrement=glyphOffset;
          glyphOffset+=sideIncrement;
        }
 else {
          positionIncrement=glyphOffset;
        }
        glyphOffset-=gji.shrinkRightLimit;
      }
 else {
        sideIncrement=gji.weight * currInfo.gapPerUnit;
        glyphOffset+=sideIncrement;
        positionIncrement=glyphOffset;
        glyphOffset+=sideIncrement;
      }
      Point2D glyphPos=getGlyphVector().getGlyphPosition(i);
      glyphPos.setLocation(glyphPos.getX() + positionIncrement,glyphPos.getY());
      getGlyphVector().setGlyphPosition(i,glyphPos);
    }
  }
  if (haveLast) {
    lastGlyph++;
    GlyphJustificationInfo gji=getGlyphJustificationInfos()[lastGlyph];
    currInfo=jInfos[gji.growPriority];
    if (currInfo != null) {
      if (currInfo.useLimits) {
        glyphOffset+=firstInfo.grow ? gji.growLeftLimit : -gji.shrinkLeftLimit;
        if (currInfo.absorb) {
          glyphOffset+=gji.weight * currInfo.absorbedGapPerUnit;
        }
 else         if (lastInfo != null && lastInfo.priority == currInfo.priority) {
          glyphOffset+=gji.weight * lastInfo.absorbedGapPerUnit;
        }
      }
 else {
        glyphOffset+=gji.weight * currInfo.gapPerUnit;
      }
    }
    for (int i=lastGlyph; i < getGlyphVector().getNumGlyphs() + 1; i++) {
      Point2D glyphPos=getGlyphVector().getGlyphPosition(i);
      glyphPos.setLocation(glyphPos.getX() + glyphOffset,glyphPos.getY());
      getGlyphVector().setGlyphPosition(i,glyphPos);
    }
  }
 else {
    Point2D glyphPos=getGlyphVector().getGlyphPosition(lastGlyph + 1);
    glyphPos.setLocation(glyphPos.getX() + glyphOffset,glyphPos.getY());
    getGlyphVector().setGlyphPosition(lastGlyph + 1,glyphPos);
  }
  gjis=null;
  this.visualBounds=null;
  this.logicalBounds=null;
  return glyphOffset;
}
