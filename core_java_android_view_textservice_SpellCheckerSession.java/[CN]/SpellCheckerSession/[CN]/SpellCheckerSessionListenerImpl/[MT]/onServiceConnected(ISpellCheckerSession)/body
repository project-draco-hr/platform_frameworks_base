{
synchronized (this) {
switch (mState) {
case STATE_WAIT_CONNECTION:
      break;
case STATE_CLOSED_BEFORE_CONNECTION:
    if (DBG)     Log.i(TAG,"ignoring onServiceConnected since the session is" + " already closed.");
  return;
default :
Log.e(TAG,"ignoring onServiceConnected due to unexpected mState=" + stateToString(mState));
return;
}
if (session == null) {
Log.e(TAG,"ignoring onServiceConnected due to session=null");
return;
}
mISpellCheckerSession=session;
if (session.asBinder() instanceof Binder && mThread == null) {
if (DBG) Log.d(TAG,"starting HandlerThread in onServiceConnected.");
mThread=new HandlerThread("SpellCheckerSession",Process.THREAD_PRIORITY_BACKGROUND);
mThread.start();
mAsyncHandler=new Handler(mThread.getLooper()){
@Override public void handleMessage(Message msg){
SpellCheckerParams scp=(SpellCheckerParams)msg.obj;
processTask(scp.mSession,scp,true);
}
}
;
}
mState=STATE_CONNECTED;
if (DBG) {
Log.d(TAG,"processed onServiceConnected: mISpellCheckerSession.hashCode()=#" + Integer.toHexString(mISpellCheckerSession.hashCode()) + " mPendingTasks.size()="+ mPendingTasks.size());
}
}
while (!mPendingTasks.isEmpty()) {
processTask(session,mPendingTasks.poll(),false);
}
}
