{
  if (async || mAsyncHandler == null) {
switch (scp.mWhat) {
case TASK_CANCEL:
      if (DBG) {
        Log.w(TAG,"Cancel spell checker tasks.");
      }
    try {
      session.onCancel();
    }
 catch (    RemoteException e) {
      Log.e(TAG,"Failed to cancel " + e);
    }
  break;
case TASK_GET_SUGGESTIONS_MULTIPLE:
if (DBG) {
  Log.w(TAG,"Get suggestions from the spell checker.");
}
try {
session.onGetSuggestionsMultiple(scp.mTextInfos,scp.mSuggestionsLimit,scp.mSequentialWords);
}
 catch (RemoteException e) {
Log.e(TAG,"Failed to get suggestions " + e);
}
break;
case TASK_GET_SUGGESTIONS_MULTIPLE_FOR_SENTENCE:
if (DBG) {
Log.w(TAG,"Get suggestions from the spell checker.");
}
try {
session.onGetSentenceSuggestionsMultiple(scp.mTextInfos,scp.mSuggestionsLimit);
}
 catch (RemoteException e) {
Log.e(TAG,"Failed to get suggestions " + e);
}
break;
case TASK_CLOSE:
if (DBG) {
Log.w(TAG,"Close spell checker tasks.");
}
try {
session.onClose();
}
 catch (RemoteException e) {
Log.e(TAG,"Failed to close " + e);
}
break;
}
}
 else {
scp.mSession=session;
mAsyncHandler.sendMessage(Message.obtain(mAsyncHandler,1,scp));
}
if (scp.mWhat == TASK_CLOSE) {
synchronized (this) {
mISpellCheckerSession=null;
mHandler=null;
if (mThread != null) {
mThread.quit();
}
mThread=null;
mAsyncHandler=null;
}
}
}
