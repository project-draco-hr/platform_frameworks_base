{
  if (DBG) {
synchronized (this) {
      Log.d(TAG,"entering processTask:" + " session.hashCode()=#" + Integer.toHexString(session.hashCode()) + " scp.mWhat="+ taskToString(scp.mWhat)+ " async="+ async+ " mAsyncHandler="+ mAsyncHandler+ " mState="+ stateToString(mState));
    }
  }
  if (async || mAsyncHandler == null) {
switch (scp.mWhat) {
case TASK_CANCEL:
      try {
        session.onCancel();
      }
 catch (      RemoteException e) {
        Log.e(TAG,"Failed to cancel " + e);
      }
    break;
case TASK_GET_SUGGESTIONS_MULTIPLE:
  try {
    session.onGetSuggestionsMultiple(scp.mTextInfos,scp.mSuggestionsLimit,scp.mSequentialWords);
  }
 catch (  RemoteException e) {
    Log.e(TAG,"Failed to get suggestions " + e);
  }
break;
case TASK_GET_SUGGESTIONS_MULTIPLE_FOR_SENTENCE:
try {
session.onGetSentenceSuggestionsMultiple(scp.mTextInfos,scp.mSuggestionsLimit);
}
 catch (RemoteException e) {
Log.e(TAG,"Failed to get suggestions " + e);
}
break;
case TASK_CLOSE:
try {
session.onClose();
}
 catch (RemoteException e) {
Log.e(TAG,"Failed to close " + e);
}
break;
}
}
 else {
scp.mSession=session;
mAsyncHandler.sendMessage(Message.obtain(mAsyncHandler,1,scp));
}
if (scp.mWhat == TASK_CLOSE) {
synchronized (this) {
processCloseLocked();
}
}
}
