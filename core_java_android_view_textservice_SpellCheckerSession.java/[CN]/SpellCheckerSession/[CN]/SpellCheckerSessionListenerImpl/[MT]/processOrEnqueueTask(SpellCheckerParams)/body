{
  ISpellCheckerSession session;
synchronized (this) {
    if (mState != STATE_WAIT_CONNECTION && mState != STATE_CONNECTED) {
      Log.e(TAG,"ignoring processOrEnqueueTask due to unexpected mState=" + taskToString(scp.mWhat) + " scp.mWhat="+ taskToString(scp.mWhat));
      return;
    }
    if (mState == STATE_WAIT_CONNECTION) {
      if (scp.mWhat == TASK_CLOSE) {
        processCloseLocked();
        return;
      }
      SpellCheckerParams closeTask=null;
      if (scp.mWhat == TASK_CANCEL) {
        if (DBG)         Log.d(TAG,"canceling pending tasks in processOrEnqueueTask.");
        while (!mPendingTasks.isEmpty()) {
          final SpellCheckerParams tmp=mPendingTasks.poll();
          if (tmp.mWhat == TASK_CLOSE) {
            closeTask=tmp;
          }
        }
      }
      mPendingTasks.offer(scp);
      if (closeTask != null) {
        mPendingTasks.offer(closeTask);
      }
      if (DBG)       Log.d(TAG,"queueing tasks in processOrEnqueueTask since the" + " connection is not established." + " mPendingTasks.size()="+ mPendingTasks.size());
      return;
    }
    session=mISpellCheckerSession;
  }
  processTask(session,scp,false);
}
