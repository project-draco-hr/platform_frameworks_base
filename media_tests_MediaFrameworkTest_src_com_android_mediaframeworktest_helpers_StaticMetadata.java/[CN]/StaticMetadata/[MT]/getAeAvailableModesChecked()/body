{
  Key<int[]> modesKey=CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES;
  int[] modes=getValueFromKeyNonNull(modesKey);
  if (modes == null) {
    modes=new int[0];
  }
  List<Integer> modeList=new ArrayList<Integer>();
  for (  int mode : modes) {
    modeList.add(mode);
  }
  checkTrueForKey(modesKey,"value is empty",!modeList.isEmpty());
  checkTrueForKey(modesKey,"values " + modeList.toString() + " must contain ON mode",modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON));
  Key<Boolean> flashKey=CameraCharacteristics.FLASH_INFO_AVAILABLE;
  Boolean hasFlash=getValueFromKeyNonNull(flashKey);
  if (hasFlash == null) {
    hasFlash=false;
  }
  if (hasFlash) {
    boolean flashModeConsistentWithFlash=modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH) && modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH);
    checkTrueForKey(modesKey,"value must contain ON_AUTO_FLASH and ON_ALWAYS_FLASH and  when flash is" + "available",flashModeConsistentWithFlash);
  }
 else {
    boolean flashModeConsistentWithoutFlash=!(modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH) || modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_ALWAYS_FLASH) || modeList.contains(CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE));
    checkTrueForKey(modesKey,"value must not contain ON_AUTO_FLASH, ON_ALWAYS_FLASH and" + "ON_AUTO_FLASH_REDEYE when flash is unavailable",flashModeConsistentWithoutFlash);
  }
  boolean condition=!isHardwareLevelFull() || modeList.contains(CameraMetadata.CONTROL_AE_MODE_OFF);
  checkTrueForKey(modesKey,"Full capability device must have OFF mode",condition);
  for (  int mode : modes) {
    checkTrueForKey(modesKey,"Value " + mode + " is out of bound",mode >= CameraMetadata.CONTROL_AE_MODE_OFF && mode <= CameraMetadata.CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE);
  }
  return modes;
}
