{
  final GradientState st=mGradientState;
  st.mChangingConfigurations|=a.getChangingConfigurations();
  st.mAttrGradient=a.extractThemeAttrs();
  st.mCenterX=getFloatOrFraction(a,R.styleable.GradientDrawableGradient_centerX,st.mCenterX);
  st.mCenterY=getFloatOrFraction(a,R.styleable.GradientDrawableGradient_centerY,st.mCenterY);
  st.mUseLevel=a.getBoolean(R.styleable.GradientDrawableGradient_useLevel,st.mUseLevel);
  st.mGradient=a.getInt(R.styleable.GradientDrawableGradient_type,st.mGradient);
  final int startColor=a.getColor(R.styleable.GradientDrawableGradient_startColor,0);
  final boolean hasCenterColor=a.hasValue(R.styleable.GradientDrawableGradient_centerColor);
  final int centerColor=a.getColor(R.styleable.GradientDrawableGradient_centerColor,0);
  final int endColor=a.getColor(R.styleable.GradientDrawableGradient_endColor,0);
  if (hasCenterColor) {
    st.mGradientColors=new int[3];
    st.mGradientColors[0]=startColor;
    st.mGradientColors[1]=centerColor;
    st.mGradientColors[2]=endColor;
    st.mPositions=new float[3];
    st.mPositions[0]=0.0f;
    st.mPositions[1]=st.mCenterX != 0.5f ? st.mCenterX : st.mCenterY;
    st.mPositions[2]=1f;
  }
 else {
    st.mGradientColors=new int[2];
    st.mGradientColors[0]=startColor;
    st.mGradientColors[1]=endColor;
  }
  if (st.mGradient == LINEAR_GRADIENT) {
    int angle=(int)a.getFloat(R.styleable.GradientDrawableGradient_angle,st.mAngle);
    angle%=360;
    if (angle % 45 != 0) {
      throw new XmlPullParserException(a.getPositionDescription() + "<gradient> tag requires 'angle' attribute to " + "be a multiple of 45");
    }
    st.mAngle=angle;
switch (angle) {
case 0:
      st.mOrientation=Orientation.LEFT_RIGHT;
    break;
case 45:
  st.mOrientation=Orientation.BL_TR;
break;
case 90:
st.mOrientation=Orientation.BOTTOM_TOP;
break;
case 135:
st.mOrientation=Orientation.BR_TL;
break;
case 180:
st.mOrientation=Orientation.RIGHT_LEFT;
break;
case 225:
st.mOrientation=Orientation.TR_BL;
break;
case 270:
st.mOrientation=Orientation.TOP_BOTTOM;
break;
case 315:
st.mOrientation=Orientation.TL_BR;
break;
}
}
 else {
final TypedValue tv=a.peekValue(R.styleable.GradientDrawableGradient_gradientRadius);
if (tv != null) {
final float radius;
final @RadiusType int radiusType;
if (tv.type == TypedValue.TYPE_FRACTION) {
radius=tv.getFraction(1.0f,1.0f);
final int unit=(tv.data >> TypedValue.COMPLEX_UNIT_SHIFT) & TypedValue.COMPLEX_UNIT_MASK;
if (unit == TypedValue.COMPLEX_UNIT_FRACTION_PARENT) {
radiusType=RADIUS_TYPE_FRACTION_PARENT;
}
 else {
radiusType=RADIUS_TYPE_FRACTION;
}
}
 else if (tv.type == TypedValue.TYPE_DIMENSION) {
radius=tv.getDimension(r.getDisplayMetrics());
radiusType=RADIUS_TYPE_PIXELS;
}
 else {
radius=tv.getFloat();
radiusType=RADIUS_TYPE_PIXELS;
}
st.mGradientRadius=radius;
st.mGradientRadiusType=radiusType;
}
 else if (st.mGradient == RADIAL_GRADIENT) {
throw new XmlPullParserException(a.getPositionDescription() + "<gradient> tag requires 'gradientRadius' " + "attribute with radial type");
}
}
}
