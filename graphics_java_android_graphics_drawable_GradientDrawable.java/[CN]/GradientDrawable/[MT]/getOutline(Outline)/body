{
  final GradientState st=mGradientState;
  final Rect bounds=getBounds();
  outline.setAlpha(st.mOpaqueOverShape ? (mAlpha / 255.0f) : 0.0f);
switch (st.mShape) {
case RECTANGLE:
    if (st.mRadiusArray != null) {
      buildPathIfDirty();
      outline.setConvexPath(mPath);
      return;
    }
  float rad=0;
if (st.mRadius > 0.0f) {
  rad=Math.min(st.mRadius,Math.min(bounds.width(),bounds.height()) * 0.5f);
}
outline.setRoundRect(bounds,rad);
return;
case OVAL:
outline.setOval(bounds);
return;
case LINE:
final float halfStrokeWidth=mStrokePaint == null ? 0.0001f : mStrokePaint.getStrokeWidth() * 0.5f;
final float centerY=bounds.centerY();
final int top=(int)Math.floor(centerY - halfStrokeWidth);
final int bottom=(int)Math.ceil(centerY + halfStrokeWidth);
outline.setRect(bounds.left,top,bounds.right,bottom);
return;
default :
}
}
