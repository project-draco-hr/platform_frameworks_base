{
  if (mRectIsDirty) {
    mRectIsDirty=false;
    Rect bounds=getBounds();
    float inset=0;
    if (mStrokePaint != null) {
      inset=mStrokePaint.getStrokeWidth() * 0.5f;
    }
    final GradientState st=mGradientState;
    mRect.set(bounds.left + inset,bounds.top + inset,bounds.right - inset,bounds.bottom - inset);
    final int[] colors=st.mColors;
    if (colors != null) {
      RectF r=mRect;
      float x0, x1, y0, y1;
      if (st.mGradient == LINEAR_GRADIENT) {
        final float level=st.mUseLevel ? (float)getLevel() / 10000.0f : 1.0f;
switch (st.mOrientation) {
case TOP_BOTTOM:
          x0=r.left;
        y0=r.top;
      x1=x0;
    y1=level * r.bottom;
  break;
case TR_BL:
x0=r.right;
y0=r.top;
x1=level * r.left;
y1=level * r.bottom;
break;
case RIGHT_LEFT:
x0=r.right;
y0=r.top;
x1=level * r.left;
y1=y0;
break;
case BR_TL:
x0=r.right;
y0=r.bottom;
x1=level * r.left;
y1=level * r.top;
break;
case BOTTOM_TOP:
x0=r.left;
y0=r.bottom;
x1=x0;
y1=level * r.top;
break;
case BL_TR:
x0=r.left;
y0=r.bottom;
x1=level * r.right;
y1=level * r.top;
break;
case LEFT_RIGHT:
x0=r.left;
y0=r.top;
x1=level * r.right;
y1=y0;
break;
default :
x0=r.left;
y0=r.top;
x1=level * r.right;
y1=level * r.bottom;
break;
}
mFillPaint.setShader(new LinearGradient(x0,y0,x1,y1,colors,st.mPositions,Shader.TileMode.CLAMP));
if (!mGradientState.mHasSolidColor) {
mFillPaint.setColor(mAlpha << 24);
}
}
 else if (st.mGradient == RADIAL_GRADIENT) {
x0=r.left + (r.right - r.left) * st.mCenterX;
y0=r.top + (r.bottom - r.top) * st.mCenterY;
final float level=st.mUseLevel ? (float)getLevel() / 10000.0f : 1.0f;
mFillPaint.setShader(new RadialGradient(x0,y0,level * st.mGradientRadius,colors,null,Shader.TileMode.CLAMP));
if (!mGradientState.mHasSolidColor) {
mFillPaint.setColor(mAlpha << 24);
}
}
 else if (st.mGradient == SWEEP_GRADIENT) {
x0=r.left + (r.right - r.left) * st.mCenterX;
y0=r.top + (r.bottom - r.top) * st.mCenterY;
int[] tempColors=colors;
float[] tempPositions=null;
if (st.mUseLevel) {
tempColors=st.mTempColors;
final int length=colors.length;
if (tempColors == null || tempColors.length != length + 1) {
tempColors=st.mTempColors=new int[length + 1];
}
System.arraycopy(colors,0,tempColors,0,length);
tempColors[length]=colors[length - 1];
tempPositions=st.mTempPositions;
final float fraction=1.0f / (float)(length - 1);
if (tempPositions == null || tempPositions.length != length + 1) {
tempPositions=st.mTempPositions=new float[length + 1];
}
final float level=(float)getLevel() / 10000.0f;
for (int i=0; i < length; i++) {
tempPositions[i]=i * fraction * level;
}
tempPositions[length]=1.0f;
}
mFillPaint.setShader(new SweepGradient(x0,y0,tempColors,tempPositions));
if (!mGradientState.mHasSolidColor) {
mFillPaint.setColor(mAlpha << 24);
}
}
}
}
return !mRect.isEmpty();
}
