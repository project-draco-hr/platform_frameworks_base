{
  if (mRectIsDirty) {
    mRectIsDirty=false;
    Rect bounds=getBounds();
    float inset=0;
    if (mStrokePaint != null) {
      inset=mStrokePaint.getStrokeWidth() * 0.5f;
    }
    final GradientState st=mGradientState;
    mRect.set(bounds.left + inset,bounds.top + inset,bounds.right - inset,bounds.bottom - inset);
    if (st.mColors != null) {
      RectF r=mRect;
      float x0, x1, y0, y1;
      if (st.mGradient == LINEAR_GRADIENT) {
        final float level=st.mUseLevel ? (float)getLevel() / 10000.0f : 1.0f;
switch (st.mOrientation) {
case TOP_BOTTOM:
          x0=r.left;
        y0=r.top;
      x1=x0;
    y1=level * r.bottom;
  break;
case TR_BL:
x0=r.right;
y0=r.top;
x1=level * r.left;
y1=level * r.bottom;
break;
case RIGHT_LEFT:
x0=r.right;
y0=r.top;
x1=level * r.left;
y1=y0;
break;
case BR_TL:
x0=r.right;
y0=r.bottom;
x1=level * r.left;
y1=level * r.top;
break;
case BOTTOM_TOP:
x0=r.left;
y0=r.bottom;
x1=x0;
y1=level * r.top;
break;
case BL_TR:
x0=r.left;
y0=r.bottom;
x1=level * r.right;
y1=level * r.top;
break;
case LEFT_RIGHT:
x0=r.left;
y0=r.top;
x1=level * r.right;
y1=y0;
break;
default :
x0=r.left;
y0=r.top;
x1=level * r.right;
y1=level * r.bottom;
break;
}
mFillPaint.setShader(new LinearGradient(x0,y0,x1,y1,st.mColors,st.mPositions,Shader.TileMode.CLAMP));
}
 else if (st.mGradient == RADIAL_GRADIENT) {
x0=r.left + (r.right - r.left) * st.mCenterX;
y0=r.top + (r.bottom - r.top) * st.mCenterY;
final float level=st.mUseLevel ? (float)getLevel() / 10000.0f : 1.0f;
mFillPaint.setShader(new RadialGradient(x0,y0,level * st.mGradientRadius,st.mColors,null,Shader.TileMode.CLAMP));
}
 else if (st.mGradient == SWEEP_GRADIENT) {
x0=r.left + (r.right - r.left) * st.mCenterX;
y0=r.top + (r.bottom - r.top) * st.mCenterY;
float[] positions=null;
int[] colors=st.mColors;
if (st.mUseLevel) {
final int length=st.mColors.length;
colors=new int[length + 1];
System.arraycopy(st.mColors,0,colors,0,length);
colors[length]=st.mColors[length - 1];
final float fraction=1.0f / (float)(length - 1);
positions=new float[length + 1];
final float level=(float)getLevel() / 10000.0f;
for (int i=0; i < length; i++) {
positions[i]=i * fraction * level;
}
positions[length]=1.0f;
}
mFillPaint.setShader(new SweepGradient(x0,y0,colors,positions));
}
}
}
return !mRect.isEmpty();
}
