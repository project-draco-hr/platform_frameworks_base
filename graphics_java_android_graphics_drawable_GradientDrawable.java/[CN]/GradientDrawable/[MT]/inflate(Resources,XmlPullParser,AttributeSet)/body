{
  final GradientState st=mGradientState;
  TypedArray a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawable);
  super.inflateWithAttributes(r,parser,a,com.android.internal.R.styleable.GradientDrawable_visible);
  int shapeType=a.getInt(com.android.internal.R.styleable.GradientDrawable_shape,RECTANGLE);
  boolean dither=a.getBoolean(com.android.internal.R.styleable.GradientDrawable_dither,false);
  if (shapeType == RING) {
    st.mInnerRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawable_innerRadius,-1);
    if (st.mInnerRadius == -1) {
      st.mInnerRadiusRatio=a.getFloat(com.android.internal.R.styleable.GradientDrawable_innerRadiusRatio,3.0f);
    }
    st.mThickness=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawable_thickness,-1);
    if (st.mThickness == -1) {
      st.mThicknessRatio=a.getFloat(com.android.internal.R.styleable.GradientDrawable_thicknessRatio,9.0f);
    }
    st.mUseLevelForShape=a.getBoolean(com.android.internal.R.styleable.GradientDrawable_useLevel,true);
  }
  a.recycle();
  setShape(shapeType);
  setDither(dither);
  int type;
  final int innerDepth=parser.getDepth() + 1;
  int depth;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && ((depth=parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
    if (type != XmlPullParser.START_TAG) {
      continue;
    }
    if (depth > innerDepth) {
      continue;
    }
    String name=parser.getName();
    if (name.equals("size")) {
      a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableSize);
      int width=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableSize_width,-1);
      int height=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableSize_height,-1);
      a.recycle();
      setSize(width,height);
    }
 else     if (name.equals("gradient")) {
      a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableGradient);
      int startColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_startColor,0);
      boolean hasCenterColor=a.hasValue(com.android.internal.R.styleable.GradientDrawableGradient_centerColor);
      int centerColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_centerColor,0);
      int endColor=a.getColor(com.android.internal.R.styleable.GradientDrawableGradient_endColor,0);
      int gradientType=a.getInt(com.android.internal.R.styleable.GradientDrawableGradient_type,LINEAR_GRADIENT);
      st.mCenterX=getFloatOrFraction(a,com.android.internal.R.styleable.GradientDrawableGradient_centerX,0.5f);
      st.mCenterY=getFloatOrFraction(a,com.android.internal.R.styleable.GradientDrawableGradient_centerY,0.5f);
      st.mUseLevel=a.getBoolean(com.android.internal.R.styleable.GradientDrawableGradient_useLevel,false);
      st.mGradient=gradientType;
      if (gradientType == LINEAR_GRADIENT) {
        int angle=(int)a.getFloat(com.android.internal.R.styleable.GradientDrawableGradient_angle,0);
        angle%=360;
        if (angle % 45 != 0) {
          throw new XmlPullParserException(a.getPositionDescription() + "<gradient> tag requires 'angle' attribute to " + "be a multiple of 45");
        }
switch (angle) {
case 0:
          st.mOrientation=Orientation.LEFT_RIGHT;
        break;
case 45:
      st.mOrientation=Orientation.BL_TR;
    break;
case 90:
  st.mOrientation=Orientation.BOTTOM_TOP;
break;
case 135:
st.mOrientation=Orientation.BR_TL;
break;
case 180:
st.mOrientation=Orientation.RIGHT_LEFT;
break;
case 225:
st.mOrientation=Orientation.TR_BL;
break;
case 270:
st.mOrientation=Orientation.TOP_BOTTOM;
break;
case 315:
st.mOrientation=Orientation.TL_BR;
break;
}
}
 else {
TypedValue tv=a.peekValue(com.android.internal.R.styleable.GradientDrawableGradient_gradientRadius);
if (tv != null) {
boolean radiusRel=tv.type == TypedValue.TYPE_FRACTION;
st.mGradientRadius=radiusRel ? tv.getFraction(1.0f,1.0f) : tv.getFloat();
}
 else if (gradientType == RADIAL_GRADIENT) {
throw new XmlPullParserException(a.getPositionDescription() + "<gradient> tag requires 'gradientRadius' " + "attribute with radial type");
}
}
a.recycle();
if (hasCenterColor) {
st.mColors=new int[3];
st.mColors[0]=startColor;
st.mColors[1]=centerColor;
st.mColors[2]=endColor;
st.mPositions=new float[3];
st.mPositions[0]=0.0f;
st.mPositions[1]=st.mCenterX != 0.5f ? st.mCenterX : st.mCenterY;
st.mPositions[2]=1f;
}
 else {
st.mColors=new int[2];
st.mColors[0]=startColor;
st.mColors[1]=endColor;
}
}
 else if (name.equals("solid")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableSolid);
final ColorStateList colorStateList=a.getColorStateList(com.android.internal.R.styleable.GradientDrawableSolid_color);
a.recycle();
setColor(colorStateList);
}
 else if (name.equals("stroke")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawableStroke);
int width=a.getDimensionPixelSize(com.android.internal.R.styleable.GradientDrawableStroke_width,0);
int color=a.getColor(com.android.internal.R.styleable.GradientDrawableStroke_color,0);
float dashWidth=a.getDimension(com.android.internal.R.styleable.GradientDrawableStroke_dashWidth,0);
if (dashWidth != 0.0f) {
float dashGap=a.getDimension(com.android.internal.R.styleable.GradientDrawableStroke_dashGap,0);
setStroke(width,color,dashWidth,dashGap);
}
 else {
setStroke(width,color);
}
a.recycle();
}
 else if (name.equals("corners")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.DrawableCorners);
int radius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_radius,0);
setCornerRadius(radius);
int topLeftRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_topLeftRadius,radius);
int topRightRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_topRightRadius,radius);
int bottomLeftRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_bottomLeftRadius,radius);
int bottomRightRadius=a.getDimensionPixelSize(com.android.internal.R.styleable.DrawableCorners_bottomRightRadius,radius);
if (topLeftRadius != radius || topRightRadius != radius || bottomLeftRadius != radius || bottomRightRadius != radius) {
setCornerRadii(new float[]{topLeftRadius,topLeftRadius,topRightRadius,topRightRadius,bottomRightRadius,bottomRightRadius,bottomLeftRadius,bottomLeftRadius});
}
a.recycle();
}
 else if (name.equals("padding")) {
a=r.obtainAttributes(attrs,com.android.internal.R.styleable.GradientDrawablePadding);
mPadding=new Rect(a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_left,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_top,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_right,0),a.getDimensionPixelOffset(com.android.internal.R.styleable.GradientDrawablePadding_bottom,0));
a.recycle();
mGradientState.mPadding=mPadding;
}
 else {
Log.w("drawable","Bad element under <shape>: " + name);
}
}
mGradientState.computeOpacity();
}
