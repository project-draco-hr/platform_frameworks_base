{
  int recCount=0;
  boolean error=false;
  mKeyToPosMap.clear();
  while (bytesLeft > kRecordHeaderSize) {
    final int start=parcel.dataPosition();
    final int size=parcel.readInt();
    if (size <= kRecordHeaderSize) {
      Log.e(TAG,"Record is too short");
      error=true;
      break;
    }
    final int metadataId=parcel.readInt();
    if (!checkMetadataId(metadataId)) {
      error=true;
      break;
    }
    if (mKeyToPosMap.containsKey(metadataId)) {
      Log.e(TAG,"Duplicate metadata ID found");
      error=true;
      break;
    }
    mKeyToPosMap.put(metadataId,parcel.dataPosition());
    final int metadataType=parcel.readInt();
    if (metadataType <= 0 || metadataType > LAST_TYPE) {
      Log.e(TAG,"Invalid metadata type " + metadataType);
      error=true;
      break;
    }
    try {
      parcel.setDataPosition(MathUtils.addOrThrow(start,size));
    }
 catch (    IllegalArgumentException e) {
      Log.e(TAG,"Invalid size: " + e.getMessage());
      error=true;
      break;
    }
    bytesLeft-=size;
    ++recCount;
  }
  if (0 != bytesLeft || error) {
    Log.e(TAG,"Ran out of data or error on record " + recCount);
    mKeyToPosMap.clear();
    return false;
  }
 else {
    return true;
  }
}
