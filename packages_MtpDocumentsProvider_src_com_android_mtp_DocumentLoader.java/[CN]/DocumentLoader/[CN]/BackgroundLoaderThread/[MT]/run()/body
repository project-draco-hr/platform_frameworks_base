{
  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
  while (true) {
    LoaderTask task;
    int deviceId;
    int[] handles;
synchronized (DocumentLoader.this) {
      task=mTaskList.findRunningTask();
      if (task == null) {
        mHasBackgroundThread=false;
        return;
      }
      deviceId=task.mIdentifier.mDeviceId;
      handles=task.getUnloadedObjectHandles(NUM_LOADING_ENTRIES);
    }
    try {
      final MtpObjectInfo[] objectInfos=loadDocuments(mMtpManager,deviceId,handles);
      task.fillDocuments(objectInfos);
      final boolean shouldNotify=task.mLastNotified.getTime() < new Date().getTime() - NOTIFY_PERIOD_MS || task.getState() != LoaderTask.STATE_LOADING;
      if (shouldNotify) {
        task.notify(mResolver);
      }
    }
 catch (    IOException exception) {
      task.setError(exception);
    }
  }
}
