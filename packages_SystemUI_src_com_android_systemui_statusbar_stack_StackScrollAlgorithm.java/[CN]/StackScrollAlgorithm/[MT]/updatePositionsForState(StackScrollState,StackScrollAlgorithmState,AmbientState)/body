{
  float bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mBottomStackSlowDownLength;
  float currentYPosition=0.0f;
  float yPositionInScrollView=0.0f;
  ExpandableNotificationRow topHeadsUpEntry=ambientState.getTopHeadsUpEntry();
  int childCount=algorithmState.visibleChildren.size();
  int numberOfElementsCompletelyIn=(int)algorithmState.itemsInTopStack;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackViewState.LOCATION_UNKNOWN;
    int childHeight=getMaxAllowedChildHeight(child,ambientState);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    float scrollOffset=yPositionInScrollView - algorithmState.scrollY + mCollapsedSize;
    if (i == algorithmState.lastTopStackIndex + 1) {
      currentYPosition=Math.min(scrollOffset,bottomStackStart);
    }
    childViewState.yTranslation=currentYPosition;
    float nextYPosition=currentYPosition + childHeight + mPaddingBetweenElements;
    if (i <= algorithmState.lastTopStackIndex) {
      updateStateForTopStackChild(algorithmState,numberOfElementsCompletelyIn,i,childHeight,childViewState,scrollOffset);
      clampPositionToTopStackEnd(childViewState,childHeight);
      if (childViewState.yTranslation + childHeight + mPaddingBetweenElements >= bottomStackStart && !mIsExpansionChanging && i != 0 && mIsSmallScreen) {
        int newSize=(int)Math.max(bottomStackStart - mPaddingBetweenElements - childViewState.yTranslation,mCollapsedSize);
        childViewState.height=newSize;
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,childViewState.yTranslation,childViewState,childHeight);
      }
      clampPositionToBottomStackStart(childViewState,childViewState.height,ambientState);
    }
 else     if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,childHeight,ambientState);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,bottomPeekStart,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackViewState.LOCATION_MAIN_AREA;
      clampYTranslation(childViewState,childHeight,ambientState);
    }
    if (i == 0) {
      childViewState.alpha=1.0f;
      childViewState.yTranslation=Math.max(mCollapsedSize - algorithmState.scrollY,0);
      if (childViewState.yTranslation + childViewState.height > bottomPeekStart - mCollapseSecondCardPadding) {
        childViewState.height=(int)Math.max(bottomPeekStart - mCollapseSecondCardPadding - childViewState.yTranslation,mCollapsedSize);
      }
      childViewState.location=StackViewState.LOCATION_FIRST_CARD;
    }
    if (childViewState.location == StackViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,"Failed to assign location for child " + i);
    }
    currentYPosition=childViewState.yTranslation + childHeight + mPaddingBetweenElements;
    yPositionInScrollView=yPositionInScrollViewAfterElement;
    if (ambientState.isShadeExpanded() && topHeadsUpEntry != null && child != topHeadsUpEntry) {
      childViewState.yTranslation+=topHeadsUpEntry.getHeadsUpHeight() - mCollapsedSize;
    }
    childViewState.yTranslation+=ambientState.getTopPadding() + ambientState.getStackTranslation();
  }
  updateHeadsUpStates(resultState,algorithmState,ambientState);
}
