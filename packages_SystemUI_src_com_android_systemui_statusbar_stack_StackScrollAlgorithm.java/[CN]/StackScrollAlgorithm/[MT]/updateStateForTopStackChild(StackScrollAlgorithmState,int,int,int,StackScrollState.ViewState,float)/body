{
  int paddedIndex=i - 1 - Math.max(numberOfElementsCompletelyIn - MAX_ITEMS_IN_TOP_STACK,0);
  if (paddedIndex >= 0) {
    float distanceToStack=(childHeight + mPaddingBetweenElements) - algorithmState.scrolledPixelsTop;
    if (i == algorithmState.lastTopStackIndex && distanceToStack > (mTopStackTotalSize + mPaddingBetweenElements)) {
      childViewState.yTranslation=scrollOffset;
    }
 else {
      float numItemsBefore;
      if (i == algorithmState.lastTopStackIndex) {
        numItemsBefore=1.0f - (distanceToStack / (mTopStackTotalSize + mPaddingBetweenElements));
      }
 else {
        numItemsBefore=algorithmState.itemsInTopStack - i;
      }
      float currentChildEndY=mCollapsedSize + mTopStackTotalSize - mTopStackIndentationFunctor.getValue(numItemsBefore);
      childViewState.yTranslation=currentChildEndY - childHeight;
    }
    childViewState.location=StackScrollState.ViewState.LOCATION_TOP_STACK_PEEKING;
  }
 else {
    if (paddedIndex == -1) {
      childViewState.alpha=1.0f - algorithmState.partialInTop;
    }
 else {
      childViewState.alpha=0.0f;
    }
    childViewState.yTranslation=mCollapsedSize - childHeight;
    childViewState.location=StackScrollState.ViewState.LOCATION_TOP_STACK_HIDDEN;
  }
}
