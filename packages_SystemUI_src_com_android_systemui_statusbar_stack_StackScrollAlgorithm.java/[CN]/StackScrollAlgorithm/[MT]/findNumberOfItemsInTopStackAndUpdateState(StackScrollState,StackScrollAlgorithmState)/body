{
  float yPositionInScrollView=0.0f;
  int childCount=algorithmState.visibleChildren.size();
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackScrollState.ViewState childViewState=resultState.getViewStateForView(child);
    int childHeight=getMaxAllowedChildHeight(child);
    float yPositionInScrollViewAfterElement=yPositionInScrollView + childHeight + mPaddingBetweenElements;
    if (yPositionInScrollView < algorithmState.scrollY) {
      if (i == 0 && algorithmState.scrollY <= mCollapsedSize) {
        int bottomPeekStart=mInnerHeight - mBottomStackPeekSize;
        float maxHeight=mIsExpansionChanging && child == mFirstChildWhileExpanding ? mFirstChildMaxHeight : childHeight;
        childViewState.height=(int)Math.max(Math.min(bottomPeekStart,maxHeight),mCollapsedSize);
        algorithmState.itemsInTopStack=1.0f;
      }
 else       if (yPositionInScrollViewAfterElement < algorithmState.scrollY) {
        algorithmState.itemsInTopStack+=1.0f;
        if (i == 0) {
          childViewState.height=mCollapsedSize;
        }
      }
 else {
        float newSize=yPositionInScrollViewAfterElement - mPaddingBetweenElements - algorithmState.scrollY;
        if (i == 0) {
          newSize+=mCollapsedSize;
        }
        algorithmState.scrolledPixelsTop=childHeight - newSize;
        algorithmState.partialInTop=(algorithmState.scrolledPixelsTop) / (childHeight + mPaddingBetweenElements);
        algorithmState.partialInTop=Math.max(0.0f,algorithmState.partialInTop);
        algorithmState.itemsInTopStack+=algorithmState.partialInTop;
        newSize=Math.max(mCollapsedSize,newSize);
        if (i == 0) {
          childViewState.height=(int)newSize;
        }
        algorithmState.lastTopStackIndex=i;
        break;
      }
    }
 else {
      algorithmState.lastTopStackIndex=i - 1;
      break;
    }
    yPositionInScrollView=yPositionInScrollViewAfterElement;
  }
}
