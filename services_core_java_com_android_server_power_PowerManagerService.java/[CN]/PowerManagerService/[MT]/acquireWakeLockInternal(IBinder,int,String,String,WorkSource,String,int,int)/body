{
synchronized (mLock) {
    if (DEBUG_SPEW) {
      Slog.d(TAG,"acquireWakeLockInternal: lock=" + Objects.hashCode(lock) + ", flags=0x"+ Integer.toHexString(flags)+ ", tag=\""+ tag+ "\", ws="+ ws+ ", uid="+ uid+ ", pid="+ pid);
    }
    WakeLock wakeLock;
    int index=findWakeLockIndexLocked(lock);
    boolean notifyAcquire;
    if (index >= 0) {
      wakeLock=mWakeLocks.get(index);
      if (!wakeLock.hasSameProperties(flags,tag,ws,uid,pid)) {
        notifyWakeLockChangingLocked(wakeLock,flags,tag,packageName,uid,pid,ws,historyTag);
        wakeLock.updateProperties(flags,tag,packageName,ws,historyTag,uid,pid);
      }
      notifyAcquire=false;
    }
 else {
      wakeLock=new WakeLock(lock,flags,tag,packageName,ws,historyTag,uid,pid);
      try {
        lock.linkToDeath(wakeLock,0);
      }
 catch (      RemoteException ex) {
        throw new IllegalArgumentException("Wake lock is already dead.");
      }
      mWakeLocks.add(wakeLock);
      notifyAcquire=true;
    }
    applyWakeLockFlagsOnAcquireLocked(wakeLock,uid);
    mDirty|=DIRTY_WAKE_LOCKS;
    updatePowerStateLocked();
    if (notifyAcquire) {
      notifyWakeLockAcquiredLocked(wakeLock);
    }
  }
}
