{
synchronized (mLock) {
    int index=findWakeLockIndexLocked(lock);
    if (index < 0) {
      if (DEBUG_SPEW) {
        Slog.d(TAG,"releaseWakeLockInternal: lock=" + Objects.hashCode(lock) + " [not found], flags=0x"+ Integer.toHexString(flags));
      }
      return;
    }
    WakeLock wakeLock=mWakeLocks.get(index);
    if (DEBUG_SPEW) {
      Slog.d(TAG,"releaseWakeLockInternal: lock=" + Objects.hashCode(lock) + " ["+ wakeLock.mTag+ "], flags=0x"+ Integer.toHexString(flags));
    }
    if ((flags & PowerManager.RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY) != 0) {
      mRequestWaitForNegativeProximity=true;
    }
    if ((wakeLock.mFlags & PowerManager.WAKE_LOCK_LEVEL_MASK) == PowerManager.SUSTAINED_PERFORMANCE_WAKE_LOCK) {
      int numberWakelock=mSustainedPerformanceUid.get(wakeLock.mOwnerUid);
      if (numberWakelock == 1) {
        mSustainedPerformanceUid.delete(wakeLock.mOwnerUid);
      }
 else {
        mSustainedPerformanceUid.put(wakeLock.mOwnerUid,numberWakelock - 1);
      }
    }
    wakeLock.mLock.unlinkToDeath(wakeLock,0);
    removeWakeLockLocked(wakeLock,index);
  }
}
