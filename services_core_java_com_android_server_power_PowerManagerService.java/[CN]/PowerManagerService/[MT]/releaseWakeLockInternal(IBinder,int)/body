{
synchronized (mLock) {
    int index=findWakeLockIndexLocked(lock);
    if (index < 0) {
      if (DEBUG_SPEW) {
        Slog.d(TAG,"releaseWakeLockInternal: lock=" + Objects.hashCode(lock) + " [not found], flags=0x"+ Integer.toHexString(flags));
      }
      return;
    }
    WakeLock wakeLock=mWakeLocks.get(index);
    if (DEBUG_SPEW) {
      Slog.d(TAG,"releaseWakeLockInternal: lock=" + Objects.hashCode(lock) + " ["+ wakeLock.mTag+ "], flags=0x"+ Integer.toHexString(flags));
    }
    mWakeLocks.remove(index);
    notifyWakeLockReleasedLocked(wakeLock);
    wakeLock.mLock.unlinkToDeath(wakeLock,0);
    if ((flags & PowerManager.WAIT_FOR_PROXIMITY_NEGATIVE) != 0) {
      mRequestWaitForNegativeProximity=true;
    }
    applyWakeLockFlagsOnReleaseLocked(wakeLock);
    mDirty|=DIRTY_WAKE_LOCKS;
    updatePowerStateLocked();
  }
}
