{
  stop();
  if (boundPosition == INVALID_POSITION) {
    start(position);
    return;
  }
  if (mDataChanged) {
    mPositionScrollAfterLayout=new Runnable(){
      @Override public void run(){
        start(position,boundPosition);
      }
    }
;
    return;
  }
  final int childCount=getChildCount();
  if (childCount == 0) {
    return;
  }
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + childCount - 1;
  int viewTravelCount;
  int clampedPosition=Math.max(0,Math.min(getCount() - 1,position));
  if (clampedPosition < firstPos) {
    final int boundPosFromLast=lastPos - boundPosition;
    if (boundPosFromLast < 1) {
      return;
    }
    final int posTravel=firstPos - clampedPosition + 1;
    final int boundTravel=boundPosFromLast - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_UP_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_UP_POS;
    }
  }
 else   if (clampedPosition > lastPos) {
    final int boundPosFromFirst=boundPosition - firstPos;
    if (boundPosFromFirst < 1) {
      return;
    }
    final int posTravel=clampedPosition - lastPos + 1;
    final int boundTravel=boundPosFromFirst - 1;
    if (boundTravel < posTravel) {
      viewTravelCount=boundTravel;
      mMode=MOVE_DOWN_BOUND;
    }
 else {
      viewTravelCount=posTravel;
      mMode=MOVE_DOWN_POS;
    }
  }
 else {
    scrollToVisible(clampedPosition,boundPosition,SCROLL_DURATION);
    return;
  }
  if (viewTravelCount > 0) {
    mScrollDuration=SCROLL_DURATION / viewTravelCount;
  }
 else {
    mScrollDuration=SCROLL_DURATION;
  }
  mTargetPos=clampedPosition;
  mBoundPos=boundPosition;
  mLastSeenPos=INVALID_POSITION;
  postOnAnimation(this);
}
