{
  stop();
  if (mDataChanged) {
    final int postOffset=offset;
    mPositionScrollAfterLayout=new Runnable(){
      @Override public void run(){
        startWithOffset(position,postOffset,duration);
      }
    }
;
    return;
  }
  final int childCount=getChildCount();
  if (childCount == 0) {
    return;
  }
  offset+=getPaddingTop();
  mTargetPos=Math.max(0,Math.min(getCount() - 1,position));
  mOffsetFromTop=offset;
  mBoundPos=INVALID_POSITION;
  mLastSeenPos=INVALID_POSITION;
  mMode=MOVE_OFFSET;
  final int firstPos=mFirstPosition;
  final int lastPos=firstPos + childCount - 1;
  int viewTravelCount;
  if (mTargetPos < firstPos) {
    viewTravelCount=firstPos - mTargetPos;
  }
 else   if (mTargetPos > lastPos) {
    viewTravelCount=mTargetPos - lastPos;
  }
 else {
    final int targetTop=getChildAt(mTargetPos - firstPos).getTop();
    smoothScrollBy(targetTop - offset,duration,true);
    return;
  }
  final float screenTravelCount=(float)viewTravelCount / childCount;
  mScrollDuration=screenTravelCount < 1 ? duration : (int)(duration / screenTravelCount);
  mLastSeenPos=INVALID_POSITION;
  postOnAnimation(this);
}
