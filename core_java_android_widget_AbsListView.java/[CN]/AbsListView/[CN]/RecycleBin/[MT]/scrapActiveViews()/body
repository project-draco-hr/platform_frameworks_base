{
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=count - 1; i >= 0; i--) {
    final View victim=activeViews[i];
    if (victim != null) {
      final AbsListView.LayoutParams lp=(AbsListView.LayoutParams)victim.getLayoutParams();
      int whichScrap=lp.viewType;
      activeViews[i]=null;
      final boolean scrapHasTransientState=victim.hasTransientState();
      if (!shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
        if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
          removeDetachedView(victim,false);
        }
        if (scrapHasTransientState) {
          if (mTransientStateViews == null) {
            mTransientStateViews=new SparseArray<View>();
          }
          mTransientStateViews.put(mFirstActivePosition + i,victim);
        }
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      victim.dispatchStartTemporaryDetach();
      lp.scrappedFromPosition=mFirstActivePosition + i;
      scrapViews.add(victim);
      victim.setAccessibilityDelegate(null);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}
