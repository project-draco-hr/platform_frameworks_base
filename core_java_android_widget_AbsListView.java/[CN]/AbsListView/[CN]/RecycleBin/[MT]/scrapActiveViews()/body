{
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=count - 1; i >= 0; i--) {
    final View victim=activeViews[i];
    if (victim != null) {
      final AbsListView.LayoutParams lp=(AbsListView.LayoutParams)victim.getLayoutParams();
      int whichScrap=lp.viewType;
      activeViews[i]=null;
      final boolean scrapHasTransientState=victim.hasTransientState();
      if (!shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
        if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER || scrapHasTransientState) {
          removeDetachedView(victim,false);
        }
        if (scrapHasTransientState) {
          if (mAdapter != null && mAdapterHasStableIds) {
            if (mTransientStateViewsById == null) {
              mTransientStateViewsById=new LongSparseArray<View>();
            }
            long id=mAdapter.getItemId(mFirstActivePosition + i);
            mTransientStateViewsById.put(id,victim);
          }
 else {
            if (mTransientStateViews == null) {
              mTransientStateViews=new SparseArray<View>();
            }
            mTransientStateViews.put(mFirstActivePosition + i,victim);
          }
        }
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      victim.dispatchStartTemporaryDetach();
      lp.scrappedFromPosition=mFirstActivePosition + i;
      scrapViews.add(victim);
      victim.setAccessibilityDelegate(null);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
    }
  }
  pruneScrapViews();
}
