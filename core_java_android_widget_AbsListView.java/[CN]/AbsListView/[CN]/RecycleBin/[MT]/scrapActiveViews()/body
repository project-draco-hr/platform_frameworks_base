{
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=count - 1; i >= 0; i--) {
    final View victim=activeViews[i];
    if (victim != null) {
      final AbsListView.LayoutParams lp=(AbsListView.LayoutParams)victim.getLayoutParams();
      final int whichScrap=lp.viewType;
      activeViews[i]=null;
      if (victim.hasTransientState()) {
        victim.dispatchStartTemporaryDetach();
        if (mAdapter != null && mAdapterHasStableIds) {
          if (mTransientStateViewsById == null) {
            mTransientStateViewsById=new LongSparseArray<View>();
          }
          long id=mAdapter.getItemId(mFirstActivePosition + i);
          mTransientStateViewsById.put(id,victim);
        }
 else         if (!mDataChanged) {
          if (mTransientStateViews == null) {
            mTransientStateViews=new SparseArray<View>();
          }
          mTransientStateViews.put(mFirstActivePosition + i,victim);
        }
 else         if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
          removeDetachedView(victim,false);
        }
      }
 else       if (!shouldRecycleViewType(whichScrap)) {
        if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
          removeDetachedView(victim,false);
        }
      }
 else {
        if (multipleScraps) {
          scrapViews=mScrapViews[whichScrap];
        }
        lp.scrappedFromPosition=mFirstActivePosition + i;
        removeDetachedView(victim,false);
        scrapViews.add(victim);
        if (hasListener) {
          mRecyclerListener.onMovedToScrapHeap(victim);
        }
      }
    }
  }
  pruneScrapViews();
}
