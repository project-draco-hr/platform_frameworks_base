{
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mMotionY=mLastY=(int)ev.getY();
          mMotionCorrection=0;
          mActivePointerId=ev.getPointerId(0);
          break;
        }
default :
{
        mActivePointerId=ev.getPointerId(0);
        final int x=(int)ev.getX();
        final int y=(int)ev.getY();
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            if (mTouchMode == TOUCH_MODE_FLING) {
              createScrollingCache();
              mTouchMode=TOUCH_MODE_SCROLL;
              mMotionCorrection=0;
              motionPosition=findMotionRow(y);
              reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
            }
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
        }
        mMotionX=x;
        mMotionY=y;
        mMotionPosition=motionPosition;
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final int y=(int)ev.getY(pointerIndex);
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing("AbsListViewScroll");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
if ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) == 0 && Math.abs(deltaY) > mTouchSlop) {
requestDisallowInterceptTouchEvent(true);
}
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int motionIndex;
if (mMotionPosition >= 0) {
motionIndex=mMotionPosition - mFirstPosition;
}
 else {
motionIndex=getChildCount() / 2;
}
int motionViewPrevTop=0;
View motionView=this.getChildAt(motionIndex);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
boolean atEdge=false;
if (incrementalDeltaY != 0) {
atEdge=trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(motionIndex);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
if (atEdge) {
  int overscroll=-incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  overscrollBy(0,overscroll,0,mScrollY,0,0,0,mOverscrollDistance,true);
  if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
    mVelocityTracker.clear();
  }
  final int overscrollMode=getOverscrollMode();
  if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
    mDirection=0;
    mTouchMode=TOUCH_MODE_OVERSCROLL;
    if (rawDeltaY > 0) {
      mEdgeGlowTop.onPull((float)overscroll / getHeight());
    }
 else     if (rawDeltaY < 0) {
      mEdgeGlowBottom.onPull((float)overscroll / getHeight());
    }
  }
}
mMotionY=y;
invalidate();
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
final int rawDeltaY=deltaY;
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
int newDirection=y > mLastY ? 1 : -1;
if (mDirection == 0) {
mDirection=newDirection;
}
if (mDirection != newDirection) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findClosestMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
overscrollBy(0,-incrementalDeltaY,0,mScrollY,0,0,0,mOverscrollDistance,true);
final int overscrollMode=getOverscrollMode();
if (overscrollMode == OVERSCROLL_ALWAYS || (overscrollMode == OVERSCROLL_IF_CONTENT_SCROLLS && !contentFits())) {
if (rawDeltaY > 0) {
mEdgeGlowTop.onPull((float)-incrementalDeltaY / getHeight());
}
 else if (rawDeltaY < 0) {
mEdgeGlowBottom.onPull((float)-incrementalDeltaY / getHeight());
}
invalidate();
}
if (Math.abs(mOverscrollDistance) == Math.abs(mScrollY)) {
mVelocityTracker.clear();
}
}
mLastY=y;
mDirection=newDirection;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
mTouchMode=TOUCH_MODE_TAP;
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
 else {
mTouchMode=TOUCH_MODE_REST;
}
return true;
}
 else if (!mDataChanged && mAdapter.isEnabled(motionPosition)) {
post(performClick);
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
final int firstChildTop=getChildAt(0).getTop();
final int lastChildBottom=getChildAt(childCount - 1).getBottom();
final int contentTop=mListPadding.top;
final int contentBottom=getHeight() - mListPadding.bottom;
if (mFirstPosition == 0 && firstChildTop >= contentTop && mFirstPosition + childCount < mItemCount && lastChildBottom <= getHeight() - contentBottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (Math.abs(initialVelocity) > mMinimumVelocity && !((mFirstPosition == 0 && firstChildTop == contentTop - mOverscrollDistance) || (mFirstPosition + childCount == mItemCount && lastChildBottom == contentBottom + mOverscrollDistance))) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
mActivePointerId=INVALID_POINTER;
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
if (mEdgeGlowTop != null) {
mEdgeGlowTop.onRelease();
mEdgeGlowBottom.onRelease();
}
mActivePointerId=INVALID_POINTER;
break;
}
case MotionEvent.ACTION_POINTER_UP:
{
onSecondaryPointerUp(ev);
final int x=mMotionX;
final int y=mMotionY;
final int motionPosition=pointToPosition(x,y);
if (motionPosition >= 0) {
v=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=v.getTop();
mMotionPosition=motionPosition;
}
mLastY=y;
break;
}
}
return true;
}
