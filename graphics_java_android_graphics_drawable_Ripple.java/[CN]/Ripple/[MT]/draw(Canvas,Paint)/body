{
  final Rect bounds=mBounds;
  final Rect padding=mPadding;
  final float dX=Math.max(mX,bounds.right - mX);
  final float dY=Math.max(mY,bounds.bottom - mY);
  final int maxRadius=(int)Math.ceil(Math.sqrt(dX * dX + dY * dY));
  final long currentTime=AnimationUtils.currentAnimationTimeMillis();
  final float enterState=mEnterTime < 0 ? 0 : INTERPOLATOR.getInterpolation(MathUtils.constrain((currentTime - mEnterTime) / (float)ENTER_DURATION,0,1));
  final float outsideState=mOutsideTime < 0 ? 1 : INTERPOLATOR.getInterpolation(MathUtils.constrain((currentTime - mOutsideTime) / (float)OUTSIDE_DURATION,0,1));
  final float exitState=mExitTime < 0 ? 0 : INTERPOLATOR.getInterpolation(MathUtils.constrain((currentTime - mExitTime) / (float)EXIT_DURATION,0,1));
  final float insideRadius=MathUtils.lerp(mMinRadius,maxRadius,enterState);
  final float outerRadius=MathUtils.lerp(mOutsideRadius,insideRadius,mInside ? outsideState : 1 - outsideState);
  final float x=looseConstrain(mX,bounds.left + padding.left,bounds.right - padding.right,outerRadius * OUTSIDE_MARGIN,OUTSIDE_RESISTANCE);
  final float y=looseConstrain(mY,bounds.top + padding.top,bounds.bottom - padding.bottom,outerRadius * OUTSIDE_MARGIN,OUTSIDE_RESISTANCE);
  final long pulseTime=(currentTime - mEnterTime - ENTER_DURATION- PULSE_DELAY);
  final int maxAlpha;
  if (pulseTime < 0) {
    maxAlpha=255;
  }
 else {
    final float pulseState=(pulseTime % (PULSE_INTERVAL + PULSE_DURATION)) / (float)PULSE_DURATION;
    if (pulseState >= 1) {
      maxAlpha=255;
    }
 else {
      final float pulseAlpha;
      if (pulseState > 0.5) {
        pulseAlpha=MathUtils.lerp(PULSE_MIN_ALPHA,255,(pulseState - .5f) * 2);
      }
 else {
        pulseAlpha=MathUtils.lerp(255,PULSE_MIN_ALPHA,pulseState * 2f);
      }
      if (exitState > 0) {
        maxAlpha=(int)(MathUtils.lerp(255,pulseAlpha,exitState) + 0.5f);
      }
 else       if (mInside) {
        maxAlpha=(int)(pulseAlpha + 0.5f);
      }
 else {
        maxAlpha=(int)(MathUtils.lerp(pulseAlpha,255,outsideState) + 0.5f);
      }
    }
  }
  if (maxAlpha > 0) {
    if (exitState <= 0) {
      if (outerRadius > 0) {
        p.setAlpha(maxAlpha);
        p.setStyle(Style.FILL);
        c.drawCircle(x,y,outerRadius,p);
        return true;
      }
    }
 else {
      final float innerRadius=MathUtils.lerp(0,outerRadius,exitState);
      final float strokeWidth=outerRadius - innerRadius;
      if (strokeWidth > 0) {
        final float strokeRadius=innerRadius + strokeWidth / 2f;
        final int alpha=(int)(MathUtils.lerp(maxAlpha,0,exitState) + 0.5f);
        if (alpha > 0) {
          p.setAlpha(alpha);
          p.setStyle(Style.STROKE);
          p.setStrokeWidth(strokeWidth);
          c.drawCircle(x,y,strokeRadius,p);
          return true;
        }
      }
    }
  }
  return false;
}
