{
  cancelSoftwareAnimations();
  mX=MathUtils.lerp(mStartingX - mBounds.exactCenterX(),mOuterX,mXGravity);
  mY=MathUtils.lerp(mStartingY - mBounds.exactCenterY(),mOuterY,mYGravity);
  final float remaining;
  if (mAnimRadius != null && mAnimRadius.isRunning()) {
    remaining=mOuterRadius - mRadius;
  }
 else {
    remaining=mOuterRadius;
  }
  final int radiusDuration=(int)(1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
  final int opacityDuration=(int)(1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
  final int outerInflection=Math.max(0,(int)(1000 * (mOpacity - mOuterOpacity) / (WAVE_OPACITY_DECAY_VELOCITY + WAVE_OUTER_OPACITY_VELOCITY) + 0.5f));
  final int inflectionOpacity=(int)(255 * (mOuterOpacity + outerInflection * WAVE_OUTER_OPACITY_VELOCITY / 1000) + 0.5f);
  if (mCanUseHardware) {
    exitHardware(radiusDuration,opacityDuration,outerInflection,inflectionOpacity);
  }
 else {
    exitSoftware(radiusDuration,opacityDuration,outerInflection,inflectionOpacity);
  }
}
