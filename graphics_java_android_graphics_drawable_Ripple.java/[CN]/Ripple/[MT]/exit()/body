{
  cancelSoftwareAnimations();
  final float radius=MathUtils.lerp(0,mOuterRadius,mTweenRadius);
  final float remaining;
  if (mAnimRadius != null && mAnimRadius.isRunning()) {
    remaining=mOuterRadius - radius;
  }
 else {
    remaining=mOuterRadius;
  }
  final int radiusDuration=(int)(1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
  final int opacityDuration=(int)(1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
  float outerSizeInfluence=MathUtils.constrain((mOuterRadius - WAVE_OUTER_SIZE_INFLUENCE_MIN * mDensity) / (WAVE_OUTER_SIZE_INFLUENCE_MAX * mDensity),0,1);
  float outerOpacityVelocity=MathUtils.lerp(WAVE_OUTER_OPACITY_VELOCITY_MIN,WAVE_OUTER_OPACITY_VELOCITY_MAX,outerSizeInfluence);
  final int outerInflection=Math.max(0,(int)(1000 * (mOpacity - mOuterOpacity) / (WAVE_OPACITY_DECAY_VELOCITY + outerOpacityVelocity) + 0.5f));
  final int inflectionOpacity=(int)(255 * (mOuterOpacity + outerInflection * outerOpacityVelocity * outerSizeInfluence / 1000) + 0.5f);
  if (mCanUseHardware) {
    exitHardware(radiusDuration,opacityDuration,outerInflection,inflectionOpacity);
  }
 else {
    exitSoftware(radiusDuration,opacityDuration,outerInflection,inflectionOpacity);
  }
}
