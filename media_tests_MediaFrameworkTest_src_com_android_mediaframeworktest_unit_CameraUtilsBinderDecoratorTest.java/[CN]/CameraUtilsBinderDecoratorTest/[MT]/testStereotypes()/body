{
  ICameraBinderStereotype mock=mock(ICameraBinderStereotype.class);
  try {
    when(mock.doNothing()).thenReturn(SOME_ARBITRARY_DOUBLE);
    when(mock.doSomethingPositive()).thenReturn(SOME_ARBITRARY_POSITIVE_INT);
    when(mock.doSomethingNoError()).thenReturn(NO_ERROR);
    when(mock.doSomethingPermissionDenied()).thenReturn(PERMISSION_DENIED);
    when(mock.doSomethingAlreadyExists()).thenReturn(ALREADY_EXISTS);
    when(mock.doSomethingBadValue()).thenReturn(BAD_VALUE);
    when(mock.doSomethingDeadObject()).thenReturn(DEAD_OBJECT);
    when(mock.doSomethingBadPolicy()).thenReturn(EACCES);
    when(mock.doSomethingDeviceBusy()).thenReturn(EBUSY);
    when(mock.doSomethingNoSuchDevice()).thenReturn(ENODEV);
    when(mock.doSomethingUnknownErrorCode()).thenReturn(SOME_ARBITRARY_NEGATIVE_INT);
    when(mock.doSomethingThrowDeadObjectException()).thenThrow(new DeadObjectException());
    when(mock.doSomethingThrowTransactionTooLargeException()).thenThrow(new TransactionTooLargeException());
  }
 catch (  RemoteException e) {
    Assert.fail("Unreachable");
  }
  ICameraBinderStereotype decoratedMock=CameraBinderDecorator.newInstance(mock);
  assertEquals(SOME_ARBITRARY_DOUBLE,decoratedMock.doNothing());
  assertEquals(SOME_ARBITRARY_POSITIVE_INT,decoratedMock.doSomethingPositive());
  assertEquals(NO_ERROR,decoratedMock.doSomethingNoError());
  try {
    decoratedMock.doSomethingPermissionDenied();
    Assert.fail("Should've thrown SecurityException");
  }
 catch (  SecurityException e) {
  }
  assertEquals(ALREADY_EXISTS,decoratedMock.doSomethingAlreadyExists());
  try {
    decoratedMock.doSomethingBadValue();
    Assert.fail("Should've thrown IllegalArgumentException");
  }
 catch (  IllegalArgumentException e) {
  }
  try {
    decoratedMock.doSomethingDeadObject();
    Assert.fail("Should've thrown CameraRuntimeException");
  }
 catch (  CameraRuntimeException e) {
    assertEquals(CAMERA_DISCONNECTED,e.getReason());
  }
  try {
    decoratedMock.doSomethingBadPolicy();
    Assert.fail("Should've thrown CameraRuntimeException");
  }
 catch (  CameraRuntimeException e) {
    assertEquals(CAMERA_DISABLED,e.getReason());
  }
  try {
    decoratedMock.doSomethingDeviceBusy();
    Assert.fail("Should've thrown CameraRuntimeException");
  }
 catch (  CameraRuntimeException e) {
    assertEquals(CAMERA_IN_USE,e.getReason());
  }
  try {
    decoratedMock.doSomethingNoSuchDevice();
    Assert.fail("Should've thrown CameraRuntimeException");
  }
 catch (  CameraRuntimeException e) {
    assertEquals(CAMERA_DISCONNECTED,e.getReason());
  }
  try {
    decoratedMock.doSomethingUnknownErrorCode();
    Assert.fail("Should've thrown UnsupportedOperationException");
  }
 catch (  UnsupportedOperationException e) {
    assertEquals(String.format("Unknown error %d",SOME_ARBITRARY_NEGATIVE_INT),e.getMessage());
  }
  try {
    decoratedMock.doSomethingThrowDeadObjectException();
    Assert.fail("Should've thrown CameraRuntimeException");
  }
 catch (  CameraRuntimeException e) {
    assertEquals(CAMERA_DISCONNECTED,e.getReason());
  }
catch (  RemoteException e) {
    Assert.fail("Should not throw a DeadObjectException directly, but rethrow");
  }
  try {
    decoratedMock.doSomethingThrowTransactionTooLargeException();
    Assert.fail("Should've thrown UnsupportedOperationException");
  }
 catch (  UnsupportedOperationException e) {
    assertTrue(e.getCause() instanceof TransactionTooLargeException);
  }
catch (  RemoteException e) {
    Assert.fail("Should not throw a TransactionTooLargeException directly, but rethrow");
  }
}
