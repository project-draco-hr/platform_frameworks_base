{
  mTaskProgressMap.clear();
  if (tasks.isEmpty()) {
    mMinScrollP=mMaxScrollP=0;
    return;
  }
  int taskHeight=mTaskRect.height();
  float pAtBottomOfStackRect=screenYToCurveProgress(mStackVisibleRect.bottom);
  float pWithinAffiliateOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset);
  float pBetweenAffiliateOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - mBetweenAffiliationOffset);
  float pTaskHeightOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - taskHeight);
  float pNavBarOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - (mStackVisibleRect.bottom - mStackRect.bottom));
  float pAtBackMostCardTop=screenYToCurveProgress(mStackVisibleRect.top + (mStackVisibleRect.height() - taskHeight) / 2);
  float pAtFrontMostCardTop=pAtBackMostCardTop;
  float pAtSecondFrontMostCardTop=pAtBackMostCardTop;
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    mTaskProgressMap.put(task.key,pAtFrontMostCardTop);
    if (i < (taskCount - 1)) {
      float pPeek=task.group.isFrontMostTask(task) ? pBetweenAffiliateOffset : pWithinAffiliateOffset;
      pAtSecondFrontMostCardTop=pAtFrontMostCardTop;
      pAtFrontMostCardTop+=pPeek;
    }
  }
  mMinScrollP=0f;
  mMaxScrollP=pAtFrontMostCardTop - ((1f - pTaskHeightOffset - pNavBarOffset));
  mInitialScrollP=pAtSecondFrontMostCardTop - ((1f - pTaskHeightOffset - pNavBarOffset));
}
