{
  mTaskProgressMap.clear();
  if (tasks.isEmpty()) {
    mMinScrollP=mMaxScrollP=0;
    return;
  }
  int taskHeight=mTaskRect.height();
  float pAtBottomOfStackRect=screenYToCurveProgress(mStackVisibleRect.bottom);
  float pWithinAffiliateTop=screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset);
  float scale=curveProgressToScale(pWithinAffiliateTop);
  int scaleYOffset=(int)(((1f - scale) * taskHeight) / 2);
  pWithinAffiliateTop=screenYToCurveProgress(mStackVisibleRect.bottom - mWithinAffiliationOffset + scaleYOffset);
  float pWithinAffiliateOffset=pAtBottomOfStackRect - pWithinAffiliateTop;
  float pBetweenAffiliateOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - mBetweenAffiliationOffset);
  float pTaskHeightOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - taskHeight);
  float pNavBarOffset=pAtBottomOfStackRect - screenYToCurveProgress(mStackVisibleRect.bottom - (mStackVisibleRect.bottom - mStackRect.bottom));
  float pAtBackMostCardTop=0.5f;
  float pAtFrontMostCardTop=pAtBackMostCardTop;
  int taskCount=tasks.size();
  for (int i=0; i < taskCount; i++) {
    Task task=tasks.get(i);
    mTaskProgressMap.put(task.key,pAtFrontMostCardTop);
    if (i < (taskCount - 1)) {
      float pPeek=task.group.isFrontMostTask(task) ? pBetweenAffiliateOffset : pWithinAffiliateOffset;
      pAtFrontMostCardTop+=pPeek;
    }
  }
  mMaxScrollP=pAtFrontMostCardTop - ((1f - pTaskHeightOffset - pNavBarOffset));
  mMinScrollP=tasks.size() == 1 ? Math.max(mMaxScrollP,0f) : 0f;
  if (launchedWithAltTab && launchedFromHome) {
    mInitialScrollP=mMaxScrollP;
  }
 else {
    mInitialScrollP=pAtFrontMostCardTop - 0.825f;
  }
  mInitialScrollP=Math.min(mMaxScrollP,Math.max(0,mInitialScrollP));
}
