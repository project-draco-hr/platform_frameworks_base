{
  int outerDepth=parser.getDepth();
  int currentKeySetDepth=-1;
  int type;
  String currentKeySet=null;
  ArrayMap<String,PublicKey> publicKeys=new ArrayMap<String,PublicKey>();
  ArraySet<String> upgradeKeySets=new ArraySet<String>();
  ArrayMap<String,ArraySet<String>> definedKeySets=new ArrayMap<String,ArraySet<String>>();
  ArraySet<String> improperKeySets=new ArraySet<String>();
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG) {
      if (parser.getDepth() == currentKeySetDepth) {
        currentKeySet=null;
        currentKeySetDepth=-1;
      }
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals("key-set")) {
      if (currentKeySet != null) {
        outError[0]="Improperly nested 'key-set' tag at " + parser.getPositionDescription();
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      final TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestKeySet);
      final String keysetName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestKeySet_name);
      definedKeySets.put(keysetName,new ArraySet<String>());
      currentKeySet=keysetName;
      currentKeySetDepth=parser.getDepth();
      sa.recycle();
    }
 else     if (tagName.equals("public-key")) {
      if (currentKeySet == null) {
        outError[0]="Improperly nested 'key-set' tag at " + parser.getPositionDescription();
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      final TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPublicKey);
      final String publicKeyName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPublicKey_name);
      final String encodedKey=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPublicKey_value);
      if (encodedKey == null && publicKeys.get(publicKeyName) == null) {
        outError[0]="'public-key' " + publicKeyName + " must define a public-key value"+ " on first use at "+ parser.getPositionDescription();
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        sa.recycle();
        return false;
      }
 else       if (encodedKey != null) {
        PublicKey currentKey=parsePublicKey(encodedKey);
        if (currentKey == null) {
          Slog.w(TAG,"No recognized valid key in 'public-key' tag at " + parser.getPositionDescription() + " key-set "+ currentKeySet+ " will not be added to the package's defined key-sets.");
          sa.recycle();
          improperKeySets.add(currentKeySet);
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        if (publicKeys.get(publicKeyName) == null || publicKeys.get(publicKeyName).equals(currentKey)) {
          publicKeys.put(publicKeyName,currentKey);
        }
 else {
          outError[0]="Value of 'public-key' " + publicKeyName + " conflicts with previously defined value at "+ parser.getPositionDescription();
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          sa.recycle();
          return false;
        }
      }
      definedKeySets.get(currentKeySet).add(publicKeyName);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals("upgrade-key-set")) {
      final TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUpgradeKeySet);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUpgradeKeySet_name);
      upgradeKeySets.add(name);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (RIGID_PARSER) {
      outError[0]="Bad element under <key-sets>: " + parser.getName() + " at "+ mArchiveSourcePath+ " "+ parser.getPositionDescription();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
 else {
      Slog.w(TAG,"Unknown element under <key-sets>: " + parser.getName() + " at "+ mArchiveSourcePath+ " "+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  Set<String> publicKeyNames=publicKeys.keySet();
  if (publicKeyNames.removeAll(definedKeySets.keySet())) {
    outError[0]="Package" + owner.packageName + " AndroidManifext.xml "+ "'key-set' and 'public-key' names must be distinct.";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  owner.mKeySetMapping=new ArrayMap<String,ArraySet<PublicKey>>();
  for (  ArrayMap.Entry<String,ArraySet<String>> e : definedKeySets.entrySet()) {
    final String keySetName=e.getKey();
    if (e.getValue().size() == 0) {
      Slog.w(TAG,"Package" + owner.packageName + " AndroidManifext.xml "+ "'key-set' "+ keySetName+ " has no valid associated 'public-key'."+ " Not including in package's defined key-sets.");
      continue;
    }
 else     if (improperKeySets.contains(keySetName)) {
      Slog.w(TAG,"Package" + owner.packageName + " AndroidManifext.xml "+ "'key-set' "+ keySetName+ " contained improper 'public-key'"+ " tags. Not including in package's defined key-sets.");
      continue;
    }
    owner.mKeySetMapping.put(keySetName,new ArraySet<PublicKey>());
    for (    String s : e.getValue()) {
      owner.mKeySetMapping.get(keySetName).add(publicKeys.get(s));
    }
  }
  if (owner.mKeySetMapping.keySet().containsAll(upgradeKeySets)) {
    owner.mUpgradeKeySets=upgradeKeySets;
  }
 else {
    outError[0]="Package" + owner.packageName + " AndroidManifext.xml "+ "does not define all 'upgrade-key-set's .";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  return true;
}
