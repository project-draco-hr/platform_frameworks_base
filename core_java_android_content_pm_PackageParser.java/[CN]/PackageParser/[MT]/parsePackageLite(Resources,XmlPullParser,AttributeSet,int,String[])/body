{
  int type;
  while ((type=parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    ;
  }
  if (type != XmlPullParser.START_TAG) {
    outError[0]="No start tag found";
    return null;
  }
  if (DEBUG_PARSER)   Slog.v(TAG,"Root element name: '" + parser.getName() + "'");
  if (!parser.getName().equals("manifest")) {
    outError[0]="No <manifest> tag";
    return null;
  }
  String pkgName=attrs.getAttributeValue(null,"package");
  if (pkgName == null || pkgName.length() == 0) {
    outError[0]="<manifest> does not specify package";
    return null;
  }
  String nameError=validateName(pkgName,true);
  if (nameError != null && !"android".equals(pkgName)) {
    outError[0]="<manifest> specifies bad package name \"" + pkgName + "\": "+ nameError;
    return null;
  }
  int installLocation=PARSE_DEFAULT_INSTALL_LOCATION;
  for (int i=0; i < attrs.getAttributeCount(); i++) {
    String attr=attrs.getAttributeName(i);
    if (attr.equals("installLocation")) {
      installLocation=attrs.getAttributeIntValue(i,PARSE_DEFAULT_INSTALL_LOCATION);
      break;
    }
  }
  final int searchDepth=parser.getDepth() + 1;
  final List<VerifierInfo> verifiers=new ArrayList<VerifierInfo>();
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() >= searchDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getDepth() == searchDepth && "package-verifier".equals(parser.getName())) {
      final VerifierInfo verifier=parseVerifier(res,parser,attrs,flags,outError);
      if (verifier != null) {
        verifiers.add(verifier);
      }
    }
  }
  return new PackageLite(pkgName.intern(),installLocation,verifiers);
}
