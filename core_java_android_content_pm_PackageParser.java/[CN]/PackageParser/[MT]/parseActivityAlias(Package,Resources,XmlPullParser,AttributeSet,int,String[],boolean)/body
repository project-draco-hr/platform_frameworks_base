{
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]="<activity-alias> does not specify android:targetActivity";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  Activity a=new Activity(owner);
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]="<activity-alias> target activity " + targetActivity + " not found in manifest";
    sa.recycle();
    return null;
  }
  a.info.targetActivity=targetActivity;
  a.info.configChanges=target.info.configChanges;
  a.info.flags=target.info.flags;
  a.info.icon=target.info.icon;
  a.info.labelRes=target.info.labelRes;
  a.info.launchMode=target.info.launchMode;
  a.info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  a.info.processName=target.info.processName;
  a.info.screenOrientation=target.info.screenOrientation;
  a.info.taskAffinity=target.info.taskAffinity;
  a.info.theme=target.info.theme;
  if (!parseComponentInfo(owner,flags,a.info,outError,receiver ? "<receiver>" : "<activity>",sa,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled)) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  a.component=new ComponentName(owner.applicationInfo.packageName,a.info.name);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals("intent-filter")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,"Intent filter for activity alias " + intent + " defines no actions");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals("meta-data")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,"Problem in package " + mArchiveSourcePath + ":");
        Log.w(TAG,"Unknown element under <activity-alias>: " + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]="Bad element under <activity-alias>: " + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}
