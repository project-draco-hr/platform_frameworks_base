{
  final File[] files=apkDir.listFiles();
  if (ArrayUtils.isEmpty(files)) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK,"No packages found in split");
  }
  String packageName=null;
  int versionCode=0;
  final ArrayMap<String,File> apks=new ArrayMap<>();
  for (  File file : files) {
    if (file.isFile() && isPackageFilename(file)) {
      final ApkLite lite=parseApkLite(file,0);
      if (packageName == null) {
        packageName=lite.packageName;
        versionCode=lite.versionCode;
      }
 else {
        if (!packageName.equals(lite.packageName)) {
          throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Inconsistent package " + lite.packageName + " in "+ file+ "; expected "+ packageName);
        }
        if (versionCode != lite.versionCode) {
          throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Inconsistent version " + lite.versionCode + " in "+ file+ "; expected "+ versionCode);
        }
      }
      if (apks.put(lite.splitName,file) != null) {
        throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Split name " + lite.splitName + " defined more than once; most recent was "+ file);
      }
    }
  }
  final File baseFile=apks.remove(null);
  if (baseFile == null) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Missing base APK in " + apkDir);
  }
  final Package pkg=parseBaseApk(baseFile,flags);
  if (pkg == null) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK,"Failed to parse base APK: " + baseFile);
  }
  final int size=apks.size();
  final String[] splitNames=apks.keySet().toArray(new String[size]);
  Arrays.sort(splitNames,sSplitNameComparator);
  for (  String splitName : splitNames) {
    final File splitFile=apks.get(splitName);
    parseSplitApk(pkg,splitFile,splitName,flags);
  }
  pkg.codePath=apkDir.getAbsolutePath();
  return pkg;
}
