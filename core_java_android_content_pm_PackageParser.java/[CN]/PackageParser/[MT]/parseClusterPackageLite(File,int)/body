{
  final File[] files=packageDir.listFiles();
  if (ArrayUtils.isEmpty(files)) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK,"No packages found in split");
  }
  String packageName=null;
  int versionCode=0;
  final ArrayMap<String,File> apks=new ArrayMap<>();
  for (  File file : files) {
    if (isApkFile(file)) {
      final ApkLite lite=parseApkLite(file,flags);
      if (packageName == null) {
        packageName=lite.packageName;
        versionCode=lite.versionCode;
      }
 else {
        if (!packageName.equals(lite.packageName)) {
          throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Inconsistent package " + lite.packageName + " in "+ file+ "; expected "+ packageName);
        }
        if (versionCode != lite.versionCode) {
          throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Inconsistent version " + lite.versionCode + " in "+ file+ "; expected "+ versionCode);
        }
      }
      if (apks.put(lite.splitName,file) != null) {
        throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Split name " + lite.splitName + " defined more than once; most recent was "+ file);
      }
    }
  }
  final File baseApk=apks.remove(null);
  if (baseApk == null) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Missing base APK in " + packageDir);
  }
  final int size=apks.size();
  String[] splitNames=null;
  String[] splitCodePaths=null;
  if (size > 0) {
    splitNames=new String[size];
    splitCodePaths=new String[size];
    splitNames=apks.keySet().toArray(splitNames);
    Arrays.sort(splitNames,sSplitNameComparator);
    for (int i=0; i < size; i++) {
      splitCodePaths[i]=apks.get(splitNames[i]).getAbsolutePath();
    }
  }
  final String codePath=packageDir.getAbsolutePath();
  final String baseCodePath=baseApk.getAbsolutePath();
  return new PackageLite(packageName,versionCode,splitNames,codePath,baseCodePath,splitCodePaths);
}
