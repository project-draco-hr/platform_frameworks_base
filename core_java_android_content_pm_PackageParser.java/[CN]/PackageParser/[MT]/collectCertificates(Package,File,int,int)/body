{
  final boolean hasCode=(apkFlags & ApplicationInfo.FLAG_HAS_CODE) != 0;
  final boolean requireCode=((parseFlags & PARSE_ENFORCE_CODE) != 0) && hasCode;
  final String apkPath=apkFile.getAbsolutePath();
  boolean codeFound=false;
  StrictJarFile jarFile=null;
  try {
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER,"strictJarFileCtor");
    jarFile=new StrictJarFile(apkPath);
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    final ZipEntry manifestEntry=jarFile.findEntry(ANDROID_MANIFEST_FILENAME);
    if (manifestEntry == null) {
      throw new PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,"Package " + apkPath + " has no manifest");
    }
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER,"buildVerifyList");
    final List<ZipEntry> toVerify=new ArrayList<>();
    toVerify.add(manifestEntry);
    if ((parseFlags & PARSE_IS_SYSTEM) == 0) {
      final Iterator<ZipEntry> i=jarFile.iterator();
      while (i.hasNext()) {
        final ZipEntry entry=i.next();
        if (entry.isDirectory())         continue;
        final String entryName=entry.getName();
        if (entryName.startsWith("META-INF/"))         continue;
        if (entryName.equals(ANDROID_MANIFEST_FILENAME))         continue;
        if (entryName.equals(BYTECODE_FILENAME)) {
          codeFound=true;
        }
        toVerify.add(entry);
      }
    }
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
    if (!codeFound && requireCode) {
      throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,"Package " + apkPath + " code is missing");
    }
    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER,"verifyEntries");
    for (    ZipEntry entry : toVerify) {
      final Certificate[][] entryCerts=loadCertificates(jarFile,entry);
      if (ArrayUtils.isEmpty(entryCerts)) {
        throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,"Package " + apkPath + " has no certificates at entry "+ entry.getName());
      }
      final Signature[] entrySignatures=convertToSignatures(entryCerts);
      if (pkg.mCertificates == null) {
        pkg.mCertificates=entryCerts;
        pkg.mSignatures=entrySignatures;
        pkg.mSigningKeys=new ArraySet<PublicKey>();
        for (int i=0; i < entryCerts.length; i++) {
          pkg.mSigningKeys.add(entryCerts[i][0].getPublicKey());
        }
      }
 else {
        if (!Signature.areExactMatch(pkg.mSignatures,entrySignatures)) {
          throw new PackageParserException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,"Package " + apkPath + " has mismatched certificates at entry "+ entry.getName());
        }
      }
    }
    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
  }
 catch (  GeneralSecurityException e) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING,"Failed to collect certificates from " + apkPath,e);
  }
catch (  IOException|RuntimeException e) {
    throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,"Failed to collect certificates from " + apkPath,e);
  }
 finally {
    closeQuietly(jarFile);
  }
}
