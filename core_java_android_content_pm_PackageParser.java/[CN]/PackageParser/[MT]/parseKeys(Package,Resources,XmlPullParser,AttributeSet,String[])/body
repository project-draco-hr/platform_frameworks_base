{
  int outerDepth=parser.getDepth();
  int type;
  PublicKey currentKey=null;
  int currentKeyDepth=-1;
  Map<PublicKey,Set<String>> definedKeySets=new HashMap<PublicKey,Set<String>>();
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG) {
      if (parser.getDepth() == currentKeyDepth) {
        currentKey=null;
        currentKeyDepth=-1;
      }
      continue;
    }
    String tagname=parser.getName();
    if (tagname.equals("publicKey")) {
      final TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.PublicKey);
      final String encodedKey=sa.getNonResourceString(com.android.internal.R.styleable.PublicKey_value);
      currentKey=parsePublicKey(encodedKey);
      if (currentKey == null) {
        Slog.w(TAG,"No valid key in 'publicKey' tag at " + parser.getPositionDescription());
        sa.recycle();
        continue;
      }
      currentKeyDepth=parser.getDepth();
      definedKeySets.put(currentKey,new HashSet<String>());
      sa.recycle();
    }
 else     if (tagname.equals("keyset")) {
      if (currentKey == null) {
        Slog.i(TAG,"'keyset' not in 'publicKey' tag at " + parser.getPositionDescription());
        continue;
      }
      final TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.KeySet);
      final String name=sa.getNonResourceString(com.android.internal.R.styleable.KeySet_name);
      definedKeySets.get(currentKey).add(name);
      sa.recycle();
    }
 else     if (RIGID_PARSER) {
      Slog.w(TAG,"Bad element under <keys>: " + parser.getName() + " at "+ mArchiveSourcePath+ " "+ parser.getPositionDescription());
      return false;
    }
 else {
      Slog.w(TAG,"Unknown element under <keys>: " + parser.getName() + " at "+ mArchiveSourcePath+ " "+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  owner.mKeySetMapping=new ArrayMap<String,Set<PublicKey>>();
  for (  Map.Entry<PublicKey,Set<String>> e : definedKeySets.entrySet()) {
    PublicKey key=e.getKey();
    Set<String> keySetNames=e.getValue();
    for (    String alias : keySetNames) {
      if (owner.mKeySetMapping.containsKey(alias)) {
        owner.mKeySetMapping.get(alias).add(key);
      }
 else {
        Set<PublicKey> keys=new ArraySet<PublicKey>();
        keys.add(key);
        owner.mKeySetMapping.put(alias,keys);
      }
    }
  }
  return true;
}
