{
  if (DBG) {
    Slog.d(TAG,"startRecognition for keyphraseId=" + keyphraseId + " soundModel="+ soundModel+ ", listener="+ listener+ ", recognitionConfig="+ recognitionConfig);
    Slog.d(TAG,"moduleProperties=" + moduleProperties);
    Slog.d(TAG,"# of current listeners=" + mActiveListeners.size());
    Slog.d(TAG,"mCurrentSoundModelHandle=" + mCurrentSoundModelHandle);
  }
  if (moduleProperties == null || mModule == null) {
    Slog.w(TAG,"Attempting startRecognition without the capability");
    return STATUS_ERROR;
  }
  if (mCurrentSoundModelHandle != INVALID_SOUND_MODEL_HANDLE) {
    Slog.w(TAG,"Canceling previous recognition");
    mModule.unloadSoundModel(mCurrentSoundModelHandle);
    mCurrentSoundModelHandle=INVALID_SOUND_MODEL_HANDLE;
  }
  IRecognitionStatusCallback oldListener=mActiveListeners.get(keyphraseId);
  if (oldListener != null && oldListener.asBinder() != listener.asBinder()) {
    try {
      oldListener.onDetectionStopped();
    }
 catch (    RemoteException e) {
      Slog.w(TAG,"RemoteException in onDetectionStopped");
    }
    mActiveListeners.remove(keyphraseId);
  }
  int[] handle=new int[]{INVALID_SOUND_MODEL_HANDLE};
  int status=mModule.loadSoundModel(soundModel,handle);
  if (status != SoundTrigger.STATUS_OK) {
    Slog.w(TAG,"loadSoundModel call failed with " + status);
    return STATUS_ERROR;
  }
  if (handle[0] == INVALID_SOUND_MODEL_HANDLE) {
    Slog.w(TAG,"loadSoundModel call returned invalid sound model handle");
    return STATUS_ERROR;
  }
  status=mModule.startRecognition(handle[0],recognitionConfig);
  if (status != SoundTrigger.STATUS_OK) {
    Slog.w(TAG,"startRecognition failed with " + status);
    return STATUS_ERROR;
  }
  mCurrentSoundModelHandle=handle[0];
  mActiveListeners.put(keyphraseId,listener);
  return STATUS_OK;
}
