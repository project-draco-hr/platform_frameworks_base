{
  if (soundModel == null || listener == null || recognitionConfig == null) {
    return STATUS_ERROR;
  }
synchronized (mLock) {
    if (DBG) {
      Slog.d(TAG,"startRecognition for keyphraseId=" + keyphraseId + " soundModel="+ soundModel+ ", listener="+ listener.asBinder()+ ", recognitionConfig="+ recognitionConfig);
      Slog.d(TAG,"moduleProperties=" + moduleProperties);
      Slog.d(TAG,"current listener=" + (mActiveListener == null ? "null" : mActiveListener.asBinder()));
      Slog.d(TAG,"current SoundModel handle=" + mCurrentSoundModelHandle);
      Slog.d(TAG,"current SoundModel UUID=" + (mCurrentSoundModelUuid == null ? null : mCurrentSoundModelUuid));
    }
    if (!mStarted) {
      mCallActive=mTelephonyManager.getCallState() != TelephonyManager.CALL_STATE_IDLE;
      mTelephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_CALL_STATE);
      if (mPowerSaveModeListener == null) {
        mPowerSaveModeListener=new PowerSaveModeListener();
        mContext.registerReceiver(mPowerSaveModeListener,new IntentFilter(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED));
      }
      mIsPowerSaveMode=mPowerManager.isPowerSaveMode();
    }
    if (moduleProperties == null) {
      Slog.w(TAG,"Attempting startRecognition without the capability");
      return STATUS_ERROR;
    }
    if (mModule == null) {
      mModule=SoundTrigger.attachModule(moduleProperties.id,this,null);
      if (mModule == null) {
        Slog.w(TAG,"startRecognition cannot attach to sound trigger module");
        return STATUS_ERROR;
      }
    }
    if (mCurrentSoundModelHandle != INVALID_VALUE && (!soundModel.uuid.equals(mCurrentSoundModelUuid) || mStarted)) {
      Slog.w(TAG,"Unloading previous sound model");
      int status=mModule.unloadSoundModel(mCurrentSoundModelHandle);
      if (status != SoundTrigger.STATUS_OK) {
        Slog.w(TAG,"unloadSoundModel call failed with " + status);
      }
      mCurrentSoundModelHandle=INVALID_VALUE;
      mCurrentSoundModelUuid=null;
      mStarted=false;
    }
    if (mActiveListener != null && mActiveListener.asBinder() != listener.asBinder()) {
      Slog.w(TAG,"Canceling previous recognition");
      try {
        mActiveListener.onError(STATUS_ERROR);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,"RemoteException in onDetectionStopped",e);
      }
      mActiveListener=null;
    }
    int soundModelHandle=mCurrentSoundModelHandle;
    if (mCurrentSoundModelHandle == INVALID_VALUE || mCurrentSoundModelUuid == null) {
      int[] handle=new int[]{INVALID_VALUE};
      int status=mModule.loadSoundModel(soundModel,handle);
      if (status != SoundTrigger.STATUS_OK) {
        Slog.w(TAG,"loadSoundModel call failed with " + status);
        return status;
      }
      if (handle[0] == INVALID_VALUE) {
        Slog.w(TAG,"loadSoundModel call returned invalid sound model handle");
        return STATUS_ERROR;
      }
      soundModelHandle=handle[0];
    }
 else {
      if (DBG)       Slog.d(TAG,"Reusing previously loaded sound model");
    }
    mRequested=true;
    mKeyphraseId=keyphraseId;
    mCurrentSoundModelHandle=soundModelHandle;
    mCurrentSoundModelUuid=soundModel.uuid;
    mRecognitionConfig=recognitionConfig;
    mActiveListener=listener;
    return updateRecognitionLocked(false);
  }
}
