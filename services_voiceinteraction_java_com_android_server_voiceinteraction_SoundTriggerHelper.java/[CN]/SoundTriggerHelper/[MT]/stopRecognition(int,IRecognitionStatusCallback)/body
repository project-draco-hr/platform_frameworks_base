{
  if (DBG) {
    Slog.d(TAG,"stopRecognition for keyphraseId=" + keyphraseId + ", listener="+ listener);
    Slog.d(TAG,"# of current listeners = " + mActiveListeners.size());
  }
  if (moduleProperties == null || mModule == null) {
    Slog.w(TAG,"Attempting stopRecognition without the capability");
    return STATUS_ERROR;
  }
  IRecognitionStatusCallback currentListener=mActiveListeners.get(keyphraseId);
  if (listener == null) {
    Slog.w(TAG,"Attempting stopRecognition without a valid listener");
    return STATUS_ERROR;
  }
  if (currentListener == null) {
    Slog.w(TAG,"Attempting stopRecognition without a successful startRecognition");
    return STATUS_ERROR;
  }
 else   if (currentListener.asBinder() != listener.asBinder()) {
    Slog.w(TAG,"Attempting stopRecognition for another recognition");
    return STATUS_ERROR;
  }
 else {
    int status=mModule.stopRecognition(mCurrentSoundModelHandle);
    if (status != SoundTrigger.STATUS_OK) {
      Slog.w(TAG,"stopRecognition call failed with " + status);
      return STATUS_ERROR;
    }
    status=mModule.unloadSoundModel(mCurrentSoundModelHandle);
    if (status != SoundTrigger.STATUS_OK) {
      Slog.w(TAG,"unloadSoundModel call failed with " + status);
      return STATUS_ERROR;
    }
    mCurrentSoundModelHandle=INVALID_SOUND_MODEL_HANDLE;
    mActiveListeners.remove(keyphraseId);
    return STATUS_OK;
  }
}
