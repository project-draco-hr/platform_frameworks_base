{
  boolean radiusHidden=(mCircleAnimator != null && mCircleWillBeHidden) || (mCircleAnimator == null && mCircleRadius == 0.0f);
  boolean nowHidden=circleRadius == 0.0f;
  boolean radiusNeedsAnimation=(radiusHidden != nowHidden) && !noAnimation;
  if (!radiusNeedsAnimation) {
    if (mCircleAnimator == null) {
      mCircleRadius=circleRadius;
      invalidate();
    }
 else     if (!mCircleWillBeHidden) {
      float diff=circleRadius - mMinBackgroundRadius;
      PropertyValuesHolder[] values=mCircleAnimator.getValues();
      values[0].setFloatValues(mCircleStartValue + diff,circleRadius);
      mCircleAnimator.setCurrentPlayTime(mCircleAnimator.getCurrentPlayTime());
    }
  }
 else {
    cancelAnimator(mCircleAnimator);
    ValueAnimator animator=getAnimatorToRadius(circleRadius);
    Interpolator interpolator=circleRadius == 0.0f ? mDisappearInterpolator : mAppearInterpolator;
    animator.setInterpolator(interpolator);
    float durationFactor=Math.abs(mCircleRadius - circleRadius) / (float)mMinBackgroundRadius;
    long duration=(long)(CIRCLE_APPEAR_DURATION * durationFactor);
    duration=Math.min(duration,CIRCLE_DISAPPEAR_MAX_DURATION);
    animator.setDuration(duration);
    animator.start();
  }
}
