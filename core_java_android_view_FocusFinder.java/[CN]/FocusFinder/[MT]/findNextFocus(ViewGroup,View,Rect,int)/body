{
  ArrayList<View> focusables=root.getFocusables(direction);
  if (focusables.isEmpty()) {
    return null;
  }
  if (direction == View.FOCUS_FORWARD || direction == View.FOCUS_BACKWARD) {
    if (focused != null && !focusables.contains(focused)) {
      focusables.add(focused);
    }
    try {
      mSequentialFocusComparator.setRoot(root);
      Collections.sort(focusables,mSequentialFocusComparator);
    }
  finally {
      mSequentialFocusComparator.recycle();
    }
    final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
      return getForwardFocusable(root,focused,focusables,count);
case View.FOCUS_BACKWARD:
    return getBackwardFocusable(root,focused,focusables,count);
}
return null;
}
mBestCandidateRect.set(focusedRect);
switch (direction) {
case View.FOCUS_LEFT:
mBestCandidateRect.offset(focusedRect.width() + 1,0);
break;
case View.FOCUS_RIGHT:
mBestCandidateRect.offset(-(focusedRect.width() + 1),0);
break;
case View.FOCUS_UP:
mBestCandidateRect.offset(0,focusedRect.height() + 1);
break;
case View.FOCUS_DOWN:
mBestCandidateRect.offset(0,-(focusedRect.height() + 1));
}
View closest=null;
int numFocusables=focusables.size();
for (int i=0; i < numFocusables; i++) {
View focusable=focusables.get(i);
if (focusable == focused || focusable == root) continue;
focusable.getDrawingRect(mOtherRect);
root.offsetDescendantRectToMyCoords(focusable,mOtherRect);
if (isBetterCandidate(direction,focusedRect,mOtherRect,mBestCandidateRect)) {
mBestCandidateRect.set(mOtherRect);
closest=focusable;
}
}
return closest;
}
