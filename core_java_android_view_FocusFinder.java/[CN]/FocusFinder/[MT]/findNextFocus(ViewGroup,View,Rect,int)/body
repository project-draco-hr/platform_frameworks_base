{
  ArrayList<View> focusables=root.getFocusables(direction);
  if (focusables.isEmpty()) {
    return null;
  }
  if (direction == View.FOCUS_FORWARD || direction == View.FOCUS_BACKWARD) {
    if (focused != null && !focusables.contains(focused)) {
      focusables.add(focused);
    }
    try {
      mSequentialFocusComparator.setRoot(root);
      Collections.sort(focusables,mSequentialFocusComparator);
    }
  finally {
      mSequentialFocusComparator.recycle();
    }
    final int count=focusables.size();
switch (direction) {
case View.FOCUS_FORWARD:
      if (focused != null) {
        int position=focusables.lastIndexOf(focused);
        if (position >= 0 && position + 1 < count) {
          return focusables.get(position + 1);
        }
      }
    return focusables.get(0);
case View.FOCUS_BACKWARD:
  if (focused != null) {
    int position=focusables.indexOf(focused);
    if (position > 0) {
      return focusables.get(position - 1);
    }
  }
return focusables.get(count - 1);
}
return null;
}
mBestCandidateRect.set(focusedRect);
switch (direction) {
case View.FOCUS_LEFT:
mBestCandidateRect.offset(focusedRect.width() + 1,0);
break;
case View.FOCUS_RIGHT:
mBestCandidateRect.offset(-(focusedRect.width() + 1),0);
break;
case View.FOCUS_UP:
mBestCandidateRect.offset(0,focusedRect.height() + 1);
break;
case View.FOCUS_DOWN:
mBestCandidateRect.offset(0,-(focusedRect.height() + 1));
}
View closest=null;
int numFocusables=focusables.size();
for (int i=0; i < numFocusables; i++) {
View focusable=focusables.get(i);
if (focusable == focused || focusable == root) continue;
focusable.getDrawingRect(mOtherRect);
root.offsetDescendantRectToMyCoords(focusable,mOtherRect);
if (isBetterCandidate(direction,focusedRect,mOtherRect,mBestCandidateRect)) {
mBestCandidateRect.set(mOtherRect);
closest=focusable;
}
}
return closest;
}
