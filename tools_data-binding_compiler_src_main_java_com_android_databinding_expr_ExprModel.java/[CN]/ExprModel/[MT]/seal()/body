{
  List<Expr> notifiableExpressions=new ArrayList<>();
  final ModelAnalyzer modelAnalyzer=ModelAnalyzer.getInstance();
  ArrayList<Expr> exprs=new ArrayList<>(mBindingExpressions);
  for (  Expr expr : exprs) {
    expr.updateExpr(modelAnalyzer);
  }
  int counter=0;
  final Iterable<Expr> observables=filterObservables(modelAnalyzer);
  List<String> flagMapping=Lists.newArrayList();
  mObservables=Lists.newArrayList();
  for (  Expr expr : observables) {
    flagMapping.add(expr.getUniqueKey());
    expr.setId(counter++);
    mObservables.add(expr);
    notifiableExpressions.add(expr);
    L.d("observable %s",expr.getUniqueKey());
  }
  final Iterable<Expr> nonObservableIds=filterNonObservableIds(modelAnalyzer);
  for (  Expr expr : nonObservableIds) {
    flagMapping.add(expr.getUniqueKey());
    expr.setId(counter++);
    notifiableExpressions.add(expr);
    L.d("non-observable %s",expr.getUniqueKey());
  }
  for (  Expr expr : observables) {
    for (    Expr parent : expr.getParents()) {
      if (parent.hasId()) {
        continue;
      }
      if (parent instanceof FieldAccessExpr) {
        FieldAccessExpr fae=(FieldAccessExpr)parent;
        L.d("checking field access expr %s. getter: %s",fae,fae.getGetter());
        if (fae.isDynamic() && fae.getGetter().canBeInvalidated) {
          flagMapping.add(parent.getUniqueKey());
          parent.setId(counter++);
          notifiableExpressions.add(parent);
          L.d("notifiable field %s : %s for %s : %s",parent.getUniqueKey(),Integer.toHexString(System.identityHashCode(parent)),expr.getUniqueKey(),Integer.toHexString(System.identityHashCode(expr)));
        }
      }
    }
  }
  for (int i=0; i < mBindingExpressions.size(); i++) {
    L.d("[" + i + "] "+ mBindingExpressions.get(i));
  }
  for (  Expr expr : mBindingExpressions) {
    if (!(expr.isDynamic() || !expr.hasId())) {
      L.d("Expr " + expr + " is dynamic? "+ expr.isDynamic()+ ", has ID? "+ expr.hasId());
    }
    Preconditions.checkState(expr.isDynamic() || !expr.hasId());
    if (!expr.isDynamic()) {
      expr.setId(counter++);
      notifiableExpressions.add(expr);
    }
  }
  for (  Expr expr : notifiableExpressions) {
    expr.enableDirectInvalidation();
  }
  for (  Expr expr : mExprMap.values()) {
    expr.getDependencies();
  }
  mInvalidateableFieldLimit=counter;
  mInvalidateableFlags=new BitSet();
  for (int i=0; i < mInvalidateableFieldLimit; i++) {
    mInvalidateableFlags.set(i,true);
  }
  for (  Expr expr : mExprMap.values()) {
    if (expr.isConditional()) {
      expr.setRequirementId(counter);
      flagMapping.add(expr.getUniqueKey() + FALSE_KEY_SUFFIX);
      flagMapping.add(expr.getUniqueKey() + TRUE_KEY_SUFFIX);
      counter+=2;
    }
  }
  mConditionalFlags=new BitSet();
  for (int i=mInvalidateableFieldLimit; i < counter; i++) {
    mConditionalFlags.set(i,true);
  }
  mRequirementIdCount=(counter - mInvalidateableFieldLimit) / 2;
  for (  Map.Entry<String,Expr> entry : mExprMap.entrySet()) {
    final Expr value=entry.getValue();
    if (!value.hasId()) {
      value.setId(counter++);
    }
  }
  mFlagMapping=new String[flagMapping.size()];
  flagMapping.toArray(mFlagMapping);
  for (  Expr expr : mExprMap.values()) {
    expr.getShouldReadFlagsWithConditionals();
  }
  for (  Expr expr : mExprMap.values()) {
    expr.getResolvedType();
  }
  mFlagBucketCount=1 + (getTotalFlagCount() / FlagSet.sBucketSize);
}
