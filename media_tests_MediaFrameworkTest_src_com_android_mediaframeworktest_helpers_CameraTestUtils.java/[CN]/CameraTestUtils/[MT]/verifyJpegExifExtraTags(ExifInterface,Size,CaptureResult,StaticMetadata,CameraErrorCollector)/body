{
  int exifWidth=exif.getAttributeInt(ExifInterface.TAG_IMAGE_WIDTH,0);
  int exifHeight=exif.getAttributeInt(ExifInterface.TAG_IMAGE_LENGTH,0);
  Size exifSize=new Size(exifWidth,exifHeight);
  int exifOrientation=exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,-1);
  if (collector.expectKeyValueNotNull(result,CaptureResult.JPEG_ORIENTATION) != null) {
    int requestedOrientation=result.get(CaptureResult.JPEG_ORIENTATION);
    final int ORIENTATION_MIN=ExifInterface.ORIENTATION_UNDEFINED;
    final int ORIENTATION_MAX=ExifInterface.ORIENTATION_ROTATE_270;
    boolean orientationValid=collector.expectTrue(String.format("Exif orientation must be in range of [%d, %d]",ORIENTATION_MIN,ORIENTATION_MAX),exifOrientation >= ORIENTATION_MIN && exifOrientation <= ORIENTATION_MAX);
    if (orientationValid) {
      boolean deviceRotatedImage=exifOrientation == ExifInterface.ORIENTATION_UNDEFINED;
      if (deviceRotatedImage) {
        boolean needSwap=(requestedOrientation % 180 == 90);
        if (needSwap) {
          exifSize=new Size(exifHeight,exifWidth);
        }
      }
 else {
        collector.expectEquals("Exif orientaiton should match requested orientation",requestedOrientation,getExifOrientationInDegree(exifOrientation,collector));
      }
    }
  }
  collector.expectEquals("Exif size should match jpeg capture size",jpegSize,exifSize);
  long currentTimeInMs=System.currentTimeMillis();
  long currentTimeInSecond=currentTimeInMs / 1000;
  Date date=new Date(currentTimeInMs);
  String localDatetime=new SimpleDateFormat("yyyy:MM:dd HH:").format(date);
  String dateTime=exif.getAttribute(ExifInterface.TAG_DATETIME);
  if (collector.expectTrue("Exif TAG_DATETIME shouldn't be null",dateTime != null)) {
    collector.expectTrue("Exif TAG_DATETIME is wrong",dateTime.length() == EXIF_DATETIME_LENGTH);
    long exifTimeInSecond=new SimpleDateFormat("yyyy:MM:dd HH:mm:ss").parse(dateTime).getTime() / 1000;
    long delta=currentTimeInSecond - exifTimeInSecond;
    collector.expectTrue("Capture time deviates too much from the current time",Math.abs(delta) < EXIF_DATETIME_ERROR_MARGIN_SEC);
    collector.expectTrue("Exif date time should be local time",dateTime.startsWith(localDatetime));
  }
  float[] focalLengths=staticInfo.getAvailableFocalLengthsChecked();
  float exifFocalLength=(float)exif.getAttributeDouble(ExifInterface.TAG_FOCAL_LENGTH,-1);
  collector.expectEquals("Focal length should match",getClosestValueInArray(focalLengths,exifFocalLength),exifFocalLength,EXIF_FOCAL_LENGTH_ERROR_MARGIN);
  collector.expectEquals("Exif focal length should match capture result",validateFocalLength(result,staticInfo,collector),exifFocalLength);
  String exposureTime=exif.getAttribute(ExifInterface.TAG_EXPOSURE_TIME);
  collector.expectNotNull("Exif TAG_EXPOSURE_TIME shouldn't be null",exposureTime);
  if (staticInfo.areKeysAvailable(CaptureResult.SENSOR_EXPOSURE_TIME)) {
    if (exposureTime != null) {
      double exposureTimeValue=Double.parseDouble(exposureTime);
      long expTimeResult=result.get(CaptureResult.SENSOR_EXPOSURE_TIME);
      double expected=expTimeResult / 1e9;
      double tolerance=expected * EXIF_EXPOSURE_TIME_ERROR_MARGIN_RATIO;
      tolerance=Math.max(tolerance,EXIF_EXPOSURE_TIME_MIN_ERROR_MARGIN_SEC);
      collector.expectEquals("Exif exposure time doesn't match",expected,exposureTimeValue,tolerance);
    }
  }
  String exifAperture=exif.getAttribute(ExifInterface.TAG_APERTURE);
  collector.expectNotNull("Exif TAG_APERTURE shouldn't be null",exifAperture);
  if (staticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES)) {
    float[] apertures=staticInfo.getAvailableAperturesChecked();
    if (exifAperture != null) {
      float apertureValue=Float.parseFloat(exifAperture);
      collector.expectEquals("Aperture value should match",getClosestValueInArray(apertures,apertureValue),apertureValue,EXIF_APERTURE_ERROR_MARGIN);
      collector.expectEquals("Exif aperture length should match capture result",validateAperture(result,staticInfo,collector),apertureValue);
    }
  }
  String flash=exif.getAttribute(ExifInterface.TAG_FLASH);
  collector.expectNotNull("Exif TAG_FLASH shouldn't be null",flash);
  String whiteBalance=exif.getAttribute(ExifInterface.TAG_WHITE_BALANCE);
  collector.expectNotNull("Exif TAG_WHITE_BALANCE shouldn't be null",whiteBalance);
  String make=exif.getAttribute(ExifInterface.TAG_MAKE);
  collector.expectEquals("Exif TAG_MAKE is incorrect",Build.MANUFACTURER,make);
  String model=exif.getAttribute(ExifInterface.TAG_MODEL);
  collector.expectEquals("Exif TAG_MODEL is incorrect",Build.MODEL,model);
  int iso=exif.getAttributeInt(ExifInterface.TAG_ISO,-1);
  if (staticInfo.areKeysAvailable(CaptureResult.SENSOR_SENSITIVITY)) {
    int expectedIso=result.get(CaptureResult.SENSOR_SENSITIVITY);
    collector.expectEquals("Exif TAG_ISO is incorrect",expectedIso,iso);
  }
  String digitizedTime=exif.getAttribute(ExifInterface.TAG_DATETIME_DIGITIZED);
  collector.expectNotNull("Exif TAG_DATETIME_DIGITIZED shouldn't be null",digitizedTime);
  if (digitizedTime != null) {
    String expectedDateTime=exif.getAttribute(ExifInterface.TAG_DATETIME);
    collector.expectNotNull("Exif TAG_DATETIME shouldn't be null",expectedDateTime);
    if (expectedDateTime != null) {
      collector.expectEquals("dataTime should match digitizedTime",expectedDateTime,digitizedTime);
    }
  }
  int subSecTime=exif.getAttributeInt(ExifInterface.TAG_SUBSEC_TIME,-1);
  collector.expectTrue("Exif TAG_SUBSEC_TIME value is null or invalid!",subSecTime > 0);
  int subSecTimeOrig=exif.getAttributeInt(ExifInterface.TAG_SUBSEC_TIME_ORIG,-1);
  collector.expectTrue("Exif TAG_SUBSEC_TIME_ORIG value is null or invalid!",subSecTimeOrig > 0);
  int subSecTimeDig=exif.getAttributeInt(ExifInterface.TAG_SUBSEC_TIME_DIG,-1);
  collector.expectTrue("Exif TAG_SUBSEC_TIME_DIG value is null or invalid!",subSecTimeDig > 0);
}
