{
switch (composite.getMode()) {
case NORMAL:
    return new Blender(){
      @Override public int[] blend(      int[] src,      int[] dst,      int[] result){
        System.arraycopy(src,0,result,0,4);
        return result;
      }
    }
;
case ADD:
  return new Blender(){
    @Override public int[] blend(    int[] src,    int[] dst,    int[] result){
      for (int i=0; i < 4; i++) {
        result[i]=Math.min(255,src[i] + dst[i]);
      }
      return result;
    }
  }
;
case AVERAGE:
return new Blender(){
  @Override public int[] blend(  int[] src,  int[] dst,  int[] result){
    for (int i=0; i < 3; i++) {
      result[i]=(src[i] + dst[i]) >> 1;
    }
    result[3]=Math.min(255,src[3] + dst[3]);
    return result;
  }
}
;
case BLUE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
  System.arraycopy(dst,0,result,0,3);
  result[3]=Math.min(255,src[3] + dst[3]);
  return result;
}
}
;
case COLOR:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
float[] srcHSL=new float[3];
RGBtoHSL(src[0],src[1],src[2],srcHSL);
float[] dstHSL=new float[3];
RGBtoHSL(dst[0],dst[1],dst[2],dstHSL);
HSLtoRGB(srcHSL[0],srcHSL[1],dstHSL[2],result);
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case COLOR_BURN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=src[i] == 0 ? 0 : Math.max(0,255 - (((255 - dst[i]) << 8) / src[i]));
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case COLOR_DODGE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=src[i] == 255 ? 255 : Math.min((dst[i] << 8) / (255 - src[i]),255);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case DARKEN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=Math.min(src[i],dst[i]);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case DIFFERENCE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=dst[i] + src[i] - (dst[i] * src[i] >> 7);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case EXCLUSION:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=dst[i] + src[i] - (dst[i] * src[i] >> 7);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case FREEZE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=src[i] == 0 ? 0 : Math.max(0,255 - (255 - dst[i]) * (255 - dst[i]) / src[i]);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case GLOW:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=dst[i] == 255 ? 255 : Math.min(255,src[i] * src[i] / (255 - dst[i]));
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case GREEN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{dst[0],dst[1],src[2],Math.min(255,src[3] + dst[3])};
}
}
;
case HARD_LIGHT:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{src[0] < 128 ? dst[0] * src[0] >> 7 : 255 - ((255 - src[0]) * (255 - dst[0]) >> 7),src[1] < 128 ? dst[1] * src[1] >> 7 : 255 - ((255 - src[1]) * (255 - dst[1]) >> 7),src[2] < 128 ? dst[2] * src[2] >> 7 : 255 - ((255 - src[2]) * (255 - dst[2]) >> 7),Math.min(255,src[3] + dst[3])};
}
}
;
case HEAT:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{dst[0] == 0 ? 0 : Math.max(0,255 - (255 - src[0]) * (255 - src[0]) / dst[0]),dst[1] == 0 ? 0 : Math.max(0,255 - (255 - src[1]) * (255 - src[1]) / dst[1]),dst[2] == 0 ? 0 : Math.max(0,255 - (255 - src[2]) * (255 - src[2]) / dst[2]),Math.min(255,src[3] + dst[3])};
}
}
;
case HUE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
float[] srcHSL=new float[3];
RGBtoHSL(src[0],src[1],src[2],srcHSL);
float[] dstHSL=new float[3];
RGBtoHSL(dst[0],dst[1],dst[2],dstHSL);
HSLtoRGB(srcHSL[0],dstHSL[1],dstHSL[2],result);
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case INVERSE_COLOR_BURN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{dst[0] == 0 ? 0 : Math.max(0,255 - (((255 - src[0]) << 8) / dst[0])),dst[1] == 0 ? 0 : Math.max(0,255 - (((255 - src[1]) << 8) / dst[1])),dst[2] == 0 ? 0 : Math.max(0,255 - (((255 - src[2]) << 8) / dst[2])),Math.min(255,src[3] + dst[3])};
}
}
;
case INVERSE_COLOR_DODGE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{dst[0] == 255 ? 255 : Math.min((src[0] << 8) / (255 - dst[0]),255),dst[1] == 255 ? 255 : Math.min((src[1] << 8) / (255 - dst[1]),255),dst[2] == 255 ? 255 : Math.min((src[2] << 8) / (255 - dst[2]),255),Math.min(255,src[3] + dst[3])};
}
}
;
case LIGHTEN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=Math.max(src[i],dst[i]);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case LUMINOSITY:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
float[] srcHSL=new float[3];
RGBtoHSL(src[0],src[1],src[2],srcHSL);
float[] dstHSL=new float[3];
RGBtoHSL(dst[0],dst[1],dst[2],dstHSL);
HSLtoRGB(dstHSL[0],dstHSL[1],srcHSL[2],result);
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case MULTIPLY:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=(src[i] * dst[i]) >> 8;
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case NEGATION:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{255 - Math.abs(255 - dst[0] - src[0]),255 - Math.abs(255 - dst[1] - src[1]),255 - Math.abs(255 - dst[2] - src[2]),Math.min(255,src[3] + dst[3])};
}
}
;
case OVERLAY:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
for (int i=0; i < 3; i++) {
result[i]=dst[i] < 128 ? dst[i] * src[i] >> 7 : 255 - ((255 - dst[i]) * (255 - src[i]) >> 7);
}
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case RED:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{src[0],dst[1],dst[2],Math.min(255,src[3] + dst[3])};
}
}
;
case REFLECT:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{src[0] == 255 ? 255 : Math.min(255,dst[0] * dst[0] / (255 - src[0])),src[1] == 255 ? 255 : Math.min(255,dst[1] * dst[1] / (255 - src[1])),src[2] == 255 ? 255 : Math.min(255,dst[2] * dst[2] / (255 - src[2])),Math.min(255,src[3] + dst[3])};
}
}
;
case SATURATION:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
float[] srcHSL=new float[3];
RGBtoHSL(src[0],src[1],src[2],srcHSL);
float[] dstHSL=new float[3];
RGBtoHSL(dst[0],dst[1],dst[2],dstHSL);
HSLtoRGB(dstHSL[0],srcHSL[1],dstHSL[2],result);
result[3]=Math.min(255,src[3] + dst[3]);
return result;
}
}
;
case SCREEN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{255 - ((255 - src[0]) * (255 - dst[0]) >> 8),255 - ((255 - src[1]) * (255 - dst[1]) >> 8),255 - ((255 - src[2]) * (255 - dst[2]) >> 8),Math.min(255,src[3] + dst[3])};
}
}
;
case SOFT_BURN:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{dst[0] + src[0] < 256 ? (dst[0] == 255 ? 255 : Math.min(255,(src[0] << 7) / (255 - dst[0]))) : Math.max(0,255 - (((255 - dst[0]) << 7) / src[0])),dst[1] + src[1] < 256 ? (dst[1] == 255 ? 255 : Math.min(255,(src[1] << 7) / (255 - dst[1]))) : Math.max(0,255 - (((255 - dst[1]) << 7) / src[1])),dst[2] + src[2] < 256 ? (dst[2] == 255 ? 255 : Math.min(255,(src[2] << 7) / (255 - dst[2]))) : Math.max(0,255 - (((255 - dst[2]) << 7) / src[2])),Math.min(255,src[3] + dst[3])};
}
}
;
case SOFT_DODGE:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{dst[0] + src[0] < 256 ? (src[0] == 255 ? 255 : Math.min(255,(dst[0] << 7) / (255 - src[0]))) : Math.max(0,255 - (((255 - src[0]) << 7) / dst[0])),dst[1] + src[1] < 256 ? (src[1] == 255 ? 255 : Math.min(255,(dst[1] << 7) / (255 - src[1]))) : Math.max(0,255 - (((255 - src[1]) << 7) / dst[1])),dst[2] + src[2] < 256 ? (src[2] == 255 ? 255 : Math.min(255,(dst[2] << 7) / (255 - src[2]))) : Math.max(0,255 - (((255 - src[2]) << 7) / dst[2])),Math.min(255,src[3] + dst[3])};
}
}
;
case SOFT_LIGHT:
break;
case STAMP:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{Math.max(0,Math.min(255,dst[0] + 2 * src[0] - 256)),Math.max(0,Math.min(255,dst[1] + 2 * src[1] - 256)),Math.max(0,Math.min(255,dst[2] + 2 * src[2] - 256)),Math.min(255,src[3] + dst[3])};
}
}
;
case SUBTRACT:
return new Blender(){
@Override public int[] blend(int[] src,int[] dst,int[] result){
return new int[]{Math.max(0,src[0] + dst[0] - 256),Math.max(0,src[1] + dst[1] - 256),Math.max(0,src[2] + dst[2] - 256),Math.min(255,src[3] + dst[3])};
}
}
;
}
throw new IllegalArgumentException("Blender not implement for " + composite.getMode().name());
}
