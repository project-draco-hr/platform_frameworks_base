{
  if (inputs.length < mInputs2.size()) {
    Log.e(TAG,this.toString() + " receives " + inputs.length+ " inputs, "+ "less than expected "+ mInputs2.size());
    return null;
  }
  if (inputs.length > mInputs2.size()) {
    Log.i(TAG,this.toString() + " receives " + inputs.length+ " inputs, "+ "more than expected "+ mInputs2.size());
  }
  for (int i=0; i < mInputs2.size(); i++) {
    Object obj=inputs[i];
    if (obj instanceof Future || obj instanceof Input) {
      Log.e(TAG,this.toString() + ": input " + i+ " is a future or unbound value");
      return null;
    }
    Input unbound=mInputs2.get(i);
    unbound.set(obj);
  }
  mRS.nScriptGroup2Execute(getID(mRS));
  Object[] outputObjs=new Object[mOutputs2.length];
  int i=0;
  for (  Future f : mOutputs2) {
    Object output=f.getValue();
    if (output instanceof Input) {
      output=((Input)output).get();
    }
    outputObjs[i++]=output;
  }
  return outputObjs;
}
