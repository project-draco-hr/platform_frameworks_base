{
  final WindowState w=mWin;
  final Task task=w.getTask();
  if (w.isResizedWhileNotDragResizing() && !w.isGoneForLayoutLw()) {
    return;
  }
  mTmpSize.set(w.mShownPosition.x,w.mShownPosition.y,0,0);
  calculateSurfaceBounds(w,w.getAttrs());
  float extraHScale=(float)1.0;
  float extraVScale=(float)1.0;
  mSurfaceResized=mSurfaceController.setSizeInTransaction(mTmpSize.width(),mTmpSize.height(),recoveringMemory);
  mForceScaleUntilResize=mForceScaleUntilResize && !mSurfaceResized;
  calculateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect);
  if ((task != null && task.mStack.getForceScaleToCrop()) || mForceScaleUntilResize) {
    int hInsets=w.getAttrs().surfaceInsets.left + w.getAttrs().surfaceInsets.right;
    int vInsets=w.getAttrs().surfaceInsets.top + w.getAttrs().surfaceInsets.bottom;
    extraHScale=(mTmpClipRect.width() - hInsets) / (float)(mTmpSize.width() - hInsets);
    extraVScale=(mTmpClipRect.height() - vInsets) / (float)(mTmpSize.height() - vInsets);
    int posX=(int)(mTmpSize.left - w.mAttrs.x * (1 - extraHScale));
    int posY=(int)(mTmpSize.top - w.mAttrs.y * (1 - extraVScale));
    posX+=w.getAttrs().surfaceInsets.left * (1 - extraHScale);
    posY+=w.getAttrs().surfaceInsets.top * (1 - extraVScale);
    mSurfaceController.setPositionInTransaction(posX,posY,recoveringMemory);
    mTmpClipRect.set(0,0,mTmpSize.width(),mTmpSize.height());
    mTmpFinalClipRect.setEmpty();
    mForceScaleUntilResize=true;
  }
 else {
    mSurfaceController.setPositionInTransaction(mTmpSize.left,mTmpSize.top,recoveringMemory);
  }
  updateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect,recoveringMemory);
  mSurfaceController.setMatrixInTransaction(mDsDx * w.mHScale * extraHScale,mDtDx * w.mVScale * extraVScale,mDsDy * w.mHScale * extraHScale,mDtDy * w.mVScale * extraVScale,recoveringMemory);
  if (mSurfaceResized) {
    mReportSurfaceResized=true;
    mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
    w.applyDimLayerIfNeeded();
  }
}
