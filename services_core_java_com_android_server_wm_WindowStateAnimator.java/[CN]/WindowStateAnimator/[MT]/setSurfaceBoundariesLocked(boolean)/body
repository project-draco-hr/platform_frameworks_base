{
  final WindowState w=mWin;
  final Task task=w.getTask();
  mTmpSize.set(w.mShownPosition.x,w.mShownPosition.y,0,0);
  calculateSurfaceBounds(w,w.getAttrs());
  float extraHScale=(float)1.0;
  float extraVScale=(float)1.0;
  calculateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect);
  if (task != null && task.mStack.getForceScaleToCrop()) {
    extraHScale=mTmpClipRect.width() / (float)mTmpSize.width();
    extraVScale=mTmpClipRect.height() / (float)mTmpSize.height();
    int posX=(int)(mTmpSize.left - w.mAttrs.x * (1 - extraHScale));
    int posY=(int)(mTmpSize.top - w.mAttrs.y * (1 - extraVScale));
    posX+=w.getAttrs().surfaceInsets.left * (1 - extraHScale);
    posY+=w.getAttrs().surfaceInsets.top * (1 - extraVScale);
    mSurfaceController.setPositionInTransaction(posX,posY,recoveringMemory);
    mTmpClipRect.set(0,0,mTmpSize.width(),mTmpSize.height());
    mTmpFinalClipRect.setEmpty();
    updateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect,recoveringMemory);
  }
 else {
    mSurfaceController.setPositionInTransaction(mTmpSize.left,mTmpSize.top,recoveringMemory);
    updateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect,recoveringMemory);
  }
  mSurfaceController.setMatrixInTransaction(mDsDx * w.mHScale * extraHScale,mDtDx * w.mVScale * extraVScale,mDsDy * w.mHScale * extraHScale,mDtDy * w.mVScale * extraVScale,recoveringMemory);
  mSurfaceResized=mSurfaceController.setSizeInTransaction(mTmpSize.width(),mTmpSize.height(),recoveringMemory);
  if (mSurfaceResized) {
    mReportSurfaceResized=true;
    mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
    w.applyDimLayerIfNeeded();
  }
}
