{
  Animator baseAnimator=null;
  Animator parentAnimator=null;
  final long duration;
switch (changeReason) {
case APPEARING:
    baseAnimator=mChangingAppearingAnim;
  duration=mChangingAppearingDuration;
parentAnimator=defaultChangeIn;
break;
case DISAPPEARING:
baseAnimator=mChangingDisappearingAnim;
duration=mChangingDisappearingDuration;
parentAnimator=defaultChangeOut;
break;
case CHANGING:
baseAnimator=mChangingAnim;
duration=mChangingDuration;
parentAnimator=defaultChange;
break;
default :
duration=0;
break;
}
if (baseAnimator == null) {
return;
}
staggerDelay=0;
final ViewTreeObserver observer=parent.getViewTreeObserver();
if (!observer.isAlive()) {
return;
}
int numChildren=parent.getChildCount();
for (int i=0; i < numChildren; ++i) {
final View child=parent.getChildAt(i);
if (child != newView) {
setupChangeAnimation(parent,changeReason,baseAnimator,duration,child);
}
}
if (mAnimateParentHierarchy) {
ViewGroup tempParent=parent;
while (tempParent != null) {
ViewParent parentParent=tempParent.getParent();
if (parentParent instanceof ViewGroup) {
setupChangeAnimation((ViewGroup)parentParent,changeReason,parentAnimator,duration,tempParent);
tempParent=(ViewGroup)parentParent;
}
 else {
tempParent=null;
}
}
}
CleanupCallback callback=new CleanupCallback(layoutChangeListenerMap,parent);
observer.addOnPreDrawListener(callback);
parent.addOnAttachStateChangeListener(callback);
}
