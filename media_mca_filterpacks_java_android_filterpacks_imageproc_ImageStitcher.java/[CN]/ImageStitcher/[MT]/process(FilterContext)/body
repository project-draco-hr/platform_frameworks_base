{
  Frame input=pullInput("image");
  FrameFormat format=input.getFormat();
  if (mSliceIndex == 0) {
    mOutputFrame=context.getFrameManager().newFrame(calcOutputFormatForInput(format));
  }
 else {
    if ((format.getWidth() != mInputWidth) || (format.getHeight() != mInputHeight)) {
      throw new RuntimeException("Image size should not change.");
    }
  }
  if (mProgram == null) {
    mProgram=ShaderProgram.createIdentity(context);
  }
  float x0=((float)mPadSize) / mInputWidth;
  float y0=((float)mPadSize) / mInputHeight;
  int outputOffsetX=(mSliceIndex % mXSlices) * mSliceWidth;
  int outputOffsetY=(mSliceIndex / mXSlices) * mSliceHeight;
  float outputWidth=(float)Math.min(mSliceWidth,mImageWidth - outputOffsetX);
  float outputHeight=(float)Math.min(mSliceHeight,mImageHeight - outputOffsetY);
  ((ShaderProgram)mProgram).setSourceRect(x0,y0,outputWidth / mInputWidth,outputHeight / mInputHeight);
  ((ShaderProgram)mProgram).setTargetRect(((float)outputOffsetX) / mImageWidth,((float)outputOffsetY) / mImageHeight,outputWidth / mImageWidth,outputHeight / mImageHeight);
  mProgram.process(input,mOutputFrame);
  mSliceIndex++;
  if (mSliceIndex == mXSlices * mYSlices) {
    pushOutput("image",mOutputFrame);
    mOutputFrame.release();
    mSliceIndex=0;
  }
}
