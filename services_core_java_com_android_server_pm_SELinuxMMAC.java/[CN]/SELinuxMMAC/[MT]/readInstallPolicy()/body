{
  List<Policy> policies=new ArrayList<>();
  FileReader policyFile=null;
  XmlPullParser parser=Xml.newPullParser();
  try {
    policyFile=new FileReader(MAC_PERMISSIONS);
    Slog.d(TAG,"Using policy file " + MAC_PERMISSIONS);
    parser.setInput(policyFile);
    parser.nextTag();
    parser.require(XmlPullParser.START_TAG,null,"policy");
    while (parser.next() != XmlPullParser.END_TAG) {
      if (parser.getEventType() != XmlPullParser.START_TAG) {
        continue;
      }
switch (parser.getName()) {
case "signer":
        policies.add(readSignerOrThrow(parser));
      break;
case "default":
    policies.add(readDefaultOrThrow(parser));
  break;
default :
skip(parser);
}
}
}
 catch (IllegalStateException|IllegalArgumentException|XmlPullParserException ex) {
StringBuilder sb=new StringBuilder("Exception @");
sb.append(parser.getPositionDescription());
sb.append(" while parsing ");
sb.append(MAC_PERMISSIONS);
sb.append(":");
sb.append(ex);
Slog.w(TAG,sb.toString());
return false;
}
catch (IOException ioe) {
Slog.w(TAG,"Exception parsing " + MAC_PERMISSIONS,ioe);
return false;
}
 finally {
IoUtils.closeQuietly(policyFile);
}
PolicyComparator policySort=new PolicyComparator();
Collections.sort(policies,policySort);
if (policySort.foundDuplicate()) {
Slog.w(TAG,"ERROR! Duplicate entries found parsing " + MAC_PERMISSIONS);
return false;
}
synchronized (sPolicies) {
sPolicies=policies;
if (DEBUG_POLICY_ORDER) {
for (Policy policy : sPolicies) {
Slog.d(TAG,"Policy: " + policy.toString());
}
}
}
return true;
}
