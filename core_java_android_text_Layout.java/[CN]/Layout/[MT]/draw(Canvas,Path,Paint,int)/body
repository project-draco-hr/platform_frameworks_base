{
  int dtop, dbottom;
synchronized (sTempRect) {
    if (!c.getClipBounds(sTempRect)) {
      return;
    }
    dtop=sTempRect.top;
    dbottom=sTempRect.bottom;
  }
  int top=0;
  int bottom=getLineTop(getLineCount());
  if (dtop > top) {
    top=dtop;
  }
  if (dbottom < bottom) {
    bottom=dbottom;
  }
  int first=getLineForVertical(top);
  int last=getLineForVertical(bottom);
  int previousLineBottom=getLineTop(first);
  int previousLineEnd=getLineStart(first);
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  int width=mWidth;
  boolean spannedText=mSpannedText;
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanend=0;
  int textLength=0;
  if (spannedText) {
    textLength=buf.length();
    for (int i=first; i <= last; i++) {
      int start=previousLineEnd;
      int end=getLineStart(i + 1);
      previousLineEnd=end;
      int ltop=previousLineBottom;
      int lbottom=getLineTop(i + 1);
      previousLineBottom=lbottom;
      int lbaseline=lbottom - getLineDescent(i);
      if (start >= spanend) {
        Spanned sp=(Spanned)buf;
        spanend=sp.nextSpanTransition(start,textLength,LineBackgroundSpan.class);
        spans=sp.getSpans(start,spanend,LineBackgroundSpan.class);
      }
      for (int n=0; n < spans.length; n++) {
        LineBackgroundSpan back=(LineBackgroundSpan)spans[n];
        back.drawBackground(c,paint,0,width,ltop,lbaseline,lbottom,buf,start,end,i);
      }
    }
    spanend=0;
    previousLineBottom=getLineTop(first);
    previousLineEnd=getLineStart(first);
    spans=NO_PARA_SPANS;
  }
  if (highlight != null) {
    if (cursorOffsetVertical != 0) {
      c.translate(0,cursorOffsetVertical);
    }
    c.drawPath(highlight,highlightPaint);
    if (cursorOffsetVertical != 0) {
      c.translate(0,-cursorOffsetVertical);
    }
  }
  Alignment align=mAlignment;
  TextLine tl=TextLine.obtain();
  for (int i=first; i <= last; i++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(i + 1);
    int end=getLineVisibleEnd(i,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(i + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(i);
    boolean isFirstParaLine=false;
    if (spannedText) {
      if (start == 0 || buf.charAt(start - 1) == '\n') {
        isFirstParaLine=true;
      }
      if (start >= spanend) {
        Spanned sp=(Spanned)buf;
        spanend=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=sp.getSpans(start,spanend,ParagraphStyle.class);
        align=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            align=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
      }
    }
    int dir=getParagraphDirection(i);
    int left=0;
    int right=mWidth;
    if (spannedText) {
      final int length=spans.length;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(c,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(isFirstParaLine);
          }
 else {
            margin.drawLeadingMargin(c,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            boolean useMargin=isFirstParaLine;
            if (margin instanceof LeadingMarginSpan.LeadingMarginSpan2) {
              int count=((LeadingMarginSpan.LeadingMarginSpan2)margin).getLeadingMarginLineCount();
              useMargin=count > i;
            }
            left+=margin.getLeadingMargin(useMargin);
          }
        }
      }
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineMax(i,spans,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_RIGHT_TO_LEFT) {
          x=left + max;
        }
 else {
          x=right - max;
        }
      }
 else {
        max=max & ~1;
        int half=(right - left - max) >> 1;
        if (dir == DIR_RIGHT_TO_LEFT) {
          x=right - half;
        }
 else {
          x=left + half;
        }
      }
    }
    Directions directions=getLineDirections(i);
    boolean hasTab=getLineContainsTab(i);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTab) {
      if (DEBUG) {
        Assert.assertTrue(dir == DIR_LEFT_TO_RIGHT);
        Assert.assertNotNull(c);
      }
      c.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTab,spans);
      tl.draw(c,x,ltop,lbaseline,lbottom);
    }
  }
  TextLine.recycle(tl);
}
