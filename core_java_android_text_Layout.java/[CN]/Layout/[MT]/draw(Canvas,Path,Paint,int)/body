{
  int dtop, dbottom;
synchronized (sTempRect) {
    if (!c.getClipBounds(sTempRect)) {
      return;
    }
    dtop=sTempRect.top;
    dbottom=sTempRect.bottom;
  }
  int top=0;
  int bottom=getLineTop(getLineCount());
  if (dtop > top) {
    top=dtop;
  }
  if (dbottom < bottom) {
    bottom=dbottom;
  }
  int first=getLineForVertical(top);
  int last=getLineForVertical(bottom);
  int previousLineBottom=getLineTop(first);
  int previousLineEnd=getLineStart(first);
  TextPaint paint=mPaint;
  CharSequence buf=mText;
  int width=mWidth;
  boolean spannedText=mSpannedText;
  ParagraphStyle[] spans=NO_PARA_SPANS;
  int spanEnd=0;
  int textLength=0;
  if (spannedText) {
    Spanned sp=(Spanned)buf;
    textLength=buf.length();
    for (int i=first; i <= last; i++) {
      int start=previousLineEnd;
      int end=getLineStart(i + 1);
      previousLineEnd=end;
      int ltop=previousLineBottom;
      int lbottom=getLineTop(i + 1);
      previousLineBottom=lbottom;
      int lbaseline=lbottom - getLineDescent(i);
      if (start >= spanEnd) {
        spanEnd=sp.nextSpanTransition(start,textLength,LineBackgroundSpan.class);
        spans=getParagraphSpans(sp,start,end,LineBackgroundSpan.class);
      }
      for (int n=0; n < spans.length; n++) {
        LineBackgroundSpan back=(LineBackgroundSpan)spans[n];
        back.drawBackground(c,paint,0,width,ltop,lbaseline,lbottom,buf,start,end,i);
      }
    }
    spanEnd=0;
    previousLineBottom=getLineTop(first);
    previousLineEnd=getLineStart(first);
    spans=NO_PARA_SPANS;
  }
  if (highlight != null) {
    if (cursorOffsetVertical != 0) {
      c.translate(0,cursorOffsetVertical);
    }
    c.drawPath(highlight,highlightPaint);
    if (cursorOffsetVertical != 0) {
      c.translate(0,-cursorOffsetVertical);
    }
  }
  Alignment paraAlign=mAlignment;
  TabStops tabStops=null;
  boolean tabStopsIsInitialized=false;
  TextLine tl=TextLine.obtain();
  for (int i=first; i <= last; i++) {
    int start=previousLineEnd;
    previousLineEnd=getLineStart(i + 1);
    int end=getLineVisibleEnd(i,start,previousLineEnd);
    int ltop=previousLineBottom;
    int lbottom=getLineTop(i + 1);
    previousLineBottom=lbottom;
    int lbaseline=lbottom - getLineDescent(i);
    int dir=getParagraphDirection(i);
    int left=0;
    int right=mWidth;
    if (spannedText) {
      Spanned sp=(Spanned)buf;
      boolean isFirstParaLine=(start == 0 || buf.charAt(start - 1) == '\n');
      if (start >= spanEnd && (i == first || isFirstParaLine)) {
        spanEnd=sp.nextSpanTransition(start,textLength,ParagraphStyle.class);
        spans=getParagraphSpans(sp,start,spanEnd,ParagraphStyle.class);
        paraAlign=mAlignment;
        for (int n=spans.length - 1; n >= 0; n--) {
          if (spans[n] instanceof AlignmentSpan) {
            paraAlign=((AlignmentSpan)spans[n]).getAlignment();
            break;
          }
        }
        tabStopsIsInitialized=false;
      }
      final int length=spans.length;
      for (int n=0; n < length; n++) {
        if (spans[n] instanceof LeadingMarginSpan) {
          LeadingMarginSpan margin=(LeadingMarginSpan)spans[n];
          boolean useFirstLineMargin=isFirstParaLine;
          if (margin instanceof LeadingMarginSpan2) {
            int count=((LeadingMarginSpan2)margin).getLeadingMarginLineCount();
            int startLine=getLineForOffset(sp.getSpanStart(margin));
            useFirstLineMargin=i < startLine + count;
          }
          if (dir == DIR_RIGHT_TO_LEFT) {
            margin.drawLeadingMargin(c,paint,right,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            right-=margin.getLeadingMargin(useFirstLineMargin);
          }
 else {
            margin.drawLeadingMargin(c,paint,left,dir,ltop,lbaseline,lbottom,buf,start,end,isFirstParaLine,this);
            left+=margin.getLeadingMargin(useFirstLineMargin);
          }
        }
      }
    }
    boolean hasTabOrEmoji=getLineContainsTab(i);
    if (hasTabOrEmoji && !tabStopsIsInitialized) {
      if (tabStops == null) {
        tabStops=new TabStops(TAB_INCREMENT,spans);
      }
 else {
        tabStops.reset(TAB_INCREMENT,spans);
      }
      tabStopsIsInitialized=true;
    }
    Alignment align=paraAlign;
    if (align == Alignment.ALIGN_LEFT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    }
 else     if (align == Alignment.ALIGN_RIGHT) {
      align=(dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
      if (dir == DIR_LEFT_TO_RIGHT) {
        x=left;
      }
 else {
        x=right;
      }
    }
 else {
      int max=(int)getLineExtent(i,tabStops,false);
      if (align == Alignment.ALIGN_OPPOSITE) {
        if (dir == DIR_LEFT_TO_RIGHT) {
          x=right - max;
        }
 else {
          x=left - max;
        }
      }
 else {
        max=max & ~1;
        x=(right + left - max) >> 1;
      }
    }
    Directions directions=getLineDirections(i);
    if (directions == DIRS_ALL_LEFT_TO_RIGHT && !spannedText && !hasTabOrEmoji) {
      c.drawText(buf,start,end,x,lbaseline,paint);
    }
 else {
      tl.set(paint,buf,start,end,dir,directions,hasTabOrEmoji,tabStops);
      tl.draw(c,x,ltop,lbaseline,lbottom);
    }
  }
  TextLine.recycle(tl);
}
