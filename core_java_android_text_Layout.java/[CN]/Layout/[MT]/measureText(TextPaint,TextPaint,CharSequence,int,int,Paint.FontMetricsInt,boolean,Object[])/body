{
  char[] buf=null;
  if (hasTabs) {
    buf=TextUtils.obtain(end - start);
    TextUtils.getChars(text,start,end,buf,0);
  }
  int len=end - start;
  int lastPos=0;
  float width=0;
  int ascent=0, descent=0, top=0, bottom=0;
  if (fm != null) {
    fm.ascent=0;
    fm.descent=0;
  }
  for (int pos=hasTabs ? 0 : len; pos <= len; pos++) {
    int codept=0;
    Bitmap bm=null;
    if (hasTabs && pos < len) {
      codept=buf[pos];
    }
    if (codept >= 0xD800 && codept <= 0xDFFF && pos < len) {
      codept=Character.codePointAt(buf,pos);
      if (codept >= MIN_EMOJI && codept <= MAX_EMOJI) {
        bm=EMOJI_FACTORY.getBitmapFromAndroidPua(codept);
      }
    }
    if (pos == len || codept == '\t' || bm != null) {
      workPaint.baselineShift=0;
      width+=Styled.measureText(paint,workPaint,text,start + lastPos,start + pos,fm);
      if (fm != null) {
        if (workPaint.baselineShift < 0) {
          fm.ascent+=workPaint.baselineShift;
          fm.top+=workPaint.baselineShift;
        }
 else {
          fm.descent+=workPaint.baselineShift;
          fm.bottom+=workPaint.baselineShift;
        }
      }
      if (pos != len) {
        if (bm == null) {
          width=nextTab(text,start,end,width,tabs);
        }
 else {
          workPaint.set(paint);
          Styled.measureText(paint,workPaint,text,start + pos,start + pos + 1,null);
          width+=(float)bm.getWidth() * -workPaint.ascent() / bm.getHeight();
          pos++;
        }
      }
      if (fm != null) {
        if (fm.ascent < ascent) {
          ascent=fm.ascent;
        }
        if (fm.descent > descent) {
          descent=fm.descent;
        }
        if (fm.top < top) {
          top=fm.top;
        }
        if (fm.bottom > bottom) {
          bottom=fm.bottom;
        }
      }
      lastPos=pos + 1;
    }
  }
  if (fm != null) {
    fm.ascent=ascent;
    fm.descent=descent;
    fm.top=top;
    fm.bottom=bottom;
  }
  if (hasTabs)   TextUtils.recycle(buf);
  return width;
}
