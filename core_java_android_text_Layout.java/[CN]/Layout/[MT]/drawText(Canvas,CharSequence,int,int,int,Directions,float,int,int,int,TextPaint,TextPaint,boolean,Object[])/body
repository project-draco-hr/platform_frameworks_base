{
  char[] buf;
  if (!hasTabs) {
    if (directions == DIRS_ALL_LEFT_TO_RIGHT) {
      if (Config.DEBUG) {
        Assert.assertTrue(DIR_LEFT_TO_RIGHT == dir);
      }
      Styled.drawText(canvas,text,start,end,dir,false,x,top,y,bottom,paint,workPaint,false);
      return;
    }
    buf=null;
  }
 else {
    buf=TextUtils.obtain(end - start);
    TextUtils.getChars(text,start,end,buf,0);
  }
  float h=0;
  int here=0;
  for (int i=0; i < directions.mDirections.length; i++) {
    int there=here + directions.mDirections[i];
    if (there > end - start)     there=end - start;
    int segstart=here;
    for (int j=hasTabs ? here : there; j <= there; j++) {
      if (j == there || buf[j] == '\t') {
        h+=Styled.drawText(canvas,text,start + segstart,start + j,dir,(i & 1) != 0,x + h,top,y,bottom,paint,workPaint,start + j != end);
        if (j != there && buf[j] == '\t')         h=dir * nextTab(text,start,end,h * dir,parspans);
        segstart=j + 1;
      }
    }
    here=there;
  }
  if (hasTabs)   TextUtils.recycle(buf);
}
