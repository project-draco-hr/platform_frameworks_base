{
  int[] rgb888=null;
  int thumbnailSize=0;
  Bitmap tempBitmap=null;
  final int newWidth=(width + 1) & 0xFFFFFFFE;
  final int newHeight=(height + 1) & 0xFFFFFFFE;
  thumbnailSize=newWidth * newHeight * 4;
  if ((newWidth != width) || (newHeight != height)) {
    tempBitmap=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
  }
  int i=0;
  int deltaTime=(int)(endMs - startMs) / thumbnailCount;
  Bitmap[] bitmaps=null;
  try {
    rgb888=new int[thumbnailSize * thumbnailCount];
    bitmaps=new Bitmap[thumbnailCount];
  }
 catch (  Throwable e) {
    try {
      rgb888=new int[thumbnailSize * MAX_THUMBNAIL_PERMITTED];
      bitmaps=new Bitmap[MAX_THUMBNAIL_PERMITTED];
      thumbnailCount=MAX_THUMBNAIL_PERMITTED;
    }
 catch (    Throwable ex) {
      throw new RuntimeException("Memory allocation fails, thumbnail count too large: " + thumbnailCount);
    }
  }
  IntBuffer tmpBuffer=IntBuffer.allocate(thumbnailSize);
  nativeGetPixelsList(filename,rgb888,newWidth,newHeight,deltaTime,thumbnailCount,startMs,endMs);
  for (; i < thumbnailCount; i++) {
    bitmaps[i]=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    tmpBuffer.put(rgb888,(i * thumbnailSize),thumbnailSize);
    tmpBuffer.rewind();
    if ((newWidth == width) && (newHeight == height)) {
      bitmaps[i].copyPixelsFromBuffer(tmpBuffer);
    }
 else {
      tempBitmap.copyPixelsFromBuffer(tmpBuffer);
      final Canvas canvas=new Canvas(bitmaps[i]);
      canvas.drawBitmap(tempBitmap,new Rect(0,0,newWidth,newHeight),new Rect(0,0,width,height),sResizePaint);
    }
  }
  if (tempBitmap != null) {
    tempBitmap.recycle();
  }
  return bitmaps;
}
