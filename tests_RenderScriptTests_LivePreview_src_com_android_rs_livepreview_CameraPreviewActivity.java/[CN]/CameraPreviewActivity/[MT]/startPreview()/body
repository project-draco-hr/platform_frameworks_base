{
  if (mState != STATE_OFF) {
    mCamera.setPreviewCallbackWithBuffer(null);
    mCamera.stopPreview();
    mState=STATE_OFF;
    Handler h=new Handler();
    Runnable mDelayedPreview=new Runnable(){
      public void run(){
        startPreview();
      }
    }
;
    h.postDelayed(mDelayedPreview,300);
    return;
  }
  mState=STATE_PREVIEW;
  Matrix transform=new Matrix();
  float widthRatio=mNextPreviewSize.width / (float)mPreviewTexWidth;
  float heightRatio=mNextPreviewSize.height / (float)mPreviewTexHeight;
  transform.setScale(1,heightRatio / widthRatio);
  transform.postTranslate(0,mPreviewTexHeight * (1 - heightRatio / widthRatio) / 2);
  mPreviewView.setTransform(transform);
  mPreviewSize=mNextPreviewSize;
  Camera.Parameters p=mCamera.getParameters();
  p.setPreviewFormat(ImageFormat.NV21);
  p.setPreviewSize(mPreviewSize.width,mPreviewSize.height);
  mCamera.setParameters(p);
  mCamera.setPreviewCallbackWithBuffer(this);
  int expectedBytes=mPreviewSize.width * mPreviewSize.height * ImageFormat.getBitsPerPixel(ImageFormat.NV21) / 8;
  for (int i=0; i < 4; i++) {
    mCamera.addCallbackBuffer(new byte[expectedBytes]);
  }
  mProcessingFirstFrame=true;
  try {
    mCamera.setPreviewTexture(mPreviewTexture);
    mCamera.startPreview();
  }
 catch (  IOException ioe) {
    Log.e(TAG,"Unable to start up preview");
  }
}
