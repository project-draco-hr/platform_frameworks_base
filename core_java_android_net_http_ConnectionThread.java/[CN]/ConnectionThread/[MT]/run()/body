{
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DEFAULT + android.os.Process.THREAD_PRIORITY_LESS_FAVORABLE);
  mCurrentThreadTime=0;
  mTotalThreadTime=0;
  while (mRunning) {
    if (mCurrentThreadTime == -1) {
      mCurrentThreadTime=SystemClock.currentThreadTimeMillis();
    }
    Request request;
    request=mRequestFeeder.getRequest();
    if (request == null) {
synchronized (mRequestFeeder) {
        if (HttpLog.LOGV)         HttpLog.v("ConnectionThread: Waiting for work");
        mWaiting=true;
        try {
          mRequestFeeder.wait();
        }
 catch (        InterruptedException e) {
        }
        mWaiting=false;
        if (mCurrentThreadTime != 0) {
          mCurrentThreadTime=SystemClock.currentThreadTimeMillis();
        }
      }
    }
 else {
      if (HttpLog.LOGV)       HttpLog.v("ConnectionThread: new request " + request.mHost + " "+ request);
      mConnection=mConnectionManager.getConnection(mContext,request.mHost);
      mConnection.processRequests(request);
      if (mConnection.getCanPersist()) {
        if (!mConnectionManager.recycleConnection(mConnection)) {
          mConnection.closeConnection();
        }
      }
 else {
        mConnection.closeConnection();
      }
      mConnection=null;
      if (mCurrentThreadTime > 0) {
        long start=mCurrentThreadTime;
        mCurrentThreadTime=SystemClock.currentThreadTimeMillis();
        mTotalThreadTime+=mCurrentThreadTime - start;
      }
    }
  }
}
