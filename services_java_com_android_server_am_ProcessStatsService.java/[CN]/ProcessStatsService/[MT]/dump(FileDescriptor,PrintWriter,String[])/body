{
  if (mAm.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println("Permission Denial: can't dump procstats from from pid=" + Binder.getCallingPid() + ", uid="+ Binder.getCallingUid()+ " without permission "+ android.Manifest.permission.DUMP);
    return;
  }
  final long now=SystemClock.uptimeMillis();
  boolean isCheckin=false;
  boolean isCompact=false;
  boolean isCsv=false;
  boolean currentOnly=false;
  boolean dumpDetails=false;
  boolean dumpFullDetails=false;
  boolean dumpAll=false;
  int aggregateHours=0;
  String reqPackage=null;
  boolean csvSepScreenStats=false;
  int[] csvScreenStats=new int[]{ProcessStats.ADJ_SCREEN_OFF,ProcessStats.ADJ_SCREEN_ON};
  boolean csvSepMemStats=false;
  int[] csvMemStats=new int[]{ProcessStats.ADJ_MEM_FACTOR_CRITICAL};
  boolean csvSepProcStats=true;
  int[] csvProcStats=ProcessStats.ALL_PROC_STATES;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if ("--checkin".equals(arg)) {
        isCheckin=true;
      }
 else       if ("-c".equals(arg)) {
        isCompact=true;
      }
 else       if ("--csv".equals(arg)) {
        isCsv=true;
      }
 else       if ("--csv-screen".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --csv-screen");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvScreenStats=parseStateList(ProcessStats.ADJ_SCREEN_NAMES_CSV,ProcessStats.ADJ_SCREEN_MOD,args[i],sep,error);
        if (csvScreenStats == null) {
          pw.println("Error in \"" + args[i] + "\": "+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepScreenStats=sep[0];
      }
 else       if ("--csv-mem".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --csv-mem");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvMemStats=parseStateList(ProcessStats.ADJ_MEM_NAMES_CSV,1,args[i],sep,error);
        if (csvMemStats == null) {
          pw.println("Error in \"" + args[i] + "\": "+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepMemStats=sep[0];
      }
 else       if ("--csv-proc".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --csv-proc");
          dumpHelp(pw);
          return;
        }
        boolean[] sep=new boolean[1];
        String[] error=new String[1];
        csvProcStats=parseStateList(ProcessStats.STATE_NAMES_CSV,1,args[i],sep,error);
        if (csvProcStats == null) {
          pw.println("Error in \"" + args[i] + "\": "+ error[0]);
          dumpHelp(pw);
          return;
        }
        csvSepProcStats=sep[0];
      }
 else       if ("--details".equals(arg)) {
        dumpDetails=true;
      }
 else       if ("--full-details".equals(arg)) {
        dumpFullDetails=true;
      }
 else       if ("--hours".equals(arg)) {
        i++;
        if (i >= args.length) {
          pw.println("Error: argument required for --hours");
          dumpHelp(pw);
          return;
        }
        try {
          aggregateHours=Integer.parseInt(args[i]);
        }
 catch (        NumberFormatException e) {
          pw.println("Error: --hours argument not an int -- " + args[i]);
          dumpHelp(pw);
          return;
        }
      }
 else       if ("--current".equals(arg)) {
        currentOnly=true;
      }
 else       if ("--commit".equals(arg)) {
synchronized (mAm) {
          mProcessStats.mFlags|=ProcessStats.FLAG_COMPLETE;
          writeStateLocked(true,true);
          pw.println("Process stats committed.");
        }
        return;
      }
 else       if ("--reset".equals(arg)) {
synchronized (mAm) {
          mProcessStats.resetSafely();
          pw.println("Process stats reset.");
        }
        return;
      }
 else       if ("--clear".equals(arg)) {
synchronized (mAm) {
          mProcessStats.resetSafely();
          ArrayList<String> files=getCommittedFiles(0,true,true);
          if (files != null) {
            for (int fi=0; fi < files.size(); fi++) {
              (new File(files.get(fi))).delete();
            }
          }
          pw.println("All process stats cleared.");
        }
        return;
      }
 else       if ("--write".equals(arg)) {
synchronized (mAm) {
          writeStateSyncLocked();
          pw.println("Process stats written.");
        }
        return;
      }
 else       if ("--read".equals(arg)) {
synchronized (mAm) {
          readLocked(mProcessStats,mFile);
          pw.println("Process stats read.");
        }
        return;
      }
 else       if ("-h".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if ("-a".equals(arg)) {
        dumpDetails=true;
        dumpAll=true;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println("Unknown option: " + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          IPackageManager pm=AppGlobals.getPackageManager();
          if (pm.getPackageUid(arg,UserHandle.getCallingUserId()) >= 0) {
            reqPackage=arg;
            dumpDetails=true;
          }
        }
 catch (        RemoteException e) {
        }
        if (reqPackage == null) {
          pw.println("Unknown package: " + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (isCsv) {
    pw.print("Processes running summed over");
    if (!csvSepScreenStats) {
      for (int i=0; i < csvScreenStats.length; i++) {
        pw.print(" ");
        ProcessStats.printScreenLabelCsv(pw,csvScreenStats[i]);
      }
    }
    if (!csvSepMemStats) {
      for (int i=0; i < csvMemStats.length; i++) {
        pw.print(" ");
        ProcessStats.printMemLabelCsv(pw,csvMemStats[i]);
      }
    }
    if (!csvSepProcStats) {
      for (int i=0; i < csvProcStats.length; i++) {
        pw.print(" ");
        pw.print(ProcessStats.STATE_NAMES_CSV[csvProcStats[i]]);
      }
    }
    pw.println();
synchronized (mAm) {
      dumpFilteredProcessesCsvLocked(pw,null,csvSepScreenStats,csvScreenStats,csvSepMemStats,csvMemStats,csvSepProcStats,csvProcStats,now,reqPackage);
    }
    return;
  }
 else   if (aggregateHours != 0) {
    ParcelFileDescriptor pfd=getStatsOverTime(aggregateHours * 60 * 60* 1000 - (ProcessStats.COMMIT_PERIOD / 2));
    if (pfd == null) {
      pw.println("Unable to build stats!");
      return;
    }
    ProcessStats stats=new ProcessStats(false);
    InputStream stream=new ParcelFileDescriptor.AutoCloseInputStream(pfd);
    stats.read(stream);
    if (stats.mReadError != null) {
      pw.print("Failure reading: ");
      pw.println(stats.mReadError);
      return;
    }
    if (isCompact) {
      stats.dumpCheckinLocked(pw,reqPackage);
    }
 else {
      if (dumpDetails || dumpFullDetails) {
        stats.dumpLocked(pw,reqPackage,now,!dumpFullDetails,dumpAll);
      }
 else {
        stats.dumpSummaryLocked(pw,reqPackage,now);
      }
    }
    return;
  }
  boolean sepNeeded=false;
  if (!currentOnly || isCheckin) {
    mWriteLock.lock();
    try {
      ArrayList<String> files=getCommittedFiles(0,false,!isCheckin);
      if (files != null) {
        for (int i=0; i < files.size(); i++) {
          if (DEBUG)           Slog.d(TAG,"Retrieving state: " + files.get(i));
          try {
            AtomicFile file=new AtomicFile(new File(files.get(i)));
            ProcessStats processStats=new ProcessStats(false);
            readLocked(processStats,file);
            if (processStats.mReadError != null) {
              if (isCheckin || isCompact)               pw.print("err,");
              pw.print("Failure reading ");
              pw.print(files.get(i));
              pw.print("; ");
              pw.println(processStats.mReadError);
              if (DEBUG)               Slog.d(TAG,"Deleting state: " + files.get(i));
              (new File(files.get(i))).delete();
              continue;
            }
            String fileStr=file.getBaseFile().getPath();
            boolean checkedIn=fileStr.endsWith(STATE_FILE_CHECKIN_SUFFIX);
            if (isCheckin || isCompact) {
              processStats.dumpCheckinLocked(pw,reqPackage);
            }
 else {
              if (sepNeeded) {
                pw.println();
              }
 else {
                sepNeeded=true;
              }
              pw.print("COMMITTED STATS FROM ");
              pw.print(processStats.mTimePeriodStartClockStr);
              if (checkedIn)               pw.print(" (checked in)");
              pw.println(":");
              if (dumpFullDetails) {
                mProcessStats.dumpLocked(pw,reqPackage,now,false,false);
              }
 else {
                processStats.dumpSummaryLocked(pw,reqPackage,now);
              }
            }
            if (isCheckin) {
              file.getBaseFile().renameTo(new File(fileStr + STATE_FILE_CHECKIN_SUFFIX));
            }
          }
 catch (          Throwable e) {
            pw.print("**** FAILURE DUMPING STATE: ");
            pw.println(files.get(i));
            e.printStackTrace(pw);
          }
        }
      }
    }
  finally {
      mWriteLock.unlock();
    }
  }
  if (!isCheckin) {
synchronized (mAm) {
      if (isCompact) {
        mProcessStats.dumpCheckinLocked(pw,reqPackage);
      }
 else {
        if (sepNeeded) {
          pw.println();
          pw.println("CURRENT STATS:");
        }
        if (dumpDetails || dumpFullDetails) {
          mProcessStats.dumpLocked(pw,reqPackage,now,!dumpFullDetails,dumpAll);
          if (dumpAll) {
            pw.print("  mFile=");
            pw.println(mFile.getBaseFile());
          }
        }
 else {
          mProcessStats.dumpSummaryLocked(pw,reqPackage,now);
        }
      }
    }
  }
}
