{
  final Class klass=((JavaClass)modelClass).mClass;
  for (  String methodName : new String[]{"get" + StringUtils.capitalize(name),"is" + StringUtils.capitalize(name),name}) {
    try {
      Method method=klass.getMethod(methodName);
      Field backingField=findField(klass,name,true);
      if (Modifier.isPublic(method.getModifiers())) {
        final Callable result=new Callable(Callable.Type.METHOD,methodName,new JavaClass(method.getReturnType()),true,isBindable(method) || (backingField != null && isBindable(backingField)));
        L.d("backing field for %s is %s",result,backingField);
        return result;
      }
    }
 catch (    Throwable t) {
    }
  }
  try {
    Field field=findField(klass,name,false);
    if (Modifier.isPublic(field.getModifiers())) {
      return new Callable(Callable.Type.FIELD,name,new JavaClass(field.getType()),!Modifier.isFinal(field.getModifiers()) || isObservable(field.getType()),isBindable(field));
    }
  }
 catch (  Throwable t) {
  }
  throw new IllegalArgumentException("cannot find " + name + " in "+ klass.getCanonicalName());
}
