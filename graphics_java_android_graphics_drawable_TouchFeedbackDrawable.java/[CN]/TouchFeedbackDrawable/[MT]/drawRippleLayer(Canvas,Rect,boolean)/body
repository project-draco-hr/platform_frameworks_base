{
  final Ripple[] activeRipples=mActiveRipples;
  final int ripplesCount=mActiveRipplesCount;
  Paint ripplePaint=null;
  boolean drewRipples=false;
  int restoreToCount=-1;
  int activeRipplesCount=0;
  for (int i=0; i < ripplesCount; i++) {
    final Ripple ripple=activeRipples[i];
    final RippleAnimator animator=ripple.animate();
    animator.update();
    if (!animator.isRunning()) {
      activeRipples[i]=null;
      continue;
    }
    if (restoreToCount < 0) {
      final int rippleColor;
      if (mState.mTint != null) {
        rippleColor=mState.mTint.getColorForState(getState(),Color.TRANSPARENT);
      }
 else {
        rippleColor=Color.TRANSPARENT;
      }
      final int rippleAlpha=Color.alpha(rippleColor);
      final boolean projected=isProjected();
      final PorterDuffXfermode xfermode;
      if (projected || maskOnly) {
        xfermode=mState.getTintXfermode();
      }
 else {
        xfermode=SRC_OVER;
      }
      final Paint layerPaint=getMaskingPaint(xfermode);
      layerPaint.setAlpha(rippleAlpha);
      final Rect layerBounds=projected ? getDirtyBounds() : bounds;
      restoreToCount=canvas.saveLayer(layerBounds.left,layerBounds.top,layerBounds.right,layerBounds.bottom,layerPaint);
      layerPaint.setAlpha(255);
    }
    if (mRipplePaint == null) {
      mRipplePaint=new Paint();
      mRipplePaint.setAntiAlias(true);
    }
    drewRipples|=ripple.draw(canvas,mRipplePaint);
    activeRipples[activeRipplesCount]=activeRipples[i];
    activeRipplesCount++;
  }
  mActiveRipplesCount=activeRipplesCount;
  if (restoreToCount >= 0 && !drewRipples) {
    canvas.restoreToCount(restoreToCount);
    restoreToCount=-1;
  }
  return restoreToCount;
}
