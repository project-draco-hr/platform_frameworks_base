{
  final int count=mAnimatingRipplesCount;
  if (count == 0) {
    return -1;
  }
  final Ripple[] ripples=mAnimatingRipples;
  final boolean projected=isProjected();
  final Rect layerBounds=projected ? getDirtyBounds() : bounds;
  final int rippleColor;
  if (mState.mTint != null) {
    rippleColor=mState.mTint.getColorForState(getState(),Color.TRANSPARENT);
  }
 else {
    rippleColor=Color.TRANSPARENT;
  }
  final int rippleAlpha=Color.alpha(rippleColor);
  if (mRipplePaint == null) {
    mRipplePaint=new Paint();
    mRipplePaint.setAntiAlias(true);
  }
  final Paint ripplePaint=mRipplePaint;
  ripplePaint.setColor(rippleColor);
  boolean drewRipples=false;
  int restoreToCount=-1;
  int animatingCount=0;
  for (int i=0; i < count; i++) {
    final Ripple ripple=ripples[i];
    if (ripple.isFinished()) {
      ripples[i]=null;
      continue;
    }
    if (restoreToCount < 0) {
      final PorterDuffXfermode xfermode;
      if (projected || maskOnly) {
        xfermode=mState.getTintXfermode();
      }
 else {
        xfermode=SRC_OVER;
      }
      final Paint layerPaint=getMaskingPaint(xfermode);
      layerPaint.setAlpha(rippleAlpha);
      restoreToCount=canvas.saveLayer(layerBounds.left,layerBounds.top,layerBounds.right,layerBounds.bottom,layerPaint);
      layerPaint.setAlpha(255);
    }
    drewRipples|=ripple.draw(canvas,ripplePaint);
    ripples[animatingCount]=ripples[i];
    animatingCount++;
  }
  mAnimatingRipplesCount=animatingCount;
  if (restoreToCount >= 0 && !drewRipples) {
    canvas.restoreToCount(restoreToCount);
    restoreToCount=-1;
  }
  return restoreToCount;
}
