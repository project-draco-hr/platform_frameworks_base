{
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=other.mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> versions=uids.valueAt(iu);
      for (int iv=0; iv < versions.size(); iv++) {
        final int vers=versions.keyAt(iv);
        final PackageState otherState=versions.valueAt(iv);
        final int NPROCS=otherState.mProcesses.size();
        final int NSRVS=otherState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState otherProc=otherState.mProcesses.valueAt(iproc);
          if (otherProc.mCommonProcess != otherProc) {
            if (DEBUG)             Slog.d(TAG,"Adding pkg " + pkgName + " uid "+ uid+ " vers "+ vers+ " proc "+ otherProc.mName);
            ProcessState thisProc=getProcessStateLocked(pkgName,uid,vers,otherProc.mName);
            if (thisProc.mCommonProcess == thisProc) {
              if (DEBUG)               Slog.d(TAG,"Existing process is single-package, splitting");
              thisProc.mMultiPackage=true;
              long now=SystemClock.uptimeMillis();
              final PackageState pkgState=getPackageStateLocked(pkgName,uid,vers);
              thisProc=thisProc.clone(thisProc.mPackage,now);
              pkgState.mProcesses.put(thisProc.mName,thisProc);
            }
            thisProc.add(otherProc);
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState otherSvc=otherState.mServices.valueAt(isvc);
          if (DEBUG)           Slog.d(TAG,"Adding pkg " + pkgName + " uid "+ uid+ " service "+ otherSvc.mName);
          ServiceState thisSvc=getServiceStateLocked(pkgName,uid,vers,otherSvc.mProcessName,otherSvc.mName);
          thisSvc.add(otherSvc);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=other.mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState otherProc=uids.valueAt(iu);
      ProcessState thisProc=mProcesses.get(otherProc.mName,uid);
      if (DEBUG)       Slog.d(TAG,"Adding uid " + uid + " proc "+ otherProc.mName);
      if (thisProc == null) {
        if (DEBUG)         Slog.d(TAG,"Creating new process!");
        thisProc=new ProcessState(this,otherProc.mPackage,uid,otherProc.mVersion,otherProc.mName);
        mProcesses.put(otherProc.mName,uid,thisProc);
        PackageState thisState=getPackageStateLocked(otherProc.mPackage,uid,otherProc.mVersion);
        if (!thisState.mProcesses.containsKey(otherProc.mName)) {
          thisState.mProcesses.put(otherProc.mName,thisProc);
        }
      }
      thisProc.add(otherProc);
    }
  }
  for (int i=0; i < ADJ_COUNT; i++) {
    if (DEBUG)     Slog.d(TAG,"Total duration #" + i + " inc by "+ other.mMemFactorDurations[i]+ " from "+ mMemFactorDurations[i]);
    mMemFactorDurations[i]+=other.mMemFactorDurations[i];
  }
  for (int i=0; i < other.mSysMemUsageTableSize; i++) {
    int ent=other.mSysMemUsageTable[i];
    int state=(ent >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
    long[] longs=other.mLongs.get((ent >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK);
    addSysMemUsage(state,longs,((ent >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK));
  }
  if (other.mTimePeriodStartClock < mTimePeriodStartClock) {
    mTimePeriodStartClock=other.mTimePeriodStartClock;
    mTimePeriodStartClockStr=other.mTimePeriodStartClockStr;
  }
  mTimePeriodEndRealtime+=other.mTimePeriodEndRealtime - other.mTimePeriodStartRealtime;
  mTimePeriodEndUptime+=other.mTimePeriodEndUptime - other.mTimePeriodStartUptime;
}
