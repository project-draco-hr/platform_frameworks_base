{
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  boolean sepNeeded=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<PackageState> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final PackageState pkgState=uids.valueAt(iu);
      final int NPROCS=pkgState.mProcesses.size();
      final int NSRVS=pkgState.mServices.size();
      final boolean pkgMatch=reqPackage == null || reqPackage.equals(pkgName);
      if (!pkgMatch) {
        boolean procMatch=false;
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (reqPackage.equals(proc.mName)) {
            procMatch=true;
            break;
          }
        }
        if (!procMatch) {
          continue;
        }
      }
      if (NPROCS > 0 || NSRVS > 0) {
        if (!printedHeader) {
          pw.println("Per-Package Stats:");
          printedHeader=true;
          sepNeeded=true;
        }
        pw.print("  * ");
        pw.print(pkgName);
        pw.print(" / ");
        UserHandle.formatUid(pw,uid);
        pw.println(":");
      }
      if (!dumpSummary || dumpAll) {
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (!pkgMatch && !reqPackage.equals(proc.mName)) {
            continue;
          }
          if (activeOnly && !proc.isInUse()) {
            pw.print("      (Not active: ");
            pw.print(pkgState.mProcesses.keyAt(iproc));
            pw.println(")");
            continue;
          }
          pw.print("      Process ");
          pw.print(pkgState.mProcesses.keyAt(iproc));
          if (proc.mCommonProcess.mMultiPackage) {
            pw.print(" (multi, ");
          }
 else {
            pw.print(" (unique, ");
          }
          pw.print(proc.mDurationsTableSize);
          pw.print(" entries)");
          pw.println(":");
          dumpProcessState(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
          dumpProcessPss(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
          dumpProcessInternalLocked(pw,"        ",proc,dumpAll);
        }
      }
 else {
        ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          if (!pkgMatch && !reqPackage.equals(proc.mName)) {
            continue;
          }
          if (activeOnly && !proc.isInUse()) {
            continue;
          }
          procs.add(proc);
        }
        dumpProcessSummaryLocked(pw,"      ",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,now,totalTime);
      }
      for (int isvc=0; isvc < NSRVS; isvc++) {
        ServiceState svc=pkgState.mServices.valueAt(isvc);
        if (!pkgMatch && !reqPackage.equals(svc.mProcessName)) {
          continue;
        }
        if (activeOnly && !svc.isInUse()) {
          pw.print("      (Not active: ");
          pw.print(pkgState.mServices.keyAt(isvc));
          pw.println(")");
          continue;
        }
        if (dumpAll) {
          pw.print("      Service ");
        }
 else {
          pw.print("      * ");
        }
        pw.print(pkgState.mServices.keyAt(isvc));
        pw.println(":");
        pw.print("        Process: ");
        pw.println(svc.mProcessName);
        dumpServiceStats(pw,"        ","          ","    ","Running",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,"        ","          ","    ","Started",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,"        ","          ","      ","Bound",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
        dumpServiceStats(pw,"        ","          ","  ","Executing",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
        if (dumpAll) {
          if (svc.mOwner != null) {
            pw.print("        mOwner=");
            pw.println(svc.mOwner);
          }
          if (svc.mStarted || svc.mRestarting) {
            pw.print("        mStarted=");
            pw.print(svc.mStarted);
            pw.print(" mRestarting=");
            pw.println(svc.mRestarting);
          }
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  printedHeader=false;
  int numShownProcs=0, numTotalProcs=0;
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      numTotalProcs++;
      ProcessState proc=uids.valueAt(iu);
      if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
        continue;
      }
      if (!proc.mMultiPackage) {
        continue;
      }
      if (reqPackage != null && !reqPackage.equals(procName) && !reqPackage.equals(proc.mPackage)) {
        continue;
      }
      numShownProcs++;
      if (sepNeeded) {
        pw.println();
      }
      sepNeeded=true;
      if (!printedHeader) {
        pw.println("Multi-Package Common Processes:");
        printedHeader=true;
      }
      if (activeOnly && !proc.isInUse()) {
        pw.print("      (Not active: ");
        pw.print(procName);
        pw.println(")");
        continue;
      }
      pw.print("  * ");
      pw.print(procName);
      pw.print(" / ");
      UserHandle.formatUid(pw,uid);
      pw.print(" (");
      pw.print(proc.mDurationsTableSize);
      pw.print(" entries)");
      pw.println(":");
      dumpProcessState(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
      dumpProcessPss(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      dumpProcessInternalLocked(pw,"        ",proc,dumpAll);
    }
  }
  if (dumpAll) {
    pw.println();
    pw.print("  Total procs: ");
    pw.print(numShownProcs);
    pw.print(" shown of ");
    pw.print(numTotalProcs);
    pw.println(" total");
  }
  if (sepNeeded) {
    pw.println();
  }
  if (dumpSummary) {
    pw.println("Summary:");
    dumpSummaryLocked(pw,reqPackage,now,activeOnly);
  }
 else {
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println("Internal state:");
    pw.print("  Num long arrays: ");
    pw.println(mLongs.size());
    pw.print("  Next long entry: ");
    pw.println(mNextLong);
    pw.print("  mRunning=");
    pw.println(mRunning);
  }
}
