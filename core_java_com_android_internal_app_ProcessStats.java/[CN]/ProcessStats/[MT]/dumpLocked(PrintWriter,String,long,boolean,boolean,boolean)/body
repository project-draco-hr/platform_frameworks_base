{
  long totalTime=dumpSingleTime(null,null,mMemFactorDurations,mMemFactor,mStartTime,now);
  ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  boolean printedHeader=false;
  boolean sepNeeded=false;
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        final boolean pkgMatch=reqPackage == null || reqPackage.equals(pkgName);
        if (!pkgMatch) {
          boolean procMatch=false;
          for (int iproc=0; iproc < NPROCS; iproc++) {
            ProcessState proc=pkgState.mProcesses.valueAt(iproc);
            if (reqPackage.equals(proc.mName)) {
              procMatch=true;
              break;
            }
          }
          if (!procMatch) {
            continue;
          }
        }
        if (NPROCS > 0 || NSRVS > 0) {
          if (!printedHeader) {
            pw.println("Per-Package Stats:");
            printedHeader=true;
            sepNeeded=true;
          }
          pw.print("  * ");
          pw.print(pkgName);
          pw.print(" / ");
          UserHandle.formatUid(pw,uid);
          pw.print(" / v");
          pw.print(vers);
          pw.println(":");
        }
        if (!dumpSummary || dumpAll) {
          for (int iproc=0; iproc < NPROCS; iproc++) {
            ProcessState proc=pkgState.mProcesses.valueAt(iproc);
            if (!pkgMatch && !reqPackage.equals(proc.mName)) {
              continue;
            }
            if (activeOnly && !proc.isInUse()) {
              pw.print("      (Not active: ");
              pw.print(pkgState.mProcesses.keyAt(iproc));
              pw.println(")");
              continue;
            }
            pw.print("      Process ");
            pw.print(pkgState.mProcesses.keyAt(iproc));
            if (proc.mCommonProcess.mMultiPackage) {
              pw.print(" (multi, ");
            }
 else {
              pw.print(" (unique, ");
            }
            pw.print(proc.mDurationsTableSize);
            pw.print(" entries)");
            pw.println(":");
            dumpProcessState(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
            dumpProcessPss(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
            dumpProcessInternalLocked(pw,"        ",proc,dumpAll);
          }
        }
 else {
          ArrayList<ProcessState> procs=new ArrayList<ProcessState>();
          for (int iproc=0; iproc < NPROCS; iproc++) {
            ProcessState proc=pkgState.mProcesses.valueAt(iproc);
            if (!pkgMatch && !reqPackage.equals(proc.mName)) {
              continue;
            }
            if (activeOnly && !proc.isInUse()) {
              continue;
            }
            procs.add(proc);
          }
          dumpProcessSummaryLocked(pw,"      ",procs,ALL_SCREEN_ADJ,ALL_MEM_ADJ,NON_CACHED_PROC_STATES,false,now,totalTime);
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          ServiceState svc=pkgState.mServices.valueAt(isvc);
          if (!pkgMatch && !reqPackage.equals(svc.mProcessName)) {
            continue;
          }
          if (activeOnly && !svc.isInUse()) {
            pw.print("      (Not active: ");
            pw.print(pkgState.mServices.keyAt(isvc));
            pw.println(")");
            continue;
          }
          if (dumpAll) {
            pw.print("      Service ");
          }
 else {
            pw.print("      * ");
          }
          pw.print(pkgState.mServices.keyAt(isvc));
          pw.println(":");
          pw.print("        Process: ");
          pw.println(svc.mProcessName);
          dumpServiceStats(pw,"        ","          ","    ","Running",svc,svc.mRunCount,ServiceState.SERVICE_RUN,svc.mRunState,svc.mRunStartTime,now,totalTime,!dumpSummary || dumpAll);
          dumpServiceStats(pw,"        ","          ","    ","Started",svc,svc.mStartedCount,ServiceState.SERVICE_STARTED,svc.mStartedState,svc.mStartedStartTime,now,totalTime,!dumpSummary || dumpAll);
          dumpServiceStats(pw,"        ","          ","      ","Bound",svc,svc.mBoundCount,ServiceState.SERVICE_BOUND,svc.mBoundState,svc.mBoundStartTime,now,totalTime,!dumpSummary || dumpAll);
          dumpServiceStats(pw,"        ","          ","  ","Executing",svc,svc.mExecCount,ServiceState.SERVICE_EXEC,svc.mExecState,svc.mExecStartTime,now,totalTime,!dumpSummary || dumpAll);
          if (dumpAll) {
            if (svc.mOwner != null) {
              pw.print("        mOwner=");
              pw.println(svc.mOwner);
            }
            if (svc.mStarted || svc.mRestarting) {
              pw.print("        mStarted=");
              pw.print(svc.mStarted);
              pw.print(" mRestarting=");
              pw.println(svc.mRestarting);
            }
          }
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  printedHeader=false;
  int numShownProcs=0, numTotalProcs=0;
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      numTotalProcs++;
      ProcessState proc=uids.valueAt(iu);
      if (proc.mDurationsTableSize == 0 && proc.mCurState == STATE_NOTHING && proc.mPssTableSize == 0) {
        continue;
      }
      if (!proc.mMultiPackage) {
        continue;
      }
      if (reqPackage != null && !reqPackage.equals(procName) && !reqPackage.equals(proc.mPackage)) {
        continue;
      }
      numShownProcs++;
      if (sepNeeded) {
        pw.println();
      }
      sepNeeded=true;
      if (!printedHeader) {
        pw.println("Multi-Package Common Processes:");
        printedHeader=true;
      }
      if (activeOnly && !proc.isInUse()) {
        pw.print("      (Not active: ");
        pw.print(procName);
        pw.println(")");
        continue;
      }
      pw.print("  * ");
      pw.print(procName);
      pw.print(" / ");
      UserHandle.formatUid(pw,uid);
      pw.print(" (");
      pw.print(proc.mDurationsTableSize);
      pw.print(" entries)");
      pw.println(":");
      dumpProcessState(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES,now);
      dumpProcessPss(pw,"        ",proc,ALL_SCREEN_ADJ,ALL_MEM_ADJ,ALL_PROC_STATES);
      dumpProcessInternalLocked(pw,"        ",proc,dumpAll);
    }
  }
  if (dumpAll) {
    pw.println();
    pw.print("  Total procs: ");
    pw.print(numShownProcs);
    pw.print(" shown of ");
    pw.print(numTotalProcs);
    pw.println(" total");
  }
  if (sepNeeded) {
    pw.println();
  }
  if (dumpSummary) {
    pw.println("Summary:");
    dumpSummaryLocked(pw,reqPackage,now,activeOnly);
  }
 else {
    dumpTotalsLocked(pw,now);
  }
  if (dumpAll) {
    pw.println();
    pw.println("Internal state:");
    pw.print("  Num long arrays: ");
    pw.println(mLongs.size());
    pw.print("  Next long entry: ");
    pw.println(mNextLong);
    pw.print("  mRunning=");
    pw.println(mRunning);
  }
}
