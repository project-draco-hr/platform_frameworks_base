{
  final long now=SystemClock.uptimeMillis();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  pw.println("vers,5");
  pw.print("period,");
  pw.print(mTimePeriodStartClockStr);
  pw.print(",");
  pw.print(mTimePeriodStartRealtime);
  pw.print(",");
  pw.print(mRunning ? SystemClock.elapsedRealtime() : mTimePeriodEndRealtime);
  boolean partial=true;
  if ((mFlags & FLAG_SHUTDOWN) != 0) {
    pw.print(",shutdown");
    partial=false;
  }
  if ((mFlags & FLAG_SYSPROPS) != 0) {
    pw.print(",sysprops");
    partial=false;
  }
  if ((mFlags & FLAG_COMPLETE) != 0) {
    pw.print(",complete");
    partial=false;
  }
  if (partial) {
    pw.print(",partial");
  }
  pw.println();
  pw.print("config,");
  pw.println(mRuntime);
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    if (reqPackage != null && !reqPackage.equals(pkgName)) {
      continue;
    }
    final SparseArray<SparseArray<PackageState>> uids=pkgMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      final int uid=uids.keyAt(iu);
      final SparseArray<PackageState> vpkgs=uids.valueAt(iu);
      for (int iv=0; iv < vpkgs.size(); iv++) {
        final int vers=vpkgs.keyAt(iv);
        final PackageState pkgState=vpkgs.valueAt(iv);
        final int NPROCS=pkgState.mProcesses.size();
        final int NSRVS=pkgState.mServices.size();
        for (int iproc=0; iproc < NPROCS; iproc++) {
          ProcessState proc=pkgState.mProcesses.valueAt(iproc);
          pw.print("pkgproc,");
          pw.print(pkgName);
          pw.print(",");
          pw.print(uid);
          pw.print(",");
          pw.print(vers);
          pw.print(",");
          pw.print(collapseString(pkgName,pkgState.mProcesses.keyAt(iproc)));
          dumpAllProcessStateCheckin(pw,proc,now);
          pw.println();
          if (proc.mPssTableSize > 0) {
            pw.print("pkgpss,");
            pw.print(pkgName);
            pw.print(",");
            pw.print(uid);
            pw.print(",");
            pw.print(vers);
            pw.print(",");
            pw.print(collapseString(pkgName,pkgState.mProcesses.keyAt(iproc)));
            dumpAllProcessPssCheckin(pw,proc);
            pw.println();
          }
          if (proc.mNumExcessiveWake > 0 || proc.mNumExcessiveCpu > 0 || proc.mNumCachedKill > 0) {
            pw.print("pkgkills,");
            pw.print(pkgName);
            pw.print(",");
            pw.print(uid);
            pw.print(",");
            pw.print(vers);
            pw.print(",");
            pw.print(collapseString(pkgName,pkgState.mProcesses.keyAt(iproc)));
            pw.print(",");
            pw.print(proc.mNumExcessiveWake);
            pw.print(",");
            pw.print(proc.mNumExcessiveCpu);
            pw.print(",");
            pw.print(proc.mNumCachedKill);
            pw.print(",");
            pw.print(proc.mMinCachedKillPss);
            pw.print(":");
            pw.print(proc.mAvgCachedKillPss);
            pw.print(":");
            pw.print(proc.mMaxCachedKillPss);
            pw.println();
          }
        }
        for (int isvc=0; isvc < NSRVS; isvc++) {
          String serviceName=collapseString(pkgName,pkgState.mServices.keyAt(isvc));
          ServiceState svc=pkgState.mServices.valueAt(isvc);
          dumpServiceTimeCheckin(pw,"pkgsvc-run",pkgName,uid,vers,serviceName,svc,ServiceState.SERVICE_RUN,svc.mRunCount,svc.mRunState,svc.mRunStartTime,now);
          dumpServiceTimeCheckin(pw,"pkgsvc-start",pkgName,uid,vers,serviceName,svc,ServiceState.SERVICE_STARTED,svc.mStartedCount,svc.mStartedState,svc.mStartedStartTime,now);
          dumpServiceTimeCheckin(pw,"pkgsvc-bound",pkgName,uid,vers,serviceName,svc,ServiceState.SERVICE_BOUND,svc.mBoundCount,svc.mBoundState,svc.mBoundStartTime,now);
          dumpServiceTimeCheckin(pw,"pkgsvc-exec",pkgName,uid,vers,serviceName,svc,ServiceState.SERVICE_EXEC,svc.mExecCount,svc.mExecState,svc.mExecStartTime,now);
        }
      }
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int ip=0; ip < procMap.size(); ip++) {
    String procName=procMap.keyAt(ip);
    SparseArray<ProcessState> uids=procMap.valueAt(ip);
    for (int iu=0; iu < uids.size(); iu++) {
      int uid=uids.keyAt(iu);
      ProcessState procState=uids.valueAt(iu);
      if (procState.mDurationsTableSize > 0) {
        pw.print("proc,");
        pw.print(procName);
        pw.print(",");
        pw.print(uid);
        dumpAllProcessStateCheckin(pw,procState,now);
        pw.println();
      }
      if (procState.mPssTableSize > 0) {
        pw.print("pss,");
        pw.print(procName);
        pw.print(",");
        pw.print(uid);
        dumpAllProcessPssCheckin(pw,procState);
        pw.println();
      }
      if (procState.mNumExcessiveWake > 0 || procState.mNumExcessiveCpu > 0 || procState.mNumCachedKill > 0) {
        pw.print("kills,");
        pw.print(procName);
        pw.print(",");
        pw.print(uid);
        pw.print(",");
        pw.print(procState.mNumExcessiveWake);
        pw.print(",");
        pw.print(procState.mNumExcessiveCpu);
        pw.print(",");
        pw.print(procState.mNumCachedKill);
        pw.print(",");
        pw.print(procState.mMinCachedKillPss);
        pw.print(":");
        pw.print(procState.mAvgCachedKillPss);
        pw.print(":");
        pw.print(procState.mMaxCachedKillPss);
        pw.println();
      }
    }
  }
  pw.print("total");
  dumpAdjTimesCheckin(pw,",",mMemFactorDurations,mMemFactor,mStartTime,now);
  if (mSysMemUsageTable != null) {
    pw.print("sysmemusage");
    for (int i=0; i < mSysMemUsageTableSize; i++) {
      int off=mSysMemUsageTable[i];
      int type=(off >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
      pw.print(",");
      printProcStateTag(pw,type);
      for (int j=SYS_MEM_USAGE_SAMPLE_COUNT; j < SYS_MEM_USAGE_COUNT; j++) {
        if (j > SYS_MEM_USAGE_CACHED_MINIMUM) {
          pw.print(":");
        }
        pw.print(getLong(off,j));
      }
    }
  }
  pw.println();
  TotalMemoryUseCollection totalMem=new TotalMemoryUseCollection(ALL_SCREEN_ADJ,ALL_MEM_ADJ);
  computeTotalMemoryUse(totalMem,now);
  pw.print("weights,");
  pw.print(totalMem.totalTime);
  pw.print(",");
  pw.print(totalMem.sysMemCachedWeight);
  pw.print(":");
  pw.print(totalMem.sysMemSamples);
  pw.print(",");
  pw.print(totalMem.sysMemFreeWeight);
  pw.print(":");
  pw.print(totalMem.sysMemSamples);
  pw.print(",");
  pw.print(totalMem.sysMemZRamWeight);
  pw.print(":");
  pw.print(totalMem.sysMemSamples);
  pw.print(",");
  pw.print(totalMem.sysMemKernelWeight);
  pw.print(":");
  pw.print(totalMem.sysMemSamples);
  pw.print(",");
  pw.print(totalMem.sysMemNativeWeight);
  pw.print(":");
  pw.print(totalMem.sysMemSamples);
  for (int i=0; i < STATE_COUNT; i++) {
    pw.print(",");
    pw.print(totalMem.processStateWeight[i]);
    pw.print(":");
    pw.print(totalMem.processStateSamples[i]);
  }
  pw.println();
}
