{
  data.totalTime=0;
  for (int i=0; i < STATE_COUNT; i++) {
    data.processStateWeight[i]=0;
    data.processStatePss[i]=0;
    data.processStateTime[i]=0;
    data.processStateSamples[i]=0;
  }
  for (int i=0; i < SYS_MEM_USAGE_COUNT; i++) {
    data.sysMemUsage[i]=0;
  }
  data.sysMemCachedWeight=0;
  data.sysMemFreeWeight=0;
  data.sysMemZRamWeight=0;
  data.sysMemKernelWeight=0;
  data.sysMemNativeWeight=0;
  data.sysMemSamples=0;
  long[] totalMemUsage=new long[SYS_MEM_USAGE_COUNT];
  for (int i=0; i < mSysMemUsageTableSize; i++) {
    int ent=mSysMemUsageTable[i];
    long[] longs=mLongs.get((ent >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK);
    int idx=(ent >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
    addSysMemUsage(totalMemUsage,0,longs,idx);
  }
  for (int is=0; is < data.screenStates.length; is++) {
    for (int im=0; im < data.memStates.length; im++) {
      int memBucket=data.screenStates[is] + data.memStates[im];
      int stateBucket=memBucket * STATE_COUNT;
      long memTime=mMemFactorDurations[memBucket];
      if (mMemFactor == memBucket) {
        memTime+=now - mStartTime;
      }
      data.totalTime+=memTime;
      int sysIdx=binarySearch(mSysMemUsageTable,mSysMemUsageTableSize,stateBucket);
      long[] longs=totalMemUsage;
      int idx=0;
      if (sysIdx >= 0) {
        int ent=mSysMemUsageTable[sysIdx];
        long[] tmpLongs=mLongs.get((ent >> OFFSET_ARRAY_SHIFT) & OFFSET_ARRAY_MASK);
        int tmpIdx=(ent >> OFFSET_INDEX_SHIFT) & OFFSET_INDEX_MASK;
        if (tmpLongs[tmpIdx + SYS_MEM_USAGE_SAMPLE_COUNT] >= 3) {
          addSysMemUsage(data.sysMemUsage,0,longs,idx);
          longs=tmpLongs;
          idx=tmpIdx;
        }
      }
      data.sysMemCachedWeight+=longs[idx + SYS_MEM_USAGE_CACHED_AVERAGE] * (double)memTime;
      data.sysMemFreeWeight+=longs[idx + SYS_MEM_USAGE_FREE_AVERAGE] * (double)memTime;
      data.sysMemZRamWeight+=longs[idx + SYS_MEM_USAGE_ZRAM_AVERAGE] * (double)memTime;
      data.sysMemKernelWeight+=longs[idx + SYS_MEM_USAGE_KERNEL_AVERAGE] * (double)memTime;
      data.sysMemNativeWeight+=longs[idx + SYS_MEM_USAGE_NATIVE_AVERAGE] * (double)memTime;
      data.sysMemSamples+=longs[idx + SYS_MEM_USAGE_SAMPLE_COUNT];
    }
  }
  ArrayMap<String,SparseArray<ProcessState>> procMap=mProcesses.getMap();
  for (int iproc=0; iproc < procMap.size(); iproc++) {
    SparseArray<ProcessState> uids=procMap.valueAt(iproc);
    for (int iu=0; iu < uids.size(); iu++) {
      final ProcessState proc=uids.valueAt(iu);
      final PssAggr fgPss=new PssAggr();
      final PssAggr bgPss=new PssAggr();
      final PssAggr cachedPss=new PssAggr();
      boolean havePss=false;
      for (int i=0; i < proc.mDurationsTableSize; i++) {
        int off=proc.mDurationsTable[i];
        int type=(off >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
        int procState=type % STATE_COUNT;
        long samples=proc.getPssSampleCount(type);
        if (samples > 0) {
          long avg=proc.getPssAverage(type);
          havePss=true;
          if (procState <= STATE_IMPORTANT_FOREGROUND) {
            fgPss.add(avg,samples);
          }
 else           if (procState <= STATE_RECEIVER) {
            bgPss.add(avg,samples);
          }
 else {
            cachedPss.add(avg,samples);
          }
        }
      }
      if (!havePss) {
        continue;
      }
      boolean fgHasBg=false;
      boolean fgHasCached=false;
      boolean bgHasCached=false;
      if (fgPss.samples < 3 && bgPss.samples > 0) {
        fgHasBg=true;
        fgPss.add(bgPss.pss,bgPss.samples);
      }
      if (fgPss.samples < 3 && cachedPss.samples > 0) {
        fgHasCached=true;
        fgPss.add(cachedPss.pss,cachedPss.samples);
      }
      if (bgPss.samples < 3 && cachedPss.samples > 0) {
        bgHasCached=true;
        bgPss.add(cachedPss.pss,cachedPss.samples);
      }
      if (bgPss.samples < 3 && !fgHasBg && fgPss.samples > 0) {
        bgPss.add(fgPss.pss,fgPss.samples);
      }
      if (cachedPss.samples < 3 && !bgHasCached && bgPss.samples > 0) {
        cachedPss.add(bgPss.pss,bgPss.samples);
      }
      if (cachedPss.samples < 3 && !fgHasCached && fgPss.samples > 0) {
        cachedPss.add(fgPss.pss,fgPss.samples);
      }
      for (int i=0; i < proc.mDurationsTableSize; i++) {
        final int off=proc.mDurationsTable[i];
        final int type=(off >> OFFSET_TYPE_SHIFT) & OFFSET_TYPE_MASK;
        long time=getLong(off,0);
        if (proc.mCurState == type) {
          time+=now - proc.mStartTime;
        }
        final int procState=type % STATE_COUNT;
        data.processStateTime[procState]+=time;
        long samples=proc.getPssSampleCount(type);
        long avg;
        if (samples > 0) {
          avg=proc.getPssAverage(type);
        }
 else         if (procState <= STATE_IMPORTANT_FOREGROUND) {
          samples=fgPss.samples;
          avg=fgPss.pss;
        }
 else         if (procState <= STATE_RECEIVER) {
          samples=bgPss.samples;
          avg=bgPss.pss;
        }
 else {
          samples=cachedPss.samples;
          avg=cachedPss.pss;
        }
        double newAvg=((data.processStatePss[procState] * (double)data.processStateSamples[procState]) + (avg * (double)samples)) / (data.processStateSamples[procState] + samples);
        data.processStatePss[procState]=(long)newAvg;
        data.processStateSamples[procState]+=samples;
        data.processStateWeight[procState]+=avg * (double)time;
      }
    }
  }
}
