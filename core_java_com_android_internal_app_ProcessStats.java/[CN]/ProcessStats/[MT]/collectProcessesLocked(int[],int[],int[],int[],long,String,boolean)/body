{
  final ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  final ArrayMap<String,SparseArray<SparseArray<PackageState>>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<SparseArray<PackageState>> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      final SparseArray<PackageState> vpkgs=procs.valueAt(iu);
      final int NVERS=vpkgs.size();
      for (int iv=0; iv < NVERS; iv++) {
        final PackageState state=vpkgs.valueAt(iv);
        final int NPROCS=state.mProcesses.size();
        final boolean pkgMatch=reqPackage == null || reqPackage.equals(pkgName);
        for (int iproc=0; iproc < NPROCS; iproc++) {
          final ProcessState proc=state.mProcesses.valueAt(iproc);
          if (!pkgMatch && !reqPackage.equals(proc.mName)) {
            continue;
          }
          if (activeOnly && !proc.isInUse()) {
            continue;
          }
          foundProcs.add(proc.mCommonProcess);
        }
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}
