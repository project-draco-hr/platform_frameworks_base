{
  final ArraySet<ProcessState> foundProcs=new ArraySet<ProcessState>();
  final ArrayMap<String,SparseArray<PackageState>> pkgMap=mPackages.getMap();
  for (int ip=0; ip < pkgMap.size(); ip++) {
    final String pkgName=pkgMap.keyAt(ip);
    final SparseArray<PackageState> procs=pkgMap.valueAt(ip);
    for (int iu=0; iu < procs.size(); iu++) {
      final PackageState state=procs.valueAt(iu);
      final int NPROCS=state.mProcesses.size();
      final boolean pkgMatch=reqPackage == null || reqPackage.equals(pkgName);
      for (int iproc=0; iproc < NPROCS; iproc++) {
        final ProcessState proc=state.mProcesses.valueAt(iproc);
        if (!pkgMatch && !reqPackage.equals(proc.mName)) {
          continue;
        }
        if (activeOnly && !proc.isInUse()) {
          continue;
        }
        foundProcs.add(proc.mCommonProcess);
      }
    }
  }
  ArrayList<ProcessState> outProcs=new ArrayList<ProcessState>(foundProcs.size());
  for (int i=0; i < foundProcs.size(); i++) {
    ProcessState proc=foundProcs.valueAt(i);
    if (computeProcessTimeLocked(proc,screenStates,memStates,procStates,now) > 0) {
      outProcs.add(proc);
      if (procStates != sortProcStates) {
        computeProcessTimeLocked(proc,screenStates,memStates,sortProcStates,now);
      }
    }
  }
  Collections.sort(outProcs,new Comparator<ProcessState>(){
    @Override public int compare(    ProcessState lhs,    ProcessState rhs){
      if (lhs.mTmpTotalTime < rhs.mTmpTotalTime) {
        return -1;
      }
 else       if (lhs.mTmpTotalTime > rhs.mTmpTotalTime) {
        return 1;
      }
      return 0;
    }
  }
);
  return outProcs;
}
