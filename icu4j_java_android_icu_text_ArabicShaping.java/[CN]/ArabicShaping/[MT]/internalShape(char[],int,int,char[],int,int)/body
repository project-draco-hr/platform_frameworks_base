{
  if (sourceLength == 0) {
    return 0;
  }
  if (destSize == 0) {
    if (((options & LETTERS_MASK) != LETTERS_NOOP) && ((options & LAMALEF_MASK) == LAMALEF_RESIZE)) {
      return calculateSize(source,sourceStart,sourceLength);
    }
 else {
      return sourceLength;
    }
  }
  char[] temp=new char[sourceLength * 2];
  System.arraycopy(source,sourceStart,temp,0,sourceLength);
  if (isLogical) {
    invertBuffer(temp,0,sourceLength);
  }
  int outputSize=sourceLength;
switch (options & LETTERS_MASK) {
case LETTERS_SHAPE_TASHKEEL_ISOLATED:
    outputSize=shapeUnicode(temp,0,sourceLength,destSize,1);
  break;
case LETTERS_SHAPE:
if (((options & TASHKEEL_MASK) > 0) && ((options & TASHKEEL_MASK) != TASHKEEL_REPLACE_BY_TATWEEL)) {
  outputSize=shapeUnicode(temp,0,sourceLength,destSize,2);
}
 else {
  outputSize=shapeUnicode(temp,0,sourceLength,destSize,0);
  if ((options & TASHKEEL_MASK) == TASHKEEL_REPLACE_BY_TATWEEL) {
    outputSize=handleTashkeelWithTatweel(temp,sourceLength);
  }
}
break;
case LETTERS_UNSHAPE:
outputSize=deShapeUnicode(temp,0,sourceLength,destSize);
break;
default :
break;
}
if (outputSize > destSize) {
throw new ArabicShapingException("not enough room for result data");
}
if ((options & DIGITS_MASK) != DIGITS_NOOP) {
char digitBase='\u0030';
switch (options & DIGIT_TYPE_MASK) {
case DIGIT_TYPE_AN:
digitBase='\u0660';
break;
case DIGIT_TYPE_AN_EXTENDED:
digitBase='\u06f0';
break;
default :
break;
}
switch (options & DIGITS_MASK) {
case DIGITS_EN2AN:
{
int digitDelta=digitBase - '\u0030';
for (int i=0; i < outputSize; ++i) {
char ch=temp[i];
if (ch <= '\u0039' && ch >= '\u0030') {
temp[i]+=digitDelta;
}
}
}
break;
case DIGITS_AN2EN:
{
char digitTop=(char)(digitBase + 9);
int digitDelta='\u0030' - digitBase;
for (int i=0; i < outputSize; ++i) {
char ch=temp[i];
if (ch <= digitTop && ch >= digitBase) {
temp[i]+=digitDelta;
}
}
}
break;
case DIGITS_EN2AN_INIT_LR:
shapeToArabicDigitsWithContext(temp,0,outputSize,digitBase,false);
break;
case DIGITS_EN2AN_INIT_AL:
shapeToArabicDigitsWithContext(temp,0,outputSize,digitBase,true);
break;
default :
break;
}
}
if (isLogical) {
invertBuffer(temp,0,outputSize);
}
System.arraycopy(temp,0,dest,destStart,outputSize);
return outputSize;
}
